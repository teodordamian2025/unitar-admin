"use strict";
exports.id = 3702;
exports.ids = [3702];
exports.modules = {

/***/ 59259:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var EventAlgorithm_1 = __webpack_require__(12467);
/**
 * Adds an algorithm to the given abort signal.
 *
 * @param algorithm - an algorithm
 * @param signal - abort signal
 */ function abort_add(algorithm, signal) {
    /**
     * 1. If signal’s aborted flag is set, then return.
     * 2. Append algorithm to signal’s abort algorithms.
     */ if (signal._abortedFlag) return;
    signal._abortAlgorithms.add(algorithm);
}
exports.abort_add = abort_add;
/**
 * Removes an algorithm from the given abort signal.
 *
 * @param algorithm - an algorithm
 * @param signal - abort signal
 */ function abort_remove(algorithm, signal) {
    /**
     * To remove an algorithm algorithm from an AbortSignal signal, remove
     * algorithm from signal’s abort algorithms.
     */ signal._abortAlgorithms.delete(algorithm);
}
exports.abort_remove = abort_remove;
/**
 * Signals abort on the given abort signal.
 *
 * @param signal - abort signal
 */ function abort_signalAbort(signal) {
    var e_1, _a;
    /**
     * 1. If signal’s aborted flag is set, then return.
     * 2. Set signal’s aborted flag.
     * 3. For each algorithm in signal’s abort algorithms: run algorithm.
     * 4. Empty signal’s abort algorithms.
     * 5. Fire an event named abort at signal.
     */ if (signal._abortedFlag) return;
    signal._abortedFlag = true;
    try {
        for(var _b = __values(signal._abortAlgorithms), _c = _b.next(); !_c.done; _c = _b.next()){
            var algorithm = _c.value;
            algorithm.call(signal);
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    signal._abortAlgorithms.clear();
    EventAlgorithm_1.event_fireAnEvent("abort", signal);
}
exports.abort_signalAbort = abort_signalAbort; //# sourceMappingURL=AbortAlgorithm.js.map


/***/ }),

/***/ 26092:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var ElementAlgorithm_1 = __webpack_require__(60077);
/**
 * Changes the value of an existing attribute.
 *
 * @param attribute - an attribute node
 * @param value - attribute value
 */ function attr_setAnExistingAttributeValue(attribute, value) {
    /**
     * 1. If attribute’s element is null, then set attribute’s value to value.
     * 2. Otherwise, change attribute from attribute’s element to value.
     */ if (attribute._element === null) {
        attribute._value = value;
    } else {
        ElementAlgorithm_1.element_change(attribute, attribute._element, value);
    }
}
exports.attr_setAnExistingAttributeValue = attr_setAnExistingAttributeValue; //# sourceMappingURL=AttrAlgorithm.js.map


/***/ }),

/***/ 35822:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
var TreeAlgorithm_1 = __webpack_require__(59614);
/**
 * Defines the position of a boundary point relative to another.
 *
 * @param bp - a boundary point
 * @param relativeTo - a boundary point to compare to
 */ function boundaryPoint_position(bp, relativeTo) {
    var nodeA = bp[0];
    var offsetA = bp[1];
    var nodeB = relativeTo[0];
    var offsetB = relativeTo[1];
    /**
     * 1. Assert: nodeA and nodeB have the same root.
     */ console.assert(TreeAlgorithm_1.tree_rootNode(nodeA) === TreeAlgorithm_1.tree_rootNode(nodeB), "Boundary points must share the same root node.");
    /**
     * 2. If nodeA is nodeB, then return equal if offsetA is offsetB, before
     * if offsetA is less than offsetB, and after if offsetA is greater than
     * offsetB.
     */ if (nodeA === nodeB) {
        if (offsetA === offsetB) {
            return interfaces_1.BoundaryPosition.Equal;
        } else if (offsetA < offsetB) {
            return interfaces_1.BoundaryPosition.Before;
        } else {
            return interfaces_1.BoundaryPosition.After;
        }
    }
    /**
     * 3. If nodeA is following nodeB, then if the position of (nodeB, offsetB)
     * relative to (nodeA, offsetA) is before, return after, and if it is after,
     * return before.
     */ if (TreeAlgorithm_1.tree_isFollowing(nodeB, nodeA)) {
        var pos = boundaryPoint_position([
            nodeB,
            offsetB
        ], [
            nodeA,
            offsetA
        ]);
        if (pos === interfaces_1.BoundaryPosition.Before) {
            return interfaces_1.BoundaryPosition.After;
        } else if (pos === interfaces_1.BoundaryPosition.After) {
            return interfaces_1.BoundaryPosition.Before;
        }
    }
    /**
     * 4. If nodeA is an ancestor of nodeB:
     */ if (TreeAlgorithm_1.tree_isAncestorOf(nodeB, nodeA)) {
        /**
         * 4.1. Let child be nodeB.
         * 4.2. While child is not a child of nodeA, set child to its parent.
         * 4.3. If child’s index is less than offsetA, then return after.
         */ var child = nodeB;
        while(!TreeAlgorithm_1.tree_isChildOf(nodeA, child)){
            /* istanbul ignore else */ if (child._parent !== null) {
                child = child._parent;
            }
        }
        if (TreeAlgorithm_1.tree_index(child) < offsetA) {
            return interfaces_1.BoundaryPosition.After;
        }
    }
    /**
     * 5. Return before.
     */ return interfaces_1.BoundaryPosition.Before;
}
exports.boundaryPoint_position = boundaryPoint_position; //# sourceMappingURL=BoundaryPointAlgorithm.js.map


/***/ }),

/***/ 77901:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var util_1 = __webpack_require__(57294);
var DOMException_1 = __webpack_require__(28905);
var TreeAlgorithm_1 = __webpack_require__(59614);
var MutationObserverAlgorithm_1 = __webpack_require__(5742);
var DOMAlgorithm_1 = __webpack_require__(24473);
/**
 * Replaces character data.
 *
 * @param node - a character data node
 * @param offset - start offset
 * @param count - count of characters to replace
 * @param data - new data
 */ function characterData_replaceData(node, offset, count, data) {
    var e_1, _a;
    /**
     * 1. Let length be node’s length.
     * 2. If offset is greater than length, then throw an "IndexSizeError"
     * DOMException.
     * 3. If offset plus count is greater than length, then set count to length
     * minus offset.
     */ var length = TreeAlgorithm_1.tree_nodeLength(node);
    if (offset > length) {
        throw new DOMException_1.IndexSizeError("Offset exceeds character data length. Offset: " + offset + ", Length: " + length + ", Node is " + node.nodeName + ".");
    }
    if (offset + count > length) {
        count = length - offset;
    }
    /**
     * 4. Queue a mutation record of "characterData" for node with null, null,
     * node’s data, « », « », null, and null.
     */ if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueMutationRecord("characterData", node, null, null, node._data, [], [], null, null);
    }
    /**
     * 5. Insert data into node’s data after offset code units.
     * 6. Let delete offset be offset + data’s length.
     * 7. Starting from delete offset code units, remove count code units from
     * node’s data.
     */ var newData = node._data.substring(0, offset) + data + node._data.substring(offset + count);
    node._data = newData;
    try {
        /**
         * 8. For each live range whose start node is node and start offset is
         * greater than offset but less than or equal to offset plus count, set its
         * start offset to offset.
         * 9. For each live range whose end node is node and end offset is greater
         * than offset but less than or equal to offset plus count, set its end
         * offset to offset.
         * 10. For each live range whose start node is node and start offset is
         * greater than offset plus count, increase its start offset by data’s
         * length and decrease it by count.
         * 11. For each live range whose end node is node and end offset is greater
         * than offset plus count, increase its end offset by data’s length and
         * decrease it by count.
         */ for(var _b = __values(DOMImpl_1.dom.rangeList), _c = _b.next(); !_c.done; _c = _b.next()){
            var range = _c.value;
            if (range._start[0] === node && range._start[1] > offset && range._start[1] <= offset + count) {
                range._start[1] = offset;
            }
            if (range._end[0] === node && range._end[1] > offset && range._end[1] <= offset + count) {
                range._end[1] = offset;
            }
            if (range._start[0] === node && range._start[1] > offset + count) {
                range._start[1] += data.length - count;
            }
            if (range._end[0] === node && range._end[1] > offset + count) {
                range._end[1] += data.length - count;
            }
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    /**
     * 12. If node is a Text node and its parent is not null, run the child
     * text content change steps for node’s parent.
     */ if (DOMImpl_1.dom.features.steps) {
        if (util_1.Guard.isTextNode(node) && node._parent !== null) {
            DOMAlgorithm_1.dom_runChildTextContentChangeSteps(node._parent);
        }
    }
}
exports.characterData_replaceData = characterData_replaceData;
/**
 * Returns `count` number of characters from `node`'s data starting at
 * the given `offset`.
 *
 * @param node - a character data node
 * @param offset - start offset
 * @param count - count of characters to return
 */ function characterData_substringData(node, offset, count) {
    /**
     * 1. Let length be node’s length.
     * 2. If offset is greater than length, then throw an "IndexSizeError"
     * DOMException.
     * 3. If offset plus count is greater than length, return a string whose
     * value is the code units from the offsetth code unit to the end of node’s
     * data, and then return.
     * 4. Return a string whose value is the code units from the offsetth code
     * unit to the offset+countth code unit in node’s data.
     */ var length = TreeAlgorithm_1.tree_nodeLength(node);
    if (offset > length) {
        throw new DOMException_1.IndexSizeError("Offset exceeds character data length. Offset: " + offset + ", Length: " + length + ", Node is " + node.nodeName + ".");
    }
    if (offset + count > length) {
        return node._data.substr(offset);
    } else {
        return node._data.substr(offset, count);
    }
}
exports.characterData_substringData = characterData_substringData; //# sourceMappingURL=CharacterDataAlgorithm.js.map


/***/ }),

/***/ 21701:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImplementationImpl_1 = __webpack_require__(36152);
var WindowImpl_1 = __webpack_require__(32130);
var XMLDocumentImpl_1 = __webpack_require__(68111);
var DocumentImpl_1 = __webpack_require__(18927);
var AbortControllerImpl_1 = __webpack_require__(64603);
var AbortSignalImpl_1 = __webpack_require__(77719);
var DocumentTypeImpl_1 = __webpack_require__(23331);
var ElementImpl_1 = __webpack_require__(33086);
var DocumentFragmentImpl_1 = __webpack_require__(14240);
var ShadowRootImpl_1 = __webpack_require__(40018);
var AttrImpl_1 = __webpack_require__(15867);
var TextImpl_1 = __webpack_require__(70098);
var CDATASectionImpl_1 = __webpack_require__(34950);
var CommentImpl_1 = __webpack_require__(77616);
var ProcessingInstructionImpl_1 = __webpack_require__(66617);
var HTMLCollectionImpl_1 = __webpack_require__(31403);
var NodeListImpl_1 = __webpack_require__(37148);
var NodeListStaticImpl_1 = __webpack_require__(22020);
var NamedNodeMapImpl_1 = __webpack_require__(9846);
var RangeImpl_1 = __webpack_require__(39694);
var NodeIteratorImpl_1 = __webpack_require__(70971);
var TreeWalkerImpl_1 = __webpack_require__(31642);
var NodeFilterImpl_1 = __webpack_require__(32482);
var MutationRecordImpl_1 = __webpack_require__(68967);
var DOMTokenListImpl_1 = __webpack_require__(26858);
/**
 * Creates a `DOMImplementation`.
 *
 * @param document - associated document
 */ function create_domImplementation(document) {
    return DOMImplementationImpl_1.DOMImplementationImpl._create(document);
}
exports.create_domImplementation = create_domImplementation;
/**
 * Creates a `Window` node.
 */ function create_window() {
    return WindowImpl_1.WindowImpl._create();
}
exports.create_window = create_window;
/**
 * Creates an `XMLDocument` node.
 */ function create_xmlDocument() {
    return new XMLDocumentImpl_1.XMLDocumentImpl();
}
exports.create_xmlDocument = create_xmlDocument;
/**
 * Creates a `Document` node.
 */ function create_document() {
    return new DocumentImpl_1.DocumentImpl();
}
exports.create_document = create_document;
/**
 * Creates an `AbortController`.
 */ function create_abortController() {
    return new AbortControllerImpl_1.AbortControllerImpl();
}
exports.create_abortController = create_abortController;
/**
 * Creates an `AbortSignal`.
 */ function create_abortSignal() {
    return AbortSignalImpl_1.AbortSignalImpl._create();
}
exports.create_abortSignal = create_abortSignal;
/**
 * Creates a `DocumentType` node.
 *
 * @param document - owner document
 * @param name - name of the node
 * @param publicId - `PUBLIC` identifier
 * @param systemId - `SYSTEM` identifier
 */ function create_documentType(document, name, publicId, systemId) {
    return DocumentTypeImpl_1.DocumentTypeImpl._create(document, name, publicId, systemId);
}
exports.create_documentType = create_documentType;
/**
 * Creates a new `Element` node.
 *
 * @param document - owner document
 * @param localName - local name
 * @param namespace - namespace
 * @param prefix - namespace prefix
 */ function create_element(document, localName, namespace, prefix) {
    return ElementImpl_1.ElementImpl._create(document, localName, namespace, prefix);
}
exports.create_element = create_element;
/**
 * Creates a new `HTMLElement` node.
 *
 * @param document - owner document
 * @param localName - local name
 * @param namespace - namespace
 * @param prefix - namespace prefix
 */ function create_htmlElement(document, localName, namespace, prefix) {
    // TODO: Implement in HTML DOM
    return ElementImpl_1.ElementImpl._create(document, localName, namespace, prefix);
}
exports.create_htmlElement = create_htmlElement;
/**
 * Creates a new `HTMLUnknownElement` node.
 *
 * @param document - owner document
 * @param localName - local name
 * @param namespace - namespace
 * @param prefix - namespace prefix
 */ function create_htmlUnknownElement(document, localName, namespace, prefix) {
    // TODO: Implement in HTML DOM
    return ElementImpl_1.ElementImpl._create(document, localName, namespace, prefix);
}
exports.create_htmlUnknownElement = create_htmlUnknownElement;
/**
 * Creates a new `DocumentFragment` node.
 *
 * @param document - owner document
 */ function create_documentFragment(document) {
    return DocumentFragmentImpl_1.DocumentFragmentImpl._create(document);
}
exports.create_documentFragment = create_documentFragment;
/**
 * Creates a new `ShadowRoot` node.
 *
 * @param document - owner document
 * @param host - shadow root's host element node
 */ function create_shadowRoot(document, host) {
    return ShadowRootImpl_1.ShadowRootImpl._create(document, host);
}
exports.create_shadowRoot = create_shadowRoot;
/**
 * Creates a new `Attr` node.
 *
 * @param document - owner document
 * @param localName - local name
 */ function create_attr(document, localName) {
    return AttrImpl_1.AttrImpl._create(document, localName);
}
exports.create_attr = create_attr;
/**
 * Creates a new `Text` node.
 *
 * @param document - owner document
 * @param data - node contents
 */ function create_text(document, data) {
    return TextImpl_1.TextImpl._create(document, data);
}
exports.create_text = create_text;
/**
 * Creates a new `CDATASection` node.
 *
 * @param document - owner document
 * @param data - node contents
 */ function create_cdataSection(document, data) {
    return CDATASectionImpl_1.CDATASectionImpl._create(document, data);
}
exports.create_cdataSection = create_cdataSection;
/**
 * Creates a new `Comment` node.
 *
 * @param document - owner document
 * @param data - node contents
 */ function create_comment(document, data) {
    return CommentImpl_1.CommentImpl._create(document, data);
}
exports.create_comment = create_comment;
/**
 * Creates a new `ProcessingInstruction` node.
 *
 * @param document - owner document
 * @param target - instruction target
 * @param data - node contents
 */ function create_processingInstruction(document, target, data) {
    return ProcessingInstructionImpl_1.ProcessingInstructionImpl._create(document, target, data);
}
exports.create_processingInstruction = create_processingInstruction;
/**
 * Creates a new `HTMLCollection`.
 *
 * @param root - root node
 * @param filter - node filter
 */ function create_htmlCollection(root, filter) {
    if (filter === void 0) {
        filter = function() {
            return true;
        };
    }
    return HTMLCollectionImpl_1.HTMLCollectionImpl._create(root, filter);
}
exports.create_htmlCollection = create_htmlCollection;
/**
 * Creates a new live `NodeList`.
 *
 * @param root - root node
 */ function create_nodeList(root) {
    return NodeListImpl_1.NodeListImpl._create(root);
}
exports.create_nodeList = create_nodeList;
/**
 * Creates a new static `NodeList`.
 *
 * @param root - root node
 * @param items - a list of items to initialize the list
 */ function create_nodeListStatic(root, items) {
    return NodeListStaticImpl_1.NodeListStaticImpl._create(root, items);
}
exports.create_nodeListStatic = create_nodeListStatic;
/**
 * Creates a new `NamedNodeMap`.
 *
 * @param element - parent element
 */ function create_namedNodeMap(element) {
    return NamedNodeMapImpl_1.NamedNodeMapImpl._create(element);
}
exports.create_namedNodeMap = create_namedNodeMap;
/**
 * Creates a new `Range`.
 *
 * @param start - start point
 * @param end - end point
 */ function create_range(start, end) {
    return RangeImpl_1.RangeImpl._create(start, end);
}
exports.create_range = create_range;
/**
 * Creates a new `NodeIterator`.
 *
 * @param root - iterator's root node
 * @param reference - reference node
 * @param pointerBeforeReference - whether the iterator is before or after the
 * reference node
 */ function create_nodeIterator(root, reference, pointerBeforeReference) {
    return NodeIteratorImpl_1.NodeIteratorImpl._create(root, reference, pointerBeforeReference);
}
exports.create_nodeIterator = create_nodeIterator;
/**
 * Creates a new `TreeWalker`.
 *
 * @param root - iterator's root node
 * @param current - current node
 */ function create_treeWalker(root, current) {
    return TreeWalkerImpl_1.TreeWalkerImpl._create(root, current);
}
exports.create_treeWalker = create_treeWalker;
/**
 * Creates a new `NodeFilter`.
 */ function create_nodeFilter() {
    return NodeFilterImpl_1.NodeFilterImpl._create();
}
exports.create_nodeFilter = create_nodeFilter;
/**
 * Creates a new `MutationRecord`.
 *
 * @param type - type of mutation: `"attributes"` for an attribute
 * mutation, `"characterData"` for a mutation to a CharacterData node
 * and `"childList"` for a mutation to the tree of nodes.
 * @param target - node affected by the mutation.
 * @param addedNodes - list of added nodes.
 * @param removedNodes - list of removed nodes.
 * @param previousSibling - previous sibling of added or removed nodes.
 * @param nextSibling - next sibling of added or removed nodes.
 * @param attributeName - local name of the changed attribute,
 * and `null` otherwise.
 * @param attributeNamespace - namespace of the changed attribute,
 * and `null` otherwise.
 * @param oldValue - value before mutation: attribute value for an attribute
 * mutation, node `data` for a mutation to a CharacterData node and `null`
 * for a mutation to the tree of nodes.
 */ function create_mutationRecord(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
    return MutationRecordImpl_1.MutationRecordImpl._create(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue);
}
exports.create_mutationRecord = create_mutationRecord;
/**
 * Creates a new `DOMTokenList`.
 *
 * @param element - associated element
 * @param attribute - associated attribute
 */ function create_domTokenList(element, attribute) {
    return DOMTokenListImpl_1.DOMTokenListImpl._create(element, attribute);
}
exports.create_domTokenList = create_domTokenList; //# sourceMappingURL=CreateAlgorithm.js.map


/***/ }),

/***/ 3381:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var PotentialCustomElementName = /[a-z]([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*-([\0-\t\x2D\._a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*/;
var NamesWithHyphen = new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
]);
var ElementNames = new Set([
    "article",
    "aside",
    "blockquote",
    "body",
    "div",
    "footer",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "main",
    "nav",
    "p",
    "section",
    "span"
]);
var VoidElementNames = new Set([
    "area",
    "base",
    "basefont",
    "bgsound",
    "br",
    "col",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "menuitem",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
]);
var ShadowHostNames = new Set([
    "article",
    "aside",
    "blockquote",
    "body",
    "div",
    "footer",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "header",
    "main",
    "nav",
    "p",
    "section",
    "span"
]);
/**
 * Determines if the given string is a valid custom element name.
 *
 * @param name - a name string
 */ function customElement_isValidCustomElementName(name) {
    if (!PotentialCustomElementName.test(name)) return false;
    if (NamesWithHyphen.has(name)) return false;
    return true;
}
exports.customElement_isValidCustomElementName = customElement_isValidCustomElementName;
/**
 * Determines if the given string is a valid element name.
 *
 * @param name - a name string
 */ function customElement_isValidElementName(name) {
    return ElementNames.has(name);
}
exports.customElement_isValidElementName = customElement_isValidElementName;
/**
 * Determines if the given string is a void element name.
 *
 * @param name - a name string
 */ function customElement_isVoidElementName(name) {
    return VoidElementNames.has(name);
}
exports.customElement_isVoidElementName = customElement_isVoidElementName;
/**
 * Determines if the given string is a valid shadow host element name.
 *
 * @param name - a name string
 */ function customElement_isValidShadowHostName(name) {
    return ShadowHostNames.has(name);
}
exports.customElement_isValidShadowHostName = customElement_isValidShadowHostName;
/**
 * Enqueues an upgrade reaction for a custom element.
 *
 * @param element - a custom element
 * @param definition - a custom element definition
 */ function customElement_enqueueACustomElementUpgradeReaction(element, definition) {
// TODO: Implement in HTML DOM
}
exports.customElement_enqueueACustomElementUpgradeReaction = customElement_enqueueACustomElementUpgradeReaction;
/**
 * Enqueues a callback reaction for a custom element.
 *
 * @param element - a custom element
 * @param callbackName - name of the callback
 * @param args - callback arguments
 */ function customElement_enqueueACustomElementCallbackReaction(element, callbackName, args) {
// TODO: Implement in HTML DOM
}
exports.customElement_enqueueACustomElementCallbackReaction = customElement_enqueueACustomElementCallbackReaction;
/**
 * Upgrade a custom element.
 *
 * @param element - a custom element
 */ function customElement_upgrade(definition, element) {
// TODO: Implement in HTML DOM
}
exports.customElement_upgrade = customElement_upgrade;
/**
 * Tries to upgrade a custom element.
 *
 * @param element - a custom element
 */ function customElement_tryToUpgrade(element) {
// TODO: Implement in HTML DOM
}
exports.customElement_tryToUpgrade = customElement_tryToUpgrade;
/**
 * Looks up a custom element definition.
 *
 * @param document - a document
 * @param namespace - element namespace
 * @param localName - element local name
 * @param is - an `is` value
 */ function customElement_lookUpACustomElementDefinition(document, namespace, localName, is) {
    // TODO: Implement in HTML DOM
    return null;
}
exports.customElement_lookUpACustomElementDefinition = customElement_lookUpACustomElementDefinition; //# sourceMappingURL=CustomElementAlgorithm.js.map


/***/ }),

/***/ 24473:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var TreeAlgorithm_1 = __webpack_require__(59614);
var util_1 = __webpack_require__(57294);
var ShadowTreeAlgorithm_1 = __webpack_require__(49576);
var supportedTokens = new Map();
/**
 * Runs removing steps for node.
 *
 * @param removedNode - removed node
 * @param oldParent - old parent node
 */ function dom_runRemovingSteps(removedNode, oldParent) {
// No steps defined
}
exports.dom_runRemovingSteps = dom_runRemovingSteps;
/**
 * Runs cloning steps for node.
 *
 * @param copy - node clone
 * @param node - node
 * @param document - document to own the cloned node
 * @param cloneChildrenFlag - whether child nodes are cloned
 */ function dom_runCloningSteps(copy, node, document, cloneChildrenFlag) {
// No steps defined
}
exports.dom_runCloningSteps = dom_runCloningSteps;
/**
 * Runs adopting steps for node.
 *
 * @param node - node
 * @param oldDocument - old document
 */ function dom_runAdoptingSteps(node, oldDocument) {
// No steps defined
}
exports.dom_runAdoptingSteps = dom_runAdoptingSteps;
/**
 * Runs attribute change steps for an element node.
 *
 * @param element - element node owning the attribute
 * @param localName - attribute's local name
 * @param oldValue - attribute's old value
 * @param value - attribute's new value
 * @param namespace - attribute's namespace
 */ function dom_runAttributeChangeSteps(element, localName, oldValue, value, namespace) {
    var e_1, _a;
    // run default steps
    if (DOMImpl_1.dom.features.slots) {
        updateASlotablesName.call(element, element, localName, oldValue, value, namespace);
        updateASlotsName.call(element, element, localName, oldValue, value, namespace);
    }
    updateAnElementID.call(element, element, localName, value, namespace);
    try {
        // run custom steps
        for(var _b = __values(element._attributeChangeSteps), _c = _b.next(); !_c.done; _c = _b.next()){
            var step = _c.value;
            step.call(element, element, localName, oldValue, value, namespace);
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
}
exports.dom_runAttributeChangeSteps = dom_runAttributeChangeSteps;
/**
 * Runs insertion steps for a node.
 *
 * @param insertedNode - inserted node
 */ function dom_runInsertionSteps(insertedNode) {
// No steps defined
}
exports.dom_runInsertionSteps = dom_runInsertionSteps;
/**
 * Runs pre-removing steps for a node iterator and node.
 *
 * @param nodeIterator - a node iterator
 * @param toBeRemoved - node to be removed
 */ function dom_runNodeIteratorPreRemovingSteps(nodeIterator, toBeRemoved) {
    removeNodeIterator.call(nodeIterator, nodeIterator, toBeRemoved);
}
exports.dom_runNodeIteratorPreRemovingSteps = dom_runNodeIteratorPreRemovingSteps;
/**
 * Determines if there are any supported tokens defined for the given
 * attribute name.
 *
 * @param attributeName - an attribute name
 */ function dom_hasSupportedTokens(attributeName) {
    return supportedTokens.has(attributeName);
}
exports.dom_hasSupportedTokens = dom_hasSupportedTokens;
/**
 * Returns the set of supported tokens defined for the given attribute name.
 *
 * @param attributeName - an attribute name
 */ function dom_getSupportedTokens(attributeName) {
    return supportedTokens.get(attributeName) || new Set();
}
exports.dom_getSupportedTokens = dom_getSupportedTokens;
/**
 * Runs event construction steps.
 *
 * @param event - an event
 */ function dom_runEventConstructingSteps(event) {
// No steps defined
}
exports.dom_runEventConstructingSteps = dom_runEventConstructingSteps;
/**
 * Runs child text content change steps for a parent node.
 *
 * @param parent - parent node with text node child nodes
 */ function dom_runChildTextContentChangeSteps(parent) {
// No steps defined
}
exports.dom_runChildTextContentChangeSteps = dom_runChildTextContentChangeSteps;
/**
 * Defines pre-removing steps for a node iterator.
 */ function removeNodeIterator(nodeIterator, toBeRemovedNode) {
    /**
     * 1. If toBeRemovedNode is not an inclusive ancestor of nodeIterator’s
     * reference, or toBeRemovedNode is nodeIterator’s root, then return.
     */ if (toBeRemovedNode === nodeIterator._root || !TreeAlgorithm_1.tree_isAncestorOf(nodeIterator._reference, toBeRemovedNode, true)) {
        return;
    }
    /**
     * 2. If nodeIterator’s pointer before reference is true, then:
     */ if (nodeIterator._pointerBeforeReference) {
        /**
         * 2.1. Let next be toBeRemovedNode’s first following node that is an
         * inclusive descendant of nodeIterator’s root and is not an inclusive
         * descendant of toBeRemovedNode, and null if there is no such node.
         */ while(true){
            var nextNode = TreeAlgorithm_1.tree_getFollowingNode(nodeIterator._root, toBeRemovedNode);
            if (nextNode !== null && TreeAlgorithm_1.tree_isDescendantOf(nodeIterator._root, nextNode, true) && !TreeAlgorithm_1.tree_isDescendantOf(toBeRemovedNode, nextNode, true)) {
                /**
                 * 2.2. If next is non-null, then set nodeIterator’s reference to next
                 * and return.
                 */ nodeIterator._reference = nextNode;
                return;
            } else if (nextNode === null) {
                /**
                 * 2.3. Otherwise, set nodeIterator’s pointer before reference to false.
                 */ nodeIterator._pointerBeforeReference = false;
                return;
            }
        }
    }
    /**
     * 3. Set nodeIterator’s reference to toBeRemovedNode’s parent, if
     * toBeRemovedNode’s previous sibling is null, and to the inclusive
     * descendant of toBeRemovedNode’s previous sibling that appears last in
     * tree order otherwise.
     */ if (toBeRemovedNode._previousSibling === null) {
        if (toBeRemovedNode._parent !== null) {
            nodeIterator._reference = toBeRemovedNode._parent;
        }
    } else {
        var referenceNode = toBeRemovedNode._previousSibling;
        var childNode = TreeAlgorithm_1.tree_getFirstDescendantNode(toBeRemovedNode._previousSibling, true, false);
        while(childNode !== null){
            if (childNode !== null) {
                referenceNode = childNode;
            }
            // loop through to get the last descendant node
            childNode = TreeAlgorithm_1.tree_getNextDescendantNode(toBeRemovedNode._previousSibling, childNode, true, false);
        }
        nodeIterator._reference = referenceNode;
    }
}
/**
 * Defines attribute change steps to update a slot’s name.
 */ function updateASlotsName(element, localName, oldValue, value, namespace) {
    /**
     * 1. If element is a slot, localName is name, and namespace is null, then:
     * 1.1. If value is oldValue, then return.
     * 1.2. If value is null and oldValue is the empty string, then return.
     * 1.3. If value is the empty string and oldValue is null, then return.
     * 1.4. If value is null or the empty string, then set element’s name to the
     * empty string.
     * 1.5. Otherwise, set element’s name to value.
     * 1.6. Run assign slotables for a tree with element’s root.
     */ if (util_1.Guard.isSlot(element) && localName === "name" && namespace === null) {
        if (value === oldValue) return;
        if (value === null && oldValue === "") return;
        if (value === "" && oldValue === null) return;
        if (value === null || value === "") {
            element._name = "";
        } else {
            element._name = value;
        }
        ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(element));
    }
}
/**
 * Defines attribute change steps to update a slotable’s name.
 */ function updateASlotablesName(element, localName, oldValue, value, namespace) {
    /**
     * 1. If localName is slot and namespace is null, then:
     * 1.1. If value is oldValue, then return.
     * 1.2. If value is null and oldValue is the empty string, then return.
     * 1.3. If value is the empty string and oldValue is null, then return.
     * 1.4. If value is null or the empty string, then set element’s name to
     * the empty string.
     * 1.5. Otherwise, set element’s name to value.
     * 1.6. If element is assigned, then run assign slotables for element’s
     * assigned slot.
     * 1.7. Run assign a slot for element.
     */ if (util_1.Guard.isSlotable(element) && localName === "slot" && namespace === null) {
        if (value === oldValue) return;
        if (value === null && oldValue === "") return;
        if (value === "" && oldValue === null) return;
        if (value === null || value === "") {
            element._name = "";
        } else {
            element._name = value;
        }
        if (ShadowTreeAlgorithm_1.shadowTree_isAssigned(element)) {
            ShadowTreeAlgorithm_1.shadowTree_assignSlotables(element._assignedSlot);
        }
        ShadowTreeAlgorithm_1.shadowTree_assignASlot(element);
    }
}
/**
 * Defines attribute change steps to update an element's ID.
 */ function updateAnElementID(element, localName, value, namespace) {
    /**
     * 1. If localName is id, namespace is null, and value is null or the empty
     * string, then unset element’s ID.
     * 2. Otherwise, if localName is id, namespace is null, then set element’s
     * ID to value.
     */ if (localName === "id" && namespace === null) {
        if (!value) element._uniqueIdentifier = undefined;
        else element._uniqueIdentifier = value;
    }
} //# sourceMappingURL=DOMAlgorithm.js.map


/***/ }),

/***/ 87595:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var OrderedSetAlgorithm_1 = __webpack_require__(26072);
var DOMAlgorithm_1 = __webpack_require__(24473);
var ElementAlgorithm_1 = __webpack_require__(60077);
/**
 * Validates a given token against the supported tokens defined for the given
 * token lists' associated attribute.
 *
 * @param tokenList - a token list
 * @param token - a token
 */ function tokenList_validationSteps(tokenList, token) {
    /**
     * 1. If the associated attribute’s local name does not define supported
     * tokens, throw a TypeError.
     * 2. Let lowercase token be a copy of token, in ASCII lowercase.
     * 3. If lowercase token is present in supported tokens, return true.
     * 4. Return false.
     */ if (!DOMAlgorithm_1.dom_hasSupportedTokens(tokenList._attribute._localName)) {
        throw new TypeError("There are no supported tokens defined for attribute name: '" + tokenList._attribute._localName + "'.");
    }
    return DOMAlgorithm_1.dom_getSupportedTokens(tokenList._attribute._localName).has(token.toLowerCase());
}
exports.tokenList_validationSteps = tokenList_validationSteps;
/**
 * Updates the value of the token lists' associated attribute.
 *
 * @param tokenList - a token list
 */ function tokenList_updateSteps(tokenList) {
    /**
     * 1. If the associated element does not have an associated attribute and
     * token set is empty, then return.
     * 2. Set an attribute value for the associated element using associated
     * attribute’s local name and the result of running the ordered set
     * serializer for token set.
     */ if (!tokenList._element.hasAttribute(tokenList._attribute._localName) && tokenList._tokenSet.size === 0) {
        return;
    }
    ElementAlgorithm_1.element_setAnAttributeValue(tokenList._element, tokenList._attribute._localName, OrderedSetAlgorithm_1.orderedSet_serialize(tokenList._tokenSet));
}
exports.tokenList_updateSteps = tokenList_updateSteps;
/**
 * Gets the value of the token lists' associated attribute.
 *
 * @param tokenList - a token list
 */ function tokenList_serializeSteps(tokenList) {
    /**
     * A DOMTokenList object’s serialize steps are to return the result of
     * running get an attribute value given the associated element and the
     * associated attribute’s local name.
     */ return ElementAlgorithm_1.element_getAnAttributeValue(tokenList._element, tokenList._attribute._localName);
}
exports.tokenList_serializeSteps = tokenList_serializeSteps; //# sourceMappingURL=DOMTokenListAlgorithm.js.map


/***/ }),

/***/ 81424:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var util_1 = __webpack_require__(57294);
var util_2 = __webpack_require__(96883);
var ElementImpl_1 = __webpack_require__(33086);
var CustomElementAlgorithm_1 = __webpack_require__(3381);
var TreeAlgorithm_1 = __webpack_require__(59614);
var NamespaceAlgorithm_1 = __webpack_require__(47277);
var DOMAlgorithm_1 = __webpack_require__(24473);
var ElementAlgorithm_1 = __webpack_require__(60077);
var MutationAlgorithm_1 = __webpack_require__(31400);
/**
 * Returns an element interface for the given name and namespace.
 *
 * @param name - element name
 * @param namespace - namespace
 */ function document_elementInterface(name, namespace) {
    return ElementImpl_1.ElementImpl;
}
exports.document_elementInterface = document_elementInterface;
/**
 * Creates a new element node.
 * See: https://dom.spec.whatwg.org/#internal-createelementns-steps
 *
 * @param document - owner document
 * @param namespace - element namespace
 * @param qualifiedName - qualified name
 * @param options - element options
 */ function document_internalCreateElementNS(document, namespace, qualifiedName, options) {
    /**
     * 1. Let namespace, prefix, and localName be the result of passing
     * namespace and qualifiedName to validate and extract.
     * 2. Let is be null.
     * 3. If options is a dictionary and options’s is is present, then set
     * is to it.
     * 4. Return the result of creating an element given document, localName,
     * namespace, prefix, is, and with the synchronous custom elements flag set.
     */ var _a = __read(NamespaceAlgorithm_1.namespace_validateAndExtract(namespace, qualifiedName), 3), ns = _a[0], prefix = _a[1], localName = _a[2];
    var is = null;
    if (options !== undefined) {
        if (util_2.isString(options)) {
            is = options;
        } else {
            is = options.is;
        }
    }
    return ElementAlgorithm_1.element_createAnElement(document, localName, ns, prefix, is, true);
}
exports.document_internalCreateElementNS = document_internalCreateElementNS;
/**
 * Removes `node` and its subtree from its document and changes
 * its owner document to `document` so that it can be inserted
 * into `document`.
 *
 * @param node - the node to move
 * @param document - document to receive the node and its subtree
 */ function document_adopt(node, document) {
    var e_1, _a;
    // Optimize for common case of inserting a fresh node
    if (node._nodeDocument === document && node._parent === null) {
        return;
    }
    /**
     * 1. Let oldDocument be node’s node document.
     * 2. If node’s parent is not null, remove node from its parent.
     */ var oldDocument = node._nodeDocument;
    if (node._parent) MutationAlgorithm_1.mutation_remove(node, node._parent);
    /**
     * 3. If document is not oldDocument, then:
     */ if (document !== oldDocument) {
        /**
         * 3.1. For each inclusiveDescendant in node’s shadow-including inclusive
         * descendants:
         */ var inclusiveDescendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node, true, true);
        while(inclusiveDescendant !== null){
            /**
             * 3.1.1. Set inclusiveDescendant’s node document to document.
             * 3.1.2. If inclusiveDescendant is an element, then set the node
             * document of each attribute in inclusiveDescendant’s attribute list
             * to document.
             */ inclusiveDescendant._nodeDocument = document;
            if (util_1.Guard.isElementNode(inclusiveDescendant)) {
                try {
                    for(var _b = (e_1 = void 0, __values(inclusiveDescendant._attributeList._asArray())), _c = _b.next(); !_c.done; _c = _b.next()){
                        var attr = _c.value;
                        attr._nodeDocument = document;
                    }
                } catch (e_1_1) {
                    e_1 = {
                        error: e_1_1
                    };
                } finally{
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    } finally{
                        if (e_1) throw e_1.error;
                    }
                }
            }
            /**
             * 3.2. For each inclusiveDescendant in node's shadow-including
             * inclusive descendants that is custom, enqueue a custom
             * element callback reaction with inclusiveDescendant,
             * callback name "adoptedCallback", and an argument list
             * containing oldDocument and document.
             */ if (DOMImpl_1.dom.features.customElements) {
                if (util_1.Guard.isElementNode(inclusiveDescendant) && inclusiveDescendant._customElementState === "custom") {
                    CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(inclusiveDescendant, "adoptedCallback", [
                        oldDocument,
                        document
                    ]);
                }
            }
            /**
             * 3.3. For each inclusiveDescendant in node’s shadow-including
             * inclusive descendants, in shadow-including tree order, run the
             * adopting steps with inclusiveDescendant and oldDocument.
             */ if (DOMImpl_1.dom.features.steps) {
                DOMAlgorithm_1.dom_runAdoptingSteps(inclusiveDescendant, oldDocument);
            }
            inclusiveDescendant = TreeAlgorithm_1.tree_getNextDescendantNode(node, inclusiveDescendant, true, true);
        }
    }
}
exports.document_adopt = document_adopt; //# sourceMappingURL=DocumentAlgorithm.js.map


/***/ }),

/***/ 60077:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var infra_1 = __webpack_require__(94317);
var util_1 = __webpack_require__(57294);
var DOMException_1 = __webpack_require__(28905);
var CreateAlgorithm_1 = __webpack_require__(21701);
var CustomElementAlgorithm_1 = __webpack_require__(3381);
var MutationObserverAlgorithm_1 = __webpack_require__(5742);
var DOMAlgorithm_1 = __webpack_require__(24473);
var MutationAlgorithm_1 = __webpack_require__(31400);
var DocumentAlgorithm_1 = __webpack_require__(81424);
/**
 * Determines whether the element's attribute list contains the given
 * attribute.
 *
 * @param attribute - an attribute node
 * @param element - an element node
 */ function element_has(attribute, element) {
    /**
     * An element has an attribute A if its attribute list contains A.
     */ return element._attributeList._asArray().indexOf(attribute) !== -1;
}
exports.element_has = element_has;
/**
 * Changes the value of an attribute node.
 *
 * @param attribute - an attribute node
 * @param element - an element node
 * @param value - attribute value
 */ function element_change(attribute, element, value) {
    /**
     * 1. Queue an attribute mutation record for element with attribute’s
     * local name, attribute’s namespace, and attribute’s value.
     */ if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, attribute._localName, attribute._namespace, attribute._value);
    }
    /**
     * 2. If element is custom, then enqueue a custom element callback reaction
     * with element, callback name "attributeChangedCallback", and an argument
     * list containing attribute’s local name, attribute’s value, value, and
     * attribute’s namespace.
     */ if (DOMImpl_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(element)) {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, "attributeChangedCallback", [
                attribute._localName,
                attribute._value,
                value,
                attribute._namespace
            ]);
        }
    }
    /**
     * 3. Run the attribute change steps with element, attribute’s local name,
     * attribute’s value, value, and attribute’s namespace.
     * 4. Set attribute’s value to value.
     */ if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runAttributeChangeSteps(element, attribute._localName, attribute._value, value, attribute._namespace);
    }
    attribute._value = value;
}
exports.element_change = element_change;
/**
 * Appends an attribute to an element node.
 *
 * @param attribute - an attribute
 * @param element - an element to receive the attribute
 */ function element_append(attribute, element) {
    /**
     * 1. Queue an attribute mutation record for element with attribute’s
     * local name, attribute’s namespace, and null.
     */ if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, attribute._localName, attribute._namespace, null);
    }
    /**
     * 2. If element is custom, then enqueue a custom element callback reaction
     * with element, callback name "attributeChangedCallback", and an argument
     * list containing attribute’s local name, null, attribute’s value, and
     * attribute’s namespace.
     */ if (DOMImpl_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(element)) {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, "attributeChangedCallback", [
                attribute._localName,
                null,
                attribute._value,
                attribute._namespace
            ]);
        }
    }
    /**
     * 3. Run the attribute change steps with element, attribute’s local name,
     * null, attribute’s value, and attribute’s namespace.
     */ if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runAttributeChangeSteps(element, attribute._localName, null, attribute._value, attribute._namespace);
    }
    /**
     * 4. Append attribute to element’s attribute list.
     * 5. Set attribute’s element to element.
     */ element._attributeList._asArray().push(attribute);
    attribute._element = element;
    // mark that the document has namespaces
    if (!element._nodeDocument._hasNamespaces && (attribute._namespace !== null || attribute._namespacePrefix !== null || attribute._localName === "xmlns")) {
        element._nodeDocument._hasNamespaces = true;
    }
}
exports.element_append = element_append;
/**
 * Removes an attribute from an element node.
 *
 * @param attribute - an attribute
 * @param element - an element to receive the attribute
 */ function element_remove(attribute, element) {
    /**
     * 1. Queue an attribute mutation record for element with attribute’s
     * local name, attribute’s namespace, and attribute’s value.
     */ if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, attribute._localName, attribute._namespace, attribute._value);
    }
    /**
     * 2. If element is custom, then enqueue a custom element callback reaction
     * with element, callback name "attributeChangedCallback", and an argument
     * list containing attribute’s local name, attribute’s value, null,
     * and attribute’s namespace.
     */ if (DOMImpl_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(element)) {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, "attributeChangedCallback", [
                attribute._localName,
                attribute._value,
                null,
                attribute._namespace
            ]);
        }
    }
    /**
     * 3. Run the attribute change steps with element, attribute’s local name,
     * attribute’s value, null, and attribute’s namespace.
     */ if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runAttributeChangeSteps(element, attribute._localName, attribute._value, null, attribute._namespace);
    }
    /**
     * 3. Remove attribute from element’s attribute list.
     * 5. Set attribute’s element to null.
     */ var index = element._attributeList._asArray().indexOf(attribute);
    element._attributeList._asArray().splice(index, 1);
    attribute._element = null;
}
exports.element_remove = element_remove;
/**
 * Replaces an attribute with another of an element node.
 *
 * @param oldAttr - old attribute
 * @param newAttr - new attribute
 * @param element - an element to receive the attribute
 */ function element_replace(oldAttr, newAttr, element) {
    /**
     * 1. Queue an attribute mutation record for element with oldAttr’s
     * local name, oldAttr’s namespace, and oldAttr’s value.
     */ if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueAttributeMutationRecord(element, oldAttr._localName, oldAttr._namespace, oldAttr._value);
    }
    /**
     * 2. If element is custom, then enqueue a custom element callback reaction
     * with element, callback name "attributeChangedCallback", and an argument
     * list containing oldAttr’s local name, oldAttr’s value, newAttr’s value,
     * and oldAttr’s namespace.
     */ if (DOMImpl_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(element)) {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(element, "attributeChangedCallback", [
                oldAttr._localName,
                oldAttr._value,
                newAttr._value,
                oldAttr._namespace
            ]);
        }
    }
    /**
     * 3. Run the attribute change steps with element, oldAttr’s local name,
     * oldAttr’s value, newAttr’s value, and oldAttr’s namespace.
     */ if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runAttributeChangeSteps(element, oldAttr._localName, oldAttr._value, newAttr._value, oldAttr._namespace);
    }
    /**
     * 4. Replace oldAttr by newAttr in element’s attribute list.
     * 5. Set oldAttr’s element to null.
     * 6. Set newAttr’s element to element.
     */ var index = element._attributeList._asArray().indexOf(oldAttr);
    if (index !== -1) {
        element._attributeList._asArray()[index] = newAttr;
    }
    oldAttr._element = null;
    newAttr._element = element;
    // mark that the document has namespaces
    if (!element._nodeDocument._hasNamespaces && (newAttr._namespace !== null || newAttr._namespacePrefix !== null || newAttr._localName === "xmlns")) {
        element._nodeDocument._hasNamespaces = true;
    }
}
exports.element_replace = element_replace;
/**
 * Retrieves an attribute with the given name from an element node.
 *
 * @param qualifiedName - an attribute name
 * @param element - an element to receive the attribute
 */ function element_getAnAttributeByName(qualifiedName, element) {
    /**
     * 1. If element is in the HTML namespace and its node document is an HTML
     * document, then set qualifiedName to qualifiedName in ASCII lowercase.
     * 2. Return the first attribute in element’s attribute list whose qualified
     * name is qualifiedName, and null otherwise.
     */ if (element._namespace === infra_1.namespace.HTML && element._nodeDocument._type === "html") {
        qualifiedName = qualifiedName.toLowerCase();
    }
    return element._attributeList._asArray().find(function(attr) {
        return attr._qualifiedName === qualifiedName;
    }) || null;
}
exports.element_getAnAttributeByName = element_getAnAttributeByName;
/**
 * Retrieves an attribute with the given namespace and local name from an
 * element node.
 *
 * @param namespace - an attribute namespace
 * @param localName - an attribute local name
 * @param element - an element to receive the attribute
 */ function element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element) {
    /**
     * 1. If namespace is the empty string, set it to null.
     * 2. Return the attribute in element’s attribute list whose namespace is
     * namespace and local name is localName, if any, and null otherwise.
     */ var ns = namespace || null;
    return element._attributeList._asArray().find(function(attr) {
        return attr._namespace === ns && attr._localName === localName;
    }) || null;
}
exports.element_getAnAttributeByNamespaceAndLocalName = element_getAnAttributeByNamespaceAndLocalName;
/**
 * Retrieves an attribute's value with the given name namespace and local
 * name from an element node.
 *
 * @param element - an element to receive the attribute
 * @param localName - an attribute local name
 * @param namespace - an attribute namespace
 */ function element_getAnAttributeValue(element, localName, namespace) {
    if (namespace === void 0) {
        namespace = "";
    }
    /**
     * 1. Let attr be the result of getting an attribute given namespace,
     * localName, and element.
     * 2. If attr is null, then return the empty string.
     * 3. Return attr’s value.
     */ var attr = element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element);
    if (attr === null) return "";
    else return attr._value;
}
exports.element_getAnAttributeValue = element_getAnAttributeValue;
/**
 * Sets an attribute of an element node.
 *
 * @param attr - an attribute
 * @param element - an element to receive the attribute
 */ function element_setAnAttribute(attr, element) {
    /**
     * 1. If attr’s element is neither null nor element, throw an
     * "InUseAttributeError" DOMException.
     * 2. Let oldAttr be the result of getting an attribute given attr’s
     * namespace, attr’s local name, and element.
     * 3. If oldAttr is attr, return attr.
     * 4. If oldAttr is non-null, replace it by attr in element.
     * 5. Otherwise, append attr to element.
     * 6. Return oldAttr.
     */ if (attr._element !== null && attr._element !== element) throw new DOMException_1.InUseAttributeError("This attribute already exists in the document: " + attr._qualifiedName + " as a child of " + attr._element._qualifiedName + ".");
    var oldAttr = element_getAnAttributeByNamespaceAndLocalName(attr._namespace || "", attr._localName, element);
    if (oldAttr === attr) return attr;
    if (oldAttr !== null) {
        element_replace(oldAttr, attr, element);
    } else {
        element_append(attr, element);
    }
    return oldAttr;
}
exports.element_setAnAttribute = element_setAnAttribute;
/**
 * Sets an attribute's value of an element node.
 *
 * @param element - an element to receive the attribute
 * @param localName - an attribute local name
 * @param value - an attribute value
 * @param prefix - an attribute prefix
 * @param namespace - an attribute namespace
 */ function element_setAnAttributeValue(element, localName, value, prefix, namespace) {
    if (prefix === void 0) {
        prefix = null;
    }
    if (namespace === void 0) {
        namespace = null;
    }
    /**
     * 1. If prefix is not given, set it to null.
     * 2. If namespace is not given, set it to null.
     * 3. Let attribute be the result of getting an attribute given namespace,
     * localName, and element.
     * 4. If attribute is null, create an attribute whose namespace is
     * namespace, namespace prefix is prefix, local name is localName, value
     * is value, and node document is element’s node document, then append this
     * attribute to element, and then return.
     * 5. Change attribute from element to value.
     */ var attribute = element_getAnAttributeByNamespaceAndLocalName(namespace || "", localName, element);
    if (attribute === null) {
        var newAttr = CreateAlgorithm_1.create_attr(element._nodeDocument, localName);
        newAttr._namespace = namespace;
        newAttr._namespacePrefix = prefix;
        newAttr._value = value;
        element_append(newAttr, element);
        return;
    }
    element_change(attribute, element, value);
}
exports.element_setAnAttributeValue = element_setAnAttributeValue;
/**
 * Removes an attribute with the given name from an element node.
 *
 * @param qualifiedName - an attribute name
 * @param element - an element to receive the attribute
 */ function element_removeAnAttributeByName(qualifiedName, element) {
    /**
     * 1. Let attr be the result of getting an attribute given qualifiedName
     * and element.
     * 2. If attr is non-null, remove it from element.
     * 3. Return attr.
     */ var attr = element_getAnAttributeByName(qualifiedName, element);
    if (attr !== null) {
        element_remove(attr, element);
    }
    return attr;
}
exports.element_removeAnAttributeByName = element_removeAnAttributeByName;
/**
 * Removes an attribute with the given namespace and local name from an
 * element node.
 *
 * @param namespace - an attribute namespace
 * @param localName - an attribute local name
 * @param element - an element to receive the attribute
 */ function element_removeAnAttributeByNamespaceAndLocalName(namespace, localName, element) {
    /**
     * 1. Let attr be the result of getting an attribute given namespace, localName, and element.
     * 2. If attr is non-null, remove it from element.
     * 3. Return attr.
     */ var attr = element_getAnAttributeByNamespaceAndLocalName(namespace, localName, element);
    if (attr !== null) {
        element_remove(attr, element);
    }
    return attr;
}
exports.element_removeAnAttributeByNamespaceAndLocalName = element_removeAnAttributeByNamespaceAndLocalName;
/**
 * Creates an element node.
 * See: https://dom.spec.whatwg.org/#concept-create-element.
 *
 * @param document - the document owning the element
 * @param localName - local name
 * @param namespace - element namespace
 * @param prefix - namespace prefix
 * @param is - the "is" value
 * @param synchronousCustomElementsFlag - synchronous custom elements flag
 */ function element_createAnElement(document, localName, namespace, prefix, is, synchronousCustomElementsFlag) {
    if (prefix === void 0) {
        prefix = null;
    }
    if (is === void 0) {
        is = null;
    }
    if (synchronousCustomElementsFlag === void 0) {
        synchronousCustomElementsFlag = false;
    }
    /**
     * 1. If prefix was not given, let prefix be null.
     * 2. If is was not given, let is be null.
     * 3. Let result be null.
     */ var result = null;
    if (!DOMImpl_1.dom.features.customElements) {
        result = CreateAlgorithm_1.create_element(document, localName, namespace, prefix);
        result._customElementState = "uncustomized";
        result._customElementDefinition = null;
        result._is = is;
        return result;
    }
    /**
     * 4. Let definition be the result of looking up a custom element definition
     * given document, namespace, localName, and is.
     */ var definition = CustomElementAlgorithm_1.customElement_lookUpACustomElementDefinition(document, namespace, localName, is);
    if (definition !== null && definition.name !== definition.localName) {
        /**
        * 5. If definition is non-null, and definition’s name is not equal to
        * its local name (i.e., definition represents a customized built-in
        * element), then:
          * 5.1. Let interface be the element interface for localName and the HTML
          * namespace.
          * 5.2. Set result to a new element that implements interface, with no
          * attributes, namespace set to the HTML namespace, namespace prefix
          * set to prefix, local name set to localName, custom element state set
          * to "undefined", custom element definition set to null, is value set
          * to is, and node document set to document.
          * 5.3. If the synchronous custom elements flag is set, upgrade element
          * using definition.
          * 5.4. Otherwise, enqueue a custom element upgrade reaction given result
          * and definition.
          */ var elemenInterface = DocumentAlgorithm_1.document_elementInterface(localName, infra_1.namespace.HTML);
        result = new elemenInterface();
        result._localName = localName;
        result._namespace = infra_1.namespace.HTML;
        result._namespacePrefix = prefix;
        result._customElementState = "undefined";
        result._customElementDefinition = null;
        result._is = is;
        result._nodeDocument = document;
        if (synchronousCustomElementsFlag) {
            CustomElementAlgorithm_1.customElement_upgrade(definition, result);
        } else {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementUpgradeReaction(result, definition);
        }
    } else if (definition !== null) {
        /**
         * 6. Otherwise, if definition is non-null, then:
         */ if (synchronousCustomElementsFlag) {
            /**
             * 6.1. If the synchronous custom elements flag is set, then run these
             * steps while catching any exceptions:
             */ try {
                /**
                 * 6.1.1. Let C be definition’s constructor.
                 * 6.1.2. Set result to the result of constructing C, with no arguments.
                 * 6.1.3. Assert: result’s custom element state and custom element definition
                 * are initialized.
                 * 6.1.4. Assert: result’s namespace is the HTML namespace.
                 * _Note:_ IDL enforces that result is an HTMLElement object, which all
                 * use the HTML namespace.
                 */ var C = definition.constructor;
                var result_1 = new C();
                console.assert(result_1._customElementState !== undefined);
                console.assert(result_1._customElementDefinition !== undefined);
                console.assert(result_1._namespace === infra_1.namespace.HTML);
                /**
                 * 6.1.5. If result’s attribute list is not empty, then throw a
                 * "NotSupportedError" DOMException.
                 * 6.1.6. If result has children, then throw a "NotSupportedError"
                 * DOMException.
                 * 6.1.7. If result’s parent is not null, then throw a
                 * "NotSupportedError" DOMException.
                 * 6.1.8. If result’s node document is not document, then throw a
                 * "NotSupportedError" DOMException.
                 * 6.1.9. If result’s local name is not equal to localName, then throw
                 * a "NotSupportedError" DOMException.
                 */ if (result_1._attributeList.length !== 0) throw new DOMException_1.NotSupportedError("Custom element already has attributes.");
                if (result_1._children.size !== 0) throw new DOMException_1.NotSupportedError("Custom element already has child nodes.");
                if (result_1._parent !== null) throw new DOMException_1.NotSupportedError("Custom element already has a parent node.");
                if (result_1._nodeDocument !== document) throw new DOMException_1.NotSupportedError("Custom element is already in a document.");
                if (result_1._localName !== localName) throw new DOMException_1.NotSupportedError("Custom element has a different local name.");
                /**
                 * 6.1.10. Set result’s namespace prefix to prefix.
                 * 6.1.11. Set result’s is value to null.
                 */ result_1._namespacePrefix = prefix;
                result_1._is = null;
            } catch (e) {
                /**
                 * If any of these steps threw an exception, then:
                 * - Report the exception.
                 * - Set result to a new element that implements the HTMLUnknownElement
                 * interface, with no attributes, namespace set to the HTML namespace,
                 * namespace prefix set to prefix, local name set to localName, custom
                 * element state set to "failed", custom element definition set to null,
                 * is value set to null, and node document set to document.
                 */ // TODO: Report the exception
                result = CreateAlgorithm_1.create_htmlUnknownElement(document, localName, infra_1.namespace.HTML, prefix);
                result._customElementState = "failed";
                result._customElementDefinition = null;
                result._is = null;
            }
        } else {
            /**
             * 6.2. Otherwise:
             * 6.2.1. Set result to a new element that implements the HTMLElement
             * interface, with no attributes, namespace set to the HTML namespace,
             * namespace prefix set to prefix, local name set to localName, custom
             * element state set to "undefined", custom element definition set to
             * null, is value set to null, and node document set to document.
             * 6.2.2. Enqueue a custom element upgrade reaction given result and
             * definition.
             */ result = CreateAlgorithm_1.create_htmlElement(document, localName, infra_1.namespace.HTML, prefix);
            result._customElementState = "undefined";
            result._customElementDefinition = null;
            result._is = null;
            CustomElementAlgorithm_1.customElement_enqueueACustomElementUpgradeReaction(result, definition);
        }
    } else {
        /**
         * 7. Otherwise:
         * 7.1. Let interface be the element interface for localName and
         * namespace.
         * 7.2. Set result to a new element that implements interface, with no
         * attributes, namespace set to namespace, namespace prefix set to prefix,
         * local name set to localName, custom element state set to
         * "uncustomized", custom element definition set to null, is value set to
         * is, and node document set to document.
         */ var elementInterface = DocumentAlgorithm_1.document_elementInterface(localName, namespace);
        result = new elementInterface();
        result._localName = localName;
        result._namespace = namespace;
        result._namespacePrefix = prefix;
        result._customElementState = "uncustomized";
        result._customElementDefinition = null;
        result._is = is;
        result._nodeDocument = document;
        /**
         * 7.3. If namespace is the HTML namespace, and either localName is a
         * valid custom element name or is is non-null, then set result’s
         * custom element state to "undefined".
         */ if (namespace === infra_1.namespace.HTML && (is !== null || CustomElementAlgorithm_1.customElement_isValidCustomElementName(localName))) {
            result._customElementState = "undefined";
        }
    }
    /* istanbul ignore next */ if (result === null) {
        throw new Error("Unable to create element.");
    }
    /**
     * 8. Returns result
     */ return result;
}
exports.element_createAnElement = element_createAnElement;
/**
 * Inserts a new node adjacent to this element.
 *
 * @param element - a reference element
 * @param where - a string defining where to insert the element node.
 *   - `beforebegin` before this element itself.
 *   - `afterbegin` before the first child.
 *   - `beforeend` after the last child.
 *   - `afterend` after this element itself.
 * @param node - node to insert
 */ function element_insertAdjacent(element, where, node) {
    /**
     * - "beforebegin"
     * If element’s parent is null, return null.
     * Return the result of pre-inserting node into element’s parent before
     * element.
     * - "afterbegin"
     * Return the result of pre-inserting node into element before element’s
     * first child.
     * - "beforeend"
     * Return the result of pre-inserting node into element before null.
     * - "afterend"
     * If element’s parent is null, return null.
     * Return the result of pre-inserting node into element’s parent before element’s next sibling.
     * - Otherwise
     * Throw a "SyntaxError" DOMException.
     */ switch(where.toLowerCase()){
        case "beforebegin":
            if (element._parent === null) return null;
            return MutationAlgorithm_1.mutation_preInsert(node, element._parent, element);
        case "afterbegin":
            return MutationAlgorithm_1.mutation_preInsert(node, element, element._firstChild);
        case "beforeend":
            return MutationAlgorithm_1.mutation_preInsert(node, element, null);
        case "afterend":
            if (element._parent === null) return null;
            return MutationAlgorithm_1.mutation_preInsert(node, element._parent, element._nextSibling);
        default:
            throw new DOMException_1.SyntaxError('Invalid \'where\' argument. "beforebegin", "afterbegin", "beforeend" or "afterend" expected');
    }
}
exports.element_insertAdjacent = element_insertAdjacent; //# sourceMappingURL=ElementAlgorithm.js.map


/***/ }),

/***/ 12467:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = (void 0) && (void 0).__spread || function() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var interfaces_1 = __webpack_require__(52580);
var util_1 = __webpack_require__(57294);
var CustomEventImpl_1 = __webpack_require__(80010);
var EventImpl_1 = __webpack_require__(38584);
var DOMException_1 = __webpack_require__(28905);
var TreeAlgorithm_1 = __webpack_require__(59614);
var ShadowTreeAlgorithm_1 = __webpack_require__(49576);
var DOMAlgorithm_1 = __webpack_require__(24473);
/**
 * Sets the canceled flag of an event.
 *
 * @param event - an event
 */ function event_setTheCanceledFlag(event) {
    if (event._cancelable && !event._inPassiveListenerFlag) {
        event._canceledFlag = true;
    }
}
exports.event_setTheCanceledFlag = event_setTheCanceledFlag;
/**
 * Initializes the value of an event.
 *
 * @param event - an event to initialize
 * @param type - the type of event
 * @param bubbles - whether the event propagates in reverse
 * @param cancelable - whether the event can be cancelled
 */ function event_initialize(event, type, bubbles, cancelable) {
    event._initializedFlag = true;
    event._stopPropagationFlag = false;
    event._stopImmediatePropagationFlag = false;
    event._canceledFlag = false;
    event._isTrusted = false;
    event._target = null;
    event._type = type;
    event._bubbles = bubbles;
    event._cancelable = cancelable;
}
exports.event_initialize = event_initialize;
/**
 * Creates a new event.
 *
 * @param eventInterface - event interface
 * @param realm - realm
 */ function event_createAnEvent(eventInterface, realm) {
    if (realm === void 0) {
        realm = undefined;
    }
    /**
     * 1. If realm is not given, then set it to null.
     * 2. Let dictionary be the result of converting the JavaScript value
     * undefined to the dictionary type accepted by eventInterface’s
     * constructor. (This dictionary type will either be EventInit or a
     * dictionary that inherits from it.)
     * 3. Let event be the result of running the inner event creation steps with
     * eventInterface, realm, the time of the occurrence that the event is
     * signaling, and dictionary.
     * 4. Initialize event’s isTrusted attribute to true.
     * 5. Return event.
     */ if (realm === undefined) realm = null;
    var dictionary = {};
    var event = event_innerEventCreationSteps(eventInterface, realm, new Date(), dictionary);
    event._isTrusted = true;
    return event;
}
exports.event_createAnEvent = event_createAnEvent;
/**
 * Performs event creation steps.
 *
 * @param eventInterface - event interface
 * @param realm - realm
 * @param time - time of occurrance
 * @param dictionary - event attributes
 *
 */ function event_innerEventCreationSteps(eventInterface, realm, time, dictionary) {
    /**
     * 1. Let event be the result of creating a new object using eventInterface.
     * TODO: Implement realms
     * If realm is non-null, then use that Realm; otherwise, use the default
     * behavior defined in Web IDL.
     */ var event = new eventInterface("");
    /**
     * 2. Set event’s initialized flag.
     * 3. Initialize event’s timeStamp attribute to a DOMHighResTimeStamp
     * representing the high resolution time from the time origin to time.
     * 4. For each member → value in dictionary, if event has an attribute
     * whose identifier is member, then initialize that attribute to value.
     * 5. Run the event constructing steps with event.
     * 6. Return event.
     */ event._initializedFlag = true;
    event._timeStamp = time.getTime();
    Object.assign(event, dictionary);
    if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runEventConstructingSteps(event);
    }
    return event;
}
exports.event_innerEventCreationSteps = event_innerEventCreationSteps;
/**
 * Dispatches an event to an event target.
 *
 * @param event - the event to dispatch
 * @param target - event target
 * @param legacyTargetOverrideFlag - legacy target override flag
 * @param legacyOutputDidListenersThrowFlag - legacy output flag that returns
 * whether the event listener's callback threw an exception
 */ function event_dispatch(event, target, legacyTargetOverrideFlag, legacyOutputDidListenersThrowFlag) {
    var e_1, _a, e_2, _b;
    if (legacyTargetOverrideFlag === void 0) {
        legacyTargetOverrideFlag = false;
    }
    if (legacyOutputDidListenersThrowFlag === void 0) {
        legacyOutputDidListenersThrowFlag = {
            value: false
        };
    }
    var clearTargets = false;
    /**
     * 1. Set event's dispatch flag.
     */ event._dispatchFlag = true;
    /**
     * 2. Let targetOverride be target, if legacy target override flag is not
     * given, and target's associated Document otherwise.
     *
     * _Note:_ legacy target override flag is only used by HTML and only when
     * target is a Window object.
     */ var targetOverride = target;
    if (legacyTargetOverrideFlag) {
        var doc = target._associatedDocument;
        if (util_1.Guard.isDocumentNode(doc)) {
            targetOverride = doc;
        }
    }
    /**
     * 3. Let activationTarget be null.
     * 4. Let relatedTarget be the result of retargeting event's relatedTarget
     * against target.
     * 5. If target is not relatedTarget or target is event's relatedTarget,
     * then:
    */ var activationTarget = null;
    var relatedTarget = TreeAlgorithm_1.tree_retarget(event._relatedTarget, target);
    if (target !== relatedTarget || target === event._relatedTarget) {
        /**
         * 5.1. Let touchTargets be a new list.
         * 5.2. For each touchTarget of event's touch target list, append the
         * result of retargeting touchTarget against target to touchTargets.
         * 5.3. Append to an event path with event, target, targetOverride,
         * relatedTarget, touchTargets, and false.
         * 5.4. Let isActivationEvent be true, if event is a MouseEvent object
         * and event's type attribute is "click", and false otherwise.
         * 5.5. If isActivationEvent is true and target has activation behavior,
         * then set activationTarget to target.
         * 5.6. Let slotable be target, if target is a slotable and is assigned,
         * and null otherwise.
         * 5.7. Let slot-in-closed-tree be false.
         * 5.8. Let parent be the result of invoking target's get the parent with
         * event.
         */ var touchTargets = [];
        try {
            for(var _c = __values(event._touchTargetList), _d = _c.next(); !_d.done; _d = _c.next()){
                var touchTarget = _d.value;
                touchTargets.push(TreeAlgorithm_1.tree_retarget(touchTarget, target));
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        event_appendToAnEventPath(event, target, targetOverride, relatedTarget, touchTargets, false);
        var isActivationEvent = util_1.Guard.isMouseEvent(event) && event._type === "click";
        if (isActivationEvent && target._activationBehavior !== undefined) {
            activationTarget = target;
        }
        var slotable = util_1.Guard.isSlotable(target) && ShadowTreeAlgorithm_1.shadowTree_isAssigned(target) ? target : null;
        var slotInClosedTree = false;
        var parent = target._getTheParent(event);
        /**
         * 5.9. While parent is non-null:
         */ while(parent !== null && util_1.Guard.isNode(parent)){
            /**
             * 5.9.1 If slotable is non-null:
             * 5.9.1.1. Assert: parent is a slot.
             * 5.9.1.2. Set slotable to null.
             * 5.9.1.3. If parent's root is a shadow root whose mode is "closed",
             * then set slot-in-closed-tree to true.
             */ if (slotable !== null) {
                if (!util_1.Guard.isSlot(parent)) {
                    throw new Error("Parent node of a slotable should be a slot.");
                }
                slotable = null;
                var root = TreeAlgorithm_1.tree_rootNode(parent, true);
                if (util_1.Guard.isShadowRoot(root) && root._mode === "closed") {
                    slotInClosedTree = true;
                }
            }
            /**
             * 5.9.2 If parent is a slotable and is assigned, then set slotable to
             * parent.
             * 5.9.3. Let relatedTarget be the result of retargeting event's
             * relatedTarget against parent.
             * 5.9.4. Let touchTargets be a new list.
             * 5.9.4. For each touchTarget of event's touch target list, append the
             * result of retargeting touchTarget against parent to touchTargets.
             */ if (util_1.Guard.isSlotable(parent) && ShadowTreeAlgorithm_1.shadowTree_isAssigned(parent)) {
                slotable = parent;
            }
            relatedTarget = TreeAlgorithm_1.tree_retarget(event._relatedTarget, parent);
            touchTargets = [];
            try {
                for(var _e = (e_2 = void 0, __values(event._touchTargetList)), _f = _e.next(); !_f.done; _f = _e.next()){
                    var touchTarget = _f.value;
                    touchTargets.push(TreeAlgorithm_1.tree_retarget(touchTarget, parent));
                }
            } catch (e_2_1) {
                e_2 = {
                    error: e_2_1
                };
            } finally{
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                } finally{
                    if (e_2) throw e_2.error;
                }
            }
            /**
             * 5.9.6. If parent is a Window object, or parent is a node and target's
             * root is a shadow-including inclusive ancestor of parent, then:
             */ if (util_1.Guard.isWindow(parent) || util_1.Guard.isNode(parent) && util_1.Guard.isNode(target) && TreeAlgorithm_1.tree_isAncestorOf(TreeAlgorithm_1.tree_rootNode(target, true), parent, true, true)) {
                /**
                 * 5.9.6.1. If isActivationEvent is true, event's bubbles attribute
                 * is true, activationTarget is null, and parent has activation
                 * behavior, then set activationTarget to parent.
                 * 5.9.6.2. Append to an event path with event, parent, null,
                 * relatedTarget, touchTargets, and slot-in-closed-tree.
                 */ if (isActivationEvent && event._bubbles && activationTarget === null && parent._activationBehavior) {
                    activationTarget = parent;
                }
                event_appendToAnEventPath(event, parent, null, relatedTarget, touchTargets, slotInClosedTree);
            } else if (parent === relatedTarget) {
                /**
                 * 5.9.7. Otherwise, if parent is relatedTarget,
                 * then set parent to null.
                 */ parent = null;
            } else {
                /**
                 * 5.9.8. Otherwise, set target to parent and then:
                 * 5.9.8.1. If isActivationEvent is true, activationTarget is null,
                 * and target has activation behavior, then set activationTarget
                 * to target.
                 * 5.9.8.2. Append to an event path with event, parent, target,
                 * relatedTarget, touchTargets, and slot-in-closed-tree.
                 */ target = parent;
                if (isActivationEvent && activationTarget === null && target._activationBehavior) {
                    activationTarget = target;
                }
                event_appendToAnEventPath(event, parent, target, relatedTarget, touchTargets, slotInClosedTree);
            }
            /**
             * 5.9.9. If parent is non-null, then set parent to the result of
             * invoking parent's get the parent with event.
             * 5.9.10. Set slot-in-closed-tree to false.
             */ if (parent !== null) {
                parent = parent._getTheParent(event);
            }
            slotInClosedTree = false;
        }
        /**
         * 5.10. Let clearTargetsStruct be the last struct in event's path whose
         * shadow-adjusted target is non-null.
         */ var clearTargetsStruct = null;
        var path = event._path;
        for(var i = path.length - 1; i >= 0; i--){
            var struct = path[i];
            if (struct.shadowAdjustedTarget !== null) {
                clearTargetsStruct = struct;
                break;
            }
        }
        /**
         * 5.11. Let clearTargets be true if clearTargetsStruct's shadow-adjusted
         * target, clearTargetsStruct's relatedTarget, or an EventTarget object
         * in clearTargetsStruct's touch target list is a node and its root is
         * a shadow root, and false otherwise.
         */ if (clearTargetsStruct !== null) {
            if (util_1.Guard.isNode(clearTargetsStruct.shadowAdjustedTarget) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(clearTargetsStruct.shadowAdjustedTarget, true))) {
                clearTargets = true;
            } else if (util_1.Guard.isNode(clearTargetsStruct.relatedTarget) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(clearTargetsStruct.relatedTarget, true))) {
                clearTargets = true;
            } else {
                for(var j = 0; j < clearTargetsStruct.touchTargetList.length; j++){
                    var struct = clearTargetsStruct.touchTargetList[j];
                    if (util_1.Guard.isNode(struct) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(struct, true))) {
                        clearTargets = true;
                        break;
                    }
                }
            }
        }
        /**
         * 5.12. If activationTarget is non-null and activationTarget has
         * legacy-pre-activation behavior, then run activationTarget's
         * legacy-pre-activation behavior.
         */ if (activationTarget !== null && activationTarget._legacyPreActivationBehavior !== undefined) {
            activationTarget._legacyPreActivationBehavior(event);
        }
        /**
         * 5.13. For each struct in event's path, in reverse order:
         */ for(var i = path.length - 1; i >= 0; i--){
            var struct = path[i];
            /**
             * 5.13.1. If struct's shadow-adjusted target is non-null, then set
             * event's eventPhase attribute to AT_TARGET.
             * 5.13.2. Otherwise, set event's eventPhase attribute to
             * CAPTURING_PHASE.
             * 5.13.3. Invoke with struct, event, "capturing", and
             * legacyOutputDidListenersThrowFlag if given.
             */ if (struct.shadowAdjustedTarget !== null) {
                event._eventPhase = interfaces_1.EventPhase.AtTarget;
            } else {
                event._eventPhase = interfaces_1.EventPhase.Capturing;
            }
            event_invoke(struct, event, "capturing", legacyOutputDidListenersThrowFlag);
        }
        /**
         * 5.14. For each struct in event's path
         */ for(var i = 0; i < path.length; i++){
            var struct = path[i];
            /**
             * 5.14.1. If struct's shadow-adjusted target is non-null, then set
             * event's eventPhase attribute to AT_TARGET.
             * 5.14.2. Otherwise:
             * 5.14.2.1. If event's bubbles attribute is false, then continue.
             * 5.14.2.2. Set event's eventPhase attribute to BUBBLING_PHASE.
             * 5.14.3. Invoke with struct, event, "bubbling", and
             * legacyOutputDidListenersThrowFlag if given.
             */ if (struct.shadowAdjustedTarget !== null) {
                event._eventPhase = interfaces_1.EventPhase.AtTarget;
            } else {
                if (!event._bubbles) continue;
                event._eventPhase = interfaces_1.EventPhase.Bubbling;
            }
            event_invoke(struct, event, "bubbling", legacyOutputDidListenersThrowFlag);
        }
    }
    /**
     * 6. Set event's eventPhase attribute to NONE.
     * 7. Set event's currentTarget attribute to null.
     * 8. Set event's path to the empty list.
     * 9. Unset event's dispatch flag, stop propagation flag, and stop
     * immediate propagation flag.
     */ event._eventPhase = interfaces_1.EventPhase.None;
    event._currentTarget = null;
    event._path = [];
    event._dispatchFlag = false;
    event._stopPropagationFlag = false;
    event._stopImmediatePropagationFlag = false;
    /**
     * 10. If clearTargets, then:
     * 10.1. Set event's target to null.
     * 10.2. Set event's relatedTarget to null.
     * 10.3. Set event's touch target list to the empty list.
     */ if (clearTargets) {
        event._target = null;
        event._relatedTarget = null;
        event._touchTargetList = [];
    }
    /**
     * 11. If activationTarget is non-null, then:
     * 11.1. If event's canceled flag is unset, then run activationTarget's
     * activation behavior with event.
     * 11.2. Otherwise, if activationTarget has legacy-canceled-activation
     * behavior, then run activationTarget's legacy-canceled-activation
     * behavior.
     */ if (activationTarget !== null) {
        if (!event._canceledFlag && activationTarget._activationBehavior !== undefined) {
            activationTarget._activationBehavior(event);
        } else if (activationTarget._legacyCanceledActivationBehavior !== undefined) {
            activationTarget._legacyCanceledActivationBehavior(event);
        }
    }
    /**
     * 12. Return false if event's canceled flag is set, and true otherwise.
     */ return !event._canceledFlag;
}
exports.event_dispatch = event_dispatch;
/**
 * Appends a new struct to an event's path.
 *
 * @param event - an event
 * @param invocationTarget - the target of the invocation
 * @param shadowAdjustedTarget - shadow-root adjusted event target
 * @param relatedTarget - related event target
 * @param touchTargets - a list of touch targets
 * @param slotInClosedTree - if the target's parent is a closed shadow root
 */ function event_appendToAnEventPath(event, invocationTarget, shadowAdjustedTarget, relatedTarget, touchTargets, slotInClosedTree) {
    /**
     * 1. Let invocationTargetInShadowTree be false.
     * 2. If invocationTarget is a node and its root is a shadow root, then
     * set invocationTargetInShadowTree to true.
     */ var invocationTargetInShadowTree = false;
    if (util_1.Guard.isNode(invocationTarget) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(invocationTarget))) {
        invocationTargetInShadowTree = true;
    }
    /**
     * 3. Let root-of-closed-tree be false.
     * 4. If invocationTarget is a shadow root whose mode is "closed", then
     * set root-of-closed-tree to true.
     */ var rootOfClosedTree = false;
    if (util_1.Guard.isShadowRoot(invocationTarget) && invocationTarget._mode === "closed") {
        rootOfClosedTree = true;
    }
    /**
     * 5. Append a new struct to event's path whose invocation target is
     * invocationTarget, invocation-target-in-shadow-tree is
     * invocationTargetInShadowTree, shadow-adjusted target is
     * shadowAdjustedTarget, relatedTarget is relatedTarget,
     * touch target list is touchTargets, root-of-closed-tree is
     * root-of-closed-tree, and slot-in-closed-tree is slot-in-closed-tree.
     */ event._path.push({
        invocationTarget: invocationTarget,
        invocationTargetInShadowTree: invocationTargetInShadowTree,
        shadowAdjustedTarget: shadowAdjustedTarget,
        relatedTarget: relatedTarget,
        touchTargetList: touchTargets,
        rootOfClosedTree: rootOfClosedTree,
        slotInClosedTree: slotInClosedTree
    });
}
exports.event_appendToAnEventPath = event_appendToAnEventPath;
/**
 * Invokes an event.
 *
 * @param struct - a struct defining event's path
 * @param event - the event to invoke
 * @param phase - event phase
 * @param legacyOutputDidListenersThrowFlag - legacy output flag that returns
 * whether the event listener's callback threw an exception
 */ function event_invoke(struct, event, phase, legacyOutputDidListenersThrowFlag) {
    if (legacyOutputDidListenersThrowFlag === void 0) {
        legacyOutputDidListenersThrowFlag = {
            value: false
        };
    }
    /**
     * 1. Set event's target to the shadow-adjusted target of the last struct
     * in event's path, that is either struct or preceding struct, whose
     * shadow-adjusted target is non-null.
     */ var path = event._path;
    var index = -1;
    for(var i = 0; i < path.length; i++){
        if (path[i] === struct) {
            index = i;
            break;
        }
    }
    if (index !== -1) {
        var item = path[index];
        if (item.shadowAdjustedTarget !== null) {
            event._target = item.shadowAdjustedTarget;
        } else if (index > 0) {
            item = path[index - 1];
            if (item.shadowAdjustedTarget !== null) {
                event._target = item.shadowAdjustedTarget;
            }
        }
    }
    /**
     * 2. Set event's relatedTarget to struct's relatedTarget.
     * 3. Set event's touch target list to struct's touch target list.
     * 4. If event's stop propagation flag is set, then return.
     * 5. Initialize event's currentTarget attribute to struct's invocation
     * target.
     * 6. Let listeners be a clone of event's currentTarget attribute value's
     * event listener list.
     *
     * _Note:_ This avoids event listeners added after this point from being
     * run. Note that removal still has an effect due to the removed field.
     */ event._relatedTarget = struct.relatedTarget;
    event._touchTargetList = struct.touchTargetList;
    if (event._stopPropagationFlag) return;
    event._currentTarget = struct.invocationTarget;
    var currentTarget = event._currentTarget;
    var targetListeners = currentTarget._eventListenerList;
    var listeners = new (Array.bind.apply(Array, __spread([
        void 0
    ], targetListeners)))();
    /**
     * 7. Let found be the result of running inner invoke with event, listeners,
     * phase, and legacyOutputDidListenersThrowFlag if given.
     */ var found = event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag);
    /**
     * 8. If found is false and event's isTrusted attribute is true, then:
     */ if (!found && event._isTrusted) {
        /**
         * 8.1. Let originalEventType be event's type attribute value.
         * 8.2. If event's type attribute value is a match for any of the strings
         * in the first column in the following table, set event's type attribute
         * value to the string in the second column on the same row as the matching
         * string, and return otherwise.
         *
         * Event type           | Legacy event type
         * -------------------------------------------------
         * "animationend"       | "webkitAnimationEnd"
         * "animationiteration" | "webkitAnimationIteration"
         * "animationstart"     | "webkitAnimationStart"
         * "transitionend"      | "webkitTransitionEnd"
         */ var originalEventType = event._type;
        if (originalEventType === "animationend") {
            event._type = "webkitAnimationEnd";
        } else if (originalEventType === "animationiteration") {
            event._type = "webkitAnimationIteration";
        } else if (originalEventType === "animationstart") {
            event._type = "webkitAnimationStart";
        } else if (originalEventType === "transitionend") {
            event._type = "webkitTransitionEnd";
        }
        /**
         * 8.3. Inner invoke with event, listeners, phase, and
         * legacyOutputDidListenersThrowFlag if given.
         * 8.4. Set event's type attribute value to originalEventType.
         */ event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag);
        event._type = originalEventType;
    }
}
exports.event_invoke = event_invoke;
/**
 * Invokes an event.
 *
 * @param event - the event to invoke
 * @param listeners - event listeners
 * @param phase - event phase
 * @param struct - a struct defining event's path
 * @param legacyOutputDidListenersThrowFlag - legacy output flag that returns
 * whether the event listener's callback threw an exception
 */ function event_innerInvoke(event, listeners, phase, struct, legacyOutputDidListenersThrowFlag) {
    if (legacyOutputDidListenersThrowFlag === void 0) {
        legacyOutputDidListenersThrowFlag = {
            value: false
        };
    }
    /**
     * 1. Let found be false.
     * 2. For each listener in listeners, whose removed is false:
     */ var found = false;
    for(var i = 0; i < listeners.length; i++){
        var listener = listeners[i];
        if (!listener.removed) {
            /**
             * 2.1. If event's type attribute value is not listener's type, then
             * continue.
             * 2.2. Set found to true.
             * 2.3. If phase is "capturing" and listener's capture is false, then
             * continue.
             * 2.4. If phase is "bubbling" and listener's capture is true, then
             * continue.
             */ if (event._type !== listener.type) continue;
            found = true;
            if (phase === "capturing" && !listener.capture) continue;
            if (phase === "bubbling" && listener.capture) continue;
            /**
             * 2.5. If listener's once is true, then remove listener from event's
             * currentTarget attribute value's event listener list.
             */ if (listener.once && event._currentTarget !== null) {
                var impl = event._currentTarget;
                var index = -1;
                for(var i_1 = 0; i_1 < impl._eventListenerList.length; i_1++){
                    if (impl._eventListenerList[i_1] === listener) {
                        index = i_1;
                        break;
                    }
                }
                if (index !== -1) {
                    impl._eventListenerList.splice(index, 1);
                }
            }
            /**
             * TODO: Implement realms
             *
             * 2.6. Let global be listener callback's associated Realm's global
             * object.
             */ var globalObject = undefined;
            /**
             * 2.7. Let currentEvent be undefined.
             * 2.8. If global is a Window object, then:
             * 2.8.1. Set currentEvent to global's current event.
             * 2.8.2. If struct's invocation-target-in-shadow-tree is false, then
             * set global's current event to event.
             */ var currentEvent = undefined;
            if (util_1.Guard.isWindow(globalObject)) {
                currentEvent = globalObject._currentEvent;
                if (struct.invocationTargetInShadowTree === false) {
                    globalObject._currentEvent = event;
                }
            }
            /**
             * 2.9. If listener's passive is true, then set event's in passive
             * listener flag.
             * 2.10. Call a user object's operation with listener's callback,
             * "handleEvent", « event », and event's currentTarget attribute value.
             */ if (listener.passive) event._inPassiveListenerFlag = true;
            try {
                listener.callback.handleEvent.call(event._currentTarget, event);
            } catch (err) {
                /**
                 * If this throws an exception, then:
                 * 2.10.1. Report the exception.
                 * 2.10.2. Set legacyOutputDidListenersThrowFlag if given.
                 *
                 * _Note:_ The legacyOutputDidListenersThrowFlag is only used by
                 * Indexed Database API.
                 * TODO: Report the exception
                 * See: https://html.spec.whatwg.org/multipage/webappapis.html#runtime-script-errors-in-documents
                 */ legacyOutputDidListenersThrowFlag.value = true;
            }
            /**
             * 2.11. Unset event's in passive listener flag.
             */ if (listener.passive) event._inPassiveListenerFlag = false;
            /**
             * 2.12. If global is a Window object, then set global's current event
             * to currentEvent.
             */ if (util_1.Guard.isWindow(globalObject)) {
                globalObject._currentEvent = currentEvent;
            }
            /**
             * 2.13. If event's stop immediate propagation flag is set, then return
             * found.
             */ if (event._stopImmediatePropagationFlag) return found;
        }
    }
    /**
     * 3. Return found.
     */ return found;
}
exports.event_innerInvoke = event_innerInvoke;
/**
 * Fires an event at target.
 * @param e - event name
 * @param target - event target
 * @param eventConstructor - an event constructor, with a description of how
 * IDL attributes are to be initialized
 * @param idlAttributes - a dictionary describing how IDL attributes are
 * to be initialized
 * @param legacyTargetOverrideFlag - legacy target override flag
 */ function event_fireAnEvent(e, target, eventConstructor, idlAttributes, legacyTargetOverrideFlag) {
    /**
     * 1. If eventConstructor is not given, then let eventConstructor be Event.
     */ if (eventConstructor === undefined) {
        eventConstructor = EventImpl_1.EventImpl;
    }
    /**
     * 2. Let event be the result of creating an event given eventConstructor,
     * in the relevant Realm of target.
     */ var event = event_createAnEvent(eventConstructor);
    /**
     * 3. Initialize event’s type attribute to e.
     */ event._type = e;
    /**
     * 4. Initialize any other IDL attributes of event as described in the
     * invocation of this algorithm.
     * _Note:_ This also allows for the isTrusted attribute to be set to false.
     */ if (idlAttributes) {
        for(var key in idlAttributes){
            var idlObj = event;
            idlObj[key] = idlAttributes[key];
        }
    }
    /**
     * 5. Return the result of dispatching event at target, with legacy target
     * override flag set if set.
     */ return event_dispatch(event, target, legacyTargetOverrideFlag);
}
exports.event_fireAnEvent = event_fireAnEvent;
/**
 * Creates an event.
 *
 * @param eventInterface - the name of the event interface
 */ function event_createLegacyEvent(eventInterface) {
    /**
     * 1. Let constructor be null.
     */ var constructor = null;
    /**
     * TODO: Implement in HTML DOM
     * 2. If interface is an ASCII case-insensitive match for any of the strings
     * in the first column in the following table, then set constructor to the
     * interface in the second column on the same row as the matching string:
     *
     * String | Interface
     * -------|----------
     * "beforeunloadevent" | BeforeUnloadEvent
     * "compositionevent" | CompositionEvent
     * "customevent" | CustomEvent
     * "devicemotionevent" | DeviceMotionEvent
     * "deviceorientationevent" | DeviceOrientationEvent
     * "dragevent" | DragEvent
     * "event" | Event
     * "events" | Event
     * "focusevent" | FocusEvent
     * "hashchangeevent" | HashChangeEvent
     * "htmlevents" | Event
     * "keyboardevent" | KeyboardEvent
     * "messageevent" | MessageEvent
     * "mouseevent" | MouseEvent
     * "mouseevents" |
     * "storageevent" | StorageEvent
     * "svgevents" | Event
     * "textevent" | CompositionEvent
     * "touchevent" | TouchEvent
     * "uievent" | UIEvent
     * "uievents" | UIEvent
     */ switch(eventInterface.toLowerCase()){
        case "beforeunloadevent":
            break;
        case "compositionevent":
            break;
        case "customevent":
            constructor = CustomEventImpl_1.CustomEventImpl;
            break;
        case "devicemotionevent":
            break;
        case "deviceorientationevent":
            break;
        case "dragevent":
            break;
        case "event":
        case "events":
            constructor = EventImpl_1.EventImpl;
            break;
        case "focusevent":
            break;
        case "hashchangeevent":
            break;
        case "htmlevents":
            break;
        case "keyboardevent":
            break;
        case "messageevent":
            break;
        case "mouseevent":
            break;
        case "mouseevents":
            break;
        case "storageevent":
            break;
        case "svgevents":
            break;
        case "textevent":
            break;
        case "touchevent":
            break;
        case "uievent":
            break;
        case "uievents":
            break;
    }
    /**
     * 3. If constructor is null, then throw a "NotSupportedError" DOMException.
     */ if (constructor === null) {
        throw new DOMException_1.NotSupportedError("Event constructor not found for interface " + eventInterface + ".");
    }
    /**
     * 4. If the interface indicated by constructor is not exposed on the
     * relevant global object of the context object, then throw a
     * "NotSupportedError" DOMException.
     * _Note:_ Typically user agents disable support for touch events in some
     * configurations, in which case this clause would be triggered for the
     * interface TouchEvent.
     */ // TODO: Implement realms
    /**
     * 5. Let event be the result of creating an event given constructor.
     * 6. Initialize event’s type attribute to the empty string.
     * 7. Initialize event’s timeStamp attribute to a DOMHighResTimeStamp
     * representing the high resolution time from the time origin to now.
     * 8. Initialize event’s isTrusted attribute to false.
     * 9. Unset event’s initialized flag.
     */ var event = new constructor("");
    event._type = "";
    event._timeStamp = new Date().getTime();
    event._isTrusted = false;
    event._initializedFlag = false;
    /**
     * 10. Return event.
     */ return event;
}
exports.event_createLegacyEvent = event_createLegacyEvent;
/**
 * Getter of an event handler IDL attribute.
 *
 * @param eventTarget - event target
 * @param name - event name
 */ function event_getterEventHandlerIDLAttribute(thisObj, name) {
    /**
     * 1. Let eventTarget be the result of determining the target of an event
     * handler given this object and name.
     * 2. If eventTarget is null, then return null.
     * 3. Return the result of getting the current value of the event handler
     * given eventTarget and name.
     */ var eventTarget = event_determineTheTargetOfAnEventHandler(thisObj, name);
    if (eventTarget === null) return null;
    return event_getTheCurrentValueOfAnEventHandler(eventTarget, name);
}
exports.event_getterEventHandlerIDLAttribute = event_getterEventHandlerIDLAttribute;
/**
 * Setter of an event handler IDL attribute.
 *
 * @param eventTarget - event target
 * @param name - event name
 * @param value - event handler
 */ function event_setterEventHandlerIDLAttribute(thisObj, name, value) {
    /**
     * 1. Let eventTarget be the result of determining the target of an event
     * handler given this object and name.
     * 2. If eventTarget is null, then return.
     * 3. If the given value is null, then deactivate an event handler given
     * eventTarget and name.
     * 4. Otherwise:
     * 4.1. Let handlerMap be eventTarget's event handler map.
     * 4.2. Let eventHandler be handlerMap[name].
     * 4.3. Set eventHandler's value to the given value.
     * 4.4. Activate an event handler given eventTarget and name.
     */ var eventTarget = event_determineTheTargetOfAnEventHandler(thisObj, name);
    if (eventTarget === null) return;
    if (value === null) {
        event_deactivateAnEventHandler(eventTarget, name);
    } else {
        var handlerMap = eventTarget._eventHandlerMap;
        var eventHandler = handlerMap["onabort"];
        if (eventHandler !== undefined) {
            eventHandler.value = value;
        }
        event_activateAnEventHandler(eventTarget, name);
    }
}
exports.event_setterEventHandlerIDLAttribute = event_setterEventHandlerIDLAttribute;
/**
 * Determines the target of an event handler.
 *
 * @param eventTarget - event target
 * @param name - event name
 */ function event_determineTheTargetOfAnEventHandler(eventTarget, name) {
    // TODO: Implement in HTML DOM
    return null;
}
exports.event_determineTheTargetOfAnEventHandler = event_determineTheTargetOfAnEventHandler;
/**
 * Gets the current value of an event handler.
 *
 * @param eventTarget - event target
 * @param name - event name
 */ function event_getTheCurrentValueOfAnEventHandler(eventTarget, name) {
    // TODO: Implement in HTML DOM
    return null;
}
exports.event_getTheCurrentValueOfAnEventHandler = event_getTheCurrentValueOfAnEventHandler;
/**
 * Activates an event handler.
 *
 * @param eventTarget - event target
 * @param name - event name
 */ function event_activateAnEventHandler(eventTarget, name) {
// TODO: Implement in HTML DOM
}
exports.event_activateAnEventHandler = event_activateAnEventHandler;
/**
 * Deactivates an event handler.
 *
 * @param eventTarget - event target
 * @param name - event name
 */ function event_deactivateAnEventHandler(eventTarget, name) {
// TODO: Implement in HTML DOM
}
exports.event_deactivateAnEventHandler = event_deactivateAnEventHandler; //# sourceMappingURL=EventAlgorithm.js.map


/***/ }),

/***/ 49221:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(96883);
/**
 * Flattens the given options argument.
 *
 * @param options - options argument
 */ function eventTarget_flatten(options) {
    /**
     * 1. If options is a boolean, then return options.
     * 2. Return options’s capture.
     */ if (util_1.isBoolean(options)) {
        return options;
    } else {
        return options.capture || false;
    }
}
exports.eventTarget_flatten = eventTarget_flatten;
/**
 * Flattens the given options argument.
 *
 * @param options - options argument
 */ function eventTarget_flattenMore(options) {
    /**
     * 1. Let capture be the result of flattening options.
     * 2. Let once and passive be false.
     * 3. If options is a dictionary, then set passive to options’s passive and
     * once to options’s once.
     * 4. Return capture, passive, and once.
     */ var capture = eventTarget_flatten(options);
    var once = false;
    var passive = false;
    if (!util_1.isBoolean(options)) {
        once = options.once || false;
        passive = options.passive || false;
    }
    return [
        capture,
        passive,
        once
    ];
}
exports.eventTarget_flattenMore = eventTarget_flattenMore;
/**
 * Adds a new event listener.
 *
 * @param eventTarget - event target
 * @param listener - event listener
 */ function eventTarget_addEventListener(eventTarget, listener) {
    /**
     * 1. If eventTarget is a ServiceWorkerGlobalScope object, its service
     * worker’s script resource’s has ever been evaluated flag is set, and
     * listener’s type matches the type attribute value of any of the service
     * worker events, then report a warning to the console that this might not
     * give the expected results. [SERVICE-WORKERS]
     */ // TODO: service worker
    /**
     * 2. If listener’s callback is null, then return.
     */ if (listener.callback === null) return;
    /**
     * 3. If eventTarget’s event listener list does not contain an event listener
     * whose type is listener’s type, callback is listener’s callback, and capture
     * is listener’s capture, then append listener to eventTarget’s event listener
     * list.
     */ for(var i = 0; i < eventTarget._eventListenerList.length; i++){
        var entry = eventTarget._eventListenerList[i];
        if (entry.type === listener.type && entry.callback.handleEvent === listener.callback.handleEvent && entry.capture === listener.capture) {
            return;
        }
    }
    eventTarget._eventListenerList.push(listener);
}
exports.eventTarget_addEventListener = eventTarget_addEventListener;
/**
 * Removes an event listener.
 *
 * @param eventTarget - event target
 * @param listener - event listener
 */ function eventTarget_removeEventListener(eventTarget, listener, index) {
    /**
     * 1. If eventTarget is a ServiceWorkerGlobalScope object and its service
     * worker’s set of event types to handle contains type, then report a
     * warning to the console that this might not give the expected results.
     * [SERVICE-WORKERS]
     */ // TODO: service worker
    /**
     * 2. Set listener’s removed to true and remove listener from eventTarget’s
     * event listener list.
     */ listener.removed = true;
    eventTarget._eventListenerList.splice(index, 1);
}
exports.eventTarget_removeEventListener = eventTarget_removeEventListener;
/**
 * Removes all event listeners.
 *
 * @param eventTarget - event target
 */ function eventTarget_removeAllEventListeners(eventTarget) {
    /**
     * To remove all event listeners, given an EventTarget object eventTarget,
     * for each listener of eventTarget’s event listener list, remove an event
     * listener with eventTarget and listener.
     */ var e_1, _a;
    try {
        for(var _b = __values(eventTarget._eventListenerList), _c = _b.next(); !_c.done; _c = _b.next()){
            var e = _c.value;
            e.removed = true;
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    eventTarget._eventListenerList.length = 0;
}
exports.eventTarget_removeAllEventListeners = eventTarget_removeAllEventListeners; //# sourceMappingURL=EventTargetAlgorithm.js.map


/***/ }),

/***/ 31400:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = (void 0) && (void 0).__spread || function() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var DOMException_1 = __webpack_require__(28905);
var interfaces_1 = __webpack_require__(52580);
var util_1 = __webpack_require__(57294);
var util_2 = __webpack_require__(96883);
var infra_1 = __webpack_require__(94317);
var CustomElementAlgorithm_1 = __webpack_require__(3381);
var TreeAlgorithm_1 = __webpack_require__(59614);
var NodeIteratorAlgorithm_1 = __webpack_require__(82572);
var ShadowTreeAlgorithm_1 = __webpack_require__(49576);
var MutationObserverAlgorithm_1 = __webpack_require__(5742);
var DOMAlgorithm_1 = __webpack_require__(24473);
var DocumentAlgorithm_1 = __webpack_require__(81424);
/**
 * Ensures pre-insertion validity of a node into a parent before a
 * child.
 *
 * @param node - node to insert
 * @param parent - parent node to receive node
 * @param child - child node to insert node before
 */ function mutation_ensurePreInsertionValidity(node, parent, child) {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
    var parentNodeType = parent._nodeType;
    var nodeNodeType = node._nodeType;
    var childNodeType = child ? child._nodeType : null;
    /**
     * 1. If parent is not a Document, DocumentFragment, or Element node,
     * throw a "HierarchyRequestError" DOMException.
     */ if (parentNodeType !== interfaces_1.NodeType.Document && parentNodeType !== interfaces_1.NodeType.DocumentFragment && parentNodeType !== interfaces_1.NodeType.Element) throw new DOMException_1.HierarchyRequestError("Only document, document fragment and element nodes can contain child nodes. Parent node is " + parent.nodeName + ".");
    /**
     * 2. If node is a host-including inclusive ancestor of parent, throw a
     * "HierarchyRequestError" DOMException.
     */ if (TreeAlgorithm_1.tree_isHostIncludingAncestorOf(parent, node, true)) throw new DOMException_1.HierarchyRequestError("The node to be inserted cannot be an inclusive ancestor of parent node. Node is " + node.nodeName + ", parent node is " + parent.nodeName + ".");
    /**
     * 3. If child is not null and its parent is not parent, then throw a
     * "NotFoundError" DOMException.
     */ if (child !== null && child._parent !== parent) throw new DOMException_1.NotFoundError("The reference child node cannot be found under parent node. Child node is " + child.nodeName + ", parent node is " + parent.nodeName + ".");
    /**
     * 4. If node is not a DocumentFragment, DocumentType, Element, Text,
     * ProcessingInstruction, or Comment node, throw a "HierarchyRequestError"
     * DOMException.
     */ if (nodeNodeType !== interfaces_1.NodeType.DocumentFragment && nodeNodeType !== interfaces_1.NodeType.DocumentType && nodeNodeType !== interfaces_1.NodeType.Element && nodeNodeType !== interfaces_1.NodeType.Text && nodeNodeType !== interfaces_1.NodeType.ProcessingInstruction && nodeNodeType !== interfaces_1.NodeType.CData && nodeNodeType !== interfaces_1.NodeType.Comment) throw new DOMException_1.HierarchyRequestError("Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is " + node.nodeName + ".");
    /**
     * 5. If either node is a Text node and parent is a document, or node is a
     * doctype and parent is not a document, throw a "HierarchyRequestError"
     * DOMException.
     */ if (nodeNodeType === interfaces_1.NodeType.Text && parentNodeType === interfaces_1.NodeType.Document) throw new DOMException_1.HierarchyRequestError("Cannot insert a text node as a child of a document node. Node is " + node.nodeName + ".");
    if (nodeNodeType === interfaces_1.NodeType.DocumentType && parentNodeType !== interfaces_1.NodeType.Document) throw new DOMException_1.HierarchyRequestError("A document type node can only be inserted under a document node. Parent node is " + parent.nodeName + ".");
    /**
     * 6. If parent is a document, and any of the statements below, switched on
     * node, are true, throw a "HierarchyRequestError" DOMException.
     * - DocumentFragment node
     * If node has more than one element child or has a Text node child.
     * Otherwise, if node has one element child and either parent has an element
     * child, child is a doctype, or child is not null and a doctype is
     * following child.
     * - element
     * parent has an element child, child is a doctype, or child is not null and
     * a doctype is following child.
     * - doctype
     * parent has a doctype child, child is non-null and an element is preceding
     * child, or child is null and parent has an element child.
     */ if (parentNodeType === interfaces_1.NodeType.Document) {
        if (nodeNodeType === interfaces_1.NodeType.DocumentFragment) {
            var eleCount = 0;
            try {
                for(var _e = __values(node._children), _f = _e.next(); !_f.done; _f = _e.next()){
                    var childNode = _f.value;
                    if (childNode._nodeType === interfaces_1.NodeType.Element) eleCount++;
                    else if (childNode._nodeType === interfaces_1.NodeType.Text) throw new DOMException_1.HierarchyRequestError("Cannot insert text a node as a child of a document node. Node is " + childNode.nodeName + ".");
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            if (eleCount > 1) {
                throw new DOMException_1.HierarchyRequestError("A document node can only have one document element node. Document fragment to be inserted has " + eleCount + " element nodes.");
            } else if (eleCount === 1) {
                try {
                    for(var _g = __values(parent._children), _h = _g.next(); !_h.done; _h = _g.next()){
                        var ele = _h.value;
                        if (ele._nodeType === interfaces_1.NodeType.Element) throw new DOMException_1.HierarchyRequestError("The document node already has a document element node.");
                    }
                } catch (e_2_1) {
                    e_2 = {
                        error: e_2_1
                    };
                } finally{
                    try {
                        if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                    } finally{
                        if (e_2) throw e_2.error;
                    }
                }
                if (child) {
                    if (childNodeType === interfaces_1.NodeType.DocumentType) throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node.");
                    var doctypeChild = child._nextSibling;
                    while(doctypeChild){
                        if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType) throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node.");
                        doctypeChild = doctypeChild._nextSibling;
                    }
                }
            }
        } else if (nodeNodeType === interfaces_1.NodeType.Element) {
            try {
                for(var _j = __values(parent._children), _k = _j.next(); !_k.done; _k = _j.next()){
                    var ele = _k.value;
                    if (ele._nodeType === interfaces_1.NodeType.Element) throw new DOMException_1.HierarchyRequestError("Document already has a document element node. Node is " + node.nodeName + ".");
                }
            } catch (e_3_1) {
                e_3 = {
                    error: e_3_1
                };
            } finally{
                try {
                    if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
                } finally{
                    if (e_3) throw e_3.error;
                }
            }
            if (child) {
                if (childNodeType === interfaces_1.NodeType.DocumentType) throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + node.nodeName + ".");
                var doctypeChild = child._nextSibling;
                while(doctypeChild){
                    if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType) throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + node.nodeName + ".");
                    doctypeChild = doctypeChild._nextSibling;
                }
            }
        } else if (nodeNodeType === interfaces_1.NodeType.DocumentType) {
            try {
                for(var _l = __values(parent._children), _m = _l.next(); !_m.done; _m = _l.next()){
                    var ele = _m.value;
                    if (ele._nodeType === interfaces_1.NodeType.DocumentType) throw new DOMException_1.HierarchyRequestError("Document already has a document type node. Node is " + node.nodeName + ".");
                }
            } catch (e_4_1) {
                e_4 = {
                    error: e_4_1
                };
            } finally{
                try {
                    if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
                } finally{
                    if (e_4) throw e_4.error;
                }
            }
            if (child) {
                var elementChild = child._previousSibling;
                while(elementChild){
                    if (elementChild._nodeType === interfaces_1.NodeType.Element) throw new DOMException_1.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + node.nodeName + ".");
                    elementChild = elementChild._previousSibling;
                }
            } else {
                var elementChild = parent._firstChild;
                while(elementChild){
                    if (elementChild._nodeType === interfaces_1.NodeType.Element) throw new DOMException_1.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + node.nodeName + ".");
                    elementChild = elementChild._nextSibling;
                }
            }
        }
    }
}
exports.mutation_ensurePreInsertionValidity = mutation_ensurePreInsertionValidity;
/**
 * Ensures pre-insertion validity of a node into a parent before a
 * child, then adopts the node to the tree and inserts it.
 *
 * @param node - node to insert
 * @param parent - parent node to receive node
 * @param child - child node to insert node before
 */ function mutation_preInsert(node, parent, child) {
    /**
     * 1. Ensure pre-insertion validity of node into parent before child.
     * 2. Let reference child be child.
     * 3. If reference child is node, set it to node’s next sibling.
     * 4. Adopt node into parent’s node document.
     * 5. Insert node into parent before reference child.
     * 6. Return node.
     */ mutation_ensurePreInsertionValidity(node, parent, child);
    var referenceChild = child;
    if (referenceChild === node) referenceChild = node._nextSibling;
    DocumentAlgorithm_1.document_adopt(node, parent._nodeDocument);
    mutation_insert(node, parent, referenceChild);
    return node;
}
exports.mutation_preInsert = mutation_preInsert;
/**
 * Inserts a node into a parent node before the given child node.
 *
 * @param node - node to insert
 * @param parent - parent node to receive node
 * @param child - child node to insert node before
 * @param suppressObservers - whether to notify observers
 */ function mutation_insert(node, parent, child, suppressObservers) {
    var e_5, _a;
    // Optimized common case
    if (child === null && node._nodeType !== interfaces_1.NodeType.DocumentFragment) {
        mutation_insert_single(node, parent, suppressObservers);
        return;
    }
    /**
     * 1. Let count be the number of children of node if it is a
     * DocumentFragment node, and one otherwise.
     */ var count = node._nodeType === interfaces_1.NodeType.DocumentFragment ? node._children.size : 1;
    /**
     * 2. If child is non-null, then:
     */ if (child !== null) {
        /**
         * 2.1. For each live range whose start node is parent and start
         * offset is greater than child's index, increase its start
         * offset by count.
         * 2.2. For each live range whose end node is parent and end
         * offset is greater than child's index, increase its end
         * offset by count.
         */ if (DOMImpl_1.dom.rangeList.size !== 0) {
            var index_1 = TreeAlgorithm_1.tree_index(child);
            try {
                for(var _b = __values(DOMImpl_1.dom.rangeList), _c = _b.next(); !_c.done; _c = _b.next()){
                    var range = _c.value;
                    if (range._start[0] === parent && range._start[1] > index_1) {
                        range._start[1] += count;
                    }
                    if (range._end[0] === parent && range._end[1] > index_1) {
                        range._end[1] += count;
                    }
                }
            } catch (e_5_1) {
                e_5 = {
                    error: e_5_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally{
                    if (e_5) throw e_5.error;
                }
            }
        }
    }
    /**
     * 3. Let nodes be node’s children, if node is a DocumentFragment node;
     * otherwise « node ».
     */ var nodes = node._nodeType === interfaces_1.NodeType.DocumentFragment ? new (Array.bind.apply(Array, __spread([
        void 0
    ], node._children)))() : [
        node
    ];
    /**
     * 4. If node is a DocumentFragment node, remove its children with the
     * suppress observers flag set.
     */ if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
        while(node._firstChild){
            mutation_remove(node._firstChild, node, true);
        }
    }
    /**
     * 5. If node is a DocumentFragment node, then queue a tree mutation record
     * for node with « », nodes, null, and null.
     */ if (DOMImpl_1.dom.features.mutationObservers) {
        if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
            MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(node, [], nodes, null, null);
        }
    }
    /**
     * 6. Let previousSibling be child’s previous sibling or parent’s last
     * child if child is null.
     */ var previousSibling = child ? child._previousSibling : parent._lastChild;
    var index = child === null ? -1 : TreeAlgorithm_1.tree_index(child);
    /**
     * 7. For each node in nodes, in tree order:
     */ for(var i = 0; i < nodes.length; i++){
        var node_1 = nodes[i];
        if (util_1.Guard.isElementNode(node_1)) {
            // set document element node
            if (util_1.Guard.isDocumentNode(parent)) {
                parent._documentElement = node_1;
            }
            // mark that the document has namespaces
            if (!node_1._nodeDocument._hasNamespaces && (node_1._namespace !== null || node_1._namespacePrefix !== null)) {
                node_1._nodeDocument._hasNamespaces = true;
            }
        }
        /**
         * 7.1. If child is null, then append node to parent’s children.
         * 7.2. Otherwise, insert node into parent’s children before child’s
         * index.
         */ node_1._parent = parent;
        if (child === null) {
            infra_1.set.append(parent._children, node_1);
        } else {
            infra_1.set.insert(parent._children, node_1, index);
            index++;
        }
        // assign siblings and children for quick lookups
        if (parent._firstChild === null) {
            node_1._previousSibling = null;
            node_1._nextSibling = null;
            parent._firstChild = node_1;
            parent._lastChild = node_1;
        } else {
            var prev = child ? child._previousSibling : parent._lastChild;
            var next = child ? child : null;
            node_1._previousSibling = prev;
            node_1._nextSibling = next;
            if (prev) prev._nextSibling = node_1;
            if (next) next._previousSibling = node_1;
            if (!prev) parent._firstChild = node_1;
            if (!next) parent._lastChild = node_1;
        }
        /**
         * 7.3. If parent is a shadow host and node is a slotable, then
         * assign a slot for node.
         */ if (DOMImpl_1.dom.features.slots) {
            if (parent._shadowRoot !== null && util_1.Guard.isSlotable(node_1)) {
                ShadowTreeAlgorithm_1.shadowTree_assignASlot(node_1);
            }
        }
        /**
         * 7.4. If node is a Text node, run the child text content change
         * steps for parent.
         */ if (DOMImpl_1.dom.features.steps) {
            if (util_1.Guard.isTextNode(node_1)) {
                DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);
            }
        }
        /**
         * 7.5. If parent's root is a shadow root, and parent is a slot
         * whose assigned nodes is the empty list, then run signal
         * a slot change for parent.
         */ if (DOMImpl_1.dom.features.slots) {
            if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) && util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {
                ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);
            }
        }
        /**
         * 7.6. Run assign slotables for a tree with node's root.
         */ if (DOMImpl_1.dom.features.slots) {
            ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(node_1));
        }
        /**
         * 7.7. For each shadow-including inclusive descendant
         * inclusiveDescendant of node, in shadow-including tree
         * order:
         */ var inclusiveDescendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node_1, true, true);
        while(inclusiveDescendant !== null){
            /**
             * 7.7.1. Run the insertion steps with inclusiveDescendant.
             */ if (DOMImpl_1.dom.features.steps) {
                DOMAlgorithm_1.dom_runInsertionSteps(inclusiveDescendant);
            }
            if (DOMImpl_1.dom.features.customElements) {
                /**
                 * 7.7.2. If inclusiveDescendant is connected, then:
                 */ if (util_1.Guard.isElementNode(inclusiveDescendant) && ShadowTreeAlgorithm_1.shadowTree_isConnected(inclusiveDescendant)) {
                    if (util_1.Guard.isCustomElementNode(inclusiveDescendant)) {
                        /**
                         * 7.7.2.1. If inclusiveDescendant is custom, then enqueue a custom
                         * element callback reaction with inclusiveDescendant, callback name
                         * "connectedCallback", and an empty argument list.
                         */ CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(inclusiveDescendant, "connectedCallback", []);
                    } else {
                        /**
                         * 7.7.2.2. Otherwise, try to upgrade inclusiveDescendant.
                         */ CustomElementAlgorithm_1.customElement_tryToUpgrade(inclusiveDescendant);
                    }
                }
            }
            inclusiveDescendant = TreeAlgorithm_1.tree_getNextDescendantNode(node_1, inclusiveDescendant, true, true);
        }
    }
    /**
     * 8. If suppress observers flag is unset, then queue a tree mutation record
     * for parent with nodes, « », previousSibling, and child.
     */ if (DOMImpl_1.dom.features.mutationObservers) {
        if (!suppressObservers) {
            MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, nodes, [], previousSibling, child);
        }
    }
}
exports.mutation_insert = mutation_insert;
/**
 * Inserts a node into a parent node. Optimized routine for the common case where
 * node is not a document fragment node and it has no child nodes.
 *
 * @param node - node to insert
 * @param parent - parent node to receive node
 * @param suppressObservers - whether to notify observers
 */ function mutation_insert_single(node, parent, suppressObservers) {
    /**
     * 1. Let count be the number of children of node if it is a
     * DocumentFragment node, and one otherwise.
     * 2. If child is non-null, then:
     * 2.1. For each live range whose start node is parent and start
     * offset is greater than child's index, increase its start
     * offset by count.
     * 2.2. For each live range whose end node is parent and end
     * offset is greater than child's index, increase its end
     * offset by count.
     * 3. Let nodes be node’s children, if node is a DocumentFragment node;
     * otherwise « node ».
     * 4. If node is a DocumentFragment node, remove its children with the
     * suppress observers flag set.
     * 5. If node is a DocumentFragment node, then queue a tree mutation record
     * for node with « », nodes, null, and null.
     */ /**
     * 6. Let previousSibling be child’s previous sibling or parent’s last
     * child if child is null.
     */ var previousSibling = parent._lastChild;
    // set document element node
    if (util_1.Guard.isElementNode(node)) {
        // set document element node
        if (util_1.Guard.isDocumentNode(parent)) {
            parent._documentElement = node;
        }
        // mark that the document has namespaces
        if (!node._nodeDocument._hasNamespaces && (node._namespace !== null || node._namespacePrefix !== null)) {
            node._nodeDocument._hasNamespaces = true;
        }
    }
    /**
     * 7. For each node in nodes, in tree order:
     * 7.1. If child is null, then append node to parent’s children.
     * 7.2. Otherwise, insert node into parent’s children before child’s
     * index.
     */ node._parent = parent;
    parent._children.add(node);
    // assign siblings and children for quick lookups
    if (parent._firstChild === null) {
        node._previousSibling = null;
        node._nextSibling = null;
        parent._firstChild = node;
        parent._lastChild = node;
    } else {
        var prev = parent._lastChild;
        node._previousSibling = prev;
        node._nextSibling = null;
        if (prev) prev._nextSibling = node;
        if (!prev) parent._firstChild = node;
        parent._lastChild = node;
    }
    /**
     * 7.3. If parent is a shadow host and node is a slotable, then
     * assign a slot for node.
     */ if (DOMImpl_1.dom.features.slots) {
        if (parent._shadowRoot !== null && util_1.Guard.isSlotable(node)) {
            ShadowTreeAlgorithm_1.shadowTree_assignASlot(node);
        }
    }
    /**
     * 7.4. If node is a Text node, run the child text content change
     * steps for parent.
     */ if (DOMImpl_1.dom.features.steps) {
        if (util_1.Guard.isTextNode(node)) {
            DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);
        }
    }
    /**
     * 7.5. If parent's root is a shadow root, and parent is a slot
     * whose assigned nodes is the empty list, then run signal
     * a slot change for parent.
     */ if (DOMImpl_1.dom.features.slots) {
        if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) && util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {
            ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);
        }
    }
    /**
     * 7.6. Run assign slotables for a tree with node's root.
     */ if (DOMImpl_1.dom.features.slots) {
        ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(node));
    }
    /**
     * 7.7. For each shadow-including inclusive descendant
     * inclusiveDescendant of node, in shadow-including tree
     * order:
     * 7.7.1. Run the insertion steps with inclusiveDescendant.
     */ if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runInsertionSteps(node);
    }
    if (DOMImpl_1.dom.features.customElements) {
        /**
         * 7.7.2. If inclusiveDescendant is connected, then:
         */ if (util_1.Guard.isElementNode(node) && ShadowTreeAlgorithm_1.shadowTree_isConnected(node)) {
            if (util_1.Guard.isCustomElementNode(node)) {
                /**
                 * 7.7.2.1. If inclusiveDescendant is custom, then enqueue a custom
                 * element callback reaction with inclusiveDescendant, callback name
                 * "connectedCallback", and an empty argument list.
                 */ CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(node, "connectedCallback", []);
            } else {
                /**
                 * 7.7.2.2. Otherwise, try to upgrade inclusiveDescendant.
                 */ CustomElementAlgorithm_1.customElement_tryToUpgrade(node);
            }
        }
    }
    /**
     * 8. If suppress observers flag is unset, then queue a tree mutation record
     * for parent with nodes, « », previousSibling, and child.
     */ if (DOMImpl_1.dom.features.mutationObservers) {
        if (!suppressObservers) {
            MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, [
                node
            ], [], previousSibling, null);
        }
    }
}
/**
 * Appends a node to the children of a parent node.
 *
 * @param node - a node
 * @param parent - the parent to receive node
 */ function mutation_append(node, parent) {
    /**
     * To append a node to a parent, pre-insert node into parent before null.
     */ return mutation_preInsert(node, parent, null);
}
exports.mutation_append = mutation_append;
/**
 * Replaces a node with another node.
 *
 * @param child - child node to remove
 * @param node - node to insert
 * @param parent - parent node to receive node
 */ function mutation_replace(child, node, parent) {
    var e_6, _a, e_7, _b, e_8, _c, e_9, _d;
    /**
     * 1. If parent is not a Document, DocumentFragment, or Element node,
     * throw a "HierarchyRequestError" DOMException.
     */ if (parent._nodeType !== interfaces_1.NodeType.Document && parent._nodeType !== interfaces_1.NodeType.DocumentFragment && parent._nodeType !== interfaces_1.NodeType.Element) throw new DOMException_1.HierarchyRequestError("Only document, document fragment and element nodes can contain child nodes. Parent node is " + parent.nodeName + ".");
    /**
     * 2. If node is a host-including inclusive ancestor of parent, throw a
     * "HierarchyRequestError" DOMException.
     */ if (TreeAlgorithm_1.tree_isHostIncludingAncestorOf(parent, node, true)) throw new DOMException_1.HierarchyRequestError("The node to be inserted cannot be an ancestor of parent node. Node is " + node.nodeName + ", parent node is " + parent.nodeName + ".");
    /**
     * 3. If child’s parent is not parent, then throw a "NotFoundError"
     * DOMException.
     */ if (child._parent !== parent) throw new DOMException_1.NotFoundError("The reference child node cannot be found under parent node. Child node is " + child.nodeName + ", parent node is " + parent.nodeName + ".");
    /**
     * 4. If node is not a DocumentFragment, DocumentType, Element, Text,
     * ProcessingInstruction, or Comment node, throw a "HierarchyRequestError"
     * DOMException.
     */ if (node._nodeType !== interfaces_1.NodeType.DocumentFragment && node._nodeType !== interfaces_1.NodeType.DocumentType && node._nodeType !== interfaces_1.NodeType.Element && node._nodeType !== interfaces_1.NodeType.Text && node._nodeType !== interfaces_1.NodeType.ProcessingInstruction && node._nodeType !== interfaces_1.NodeType.CData && node._nodeType !== interfaces_1.NodeType.Comment) throw new DOMException_1.HierarchyRequestError("Only document fragment, document type, element, text, processing instruction, cdata section or comment nodes can be inserted. Node is " + node.nodeName + ".");
    /**
     * 5. If either node is a Text node and parent is a document, or node is a
     * doctype and parent is not a document, throw a "HierarchyRequestError"
     * DOMException.
     */ if (node._nodeType === interfaces_1.NodeType.Text && parent._nodeType === interfaces_1.NodeType.Document) throw new DOMException_1.HierarchyRequestError("Cannot insert a text node as a child of a document node. Node is " + node.nodeName + ".");
    if (node._nodeType === interfaces_1.NodeType.DocumentType && parent._nodeType !== interfaces_1.NodeType.Document) throw new DOMException_1.HierarchyRequestError("A document type node can only be inserted under a document node. Parent node is " + parent.nodeName + ".");
    /**
     * 6. If parent is a document, and any of the statements below, switched on
     * node, are true, throw a "HierarchyRequestError" DOMException.
     * - DocumentFragment node
     * If node has more than one element child or has a Text node child.
     * Otherwise, if node has one element child and either parent has an element
     * child that is not child or a doctype is following child.
     * - element
     * parent has an element child that is not child or a doctype is
     * following child.
     * - doctype
     * parent has a doctype child that is not child, or an element is
     * preceding child.
     */ if (parent._nodeType === interfaces_1.NodeType.Document) {
        if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
            var eleCount = 0;
            try {
                for(var _e = __values(node._children), _f = _e.next(); !_f.done; _f = _e.next()){
                    var childNode = _f.value;
                    if (childNode._nodeType === interfaces_1.NodeType.Element) eleCount++;
                    else if (childNode._nodeType === interfaces_1.NodeType.Text) throw new DOMException_1.HierarchyRequestError("Cannot insert text a node as a child of a document node. Node is " + childNode.nodeName + ".");
                }
            } catch (e_6_1) {
                e_6 = {
                    error: e_6_1
                };
            } finally{
                try {
                    if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                } finally{
                    if (e_6) throw e_6.error;
                }
            }
            if (eleCount > 1) {
                throw new DOMException_1.HierarchyRequestError("A document node can only have one document element node. Document fragment to be inserted has " + eleCount + " element nodes.");
            } else if (eleCount === 1) {
                try {
                    for(var _g = __values(parent._children), _h = _g.next(); !_h.done; _h = _g.next()){
                        var ele = _h.value;
                        if (ele._nodeType === interfaces_1.NodeType.Element && ele !== child) throw new DOMException_1.HierarchyRequestError("The document node already has a document element node.");
                    }
                } catch (e_7_1) {
                    e_7 = {
                        error: e_7_1
                    };
                } finally{
                    try {
                        if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                    } finally{
                        if (e_7) throw e_7.error;
                    }
                }
                var doctypeChild = child._nextSibling;
                while(doctypeChild){
                    if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType) throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node.");
                    doctypeChild = doctypeChild._nextSibling;
                }
            }
        } else if (node._nodeType === interfaces_1.NodeType.Element) {
            try {
                for(var _j = __values(parent._children), _k = _j.next(); !_k.done; _k = _j.next()){
                    var ele = _k.value;
                    if (ele._nodeType === interfaces_1.NodeType.Element && ele !== child) throw new DOMException_1.HierarchyRequestError("Document already has a document element node. Node is " + node.nodeName + ".");
                }
            } catch (e_8_1) {
                e_8 = {
                    error: e_8_1
                };
            } finally{
                try {
                    if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
                } finally{
                    if (e_8) throw e_8.error;
                }
            }
            var doctypeChild = child._nextSibling;
            while(doctypeChild){
                if (doctypeChild._nodeType === interfaces_1.NodeType.DocumentType) throw new DOMException_1.HierarchyRequestError("Cannot insert an element node before a document type node. Node is " + node.nodeName + ".");
                doctypeChild = doctypeChild._nextSibling;
            }
        } else if (node._nodeType === interfaces_1.NodeType.DocumentType) {
            try {
                for(var _l = __values(parent._children), _m = _l.next(); !_m.done; _m = _l.next()){
                    var ele = _m.value;
                    if (ele._nodeType === interfaces_1.NodeType.DocumentType && ele !== child) throw new DOMException_1.HierarchyRequestError("Document already has a document type node. Node is " + node.nodeName + ".");
                }
            } catch (e_9_1) {
                e_9 = {
                    error: e_9_1
                };
            } finally{
                try {
                    if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
                } finally{
                    if (e_9) throw e_9.error;
                }
            }
            var elementChild = child._previousSibling;
            while(elementChild){
                if (elementChild._nodeType === interfaces_1.NodeType.Element) throw new DOMException_1.HierarchyRequestError("Cannot insert a document type node before an element node. Node is " + node.nodeName + ".");
                elementChild = elementChild._previousSibling;
            }
        }
    }
    /**
     * 7. Let reference child be child’s next sibling.
     * 8. If reference child is node, set it to node’s next sibling.
     * 8. Let previousSibling be child’s previous sibling.
     */ var referenceChild = child._nextSibling;
    if (referenceChild === node) referenceChild = node._nextSibling;
    var previousSibling = child._previousSibling;
    /**
     * 10. Adopt node into parent’s node document.
     * 11. Let removedNodes be the empty list.
     */ DocumentAlgorithm_1.document_adopt(node, parent._nodeDocument);
    var removedNodes = [];
    /**
     * 12. If child’s parent is not null, then:
     */ if (child._parent !== null) {
        /**
         * 12.1. Set removedNodes to [child].
         * 12.2. Remove child from its parent with the suppress observers flag
         * set.
         */ removedNodes.push(child);
        mutation_remove(child, child._parent, true);
    }
    /**
     * 13. Let nodes be node’s children if node is a DocumentFragment node;
     * otherwise [node].
     */ var nodes = [];
    if (node._nodeType === interfaces_1.NodeType.DocumentFragment) {
        nodes = Array.from(node._children);
    } else {
        nodes.push(node);
    }
    /**
     * 14. Insert node into parent before reference child with the suppress
     * observers flag set.
     */ mutation_insert(node, parent, referenceChild, true);
    /**
     * 15. Queue a tree mutation record for parent with nodes, removedNodes,
     * previousSibling, and reference child.
     */ if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, nodes, removedNodes, previousSibling, referenceChild);
    }
    /**
     * 16. Return child.
     */ return child;
}
exports.mutation_replace = mutation_replace;
/**
 * Replaces all nodes of a parent with the given node.
 *
 * @param node - node to insert
 * @param parent - parent node to receive node
 */ function mutation_replaceAll(node, parent) {
    var e_10, _a;
    /**
     * 1. If node is not null, adopt node into parent’s node document.
     */ if (node !== null) {
        DocumentAlgorithm_1.document_adopt(node, parent._nodeDocument);
    }
    /**
     * 2. Let removedNodes be parent’s children.
     */ var removedNodes = Array.from(parent._children);
    /**
     * 3. Let addedNodes be the empty list.
     * 4. If node is DocumentFragment node, then set addedNodes to node’s
     * children.
     * 5. Otherwise, if node is non-null, set addedNodes to [node].
     */ var addedNodes = [];
    if (node && node._nodeType === interfaces_1.NodeType.DocumentFragment) {
        addedNodes = Array.from(node._children);
    } else if (node !== null) {
        addedNodes.push(node);
    }
    try {
        /**
         * 6. Remove all parent’s children, in tree order, with the suppress
         * observers flag set.
         */ for(var removedNodes_1 = __values(removedNodes), removedNodes_1_1 = removedNodes_1.next(); !removedNodes_1_1.done; removedNodes_1_1 = removedNodes_1.next()){
            var childNode = removedNodes_1_1.value;
            mutation_remove(childNode, parent, true);
        }
    } catch (e_10_1) {
        e_10 = {
            error: e_10_1
        };
    } finally{
        try {
            if (removedNodes_1_1 && !removedNodes_1_1.done && (_a = removedNodes_1.return)) _a.call(removedNodes_1);
        } finally{
            if (e_10) throw e_10.error;
        }
    }
    /**
     * 7. If node is not null, then insert node into parent before null with the
     * suppress observers flag set.
     */ if (node !== null) {
        mutation_insert(node, parent, null, true);
    }
    /**
     * 8. Queue a tree mutation record for parent with addedNodes, removedNodes,
     * null, and null.
     */ if (DOMImpl_1.dom.features.mutationObservers) {
        MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, addedNodes, removedNodes, null, null);
    }
}
exports.mutation_replaceAll = mutation_replaceAll;
/**
 * Ensures pre-removal validity of a child node from a parent, then
 * removes it.
 *
 * @param child - child node to remove
 * @param parent - parent node
 */ function mutation_preRemove(child, parent) {
    /**
     * 1. If child’s parent is not parent, then throw a "NotFoundError"
     * DOMException.
     * 2. Remove child from parent.
     * 3. Return child.
     */ if (child._parent !== parent) throw new DOMException_1.NotFoundError("The child node cannot be found under parent node. Child node is " + child.nodeName + ", parent node is " + parent.nodeName + ".");
    mutation_remove(child, parent);
    return child;
}
exports.mutation_preRemove = mutation_preRemove;
/**
 * Removes a child node from its parent.
 *
 * @param node - node to remove
 * @param parent - parent node
 * @param suppressObservers - whether to notify observers
 */ function mutation_remove(node, parent, suppressObservers) {
    var e_11, _a, e_12, _b, e_13, _c, e_14, _d;
    if (DOMImpl_1.dom.rangeList.size !== 0) {
        /**
         * 1. Let index be node’s index.
         */ var index = TreeAlgorithm_1.tree_index(node);
        try {
            /**
             * 2. For each live range whose start node is an inclusive descendant of
             * node, set its start to (parent, index).
             * 3. For each live range whose end node is an inclusive descendant of
             * node, set its end to (parent, index).
             */ for(var _e = __values(DOMImpl_1.dom.rangeList), _f = _e.next(); !_f.done; _f = _e.next()){
                var range = _f.value;
                if (TreeAlgorithm_1.tree_isDescendantOf(node, range._start[0], true)) {
                    range._start = [
                        parent,
                        index
                    ];
                }
                if (TreeAlgorithm_1.tree_isDescendantOf(node, range._end[0], true)) {
                    range._end = [
                        parent,
                        index
                    ];
                }
                if (range._start[0] === parent && range._start[1] > index) {
                    range._start[1]--;
                }
                if (range._end[0] === parent && range._end[1] > index) {
                    range._end[1]--;
                }
            }
        } catch (e_11_1) {
            e_11 = {
                error: e_11_1
            };
        } finally{
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            } finally{
                if (e_11) throw e_11.error;
            }
        }
        try {
            /**
             * 4. For each live range whose start node is parent and start offset is
             * greater than index, decrease its start offset by 1.
             * 5. For each live range whose end node is parent and end offset is greater
             * than index, decrease its end offset by 1.
             */ for(var _g = __values(DOMImpl_1.dom.rangeList), _h = _g.next(); !_h.done; _h = _g.next()){
                var range = _h.value;
                if (range._start[0] === parent && range._start[1] > index) {
                    range._start[1] -= 1;
                }
                if (range._end[0] === parent && range._end[1] > index) {
                    range._end[1] -= 1;
                }
            }
        } catch (e_12_1) {
            e_12 = {
                error: e_12_1
            };
        } finally{
            try {
                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
            } finally{
                if (e_12) throw e_12.error;
            }
        }
    }
    /**
     * 6. For each NodeIterator object iterator whose root’s node document is
     * node’s node document, run the NodeIterator pre-removing steps given node
     * and iterator.
     */ if (DOMImpl_1.dom.features.steps) {
        try {
            for(var _j = __values(NodeIteratorAlgorithm_1.nodeIterator_iteratorList()), _k = _j.next(); !_k.done; _k = _j.next()){
                var iterator = _k.value;
                if (iterator._root._nodeDocument === node._nodeDocument) {
                    DOMAlgorithm_1.dom_runNodeIteratorPreRemovingSteps(iterator, node);
                }
            }
        } catch (e_13_1) {
            e_13 = {
                error: e_13_1
            };
        } finally{
            try {
                if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
            } finally{
                if (e_13) throw e_13.error;
            }
        }
    }
    /**
     * 7. Let oldPreviousSibling be node’s previous sibling.
     * 8. Let oldNextSibling be node’s next sibling.
     */ var oldPreviousSibling = node._previousSibling;
    var oldNextSibling = node._nextSibling;
    // set document element node
    if (util_1.Guard.isDocumentNode(parent) && util_1.Guard.isElementNode(node)) {
        parent._documentElement = null;
    }
    /**
     * 9. Remove node from its parent’s children.
     */ node._parent = null;
    parent._children.delete(node);
    // assign siblings and children for quick lookups
    var prev = node._previousSibling;
    var next = node._nextSibling;
    node._previousSibling = null;
    node._nextSibling = null;
    if (prev) prev._nextSibling = next;
    if (next) next._previousSibling = prev;
    if (!prev) parent._firstChild = next;
    if (!next) parent._lastChild = prev;
    /**
     * 10. If node is assigned, then run assign slotables for node’s assigned
     * slot.
     */ if (DOMImpl_1.dom.features.slots) {
        if (util_1.Guard.isSlotable(node) && node._assignedSlot !== null && ShadowTreeAlgorithm_1.shadowTree_isAssigned(node)) {
            ShadowTreeAlgorithm_1.shadowTree_assignSlotables(node._assignedSlot);
        }
    }
    /**
     * 11. If parent’s root is a shadow root, and parent is a slot whose
     * assigned nodes is the empty list, then run signal a slot change for
     * parent.
     */ if (DOMImpl_1.dom.features.slots) {
        if (util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(parent)) && util_1.Guard.isSlot(parent) && util_2.isEmpty(parent._assignedNodes)) {
            ShadowTreeAlgorithm_1.shadowTree_signalASlotChange(parent);
        }
    }
    /**
     * 12. If node has an inclusive descendant that is a slot, then:
     * 12.1. Run assign slotables for a tree with parent's root.
     * 12.2. Run assign slotables for a tree with node.
     */ if (DOMImpl_1.dom.features.slots) {
        var descendant_1 = TreeAlgorithm_1.tree_getFirstDescendantNode(node, true, false, function(e) {
            return util_1.Guard.isSlot(e);
        });
        if (descendant_1 !== null) {
            ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(TreeAlgorithm_1.tree_rootNode(parent));
            ShadowTreeAlgorithm_1.shadowTree_assignSlotablesForATree(node);
        }
    }
    /**
     * 13. Run the removing steps with node and parent.
     */ if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runRemovingSteps(node, parent);
    }
    /**
     * 14. If node is custom, then enqueue a custom element callback
     * reaction with node, callback name "disconnectedCallback",
     * and an empty argument list.
     */ if (DOMImpl_1.dom.features.customElements) {
        if (util_1.Guard.isCustomElementNode(node)) {
            CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(node, "disconnectedCallback", []);
        }
    }
    /**
     * 15. For each shadow-including descendant descendant of node,
     * in shadow-including tree order, then:
     */ var descendant = TreeAlgorithm_1.tree_getFirstDescendantNode(node, false, true);
    while(descendant !== null){
        /**
         * 15.1. Run the removing steps with descendant.
         */ if (DOMImpl_1.dom.features.steps) {
            DOMAlgorithm_1.dom_runRemovingSteps(descendant, node);
        }
        /**
         * 15.2. If descendant is custom, then enqueue a custom element
         * callback reaction with descendant, callback name
         * "disconnectedCallback", and an empty argument list.
         */ if (DOMImpl_1.dom.features.customElements) {
            if (util_1.Guard.isCustomElementNode(descendant)) {
                CustomElementAlgorithm_1.customElement_enqueueACustomElementCallbackReaction(descendant, "disconnectedCallback", []);
            }
        }
        descendant = TreeAlgorithm_1.tree_getNextDescendantNode(node, descendant, false, true);
    }
    /**
     * 16. For each inclusive ancestor inclusiveAncestor of parent, and
     * then for each registered of inclusiveAncestor's registered
     * observer list, if registered's options's subtree is true,
     * then append a new transient registered observer whose
     * observer is registered's observer, options is registered's
     * options, and source is registered to node's registered
     * observer list.
     */ if (DOMImpl_1.dom.features.mutationObservers) {
        var inclusiveAncestor = TreeAlgorithm_1.tree_getFirstAncestorNode(parent, true);
        while(inclusiveAncestor !== null){
            try {
                for(var _l = (e_14 = void 0, __values(inclusiveAncestor._registeredObserverList)), _m = _l.next(); !_m.done; _m = _l.next()){
                    var registered = _m.value;
                    if (registered.options.subtree) {
                        node._registeredObserverList.push({
                            observer: registered.observer,
                            options: registered.options,
                            source: registered
                        });
                    }
                }
            } catch (e_14_1) {
                e_14 = {
                    error: e_14_1
                };
            } finally{
                try {
                    if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
                } finally{
                    if (e_14) throw e_14.error;
                }
            }
            inclusiveAncestor = TreeAlgorithm_1.tree_getNextAncestorNode(parent, inclusiveAncestor, true);
        }
    }
    /**
     * 17. If suppress observers flag is unset, then queue a tree mutation
     * record for parent with « », « node », oldPreviousSibling, and
     * oldNextSibling.
     */ if (DOMImpl_1.dom.features.mutationObservers) {
        if (!suppressObservers) {
            MutationObserverAlgorithm_1.observer_queueTreeMutationRecord(parent, [], [
                node
            ], oldPreviousSibling, oldNextSibling);
        }
    }
    /**
     * 18. If node is a Text node, then run the child text content change steps
     * for parent.
     */ if (DOMImpl_1.dom.features.steps) {
        if (util_1.Guard.isTextNode(node)) {
            DOMAlgorithm_1.dom_runChildTextContentChangeSteps(parent);
        }
    }
}
exports.mutation_remove = mutation_remove; //# sourceMappingURL=MutationAlgorithm.js.map


/***/ }),

/***/ 5742:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var util_1 = __webpack_require__(57294);
var infra_1 = __webpack_require__(94317);
var CreateAlgorithm_1 = __webpack_require__(21701);
var TreeAlgorithm_1 = __webpack_require__(59614);
var EventAlgorithm_1 = __webpack_require__(12467);
/**
 * Queues a mutation observer microtask to the surrounding agent’s mutation
 * observers.
 */ function observer_queueAMutationObserverMicrotask() {
    /**
     * 1. If the surrounding agent’s mutation observer microtask queued is true,
     * then return.
     * 2. Set the surrounding agent’s mutation observer microtask queued to true.
     * 3. Queue a microtask to notify mutation observers.
     */ var window = DOMImpl_1.dom.window;
    if (window._mutationObserverMicrotaskQueued) return;
    window._mutationObserverMicrotaskQueued = true;
    Promise.resolve().then(function() {
        observer_notifyMutationObservers();
    });
}
exports.observer_queueAMutationObserverMicrotask = observer_queueAMutationObserverMicrotask;
/**
 * Notifies the surrounding agent’s mutation observers.
 */ function observer_notifyMutationObservers() {
    var e_1, _a, e_2, _b;
    /**
     * 1. Set the surrounding agent’s mutation observer microtask queued to false.
     * 2. Let notifySet be a clone of the surrounding agent’s mutation observers.
     * 3. Let signalSet be a clone of the surrounding agent’s signal slots.
     * 4. Empty the surrounding agent’s signal slots.
     */ var window = DOMImpl_1.dom.window;
    window._mutationObserverMicrotaskQueued = false;
    var notifySet = infra_1.set.clone(window._mutationObservers);
    var signalSet = infra_1.set.clone(window._signalSlots);
    infra_1.set.empty(window._signalSlots);
    var _loop_1 = function(mo) {
        /**
         * 5.1. Let records be a clone of mo’s record queue.
         * 5.2. Empty mo’s record queue.
         */ var records = infra_1.list.clone(mo._recordQueue);
        infra_1.list.empty(mo._recordQueue);
        /**
         * 5.3. For each node of mo’s node list, remove all transient registered
         * observers whose observer is mo from node’s registered observer list.
         */ for(var i = 0; i < mo._nodeList.length; i++){
            var node = mo._nodeList[i];
            infra_1.list.remove(node._registeredObserverList, function(observer) {
                return util_1.Guard.isTransientRegisteredObserver(observer) && observer.observer === mo;
            });
        }
        /**
         * 5.4. If records is not empty, then invoke mo’s callback with « records,
         * mo », and mo. If this throws an exception, then report the exception.
         */ if (!infra_1.list.isEmpty(records)) {
            try {
                mo._callback.call(mo, records, mo);
            } catch (err) {
            // TODO: Report the exception
            }
        }
    };
    try {
        /**
         * 5. For each mo of notifySet:
         */ for(var notifySet_1 = __values(notifySet), notifySet_1_1 = notifySet_1.next(); !notifySet_1_1.done; notifySet_1_1 = notifySet_1.next()){
            var mo = notifySet_1_1.value;
            _loop_1(mo);
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (notifySet_1_1 && !notifySet_1_1.done && (_a = notifySet_1.return)) _a.call(notifySet_1);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    /**
     * 6. For each slot of signalSet, fire an event named slotchange, with its
     * bubbles attribute set to true, at slot.
     */ if (DOMImpl_1.dom.features.slots) {
        try {
            for(var signalSet_1 = __values(signalSet), signalSet_1_1 = signalSet_1.next(); !signalSet_1_1.done; signalSet_1_1 = signalSet_1.next()){
                var slot = signalSet_1_1.value;
                EventAlgorithm_1.event_fireAnEvent("slotchange", slot, undefined, {
                    bubbles: true
                });
            }
        } catch (e_2_1) {
            e_2 = {
                error: e_2_1
            };
        } finally{
            try {
                if (signalSet_1_1 && !signalSet_1_1.done && (_b = signalSet_1.return)) _b.call(signalSet_1);
            } finally{
                if (e_2) throw e_2.error;
            }
        }
    }
}
exports.observer_notifyMutationObservers = observer_notifyMutationObservers;
/**
 * Queues a mutation record of the given type for target.
 *
 * @param type - mutation record type
 * @param target - target node
 * @param name - name before mutation
 * @param namespace - namespace before mutation
 * @param oldValue - attribute value before mutation
 * @param addedNodes - a list od added nodes
 * @param removedNodes - a list of removed nodes
 * @param previousSibling - previous sibling of target before mutation
 * @param nextSibling - next sibling of target before mutation
 */ function observer_queueMutationRecord(type, target, name, namespace, oldValue, addedNodes, removedNodes, previousSibling, nextSibling) {
    var e_3, _a;
    /**
     * 1. Let interestedObservers be an empty map.
     * 2. Let nodes be the inclusive ancestors of target.
     * 3. For each node in nodes, and then for each registered of node’s
     * registered observer list:
     */ var interestedObservers = new Map();
    var node = TreeAlgorithm_1.tree_getFirstAncestorNode(target, true);
    while(node !== null){
        for(var i = 0; i < node._registeredObserverList.length; i++){
            var registered = node._registeredObserverList[i];
            /**
             * 3.1. Let options be registered’s options.
             * 3.2. If none of the following are true
             * - node is not target and options’s subtree is false
             * - type is "attributes" and options’s attributes is not true
             * - type is "attributes", options’s attributeFilter is present, and
             * options’s attributeFilter does not contain name or namespace is
             * non-null
             * - type is "characterData" and options’s characterData is not true
             * - type is "childList" and options’s childList is false
             */ var options = registered.options;
            if (node !== target && !options.subtree) continue;
            if (type === "attributes" && !options.attributes) continue;
            if (type === "attributes" && options.attributeFilter && (!options.attributeFilter.indexOf(name || "") || namespace !== null)) continue;
            if (type === "characterData" && !options.characterData) continue;
            if (type === "childList" && !options.childList) continue;
            /**
             * then:
             * 3.2.1. Let mo be registered’s observer.
             * 3.2.2. If interestedObservers[mo] does not exist, then set
             * interestedObservers[mo] to null.
             * 3.2.3. If either type is "attributes" and options’s attributeOldValue
             * is true, or type is "characterData" and options’s
             * characterDataOldValue is true, then set interestedObservers[mo]
             * to oldValue.
             */ var mo = registered.observer;
            if (!interestedObservers.has(mo)) {
                interestedObservers.set(mo, null);
            }
            if (type === "attributes" && options.attributeOldValue || type === "characterData" && options.characterDataOldValue) {
                interestedObservers.set(mo, oldValue);
            }
        }
        node = TreeAlgorithm_1.tree_getNextAncestorNode(target, node, true);
    }
    try {
        /**
         * 4. For each observer → mappedOldValue of interestedObservers:
         */ for(var interestedObservers_1 = __values(interestedObservers), interestedObservers_1_1 = interestedObservers_1.next(); !interestedObservers_1_1.done; interestedObservers_1_1 = interestedObservers_1.next()){
            var _b = __read(interestedObservers_1_1.value, 2), observer = _b[0], mappedOldValue = _b[1];
            /**
             * 4.1. Let record be a new MutationRecord object with its type set to
             * type, target set to target, attributeName set to name,
             * attributeNamespace set to namespace, oldValue set to mappedOldValue,
             * addedNodes set to addedNodes, removedNodes set to removedNodes,
             * previousSibling set to previousSibling, and nextSibling set to
             * nextSibling.
             * 4.2. Enqueue record to observer’s record queue.
             */ var record = CreateAlgorithm_1.create_mutationRecord(type, target, CreateAlgorithm_1.create_nodeListStatic(target, addedNodes), CreateAlgorithm_1.create_nodeListStatic(target, removedNodes), previousSibling, nextSibling, name, namespace, mappedOldValue);
            var queue = observer._recordQueue;
            queue.push(record);
        }
    } catch (e_3_1) {
        e_3 = {
            error: e_3_1
        };
    } finally{
        try {
            if (interestedObservers_1_1 && !interestedObservers_1_1.done && (_a = interestedObservers_1.return)) _a.call(interestedObservers_1);
        } finally{
            if (e_3) throw e_3.error;
        }
    }
    /**
     * 5. Queue a mutation observer microtask.
     */ observer_queueAMutationObserverMicrotask();
}
exports.observer_queueMutationRecord = observer_queueMutationRecord;
/**
 * Queues a tree mutation record for target.
 *
 * @param target - target node
 * @param addedNodes - a list od added nodes
 * @param removedNodes - a list of removed nodes
 * @param previousSibling - previous sibling of target before mutation
 * @param nextSibling - next sibling of target before mutation
 */ function observer_queueTreeMutationRecord(target, addedNodes, removedNodes, previousSibling, nextSibling) {
    /**
     * To queue a tree mutation record for target with addedNodes, removedNodes,
     * previousSibling, and nextSibling, queue a mutation record of "childList"
     * for target with null, null, null, addedNodes, removedNodes,
     * previousSibling, and nextSibling.
     */ observer_queueMutationRecord("childList", target, null, null, null, addedNodes, removedNodes, previousSibling, nextSibling);
}
exports.observer_queueTreeMutationRecord = observer_queueTreeMutationRecord;
/**
 * Queues an attribute mutation record for target.
 *
 * @param target - target node
 * @param name - name before mutation
 * @param namespace - namespace before mutation
 * @param oldValue - attribute value before mutation
 */ function observer_queueAttributeMutationRecord(target, name, namespace, oldValue) {
    /**
     * To queue an attribute mutation record for target with name, namespace,
     * and oldValue, queue a mutation record of "attributes" for target with
     * name, namespace, oldValue, « », « », null, and null.
     */ observer_queueMutationRecord("attributes", target, name, namespace, oldValue, [], [], null, null);
}
exports.observer_queueAttributeMutationRecord = observer_queueAttributeMutationRecord; //# sourceMappingURL=MutationObserverAlgorithm.js.map


/***/ }),

/***/ 47277:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMException_1 = __webpack_require__(28905);
var infra_1 = __webpack_require__(94317);
var XMLAlgorithm_1 = __webpack_require__(12356);
/**
 * Validates the given qualified name.
 *
 * @param qualifiedName - qualified name
 */ function namespace_validate(qualifiedName) {
    /**
     * To validate a qualifiedName, throw an "InvalidCharacterError"
     * DOMException if qualifiedName does not match the Name or QName
     * production.
     */ if (!XMLAlgorithm_1.xml_isName(qualifiedName)) throw new DOMException_1.InvalidCharacterError("Invalid XML name: " + qualifiedName);
    if (!XMLAlgorithm_1.xml_isQName(qualifiedName)) throw new DOMException_1.InvalidCharacterError("Invalid XML qualified name: " + qualifiedName + ".");
}
exports.namespace_validate = namespace_validate;
/**
 * Validates and extracts a namespace, prefix and localName from the
 * given namespace and qualified name.
 * See: https://dom.spec.whatwg.org/#validate-and-extract.
 *
 * @param namespace - namespace
 * @param qualifiedName - qualified name
 *
 * @returns a tuple with `namespace`, `prefix` and `localName`.
 */ function namespace_validateAndExtract(namespace, qualifiedName) {
    /**
     * 1. If namespace is the empty string, set it to null.
     * 2. Validate qualifiedName.
     * 3. Let prefix be null.
     * 4. Let localName be qualifiedName.
     * 5. If qualifiedName contains a ":" (U+003E), then split the string on it
     * and set prefix to the part before and localName to the part after.
     * 6. If prefix is non-null and namespace is null, then throw a
     * "NamespaceError" DOMException.
     * 7. If prefix is "xml" and namespace is not the XML namespace, then throw
     * a "NamespaceError" DOMException.
     * 8. If either qualifiedName or prefix is "xmlns" and namespace is not the
     * XMLNS namespace, then throw a "NamespaceError" DOMException.
     * 9. If namespace is the XMLNS namespace and neither qualifiedName nor
     * prefix is "xmlns", then throw a "NamespaceError" DOMException.
     * 10. Return namespace, prefix, and localName.
     */ if (!namespace) namespace = null;
    namespace_validate(qualifiedName);
    var parts = qualifiedName.split(":");
    var prefix = parts.length === 2 ? parts[0] : null;
    var localName = parts.length === 2 ? parts[1] : qualifiedName;
    if (prefix && namespace === null) throw new DOMException_1.NamespaceError("Qualified name includes a prefix but the namespace is null.");
    if (prefix === "xml" && namespace !== infra_1.namespace.XML) throw new DOMException_1.NamespaceError('Qualified name includes the "xml" prefix but the namespace is not the XML namespace.');
    if (namespace !== infra_1.namespace.XMLNS && (prefix === "xmlns" || qualifiedName === "xmlns")) throw new DOMException_1.NamespaceError('Qualified name includes the "xmlns" prefix but the namespace is not the XMLNS namespace.');
    if (namespace === infra_1.namespace.XMLNS && prefix !== "xmlns" && qualifiedName !== "xmlns") throw new DOMException_1.NamespaceError('Qualified name does not include the "xmlns" prefix but the namespace is the XMLNS namespace.');
    return [
        namespace,
        prefix,
        localName
    ];
}
exports.namespace_validateAndExtract = namespace_validateAndExtract;
/**
 * Extracts a prefix and localName from the given qualified name.
 *
 * @param qualifiedName - qualified name
 *
 * @returns an tuple with `prefix` and `localName`.
 */ function namespace_extractQName(qualifiedName) {
    namespace_validate(qualifiedName);
    var parts = qualifiedName.split(":");
    var prefix = parts.length === 2 ? parts[0] : null;
    var localName = parts.length === 2 ? parts[1] : qualifiedName;
    return [
        prefix,
        localName
    ];
}
exports.namespace_extractQName = namespace_extractQName; //# sourceMappingURL=NamespaceAlgorithm.js.map


/***/ }),

/***/ 84056:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var util_1 = __webpack_require__(57294);
var infra_1 = __webpack_require__(94317);
var CreateAlgorithm_1 = __webpack_require__(21701);
var OrderedSetAlgorithm_1 = __webpack_require__(26072);
var DOMAlgorithm_1 = __webpack_require__(24473);
var MutationAlgorithm_1 = __webpack_require__(31400);
var ElementAlgorithm_1 = __webpack_require__(60077);
/**
 * Replaces the contents of the given node with a single text node.
 *
 * @param string - node contents
 * @param parent - a node
 */ function node_stringReplaceAll(str, parent) {
    /**
     * 1. Let node be null.
     * 2. If string is not the empty string, then set node to a new Text node
     * whose data is string and node document is parent’s node document.
     * 3. Replace all with node within parent.
     */ var node = null;
    if (str !== "") {
        node = CreateAlgorithm_1.create_text(parent._nodeDocument, str);
    }
    MutationAlgorithm_1.mutation_replaceAll(node, parent);
}
exports.node_stringReplaceAll = node_stringReplaceAll;
/**
 * Clones a node.
 *
 * @param node - a node to clone
 * @param document - the document to own the cloned node
 * @param cloneChildrenFlag - whether to clone node's children
 */ function node_clone(node, document, cloneChildrenFlag) {
    var e_1, _a, e_2, _b;
    if (document === void 0) {
        document = null;
    }
    if (cloneChildrenFlag === void 0) {
        cloneChildrenFlag = false;
    }
    /**
     * 1. If document is not given, let document be node’s node document.
     */ if (document === null) document = node._nodeDocument;
    var copy;
    if (util_1.Guard.isElementNode(node)) {
        /**
         * 2. If node is an element, then:
         * 2.1. Let copy be the result of creating an element, given document,
         * node’s local name, node’s namespace, node’s namespace prefix,
         * and node’s is value, with the synchronous custom elements flag unset.
         * 2.2. For each attribute in node’s attribute list:
         * 2.2.1. Let copyAttribute be a clone of attribute.
         * 2.2.2. Append copyAttribute to copy.
         */ copy = ElementAlgorithm_1.element_createAnElement(document, node._localName, node._namespace, node._namespacePrefix, node._is, false);
        try {
            for(var _c = __values(node._attributeList), _d = _c.next(); !_d.done; _d = _c.next()){
                var attribute = _d.value;
                var copyAttribute = node_clone(attribute, document);
                ElementAlgorithm_1.element_append(copyAttribute, copy);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
    } else {
        /**
         * 3. Otherwise, let copy be a node that implements the same interfaces as
         * node, and fulfills these additional requirements, switching on node:
         * - Document
         * Set copy’s encoding, content type, URL, origin, type, and mode, to those
         * of node.
         * - DocumentType
         * Set copy’s name, public ID, and system ID, to those of node.
         * - Attr
         * Set copy’s namespace, namespace prefix, local name, and value, to
         * those of node.
         * - Text
         * - Comment
         * Set copy’s data, to that of node.
         * - ProcessingInstruction
         * Set copy’s target and data to those of node.
         * - Any other node
         */ if (util_1.Guard.isDocumentNode(node)) {
            var doc = CreateAlgorithm_1.create_document();
            doc._encoding = node._encoding;
            doc._contentType = node._contentType;
            doc._URL = node._URL;
            doc._origin = node._origin;
            doc._type = node._type;
            doc._mode = node._mode;
            copy = doc;
        } else if (util_1.Guard.isDocumentTypeNode(node)) {
            var doctype = CreateAlgorithm_1.create_documentType(document, node._name, node._publicId, node._systemId);
            copy = doctype;
        } else if (util_1.Guard.isAttrNode(node)) {
            var attr = CreateAlgorithm_1.create_attr(document, node.localName);
            attr._namespace = node._namespace;
            attr._namespacePrefix = node._namespacePrefix;
            attr._value = node._value;
            copy = attr;
        } else if (util_1.Guard.isExclusiveTextNode(node)) {
            copy = CreateAlgorithm_1.create_text(document, node._data);
        } else if (util_1.Guard.isCDATASectionNode(node)) {
            copy = CreateAlgorithm_1.create_cdataSection(document, node._data);
        } else if (util_1.Guard.isCommentNode(node)) {
            copy = CreateAlgorithm_1.create_comment(document, node._data);
        } else if (util_1.Guard.isProcessingInstructionNode(node)) {
            copy = CreateAlgorithm_1.create_processingInstruction(document, node._target, node._data);
        } else if (util_1.Guard.isDocumentFragmentNode(node)) {
            copy = CreateAlgorithm_1.create_documentFragment(document);
        } else {
            copy = Object.create(node);
        }
    }
    /**
     * 4. Set copy’s node document and document to copy, if copy is a document,
     * and set copy’s node document to document otherwise.
     */ if (util_1.Guard.isDocumentNode(copy)) {
        copy._nodeDocument = copy;
        document = copy;
    } else {
        copy._nodeDocument = document;
    }
    /**
     * 5. Run any cloning steps defined for node in other applicable
     * specifications and pass copy, node, document and the clone children flag
     * if set, as parameters.
     */ if (DOMImpl_1.dom.features.steps) {
        DOMAlgorithm_1.dom_runCloningSteps(copy, node, document, cloneChildrenFlag);
    }
    /**
     * 6. If the clone children flag is set, clone all the children of node and
     * append them to copy, with document as specified and the clone children
     * flag being set.
     */ if (cloneChildrenFlag) {
        try {
            for(var _e = __values(node._children), _f = _e.next(); !_f.done; _f = _e.next()){
                var child = _f.value;
                var childCopy = node_clone(child, document, true);
                MutationAlgorithm_1.mutation_append(childCopy, copy);
            }
        } catch (e_2_1) {
            e_2 = {
                error: e_2_1
            };
        } finally{
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            } finally{
                if (e_2) throw e_2.error;
            }
        }
    }
    /**
     * 7. Return copy.
     */ return copy;
}
exports.node_clone = node_clone;
/**
 * Determines if two nodes can be considered equal.
 *
 * @param a - node to compare
 * @param b - node to compare
 */ function node_equals(a, b) {
    var e_3, _a, e_4, _b;
    /**
     * 1. A and B’s nodeType attribute value is identical.
     */ if (a._nodeType !== b._nodeType) return false;
    /**
     * 2. The following are also equal, depending on A:
     * - DocumentType
     * Its name, public ID, and system ID.
     * - Element
     * Its namespace, namespace prefix, local name, and its attribute list’s size.
     * - Attr
     * Its namespace, local name, and value.
     * - ProcessingInstruction
     * Its target and data.
     * - Text
     * - Comment
     * Its data.
     */ if (util_1.Guard.isDocumentTypeNode(a) && util_1.Guard.isDocumentTypeNode(b)) {
        if (a._name !== b._name || a._publicId !== b._publicId || a._systemId !== b._systemId) return false;
    } else if (util_1.Guard.isElementNode(a) && util_1.Guard.isElementNode(b)) {
        if (a._namespace !== b._namespace || a._namespacePrefix !== b._namespacePrefix || a._localName !== b._localName || a._attributeList.length !== b._attributeList.length) return false;
    } else if (util_1.Guard.isAttrNode(a) && util_1.Guard.isAttrNode(b)) {
        if (a._namespace !== b._namespace || a._localName !== b._localName || a._value !== b._value) return false;
    } else if (util_1.Guard.isProcessingInstructionNode(a) && util_1.Guard.isProcessingInstructionNode(b)) {
        if (a._target !== b._target || a._data !== b._data) return false;
    } else if (util_1.Guard.isCharacterDataNode(a) && util_1.Guard.isCharacterDataNode(b)) {
        if (a._data !== b._data) return false;
    }
    /**
     * 3. If A is an element, each attribute in its attribute list has an attribute
     * that equals an attribute in B’s attribute list.
     */ if (util_1.Guard.isElementNode(a) && util_1.Guard.isElementNode(b)) {
        var attrMap = {};
        try {
            for(var _c = __values(a._attributeList), _d = _c.next(); !_d.done; _d = _c.next()){
                var attrA = _d.value;
                attrMap[attrA._localName] = attrA;
            }
        } catch (e_3_1) {
            e_3 = {
                error: e_3_1
            };
        } finally{
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            } finally{
                if (e_3) throw e_3.error;
            }
        }
        try {
            for(var _e = __values(b._attributeList), _f = _e.next(); !_f.done; _f = _e.next()){
                var attrB = _f.value;
                var attrA = attrMap[attrB._localName];
                if (!attrA) return false;
                if (!node_equals(attrA, attrB)) return false;
            }
        } catch (e_4_1) {
            e_4 = {
                error: e_4_1
            };
        } finally{
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            } finally{
                if (e_4) throw e_4.error;
            }
        }
    }
    /**
     * 4. A and B have the same number of children.
     * 5. Each child of A equals the child of B at the identical index.
     */ if (a._children.size !== b._children.size) return false;
    var itA = a._children[Symbol.iterator]();
    var itB = b._children[Symbol.iterator]();
    var resultA = itA.next();
    var resultB = itB.next();
    while(!resultA.done && !resultB.done){
        var child1 = resultA.value;
        var child2 = resultB.value;
        if (!node_equals(child1, child2)) return false;
        resultA = itA.next();
        resultB = itB.next();
    }
    return true;
}
exports.node_equals = node_equals;
/**
 * Returns a collection of elements with the given qualified name which are
 * descendants of the given root node.
 * See: https://dom.spec.whatwg.org/#concept-getelementsbytagname
 *
 * @param qualifiedName - qualified name
 * @param root - root node
 */ function node_listOfElementsWithQualifiedName(qualifiedName, root) {
    /**
     * 1. If qualifiedName is "*" (U+002A), return a HTMLCollection rooted at
     * root, whose filter matches only descendant elements.
     * 2. Otherwise, if root’s node document is an HTML document, return a
     * HTMLCollection rooted at root, whose filter matches the following
     * descendant elements:
     * 2.1. Whose namespace is the HTML namespace and whose qualified name is
     * qualifiedName, in ASCII lowercase.
     * 2.2. Whose namespace is not the HTML namespace and whose qualified name
     * is qualifiedName.
     * 3. Otherwise, return a HTMLCollection rooted at root, whose filter
     * matches descendant elements whose qualified name is qualifiedName.
     */ if (qualifiedName === "*") {
        return CreateAlgorithm_1.create_htmlCollection(root);
    } else if (root._nodeDocument._type === "html") {
        return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
            if (ele._namespace === infra_1.namespace.HTML && ele._qualifiedName === qualifiedName.toLowerCase()) {
                return true;
            } else if (ele._namespace !== infra_1.namespace.HTML && ele._qualifiedName === qualifiedName) {
                return true;
            } else {
                return false;
            }
        });
    } else {
        return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
            return ele._qualifiedName === qualifiedName;
        });
    }
}
exports.node_listOfElementsWithQualifiedName = node_listOfElementsWithQualifiedName;
/**
 * Returns a collection of elements with the given namespace which are
 * descendants of the given root node.
 * See: https://dom.spec.whatwg.org/#concept-getelementsbytagnamens
 *
 * @param namespace - element namespace
 * @param localName - local name
 * @param root - root node
 */ function node_listOfElementsWithNamespace(namespace, localName, root) {
    /**
     * 1. If namespace is the empty string, set it to null.
     * 2. If both namespace and localName are "*" (U+002A), return a
     * HTMLCollection rooted at root, whose filter matches descendant elements.
     * 3. Otherwise, if namespace is "*" (U+002A), return a HTMLCollection
     * rooted at root, whose filter matches descendant elements whose local
     * name is localName.
     * 4. Otherwise, if localName is "*" (U+002A), return a HTMLCollection
     * rooted at root, whose filter matches descendant elements whose
     * namespace is namespace.
     * 5. Otherwise, return a HTMLCollection rooted at root, whose filter
     * matches descendant elements whose namespace is namespace and local
     * name is localName.
     */ if (namespace === "") namespace = null;
    if (namespace === "*" && localName === "*") {
        return CreateAlgorithm_1.create_htmlCollection(root);
    } else if (namespace === "*") {
        return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
            return ele._localName === localName;
        });
    } else if (localName === "*") {
        return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
            return ele._namespace === namespace;
        });
    } else {
        return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
            return ele._localName === localName && ele._namespace === namespace;
        });
    }
}
exports.node_listOfElementsWithNamespace = node_listOfElementsWithNamespace;
/**
 * Returns a collection of elements with the given class names which are
 * descendants of the given root node.
 * See: https://dom.spec.whatwg.org/#concept-getelementsbyclassname
 *
 * @param namespace - element namespace
 * @param localName - local name
 * @param root - root node
 */ function node_listOfElementsWithClassNames(classNames, root) {
    /**
     * 1. Let classes be the result of running the ordered set parser
     * on classNames.
     * 2. If classes is the empty set, return an empty HTMLCollection.
     * 3. Return a HTMLCollection rooted at root, whose filter matches
     * descendant elements that have all their classes in classes.
     * The comparisons for the classes must be done in an ASCII case-insensitive
     * manner if root’s node document’s mode is "quirks", and in a
     * case-sensitive manner otherwise.
     */ var classes = OrderedSetAlgorithm_1.orderedSet_parse(classNames);
    if (classes.size === 0) {
        return CreateAlgorithm_1.create_htmlCollection(root, function() {
            return false;
        });
    }
    var caseSensitive = root._nodeDocument._mode !== "quirks";
    return CreateAlgorithm_1.create_htmlCollection(root, function(ele) {
        var eleClasses = ele.classList;
        return OrderedSetAlgorithm_1.orderedSet_contains(eleClasses._tokenSet, classes, caseSensitive);
    });
}
exports.node_listOfElementsWithClassNames = node_listOfElementsWithClassNames;
/**
 * Searches for a namespace prefix associated with the given namespace
 * starting from the given element through its ancestors.
 *
 * @param element - an element node to start searching at
 * @param namespace - namespace to search for
 */ function node_locateANamespacePrefix(element, namespace) {
    /**
     * 1. If element’s namespace is namespace and its namespace prefix is not
     * null, then return its namespace prefix.
     */ if (element._namespace === namespace && element._namespacePrefix !== null) {
        return element._namespacePrefix;
    }
    /**
     * 2. If element has an attribute whose namespace prefix is "xmlns" and
     * value is namespace, then return element’s first such attribute’s
     * local name.
     */ for(var i = 0; i < element._attributeList.length; i++){
        var attr = element._attributeList[i];
        if (attr._namespacePrefix === "xmlns" && attr._value === namespace) {
            return attr._localName;
        }
    }
    /**
     * 3. If element’s parent element is not null, then return the result of
     * running locate a namespace prefix on that element using namespace.
     */ if (element._parent && util_1.Guard.isElementNode(element._parent)) {
        return node_locateANamespacePrefix(element._parent, namespace);
    }
    /**
     * 4. Return null.
     */ return null;
}
exports.node_locateANamespacePrefix = node_locateANamespacePrefix;
/**
 * Searches for a namespace associated with the given namespace prefix
 * starting from the given node through its ancestors.
 *
 * @param node - a node to start searching at
 * @param prefix - namespace prefix to search for
 */ function node_locateANamespace(node, prefix) {
    if (util_1.Guard.isElementNode(node)) {
        /**
         * 1. If its namespace is not null and its namespace prefix is prefix,
         * then return namespace.
         */ if (node._namespace !== null && node._namespacePrefix === prefix) {
            return node._namespace;
        }
        /**
         * 2. If it has an attribute whose namespace is the XMLNS namespace,
         * namespace prefix is "xmlns", and local name is prefix, or if prefix
         * is null and it has an attribute whose namespace is the XMLNS namespace,
         * namespace prefix is null, and local name is "xmlns", then return its
         * value if it is not the empty string, and null otherwise.
         */ for(var i = 0; i < node._attributeList.length; i++){
            var attr = node._attributeList[i];
            if (attr._namespace === infra_1.namespace.XMLNS && attr._namespacePrefix === "xmlns" && attr._localName === prefix) {
                return attr._value || null;
            }
            if (prefix === null && attr._namespace === infra_1.namespace.XMLNS && attr._namespacePrefix === null && attr._localName === "xmlns") {
                return attr._value || null;
            }
        }
        /**
         * 3. If its parent element is null, then return null.
         */ if (node.parentElement === null) return null;
        /**
         * 4. Return the result of running locate a namespace on its parent
         * element using prefix.
         */ return node_locateANamespace(node.parentElement, prefix);
    } else if (util_1.Guard.isDocumentNode(node)) {
        /**
         * 1. If its document element is null, then return null.
         * 2. Return the result of running locate a namespace on its document
         * element using prefix.
         */ if (node.documentElement === null) return null;
        return node_locateANamespace(node.documentElement, prefix);
    } else if (util_1.Guard.isDocumentTypeNode(node) || util_1.Guard.isDocumentFragmentNode(node)) {
        return null;
    } else if (util_1.Guard.isAttrNode(node)) {
        /**
         * 1. If its element is null, then return null.
         * 2. Return the result of running locate a namespace on its element
         * using prefix.
         */ if (node._element === null) return null;
        return node_locateANamespace(node._element, prefix);
    } else {
        /**
         * 1. If its parent element is null, then return null.
         * 2. Return the result of running locate a namespace on its parent
         * element using prefix.
         */ if (!node._parent || !util_1.Guard.isElementNode(node._parent)) return null;
        return node_locateANamespace(node._parent, prefix);
    }
}
exports.node_locateANamespace = node_locateANamespace; //# sourceMappingURL=NodeAlgorithm.js.map


/***/ }),

/***/ 82572:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var interfaces_1 = __webpack_require__(52580);
var TraversalAlgorithm_1 = __webpack_require__(24991);
var TreeAlgorithm_1 = __webpack_require__(59614);
/**
 * Returns the next or previous node in the subtree, or `null` if
 * there are none.
 *
 * @param iterator - the `NodeIterator` instance
 * @param forward- `true` to return the next node, or `false` to
 * return the previous node.
 */ function nodeIterator_traverse(iterator, forward) {
    /**
     * 1. Let node be iterator’s reference.
     * 2. Let beforeNode be iterator’s pointer before reference.
     */ var node = iterator._reference;
    var beforeNode = iterator._pointerBeforeReference;
    /**
     * 3. While true:
     */ while(true){
        /**
         * 3.1. Branch on direction:
         */ if (forward) {
            /**
             * - next
             */ if (!beforeNode) {
                /**
                 * If beforeNode is false, then set node to the first node following
                 * node in iterator’s iterator collection. If there is no such node,
                 * then return null.
                 */ var nextNode = TreeAlgorithm_1.tree_getFollowingNode(iterator._root, node);
                if (nextNode) {
                    node = nextNode;
                } else {
                    return null;
                }
            } else {
                /**
                 * If beforeNode is true, then set it to false.
                 */ beforeNode = false;
            }
        } else {
            /**
             * - previous
             */ if (beforeNode) {
                /**
                 * If beforeNode is true, then set node to the first node preceding
                 * node in iterator’s iterator collection. If there is no such node,
                 * then return null.
                 */ var prevNode = TreeAlgorithm_1.tree_getPrecedingNode(iterator.root, node);
                if (prevNode) {
                    node = prevNode;
                } else {
                    return null;
                }
            } else {
                /**
                 * If beforeNode is false, then set it to true.
                 */ beforeNode = true;
            }
        }
        /**
         * 3.2. Let result be the result of filtering node within iterator.
         * 3.3. If result is FILTER_ACCEPT, then break.
         */ var result = TraversalAlgorithm_1.traversal_filter(iterator, node);
        if (result === interfaces_1.FilterResult.Accept) {
            break;
        }
    }
    /**
     * 4. Set iterator’s reference to node.
     * 5. Set iterator’s pointer before reference to beforeNode.
     * 6. Return node.
     */ iterator._reference = node;
    iterator._pointerBeforeReference = beforeNode;
    return node;
}
exports.nodeIterator_traverse = nodeIterator_traverse;
/**
 * Gets the global iterator list.
 */ function nodeIterator_iteratorList() {
    return DOMImpl_1.dom.window._iteratorList;
}
exports.nodeIterator_iteratorList = nodeIterator_iteratorList; //# sourceMappingURL=NodeIteratorAlgorithm.js.map


/***/ }),

/***/ 26072:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = (void 0) && (void 0).__spread || function() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var infra_1 = __webpack_require__(94317);
/**
 * Converts a whitespace separated string into an array of tokens.
 *
 * @param value - a string of whitespace separated tokens
 */ function orderedSet_parse(value) {
    /**
     * 1. Let inputTokens be the result of splitting input on ASCII whitespace.
     * 2. Let tokens be a new ordered set.
     * 3. For each token in inputTokens, append token to tokens.
     * 4. Return tokens.
     */ var inputTokens = infra_1.string.splitAStringOnASCIIWhitespace(value);
    return new Set(inputTokens);
}
exports.orderedSet_parse = orderedSet_parse;
/**
 * Converts an array of tokens into a space separated string.
 *
 * @param tokens - an array of token strings
 */ function orderedSet_serialize(tokens) {
    /**
     * The ordered set serializer takes a set and returns the concatenation of
     * set using U+0020 SPACE.
     */ return __spread(tokens).join(" ");
}
exports.orderedSet_serialize = orderedSet_serialize;
/**
 * Removes duplicate tokens and convert all whitespace characters
 * to space.
 *
 * @param value - a string of whitespace separated tokens
 */ function orderedSet_sanitize(value) {
    return orderedSet_serialize(orderedSet_parse(value));
}
exports.orderedSet_sanitize = orderedSet_sanitize;
/**
 * Determines whether a set contains the other.
 *
 * @param set1 - a set
 * @param set1 - a set that is contained in set1
 * @param caseSensitive - whether matches are case-sensitive
 */ function orderedSet_contains(set1, set2, caseSensitive) {
    var e_1, _a, e_2, _b;
    try {
        for(var set2_1 = __values(set2), set2_1_1 = set2_1.next(); !set2_1_1.done; set2_1_1 = set2_1.next()){
            var val2 = set2_1_1.value;
            var found = false;
            try {
                for(var set1_1 = (e_2 = void 0, __values(set1)), set1_1_1 = set1_1.next(); !set1_1_1.done; set1_1_1 = set1_1.next()){
                    var val1 = set1_1_1.value;
                    if (caseSensitive) {
                        if (val1 === val2) {
                            found = true;
                            break;
                        }
                    } else {
                        if (val1.toUpperCase() === val2.toUpperCase()) {
                            found = true;
                            break;
                        }
                    }
                }
            } catch (e_2_1) {
                e_2 = {
                    error: e_2_1
                };
            } finally{
                try {
                    if (set1_1_1 && !set1_1_1.done && (_b = set1_1.return)) _b.call(set1_1);
                } finally{
                    if (e_2) throw e_2.error;
                }
            }
            if (!found) return false;
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (set2_1_1 && !set2_1_1.done && (_a = set2_1.return)) _a.call(set2_1);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    return true;
}
exports.orderedSet_contains = orderedSet_contains; //# sourceMappingURL=OrderedSetAlgorithm.js.map


/***/ }),

/***/ 62598:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(96883);
var CreateAlgorithm_1 = __webpack_require__(21701);
/**
 * Converts the given nodes or strings into a node (if `nodes` has
 * only one element) or a document fragment.
 *
 * @param nodes - the array of nodes or strings,
 * @param document - owner document
 */ function parentNode_convertNodesIntoANode(nodes, document) {
    var e_1, _a;
    /**
     * 1. Let node be null.
     * 2. Replace each string in nodes with a new Text node whose data is the
     * string and node document is document.
     */ var node = null;
    for(var i = 0; i < nodes.length; i++){
        var item = nodes[i];
        if (util_1.isString(item)) {
            var text = CreateAlgorithm_1.create_text(document, item);
            nodes[i] = text;
        }
    }
    /**
     * 3. If nodes contains one node, set node to that node.
     * 4. Otherwise, set node to a new DocumentFragment whose node document is
     * document, and then append each node in nodes, if any, to it.
     */ if (nodes.length === 1) {
        node = nodes[0];
    } else {
        node = CreateAlgorithm_1.create_documentFragment(document);
        var ns = node;
        try {
            for(var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()){
                var item = nodes_1_1.value;
                ns.appendChild(item);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
    }
    /**
     * 5. Return node.
     */ return node;
}
exports.parentNode_convertNodesIntoANode = parentNode_convertNodesIntoANode; //# sourceMappingURL=ParentNodeAlgorithm.js.map


/***/ }),

/***/ 20031:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = (void 0) && (void 0).__spread || function() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
var DOMException_1 = __webpack_require__(28905);
var util_1 = __webpack_require__(57294);
var CreateAlgorithm_1 = __webpack_require__(21701);
var TreeAlgorithm_1 = __webpack_require__(59614);
var BoundaryPointAlgorithm_1 = __webpack_require__(35822);
var CharacterDataAlgorithm_1 = __webpack_require__(77901);
var NodeAlgorithm_1 = __webpack_require__(84056);
var MutationAlgorithm_1 = __webpack_require__(31400);
var TextAlgorithm_1 = __webpack_require__(712);
/**
 * Determines if the node's start boundary point is at its end boundary
 * point.
 *
 * @param range - a range
 */ function range_collapsed(range) {
    /**
     * A range is collapsed if its start node is its end node and its start offset is its end offset.
     */ return range._startNode === range._endNode && range._startOffset === range._endOffset;
}
exports.range_collapsed = range_collapsed;
/**
 * Gets the root node of a range.
 *
 * @param range - a range
 */ function range_root(range) {
    /**
     * The root of a live range is the root of its start node.
     */ return TreeAlgorithm_1.tree_rootNode(range._startNode);
}
exports.range_root = range_root;
/**
 * Determines if a node is fully contained in a range.
 *
 * @param node - a node
 * @param range - a range
 */ function range_isContained(node, range) {
    /**
     * A node node is contained in a live range range if node’s root is range’s
     * root, and (node, 0) is after range’s start, and (node, node’s length) is
     * before range’s end.
     */ return TreeAlgorithm_1.tree_rootNode(node) === range_root(range) && BoundaryPointAlgorithm_1.boundaryPoint_position([
        node,
        0
    ], range._start) === interfaces_1.BoundaryPosition.After && BoundaryPointAlgorithm_1.boundaryPoint_position([
        node,
        TreeAlgorithm_1.tree_nodeLength(node)
    ], range._end) === interfaces_1.BoundaryPosition.Before;
}
exports.range_isContained = range_isContained;
/**
 * Determines if a node is partially contained in a range.
 *
 * @param node - a node
 * @param range - a range
 */ function range_isPartiallyContained(node, range) {
    /**
     * A node is partially contained in a live range if it’s an inclusive
     * ancestor of the live range’s start node but not its end node,
     * or vice versa.
     */ var startCheck = TreeAlgorithm_1.tree_isAncestorOf(range._startNode, node, true);
    var endCheck = TreeAlgorithm_1.tree_isAncestorOf(range._endNode, node, true);
    return startCheck && !endCheck || !startCheck && endCheck;
}
exports.range_isPartiallyContained = range_isPartiallyContained;
/**
 * Sets the start boundary point of a range.
 *
 * @param range - a range
 * @param node - a node
 * @param offset - an offset into node
 */ function range_setTheStart(range, node, offset) {
    /**
     * 1. If node is a doctype, then throw an "InvalidNodeTypeError" DOMException.
     * 2. If offset is greater than node’s length, then throw an "IndexSizeError"
     * DOMException.
     * 3. Let bp be the boundary point (node, offset).
     * 4. If these steps were invoked as "set the start"
     * 4.1. If bp is after the range’s end, or if range’s root is not equal to
     * node’s root, set range’s end to bp.
     * 4.2. Set range’s start to bp.
     */ if (util_1.Guard.isDocumentTypeNode(node)) {
        throw new DOMException_1.InvalidNodeTypeError();
    }
    if (offset > TreeAlgorithm_1.tree_nodeLength(node)) {
        throw new DOMException_1.IndexSizeError();
    }
    var bp = [
        node,
        offset
    ];
    if (range_root(range) !== TreeAlgorithm_1.tree_rootNode(node) || BoundaryPointAlgorithm_1.boundaryPoint_position(bp, range._end) === interfaces_1.BoundaryPosition.After) {
        range._end = bp;
    }
    range._start = bp;
}
exports.range_setTheStart = range_setTheStart;
/**
 * Sets the end boundary point of a range.
 *
 * @param range - a range
 * @param node - a node
 * @param offset - an offset into node
 */ function range_setTheEnd(range, node, offset) {
    /**
     * 1. If node is a doctype, then throw an "InvalidNodeTypeError" DOMException.
     * 2. If offset is greater than node’s length, then throw an "IndexSizeError"
     * DOMException.
     * 3. Let bp be the boundary point (node, offset).
     * 4. If these steps were invoked as "set the end"
     * 4.1. If bp is before the range’s start, or if range’s root is not equal
     * to node’s root, set range’s start to bp.
     * 4.2. Set range’s end to bp.
     */ if (util_1.Guard.isDocumentTypeNode(node)) {
        throw new DOMException_1.InvalidNodeTypeError();
    }
    if (offset > TreeAlgorithm_1.tree_nodeLength(node)) {
        throw new DOMException_1.IndexSizeError();
    }
    var bp = [
        node,
        offset
    ];
    if (range_root(range) !== TreeAlgorithm_1.tree_rootNode(node) || BoundaryPointAlgorithm_1.boundaryPoint_position(bp, range._start) === interfaces_1.BoundaryPosition.Before) {
        range._start = bp;
    }
    range._end = bp;
}
exports.range_setTheEnd = range_setTheEnd;
/**
 * Selects a node.
 *
 * @param range - a range
 * @param node - a node
 */ function range_select(node, range) {
    /**
     * 1. Let parent be node’s parent.
     * 2. If parent is null, then throw an "InvalidNodeTypeError" DOMException.
     */ var parent = node._parent;
    if (parent === null) throw new DOMException_1.InvalidNodeTypeError();
    /**
     * 3. Let index be node’s index.
     * 4. Set range’s start to boundary point (parent, index).
     * 5. Set range’s end to boundary point (parent, index plus 1).
     */ var index = TreeAlgorithm_1.tree_index(node);
    range._start = [
        parent,
        index
    ];
    range._end = [
        parent,
        index + 1
    ];
}
exports.range_select = range_select;
/**
 * EXtracts the contents of range as a document fragment.
 *
 * @param range - a range
 */ function range_extract(range) {
    var e_1, _a, e_2, _b, e_3, _c;
    /**
     * 1. Let fragment be a new DocumentFragment node whose node document is
     * range’s start node’s node document.
     * 2. If range is collapsed, then return fragment.
     */ var fragment = CreateAlgorithm_1.create_documentFragment(range._startNode._nodeDocument);
    if (range_collapsed(range)) return fragment;
    /**
     * 3. Let original start node, original start offset, original end node,
     * and original end offset be range’s start node, start offset, end node,
     * and end offset, respectively.
     */ var originalStartNode = range._startNode;
    var originalStartOffset = range._startOffset;
    var originalEndNode = range._endNode;
    var originalEndOffset = range._endOffset;
    /**
     * 4. If original start node is original end node, and they are a Text,
     * ProcessingInstruction, or Comment node:
     * 4.1. Let clone be a clone of original start node.
     * 4.2. Set the data of clone to the result of substringing data with node
     * original start node, offset original start offset, and count original end
     * offset minus original start offset.
     * 4.3. Append clone to fragment.
     * 4.4. Replace data with node original start node, offset original start
     * offset, count original end offset minus original start offset, and data
     * the empty string.
     * 4.5. Return fragment.
     */ if (originalStartNode === originalEndNode && util_1.Guard.isCharacterDataNode(originalStartNode)) {
        var clone = NodeAlgorithm_1.node_clone(originalStartNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        CharacterDataAlgorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset, "");
        return fragment;
    }
    /**
     * 5. Let common ancestor be original start node.
     * 6. While common ancestor is not an inclusive ancestor of original end
     * node, set common ancestor to its own parent.
     */ var commonAncestor = originalStartNode;
    while(!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, commonAncestor, true)){
        if (commonAncestor._parent === null) {
            throw new Error("Parent node  is null.");
        }
        commonAncestor = commonAncestor._parent;
    }
    /**
     * 7. Let first partially contained child be null.
     * 8. If original start node is not an inclusive ancestor of original end
     * node, set first partially contained child to the first child of common
     * ancestor that is partially contained in range.
     */ var firstPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
        try {
            for(var _d = __values(commonAncestor._children), _e = _d.next(); !_e.done; _e = _d.next()){
                var node = _e.value;
                if (range_isPartiallyContained(node, range)) {
                    firstPartiallyContainedChild = node;
                    break;
                }
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
    }
    /**
     * 9. Let last partially contained child be null.
     * 10. If original end node is not an inclusive ancestor of original start
     * node, set last partially contained child to the last child of common
     * ancestor that is partially contained in range.
     */ var lastPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalStartNode, originalEndNode, true)) {
        var children = __spread(commonAncestor._children);
        for(var i = children.length - 1; i > 0; i--){
            var node = children[i];
            if (range_isPartiallyContained(node, range)) {
                lastPartiallyContainedChild = node;
                break;
            }
        }
    }
    /**
     * 11. Let contained children be a list of all children of common ancestor
     * that are contained in range, in tree order.
     * 12. If any member of contained children is a doctype, then throw a
     * "HierarchyRequestError" DOMException.
     */ var containedChildren = [];
    try {
        for(var _f = __values(commonAncestor._children), _g = _f.next(); !_g.done; _g = _f.next()){
            var child = _g.value;
            if (range_isContained(child, range)) {
                if (util_1.Guard.isDocumentTypeNode(child)) {
                    throw new DOMException_1.HierarchyRequestError();
                }
                containedChildren.push(child);
            }
        }
    } catch (e_2_1) {
        e_2 = {
            error: e_2_1
        };
    } finally{
        try {
            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
        } finally{
            if (e_2) throw e_2.error;
        }
    }
    var newNode;
    var newOffset;
    if (TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
        /**
         * 13. If original start node is an inclusive ancestor of original end node,
         * set new node to original start node and new offset to original start
         * offset.
         */ newNode = originalStartNode;
        newOffset = originalStartOffset;
    } else {
        /**
         * 14. Otherwise:
         * 14.1. Let reference node equal original start node.
         * 14.2. While reference node’s parent is not null and is not an inclusive
         * ancestor of original end node, set reference node to its parent.
         * 14.3. Set new node to the parent of reference node, and new offset to
         * one plus reference node’s index.
         */ var referenceNode = originalStartNode;
        while(referenceNode._parent !== null && !TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, referenceNode._parent)){
            referenceNode = referenceNode._parent;
        }
        /* istanbul ignore next */ if (referenceNode._parent === null) {
            /**
             * If reference node’s parent is null, it would be the root of range,
             * so would be an inclusive ancestor of original end node, and we could
             * not reach this point.
             */ throw new Error("Parent node is null.");
        }
        newNode = referenceNode._parent;
        newOffset = 1 + TreeAlgorithm_1.tree_index(referenceNode);
    }
    if (util_1.Guard.isCharacterDataNode(firstPartiallyContainedChild)) {
        /**
         * 15. If first partially contained child is a Text, ProcessingInstruction,
         * or Comment node:
         * 15.1. Let clone be a clone of original start node.
         * 15.2. Set the data of clone to the result of substringing data with
         * node original start node, offset original start offset, and count
         * original start node’s length minus original start offset.
         * 15.3. Append clone to fragment.
         * 15.4. Replace data with node original start node, offset original
         * start offset, count original start node’s length minus original start
         * offset, and data the empty string.
         */ var clone = NodeAlgorithm_1.node_clone(originalStartNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        CharacterDataAlgorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset, "");
    } else if (firstPartiallyContainedChild !== null) {
        /**
         * 16. Otherwise, if first partially contained child is not null:
         * 16.1. Let clone be a clone of first partially contained child.
         * 16.2. Append clone to fragment.
         * 16.3. Let subrange be a new live range whose start is (original start
         * node, original start offset) and whose end is (first partially
         * contained child, first partially contained child’s length).
         * 16.4. Let subfragment be the result of extracting subrange.
         * 16.5. Append subfragment to clone.
         */ var clone = NodeAlgorithm_1.node_clone(firstPartiallyContainedChild);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        var subrange = CreateAlgorithm_1.create_range([
            originalStartNode,
            originalStartOffset
        ], [
            firstPartiallyContainedChild,
            TreeAlgorithm_1.tree_nodeLength(firstPartiallyContainedChild)
        ]);
        var subfragment = range_extract(subrange);
        MutationAlgorithm_1.mutation_append(subfragment, clone);
    }
    try {
        /**
         * 17. For each contained child in contained children, append contained
         * child to fragment.
         */ for(var containedChildren_1 = __values(containedChildren), containedChildren_1_1 = containedChildren_1.next(); !containedChildren_1_1.done; containedChildren_1_1 = containedChildren_1.next()){
            var child = containedChildren_1_1.value;
            MutationAlgorithm_1.mutation_append(child, fragment);
        }
    } catch (e_3_1) {
        e_3 = {
            error: e_3_1
        };
    } finally{
        try {
            if (containedChildren_1_1 && !containedChildren_1_1.done && (_c = containedChildren_1.return)) _c.call(containedChildren_1);
        } finally{
            if (e_3) throw e_3.error;
        }
    }
    if (util_1.Guard.isCharacterDataNode(lastPartiallyContainedChild)) {
        /**
         * 18. If last partially contained child is a Text, ProcessingInstruction,
         * or Comment node:
         * 18.1. Let clone be a clone of original end node.
         * 18.2. Set the data of clone to the result of substringing data with
         * node original end node, offset 0, and count original end offset.
         * 18.3. Append clone to fragment.
         * 18.4. Replace data with node original end node, offset 0, count
         * original end offset, and data the empty string.
         */ var clone = NodeAlgorithm_1.node_clone(originalEndNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalEndNode, 0, originalEndOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        CharacterDataAlgorithm_1.characterData_replaceData(originalEndNode, 0, originalEndOffset, "");
    } else if (lastPartiallyContainedChild !== null) {
        /**
         * 19. Otherwise, if last partially contained child is not null:
         * 19.1. Let clone be a clone of last partially contained child.
         * 19.2. Append clone to fragment.
         * 19.3. Let subrange be a new live range whose start is (last partially
         * contained child, 0) and whose end is (original end node, original
         * end offset).
         * 19.4. Let subfragment be the result of extracting subrange.
         * 19.5. Append subfragment to clone.
         */ var clone = NodeAlgorithm_1.node_clone(lastPartiallyContainedChild);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        var subrange = CreateAlgorithm_1.create_range([
            lastPartiallyContainedChild,
            0
        ], [
            originalEndNode,
            originalEndOffset
        ]);
        var subfragment = range_extract(subrange);
        MutationAlgorithm_1.mutation_append(subfragment, clone);
    }
    /**
     * 20. Set range’s start and end to (new node, new offset).
     */ range._start = [
        newNode,
        newOffset
    ];
    range._end = [
        newNode,
        newOffset
    ];
    /**
     * 21. Return fragment.
     */ return fragment;
}
exports.range_extract = range_extract;
/**
 * Clones the contents of range as a document fragment.
 *
 * @param range - a range
 */ function range_cloneTheContents(range) {
    var e_4, _a, e_5, _b, e_6, _c;
    /**
     * 1. Let fragment be a new DocumentFragment node whose node document
     * is range’s start node’s node document.
     * 2. If range is collapsed, then return fragment.
     */ var fragment = CreateAlgorithm_1.create_documentFragment(range._startNode._nodeDocument);
    if (range_collapsed(range)) return fragment;
    /**
     * 3. Let original start node, original start offset, original end node,
     * and original end offset be range’s start node, start offset, end node,
     * and end offset, respectively.
     * 4. If original start node is original end node, and they are a Text,
     * ProcessingInstruction, or Comment node:
     * 4.1. Let clone be a clone of original start node.
     * 4.2. Set the data of clone to the result of substringing data with node
     * original start node, offset original start offset, and count original end
     * offset minus original start offset.
     * 4.3. Append clone to fragment.
     * 4.5. Return fragment.
     */ var originalStartNode = range._startNode;
    var originalStartOffset = range._startOffset;
    var originalEndNode = range._endNode;
    var originalEndOffset = range._endOffset;
    if (originalStartNode === originalEndNode && util_1.Guard.isCharacterDataNode(originalStartNode)) {
        var clone = NodeAlgorithm_1.node_clone(originalStartNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
    }
    /**
     * 5. Let common ancestor be original start node.
     * 6. While common ancestor is not an inclusive ancestor of original end
     * node, set common ancestor to its own parent.
     */ var commonAncestor = originalStartNode;
    while(!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, commonAncestor, true)){
        if (commonAncestor._parent === null) {
            throw new Error("Parent node  is null.");
        }
        commonAncestor = commonAncestor._parent;
    }
    /**
     * 7. Let first partially contained child be null.
     * 8. If original start node is not an inclusive ancestor of original end
     * node, set first partially contained child to the first child of common
     * ancestor that is partially contained in range.
     */ var firstPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
        try {
            for(var _d = __values(commonAncestor._children), _e = _d.next(); !_e.done; _e = _d.next()){
                var node = _e.value;
                if (range_isPartiallyContained(node, range)) {
                    firstPartiallyContainedChild = node;
                    break;
                }
            }
        } catch (e_4_1) {
            e_4 = {
                error: e_4_1
            };
        } finally{
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            } finally{
                if (e_4) throw e_4.error;
            }
        }
    }
    /**
     * 9. Let last partially contained child be null.
     * 10. If original end node is not an inclusive ancestor of original start
     * node, set last partially contained child to the last child of common
     * ancestor that is partially contained in range.
     */ var lastPartiallyContainedChild = null;
    if (!TreeAlgorithm_1.tree_isAncestorOf(originalStartNode, originalEndNode, true)) {
        var children = __spread(commonAncestor._children);
        for(var i = children.length - 1; i > 0; i--){
            var node = children[i];
            if (range_isPartiallyContained(node, range)) {
                lastPartiallyContainedChild = node;
                break;
            }
        }
    }
    /**
     * 11. Let contained children be a list of all children of common ancestor
     * that are contained in range, in tree order.
     * 12. If any member of contained children is a doctype, then throw a
     * "HierarchyRequestError" DOMException.
     */ var containedChildren = [];
    try {
        for(var _f = __values(commonAncestor._children), _g = _f.next(); !_g.done; _g = _f.next()){
            var child = _g.value;
            if (range_isContained(child, range)) {
                if (util_1.Guard.isDocumentTypeNode(child)) {
                    throw new DOMException_1.HierarchyRequestError();
                }
                containedChildren.push(child);
            }
        }
    } catch (e_5_1) {
        e_5 = {
            error: e_5_1
        };
    } finally{
        try {
            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
        } finally{
            if (e_5) throw e_5.error;
        }
    }
    if (util_1.Guard.isCharacterDataNode(firstPartiallyContainedChild)) {
        /**
         * 13. If first partially contained child is a Text, ProcessingInstruction,
         * or Comment node:
         * 13.1. Let clone be a clone of original start node.
         * 13.2. Set the data of clone to the result of substringing data with
         * node original start node, offset original start offset, and count
         * original start node’s length minus original start offset.
         * 13.3. Append clone to fragment.
         */ var clone = NodeAlgorithm_1.node_clone(originalStartNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalStartNode, originalStartOffset, TreeAlgorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
    } else if (firstPartiallyContainedChild !== null) {
        /**
         * 14. Otherwise, if first partially contained child is not null:
         * 14.1. Let clone be a clone of first partially contained child.
         * 14.2. Append clone to fragment.
         * 14.3. Let subrange be a new live range whose start is (original start
         * node, original start offset) and whose end is (first partially
         * contained child, first partially contained child’s length).
         * 14.4. Let subfragment be the result of cloning the contents of
         * subrange.
         * 14.5. Append subfragment to clone.
         */ var clone = NodeAlgorithm_1.node_clone(firstPartiallyContainedChild);
        MutationAlgorithm_1.mutation_append(clone, fragment);
        var subrange = CreateAlgorithm_1.create_range([
            originalStartNode,
            originalStartOffset
        ], [
            firstPartiallyContainedChild,
            TreeAlgorithm_1.tree_nodeLength(firstPartiallyContainedChild)
        ]);
        var subfragment = range_cloneTheContents(subrange);
        MutationAlgorithm_1.mutation_append(subfragment, clone);
    }
    try {
        /**
         * 15. For each contained child in contained children, append contained
         * child to fragment.
         * 15.1. Let clone be a clone of contained child with the clone children
         * flag set.
         * 15.2. Append clone to fragment.
         */ for(var containedChildren_2 = __values(containedChildren), containedChildren_2_1 = containedChildren_2.next(); !containedChildren_2_1.done; containedChildren_2_1 = containedChildren_2.next()){
            var child = containedChildren_2_1.value;
            var clone = NodeAlgorithm_1.node_clone(child);
            MutationAlgorithm_1.mutation_append(clone, fragment);
        }
    } catch (e_6_1) {
        e_6 = {
            error: e_6_1
        };
    } finally{
        try {
            if (containedChildren_2_1 && !containedChildren_2_1.done && (_c = containedChildren_2.return)) _c.call(containedChildren_2);
        } finally{
            if (e_6) throw e_6.error;
        }
    }
    if (util_1.Guard.isCharacterDataNode(lastPartiallyContainedChild)) {
        /**
         * 16. If last partially contained child is a Text, ProcessingInstruction,
         * or Comment node:
         * 16.1. Let clone be a clone of original end node.
         * 16.2. Set the data of clone to the result of substringing data with
         * node original end node, offset 0, and count original end offset.
         * 16.3. Append clone to fragment.
         */ var clone = NodeAlgorithm_1.node_clone(originalEndNode);
        clone._data = CharacterDataAlgorithm_1.characterData_substringData(originalEndNode, 0, originalEndOffset);
        MutationAlgorithm_1.mutation_append(clone, fragment);
    } else if (lastPartiallyContainedChild !== null) {
        /**
         * 17. Otherwise, if last partially contained child is not null:
         * 17.1. Let clone be a clone of last partially contained child.
         * 17.2. Append clone to fragment.
         * 17.3. Let subrange be a new live range whose start is (last partially
         * contained child, 0) and whose end is (original end node, original
         * end offset).
         * 17.4. Let subfragment be the result of cloning the contents of subrange.
         * 17.5. Append subfragment to clone.
         */ var clone = NodeAlgorithm_1.node_clone(lastPartiallyContainedChild);
        fragment.append(clone);
        var subrange = CreateAlgorithm_1.create_range([
            lastPartiallyContainedChild,
            0
        ], [
            originalEndNode,
            originalEndOffset
        ]);
        var subfragment = range_extract(subrange);
        MutationAlgorithm_1.mutation_append(subfragment, clone);
    }
    /**
     * 18. Return fragment.
     */ return fragment;
}
exports.range_cloneTheContents = range_cloneTheContents;
/**
 * Inserts a node into a range at the start boundary point.
 *
 * @param node - node to insert
 * @param range - a range
 */ function range_insert(node, range) {
    var e_7, _a;
    /**
     * 1. If range’s start node is a ProcessingInstruction or Comment node, is a
     * Text node whose parent is null, or is node, then throw a
     * "HierarchyRequestError" DOMException.
     */ if (util_1.Guard.isProcessingInstructionNode(range._startNode) || util_1.Guard.isCommentNode(range._startNode) || util_1.Guard.isTextNode(range._startNode) && range._startNode._parent === null || range._startNode === node) {
        throw new DOMException_1.HierarchyRequestError();
    }
    /**
     * 2. Let referenceNode be null.
     * 3. If range’s start node is a Text node, set referenceNode to that Text
     * node.
     * 4. Otherwise, set referenceNode to the child of start node whose index is
     * start offset, and null if there is no such child.
     */ var referenceNode = null;
    if (util_1.Guard.isTextNode(range._startNode)) {
        referenceNode = range._startNode;
    } else {
        var index = 0;
        try {
            for(var _b = __values(range._startNode._children), _c = _b.next(); !_c.done; _c = _b.next()){
                var child = _c.value;
                if (index === range._startOffset) {
                    referenceNode = child;
                    break;
                }
                index++;
            }
        } catch (e_7_1) {
            e_7 = {
                error: e_7_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_7) throw e_7.error;
            }
        }
    }
    /**
     * 5. Let parent be range’s start node if referenceNode is null, and
     * referenceNode’s parent otherwise.
     */ var parent;
    if (referenceNode === null) {
        parent = range._startNode;
    } else {
        if (referenceNode._parent === null) {
            throw new Error("Parent node is null.");
        }
        parent = referenceNode._parent;
    }
    /**
     * 6. Ensure pre-insertion validity of node into parent before referenceNode.
     */ MutationAlgorithm_1.mutation_ensurePreInsertionValidity(node, parent, referenceNode);
    /**
     * 7. If range’s start node is a Text node, set referenceNode to the result
     * of splitting it with offset range’s start offset.
     */ if (util_1.Guard.isTextNode(range._startNode)) {
        referenceNode = TextAlgorithm_1.text_split(range._startNode, range._startOffset);
    }
    /**
     * 8. If node is referenceNode, set referenceNode to its next sibling.
     */ if (node === referenceNode) {
        referenceNode = node._nextSibling;
    }
    /**
     * 9. If node’s parent is not null, remove node from its parent.
     */ if (node._parent !== null) {
        MutationAlgorithm_1.mutation_remove(node, node._parent);
    }
    /**
     * 10. Let newOffset be parent’s length if referenceNode is null, and
     * referenceNode’s index otherwise.
     */ var newOffset = referenceNode === null ? TreeAlgorithm_1.tree_nodeLength(parent) : TreeAlgorithm_1.tree_index(referenceNode);
    /**
     * 11. Increase newOffset by node’s length if node is a DocumentFragment
     * node, and one otherwise.
     */ if (util_1.Guard.isDocumentFragmentNode(node)) {
        newOffset += TreeAlgorithm_1.tree_nodeLength(node);
    } else {
        newOffset++;
    }
    /**
     * 12. Pre-insert node into parent before referenceNode.
     */ MutationAlgorithm_1.mutation_preInsert(node, parent, referenceNode);
    /**
     * 13. If range is collapsed, then set range’s end to (parent, newOffset).
     */ if (range_collapsed(range)) {
        range._end = [
            parent,
            newOffset
        ];
    }
}
exports.range_insert = range_insert;
/**
 * Traverses through all contained nodes of a range.
 *
 * @param range - a range
 */ function range_getContainedNodes(range) {
    var _a;
    return _a = {}, _a[Symbol.iterator] = function() {
        var container = range.commonAncestorContainer;
        var currentNode = TreeAlgorithm_1.tree_getFirstDescendantNode(container);
        return {
            next: function() {
                while(currentNode && !range_isContained(currentNode, range)){
                    currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
                }
                if (currentNode === null) {
                    return {
                        done: true,
                        value: null
                    };
                } else {
                    var result = {
                        done: false,
                        value: currentNode
                    };
                    currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
                    return result;
                }
            }
        };
    }, _a;
}
exports.range_getContainedNodes = range_getContainedNodes;
/**
 * Traverses through all partially contained nodes of a range.
 *
 * @param range - a range
 */ function range_getPartiallyContainedNodes(range) {
    var _a;
    return _a = {}, _a[Symbol.iterator] = function() {
        var container = range.commonAncestorContainer;
        var currentNode = TreeAlgorithm_1.tree_getFirstDescendantNode(container);
        return {
            next: function() {
                while(currentNode && !range_isPartiallyContained(currentNode, range)){
                    currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
                }
                if (currentNode === null) {
                    return {
                        done: true,
                        value: null
                    };
                } else {
                    var result = {
                        done: false,
                        value: currentNode
                    };
                    currentNode = TreeAlgorithm_1.tree_getNextDescendantNode(container, currentNode);
                    return result;
                }
            }
        };
    }, _a;
}
exports.range_getPartiallyContainedNodes = range_getPartiallyContainedNodes; //# sourceMappingURL=RangeAlgorithm.js.map


/***/ }),

/***/ 33740:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMException_1 = __webpack_require__(28905);
/**
 * Matches elements with the given selectors.
 *
 * @param selectors - selectors
 * @param node - the node to match against
 */ function selectors_scopeMatchASelectorsString(selectors, node) {
    /**
     * TODO: Selectors
     * 1. Let s be the result of parse a selector selectors. [SELECTORS4]
     * 2. If s is failure, then throw a "SyntaxError" DOMException.
     * 3. Return the result of match a selector against a tree with s and node’s
     * root using scoping root node. [SELECTORS4].
     */ throw new DOMException_1.NotSupportedError();
}
exports.selectors_scopeMatchASelectorsString = selectors_scopeMatchASelectorsString; //# sourceMappingURL=SelectorsAlgorithm.js.map


/***/ }),

/***/ 49576:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = (void 0) && (void 0).__spread || function() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var util_1 = __webpack_require__(57294);
var util_2 = __webpack_require__(96883);
var TreeAlgorithm_1 = __webpack_require__(59614);
var MutationObserverAlgorithm_1 = __webpack_require__(5742);
/**
 * Signals a slot change to the given slot.
 *
 * @param slot - a slot
 */ function shadowTree_signalASlotChange(slot) {
    /**
     * 1. Append slot to slot’s relevant agent’s signal slots.
     * 2. Queue a mutation observer microtask.
     */ var window = DOMImpl_1.dom.window;
    window._signalSlots.add(slot);
    MutationObserverAlgorithm_1.observer_queueAMutationObserverMicrotask();
}
exports.shadowTree_signalASlotChange = shadowTree_signalASlotChange;
/**
 * Determines whether a the shadow tree of the given element node is
 * connected to a document node.
 *
 * @param element - an element node of the shadow tree
 */ function shadowTree_isConnected(element) {
    /**
     * An element is connected if its shadow-including root is a document.
     */ return util_1.Guard.isDocumentNode(TreeAlgorithm_1.tree_rootNode(element, true));
}
exports.shadowTree_isConnected = shadowTree_isConnected;
/**
 * Determines whether a slotable is assigned.
 *
 * @param slotable - a slotable
 */ function shadowTree_isAssigned(slotable) {
    /**
     * A slotable is assigned if its assigned slot is non-null.
     */ return slotable._assignedSlot !== null;
}
exports.shadowTree_isAssigned = shadowTree_isAssigned;
/**
 * Finds a slot for the given slotable.
 *
 * @param slotable - a slotable
 * @param openFlag - `true` to search open shadow tree's only
 */ function shadowTree_findASlot(slotable, openFlag) {
    if (openFlag === void 0) {
        openFlag = false;
    }
    /**
     * 1. If slotable’s parent is null, then return null.
     * 2. Let shadow be slotable’s parent’s shadow root.
     * 3. If shadow is null, then return null.
     * 4. If the open flag is set and shadow’s mode is not "open", then
     * return null.
     * 5. Return the first slot in tree order in shadow’s descendants whose name
     * is slotable’s name, if any, and null otherwise.
     */ var node = util_1.Cast.asNode(slotable);
    var parent = node._parent;
    if (parent === null) return null;
    var shadow = parent._shadowRoot || null;
    if (shadow === null) return null;
    if (openFlag && shadow._mode !== "open") return null;
    var child = TreeAlgorithm_1.tree_getFirstDescendantNode(shadow, false, true, function(e) {
        return util_1.Guard.isSlot(e);
    });
    while(child !== null){
        if (child._name === slotable._name) return child;
        child = TreeAlgorithm_1.tree_getNextDescendantNode(shadow, child, false, true, function(e) {
            return util_1.Guard.isSlot(e);
        });
    }
    return null;
}
exports.shadowTree_findASlot = shadowTree_findASlot;
/**
 * Finds slotables for the given slot.
 *
 * @param slot - a slot
 */ function shadowTree_findSlotables(slot) {
    var e_1, _a;
    /**
     * 1. Let result be an empty list.
     * 2. If slot’s root is not a shadow root, then return result.
     */ var result = [];
    var root = TreeAlgorithm_1.tree_rootNode(slot);
    if (!util_1.Guard.isShadowRoot(root)) return result;
    /**
     * 3. Let host be slot’s root’s host.
     * 4. For each slotable child of host, slotable, in tree order:
     */ var host = root._host;
    try {
        for(var _b = __values(host._children), _c = _b.next(); !_c.done; _c = _b.next()){
            var slotable = _c.value;
            if (util_1.Guard.isSlotable(slotable)) {
                /**
                 * 4.1. Let foundSlot be the result of finding a slot given slotable.
                 * 4.2. If foundSlot is slot, then append slotable to result.
                 */ var foundSlot = shadowTree_findASlot(slotable);
                if (foundSlot === slot) {
                    result.push(slotable);
                }
            }
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    /**
     * 5. Return result.
     */ return result;
}
exports.shadowTree_findSlotables = shadowTree_findSlotables;
/**
 * Finds slotables for the given slot.
 *
 * @param slot - a slot
 */ function shadowTree_findFlattenedSlotables(slot) {
    var e_2, _a, e_3, _b;
    /**
     * 1. Let result be an empty list.
     * 2. If slot’s root is not a shadow root, then return result.
     */ var result = [];
    var root = TreeAlgorithm_1.tree_rootNode(slot);
    if (!util_1.Guard.isShadowRoot(root)) return result;
    /**
     * 3. Let slotables be the result of finding slotables given slot.
     * 4. If slotables is the empty list, then append each slotable child of
     * slot, in tree order, to slotables.
     */ var slotables = shadowTree_findSlotables(slot);
    if (util_2.isEmpty(slotables)) {
        try {
            for(var _c = __values(slot._children), _d = _c.next(); !_d.done; _d = _c.next()){
                var slotable = _d.value;
                if (util_1.Guard.isSlotable(slotable)) {
                    slotables.push(slotable);
                }
            }
        } catch (e_2_1) {
            e_2 = {
                error: e_2_1
            };
        } finally{
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            } finally{
                if (e_2) throw e_2.error;
            }
        }
    }
    try {
        /**
         * 5. For each node in slotables:
         */ for(var slotables_1 = __values(slotables), slotables_1_1 = slotables_1.next(); !slotables_1_1.done; slotables_1_1 = slotables_1.next()){
            var node = slotables_1_1.value;
            /**
             * 5.1. If node is a slot whose root is a shadow root, then:
             */ if (util_1.Guard.isSlot(node) && util_1.Guard.isShadowRoot(TreeAlgorithm_1.tree_rootNode(node))) {
                /**
                 * 5.1.1. Let temporaryResult be the result of finding flattened slotables given node.
                 * 5.1.2. Append each slotable in temporaryResult, in order, to result.
                 */ var temporaryResult = shadowTree_findFlattenedSlotables(node);
                result.push.apply(result, __spread(temporaryResult));
            } else {
                /**
                 * 5.2. Otherwise, append node to result.
                 */ result.push(node);
            }
        }
    } catch (e_3_1) {
        e_3 = {
            error: e_3_1
        };
    } finally{
        try {
            if (slotables_1_1 && !slotables_1_1.done && (_b = slotables_1.return)) _b.call(slotables_1);
        } finally{
            if (e_3) throw e_3.error;
        }
    }
    /**
     * 6. Return result.
     */ return result;
}
exports.shadowTree_findFlattenedSlotables = shadowTree_findFlattenedSlotables;
/**
 * Assigns slotables to the given slot.
 *
 * @param slot - a slot
 */ function shadowTree_assignSlotables(slot) {
    var e_4, _a;
    /**
     * 1. Let slotables be the result of finding slotables for slot.
     * 2. If slotables and slot’s assigned nodes are not identical, then run
     * signal a slot change for slot.
     */ var slotables = shadowTree_findSlotables(slot);
    if (slotables.length === slot._assignedNodes.length) {
        var nodesIdentical = true;
        for(var i = 0; i < slotables.length; i++){
            if (slotables[i] !== slot._assignedNodes[i]) {
                nodesIdentical = false;
                break;
            }
        }
        if (!nodesIdentical) {
            shadowTree_signalASlotChange(slot);
        }
    }
    /**
     * 3. Set slot’s assigned nodes to slotables.
     * 4. For each slotable in slotables, set slotable’s assigned slot to slot.
     */ slot._assignedNodes = slotables;
    try {
        for(var slotables_2 = __values(slotables), slotables_2_1 = slotables_2.next(); !slotables_2_1.done; slotables_2_1 = slotables_2.next()){
            var slotable = slotables_2_1.value;
            slotable._assignedSlot = slot;
        }
    } catch (e_4_1) {
        e_4 = {
            error: e_4_1
        };
    } finally{
        try {
            if (slotables_2_1 && !slotables_2_1.done && (_a = slotables_2.return)) _a.call(slotables_2);
        } finally{
            if (e_4) throw e_4.error;
        }
    }
}
exports.shadowTree_assignSlotables = shadowTree_assignSlotables;
/**
 * Assigns slotables to all nodes of a tree.
 *
 * @param root - root node
 */ function shadowTree_assignSlotablesForATree(root) {
    /**
     * To assign slotables for a tree, given a node root, run assign slotables
     * for each slot slot in root’s inclusive descendants, in tree order.
     */ var descendant = TreeAlgorithm_1.tree_getFirstDescendantNode(root, true, false, function(e) {
        return util_1.Guard.isSlot(e);
    });
    while(descendant !== null){
        shadowTree_assignSlotables(descendant);
        descendant = TreeAlgorithm_1.tree_getNextDescendantNode(root, descendant, true, false, function(e) {
            return util_1.Guard.isSlot(e);
        });
    }
}
exports.shadowTree_assignSlotablesForATree = shadowTree_assignSlotablesForATree;
/**
 * Assigns a slot to a slotables.
 *
 * @param slotable - a slotable
 */ function shadowTree_assignASlot(slotable) {
    /**
     * 1. Let slot be the result of finding a slot with slotable.
     * 2. If slot is non-null, then run assign slotables for slot.
     */ var slot = shadowTree_findASlot(slotable);
    if (slot !== null) {
        shadowTree_assignSlotables(slot);
    }
}
exports.shadowTree_assignASlot = shadowTree_assignASlot; //# sourceMappingURL=ShadowTreeAlgorithm.js.map


/***/ }),

/***/ 712:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var util_1 = __webpack_require__(57294);
var DOMException_1 = __webpack_require__(28905);
var CreateAlgorithm_1 = __webpack_require__(21701);
var TreeAlgorithm_1 = __webpack_require__(59614);
var CharacterDataAlgorithm_1 = __webpack_require__(77901);
var MutationAlgorithm_1 = __webpack_require__(31400);
/**
 * Returns node with its adjacent text and cdata node siblings.
 *
 * @param node - a node
 * @param self - whether to include node itself
 */ function text_contiguousTextNodes(node, self) {
    var _a;
    if (self === void 0) {
        self = false;
    }
    /**
     * The contiguous Text nodes of a node node are node, node’s previous
     * sibling Text node, if any, and its contiguous Text nodes, and node’s next
     * sibling Text node, if any, and its contiguous Text nodes, avoiding any
     * duplicates.
     */ return _a = {}, _a[Symbol.iterator] = function() {
        var currentNode = node;
        while(currentNode && util_1.Guard.isTextNode(currentNode._previousSibling)){
            currentNode = currentNode._previousSibling;
        }
        return {
            next: function() {
                if (currentNode && !self && currentNode === node) {
                    if (util_1.Guard.isTextNode(currentNode._nextSibling)) {
                        currentNode = currentNode._nextSibling;
                    } else {
                        currentNode = null;
                    }
                }
                if (currentNode === null) {
                    return {
                        done: true,
                        value: null
                    };
                } else {
                    var result = {
                        done: false,
                        value: currentNode
                    };
                    if (util_1.Guard.isTextNode(currentNode._nextSibling)) {
                        currentNode = currentNode._nextSibling;
                    } else {
                        currentNode = null;
                    }
                    return result;
                }
            }
        };
    }, _a;
}
exports.text_contiguousTextNodes = text_contiguousTextNodes;
/**
 * Returns node with its adjacent text node siblings.
 *
 * @param node - a node
 * @param self - whether to include node itself
 */ function text_contiguousExclusiveTextNodes(node, self) {
    var _a;
    if (self === void 0) {
        self = false;
    }
    /**
     * The contiguous exclusive Text nodes of a node node are node, node’s
     * previous sibling exclusive Text node, if any, and its contiguous
     * exclusive Text nodes, and node’s next sibling exclusive Text node,
     * if any, and its contiguous exclusive Text nodes, avoiding any duplicates.
     */ return _a = {}, _a[Symbol.iterator] = function() {
        var currentNode = node;
        while(currentNode && util_1.Guard.isExclusiveTextNode(currentNode._previousSibling)){
            currentNode = currentNode._previousSibling;
        }
        return {
            next: function() {
                if (currentNode && !self && currentNode === node) {
                    if (util_1.Guard.isExclusiveTextNode(currentNode._nextSibling)) {
                        currentNode = currentNode._nextSibling;
                    } else {
                        currentNode = null;
                    }
                }
                if (currentNode === null) {
                    return {
                        done: true,
                        value: null
                    };
                } else {
                    var result = {
                        done: false,
                        value: currentNode
                    };
                    if (util_1.Guard.isExclusiveTextNode(currentNode._nextSibling)) {
                        currentNode = currentNode._nextSibling;
                    } else {
                        currentNode = null;
                    }
                    return result;
                }
            }
        };
    }, _a;
}
exports.text_contiguousExclusiveTextNodes = text_contiguousExclusiveTextNodes;
/**
 * Returns the concatenation of the data of all the Text node descendants of
 * node, in tree order.
 *
 * @param node - a node
 */ function text_descendantTextContent(node) {
    /**
     * The descendant text content of a node node is the concatenation of the
     * data of all the Text node descendants of node, in tree order.
     */ var contents = "";
    var text = TreeAlgorithm_1.tree_getFirstDescendantNode(node, false, false, function(e) {
        return util_1.Guard.isTextNode(e);
    });
    while(text !== null){
        contents += text._data;
        text = TreeAlgorithm_1.tree_getNextDescendantNode(node, text, false, false, function(e) {
            return util_1.Guard.isTextNode(e);
        });
    }
    return contents;
}
exports.text_descendantTextContent = text_descendantTextContent;
/**
 * Splits data at the given offset and returns the remainder as a text
 * node.
 *
 * @param node - a text node
 * @param offset - the offset at which to split the nodes.
 */ function text_split(node, offset) {
    var e_1, _a;
    /**
     * 1. Let length be node’s length.
     * 2. If offset is greater than length, then throw an "IndexSizeError"
     * DOMException.
     */ var length = node._data.length;
    if (offset > length) {
        throw new DOMException_1.IndexSizeError();
    }
    /**
     * 3. Let count be length minus offset.
     * 4. Let new data be the result of substringing data with node node,
     * offset offset, and count count.
     * 5. Let new node be a new Text node, with the same node document as node.
     * Set new node’s data to new data.
     * 6. Let parent be node’s parent.
     * 7. If parent is not null, then:
     */ var count = length - offset;
    var newData = CharacterDataAlgorithm_1.characterData_substringData(node, offset, count);
    var newNode = CreateAlgorithm_1.create_text(node._nodeDocument, newData);
    var parent = node._parent;
    if (parent !== null) {
        /**
         * 7.1. Insert new node into parent before node’s next sibling.
         */ MutationAlgorithm_1.mutation_insert(newNode, parent, node._nextSibling);
        try {
            /**
             * 7.2. For each live range whose start node is node and start offset is
             * greater than offset, set its start node to new node and decrease its
             * start offset by offset.
             * 7.3. For each live range whose end node is node and end offset is greater
             * than offset, set its end node to new node and decrease its end offset
             * by offset.
             * 7.4. For each live range whose start node is parent and start offset is
             * equal to the index of node plus 1, increase its start offset by 1.
             * 7.5. For each live range whose end node is parent and end offset is equal
             * to the index of node plus 1, increase its end offset by 1.
             */ for(var _b = __values(DOMImpl_1.dom.rangeList), _c = _b.next(); !_c.done; _c = _b.next()){
                var range = _c.value;
                if (range._start[0] === node && range._start[1] > offset) {
                    range._start[0] = newNode;
                    range._start[1] -= offset;
                }
                if (range._end[0] === node && range._end[1] > offset) {
                    range._end[0] = newNode;
                    range._end[1] -= offset;
                }
                var index = TreeAlgorithm_1.tree_index(node);
                if (range._start[0] === parent && range._start[1] === index + 1) {
                    range._start[1]++;
                }
                if (range._end[0] === parent && range._end[1] === index + 1) {
                    range._end[1]++;
                }
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
    }
    /**
     * 8. Replace data with node node, offset offset, count count, and data
     * the empty string.
     * 9. Return new node.
     */ CharacterDataAlgorithm_1.characterData_replaceData(node, offset, count, "");
    return newNode;
}
exports.text_split = text_split; //# sourceMappingURL=TextAlgorithm.js.map


/***/ }),

/***/ 24991:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
var DOMException_1 = __webpack_require__(28905);
/**
 * Applies the filter to the given node and returns the result.
 *
 * @param traverser - the `NodeIterator` or `TreeWalker` instance
 * @param node - the node to filter
 */ function traversal_filter(traverser, node) {
    /**
     * 1. If traverser’s active flag is set, then throw an "InvalidStateError"
     * DOMException.
     */ if (traverser._activeFlag) {
        throw new DOMException_1.InvalidStateError();
    }
    /**
     * 2. Let n be node’s nodeType attribute value − 1.
     */ var n = node._nodeType - 1;
    /**
     * 3. If the nth bit (where 0 is the least significant bit) of traverser’s
     * whatToShow is not set, then return FILTER_SKIP.
     */ var mask = 1 << n;
    if ((traverser.whatToShow & mask) === 0) {
        return interfaces_1.FilterResult.Skip;
    }
    /**
     * 4. If traverser’s filter is null, then return FILTER_ACCEPT.
     */ if (!traverser.filter) {
        return interfaces_1.FilterResult.Accept;
    }
    /**
     * 5. Set traverser’s active flag.
     */ traverser._activeFlag = true;
    /**
     * 6. Let result be the return value of call a user object’s operation with
     * traverser’s filter, "acceptNode", and « node ». If this throws an
     * exception, then unset traverser’s active flag and rethrow the exception.
     */ var result = interfaces_1.FilterResult.Reject;
    try {
        result = traverser.filter.acceptNode(node);
    } catch (err) {
        traverser._activeFlag = false;
        throw err;
    }
    /**
     * 7. Unset traverser’s active flag.
     * 8. Return result.
     */ traverser._activeFlag = false;
    return result;
}
exports.traversal_filter = traversal_filter; //# sourceMappingURL=TraversalAlgorithm.js.map


/***/ }),

/***/ 59614:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(57294);
var interfaces_1 = __webpack_require__(52580);
/**
 * Gets the next descendant of the given node of the tree rooted at `root`
 * in depth-first pre-order.
 *
 * @param root - root node of the tree
 * @param node - a node
 * @param shadow - whether to visit shadow tree nodes
 */ function _getNextDescendantNode(root, node, shadow) {
    if (shadow === void 0) {
        shadow = false;
    }
    // traverse shadow tree
    if (shadow && util_1.Guard.isElementNode(node) && util_1.Guard.isShadowRoot(node.shadowRoot)) {
        if (node.shadowRoot._firstChild) return node.shadowRoot._firstChild;
    }
    // traverse child nodes
    if (node._firstChild) return node._firstChild;
    if (node === root) return null;
    // traverse siblings
    if (node._nextSibling) return node._nextSibling;
    // traverse parent's next sibling
    var parent = node._parent;
    while(parent && parent !== root){
        if (parent._nextSibling) return parent._nextSibling;
        parent = parent._parent;
    }
    return null;
}
function _emptyIterator() {
    var _a;
    return _a = {}, _a[Symbol.iterator] = function() {
        return {
            next: function() {
                return {
                    done: true,
                    value: null
                };
            }
        };
    }, _a;
}
/**
 * Returns the first descendant node of the tree rooted at `node` in
 * depth-first pre-order.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param shadow - whether to visit shadow tree nodes
 * @param filter - a function to filter nodes
 */ function tree_getFirstDescendantNode(node, self, shadow, filter) {
    if (self === void 0) {
        self = false;
    }
    if (shadow === void 0) {
        shadow = false;
    }
    var firstNode = self ? node : _getNextDescendantNode(node, node, shadow);
    while(firstNode && filter && !filter(firstNode)){
        firstNode = _getNextDescendantNode(node, firstNode, shadow);
    }
    return firstNode;
}
exports.tree_getFirstDescendantNode = tree_getFirstDescendantNode;
/**
 * Returns the next descendant node of the tree rooted at `node` in
 * depth-first pre-order.
 *
 * @param node - root node of the tree
 * @param currentNode - current descendant node
 * @param self - whether to include `node` in traversal
 * @param shadow - whether to visit shadow tree nodes
 * @param filter - a function to filter nodes
 */ function tree_getNextDescendantNode(node, currentNode, self, shadow, filter) {
    if (self === void 0) {
        self = false;
    }
    if (shadow === void 0) {
        shadow = false;
    }
    var nextNode = _getNextDescendantNode(node, currentNode, shadow);
    while(nextNode && filter && !filter(nextNode)){
        nextNode = _getNextDescendantNode(node, nextNode, shadow);
    }
    return nextNode;
}
exports.tree_getNextDescendantNode = tree_getNextDescendantNode;
/**
 * Traverses through all descendant nodes of the tree rooted at
 * `node` in depth-first pre-order.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param shadow - whether to visit shadow tree nodes
 * @param filter - a function to filter nodes
 */ function tree_getDescendantNodes(node, self, shadow, filter) {
    var _a;
    if (self === void 0) {
        self = false;
    }
    if (shadow === void 0) {
        shadow = false;
    }
    if (!self && node._children.size === 0) {
        return _emptyIterator();
    }
    return _a = {}, _a[Symbol.iterator] = function() {
        var currentNode = self ? node : _getNextDescendantNode(node, node, shadow);
        return {
            next: function() {
                while(currentNode && filter && !filter(currentNode)){
                    currentNode = _getNextDescendantNode(node, currentNode, shadow);
                }
                if (currentNode === null) {
                    return {
                        done: true,
                        value: null
                    };
                } else {
                    var result = {
                        done: false,
                        value: currentNode
                    };
                    currentNode = _getNextDescendantNode(node, currentNode, shadow);
                    return result;
                }
            }
        };
    }, _a;
}
exports.tree_getDescendantNodes = tree_getDescendantNodes;
/**
 * Traverses through all descendant element nodes of the tree rooted at
 * `node` in depth-first preorder.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param shadow - whether to visit shadow tree nodes
 * @param filter - a function to filter nodes
 */ function tree_getDescendantElements(node, self, shadow, filter) {
    var _a;
    if (self === void 0) {
        self = false;
    }
    if (shadow === void 0) {
        shadow = false;
    }
    if (!self && node._children.size === 0) {
        return _emptyIterator();
    }
    return _a = {}, _a[Symbol.iterator] = function() {
        var it = tree_getDescendantNodes(node, self, shadow, function(e) {
            return util_1.Guard.isElementNode(e);
        })[Symbol.iterator]();
        var currentNode = it.next().value;
        return {
            next: function() {
                while(currentNode && filter && !filter(currentNode)){
                    currentNode = it.next().value;
                }
                if (currentNode === null) {
                    return {
                        done: true,
                        value: null
                    };
                } else {
                    var result = {
                        done: false,
                        value: currentNode
                    };
                    currentNode = it.next().value;
                    return result;
                }
            }
        };
    }, _a;
}
exports.tree_getDescendantElements = tree_getDescendantElements;
/**
 * Traverses through all sibling nodes of `node`.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param filter - a function to filter nodes
 */ function tree_getSiblingNodes(node, self, filter) {
    var _a;
    if (self === void 0) {
        self = false;
    }
    if (!node._parent || node._parent._children.size === 0) {
        return _emptyIterator();
    }
    return _a = {}, _a[Symbol.iterator] = function() {
        var currentNode = node._parent ? node._parent._firstChild : null;
        return {
            next: function() {
                while(currentNode && (filter && !filter(currentNode) || !self && currentNode === node)){
                    currentNode = currentNode._nextSibling;
                }
                if (currentNode === null) {
                    return {
                        done: true,
                        value: null
                    };
                } else {
                    var result = {
                        done: false,
                        value: currentNode
                    };
                    currentNode = currentNode._nextSibling;
                    return result;
                }
            }
        };
    }, _a;
}
exports.tree_getSiblingNodes = tree_getSiblingNodes;
/**
 * Gets the first ancestor of `node` in reverse tree order.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param filter - a function to filter nodes
 */ function tree_getFirstAncestorNode(node, self, filter) {
    if (self === void 0) {
        self = false;
    }
    var firstNode = self ? node : node._parent;
    while(firstNode && filter && !filter(firstNode)){
        firstNode = firstNode._parent;
    }
    return firstNode;
}
exports.tree_getFirstAncestorNode = tree_getFirstAncestorNode;
/**
 * Gets the first ancestor of `node` in reverse tree order.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param filter - a function to filter nodes
 */ function tree_getNextAncestorNode(node, currentNode, self, filter) {
    if (self === void 0) {
        self = false;
    }
    var nextNode = currentNode._parent;
    while(nextNode && filter && !filter(nextNode)){
        nextNode = nextNode._parent;
    }
    return nextNode;
}
exports.tree_getNextAncestorNode = tree_getNextAncestorNode;
/**
 * Traverses through all ancestor nodes `node` in reverse tree order.
 *
 * @param node - root node of the tree
 * @param self - whether to include `node` in traversal
 * @param filter - a function to filter nodes
 */ function tree_getAncestorNodes(node, self, filter) {
    var _a;
    if (self === void 0) {
        self = false;
    }
    if (!self && !node._parent) {
        return _emptyIterator();
    }
    return _a = {}, _a[Symbol.iterator] = function() {
        var currentNode = tree_getFirstAncestorNode(node, self, filter);
        return {
            next: function() {
                if (currentNode === null) {
                    return {
                        done: true,
                        value: null
                    };
                } else {
                    var result = {
                        done: false,
                        value: currentNode
                    };
                    currentNode = tree_getNextAncestorNode(node, currentNode, self, filter);
                    return result;
                }
            }
        };
    }, _a;
}
exports.tree_getAncestorNodes = tree_getAncestorNodes;
/**
 * Returns the common ancestor of the given nodes.
 *
 * @param nodeA - a node
 * @param nodeB - a node
 */ function tree_getCommonAncestor(nodeA, nodeB) {
    if (nodeA === nodeB) {
        return nodeA._parent;
    }
    // lists of parent nodes
    var parentsA = [];
    var parentsB = [];
    var pA = tree_getFirstAncestorNode(nodeA, true);
    while(pA !== null){
        parentsA.push(pA);
        pA = tree_getNextAncestorNode(nodeA, pA, true);
    }
    var pB = tree_getFirstAncestorNode(nodeB, true);
    while(pB !== null){
        parentsB.push(pB);
        pB = tree_getNextAncestorNode(nodeB, pB, true);
    }
    // walk through parents backwards until they differ
    var pos1 = parentsA.length;
    var pos2 = parentsB.length;
    var parent = null;
    for(var i = Math.min(pos1, pos2); i > 0; i--){
        var parent1 = parentsA[--pos1];
        var parent2 = parentsB[--pos2];
        if (parent1 !== parent2) {
            break;
        }
        parent = parent1;
    }
    return parent;
}
exports.tree_getCommonAncestor = tree_getCommonAncestor;
/**
 * Returns the node following `node` in depth-first preorder.
 *
 * @param root - root of the subtree
 * @param node - a node
 */ function tree_getFollowingNode(root, node) {
    if (node._firstChild) {
        return node._firstChild;
    } else if (node._nextSibling) {
        return node._nextSibling;
    } else {
        while(true){
            var parent = node._parent;
            if (parent === null || parent === root) {
                return null;
            } else if (parent._nextSibling) {
                return parent._nextSibling;
            } else {
                node = parent;
            }
        }
    }
}
exports.tree_getFollowingNode = tree_getFollowingNode;
/**
 * Returns the node preceding `node` in depth-first preorder.
 *
 * @param root - root of the subtree
 * @param node - a node
 */ function tree_getPrecedingNode(root, node) {
    if (node === root) {
        return null;
    }
    if (node._previousSibling) {
        node = node._previousSibling;
        if (node._lastChild) {
            return node._lastChild;
        } else {
            return node;
        }
    } else {
        return node._parent;
    }
}
exports.tree_getPrecedingNode = tree_getPrecedingNode;
/**
 * Determines if the node tree is constrained. A node tree is
 * constrained as follows, expressed as a relationship between the
 * type of node and its allowed children:
 *  - Document (In tree order)
 *    * Zero or more nodes each of which is ProcessingInstruction
 *      or Comment.
 *    * Optionally one DocumentType node.
 *    * Zero or more nodes each of which is ProcessingInstruction
 *      or Comment.
 *    * Optionally one Element node.
 *    * Zero or more nodes each of which is ProcessingInstruction
 *      or Comment.
 *  - DocumentFragment, Element
 *    * Zero or more nodes each of which is Element, Text,
 *      ProcessingInstruction, or Comment.
 *  - DocumentType, Text, ProcessingInstruction, Comment
 *    * None.
 *
 * @param node - the root of the tree
 */ function tree_isConstrained(node) {
    var e_1, _a, e_2, _b, e_3, _c;
    switch(node._nodeType){
        case interfaces_1.NodeType.Document:
            var hasDocType = false;
            var hasElement = false;
            try {
                for(var _d = __values(node._children), _e = _d.next(); !_e.done; _e = _d.next()){
                    var childNode = _e.value;
                    switch(childNode._nodeType){
                        case interfaces_1.NodeType.ProcessingInstruction:
                        case interfaces_1.NodeType.Comment:
                            break;
                        case interfaces_1.NodeType.DocumentType:
                            if (hasDocType || hasElement) return false;
                            hasDocType = true;
                            break;
                        case interfaces_1.NodeType.Element:
                            if (hasElement) return false;
                            hasElement = true;
                            break;
                        default:
                            return false;
                    }
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            break;
        case interfaces_1.NodeType.DocumentFragment:
        case interfaces_1.NodeType.Element:
            try {
                for(var _f = __values(node._children), _g = _f.next(); !_g.done; _g = _f.next()){
                    var childNode = _g.value;
                    switch(childNode._nodeType){
                        case interfaces_1.NodeType.Element:
                        case interfaces_1.NodeType.Text:
                        case interfaces_1.NodeType.ProcessingInstruction:
                        case interfaces_1.NodeType.CData:
                        case interfaces_1.NodeType.Comment:
                            break;
                        default:
                            return false;
                    }
                }
            } catch (e_2_1) {
                e_2 = {
                    error: e_2_1
                };
            } finally{
                try {
                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                } finally{
                    if (e_2) throw e_2.error;
                }
            }
            break;
        case interfaces_1.NodeType.DocumentType:
        case interfaces_1.NodeType.Text:
        case interfaces_1.NodeType.ProcessingInstruction:
        case interfaces_1.NodeType.CData:
        case interfaces_1.NodeType.Comment:
            return !node.hasChildNodes();
    }
    try {
        for(var _h = __values(node._children), _j = _h.next(); !_j.done; _j = _h.next()){
            var childNode = _j.value;
            // recursively check child nodes
            if (!tree_isConstrained(childNode)) return false;
        }
    } catch (e_3_1) {
        e_3 = {
            error: e_3_1
        };
    } finally{
        try {
            if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
        } finally{
            if (e_3) throw e_3.error;
        }
    }
    return true;
}
exports.tree_isConstrained = tree_isConstrained;
/**
 * Returns the length of a node.
 *
 * @param node - a node to check
 */ function tree_nodeLength(node) {
    /**
        * To determine the length of a node node, switch on node:
        * - DocumentType
        * Zero.
        * - Text
        * - ProcessingInstruction
        * - Comment
        * Its data’s length.
        * - Any other node
        * Its number of children.
        */ if (util_1.Guard.isDocumentTypeNode(node)) {
        return 0;
    } else if (util_1.Guard.isCharacterDataNode(node)) {
        return node._data.length;
    } else {
        return node._children.size;
    }
}
exports.tree_nodeLength = tree_nodeLength;
/**
 * Determines if a node is empty.
 *
 * @param node - a node to check
 */ function tree_isEmpty(node) {
    /**
        * A node is considered empty if its length is zero.
        */ return tree_nodeLength(node) === 0;
}
exports.tree_isEmpty = tree_isEmpty;
/**
 * Returns the root node of a tree. The root of an object is itself,
 * if its parent is `null`, or else it is the root of its parent.
 * The root of a tree is any object participating in that tree
 * whose parent is `null`.
 *
 * @param node - a node of the tree
 * @param shadow - `true` to return shadow-including root, otherwise
 * `false`
 */ function tree_rootNode(node, shadow) {
    if (shadow === void 0) {
        shadow = false;
    }
    /**
        * The root of an object is itself, if its parent is null, or else it is the
        * root of its parent. The root of a tree is any object participating in
        * that tree whose parent is null.
        */ if (shadow) {
        var root = tree_rootNode(node, false);
        if (util_1.Guard.isShadowRoot(root)) return tree_rootNode(root._host, true);
        else return root;
    } else {
        if (!node._parent) return node;
        else return tree_rootNode(node._parent);
    }
}
exports.tree_rootNode = tree_rootNode;
/**
 * Determines whether `other` is a descendant of `node`. An object
 * A is called a descendant of an object B, if either A is a child
 * of B or A is a child of an object C that is a descendant of B.
 *
 * @param node - a node
 * @param other - the node to check
 * @param self - if `true`, traversal includes `node` itself
 * @param shadow - if `true`, traversal includes the
 * node's and its descendant's shadow trees as well.
 */ function tree_isDescendantOf(node, other, self, shadow) {
    if (self === void 0) {
        self = false;
    }
    if (shadow === void 0) {
        shadow = false;
    }
    /**
        * An object A is called a descendant of an object B, if either A is a
        * child of B or A is a child of an object C that is a descendant of B.
        *
        * An inclusive descendant is an object or one of its descendants.
    */ var child = tree_getFirstDescendantNode(node, self, shadow);
    while(child !== null){
        if (child === other) {
            return true;
        }
        child = tree_getNextDescendantNode(node, child, self, shadow);
    }
    return false;
}
exports.tree_isDescendantOf = tree_isDescendantOf;
/**
 * Determines whether `other` is an ancestor of `node`. An object A
 * is called an ancestor of an object B if and only if B is a
 * descendant of A.
 *
 * @param node - a node
 * @param other - the node to check
 * @param self - if `true`, traversal includes `node` itself
 * @param shadow - if `true`, traversal includes the
 * node's and its descendant's shadow trees as well.
 */ function tree_isAncestorOf(node, other, self, shadow) {
    if (self === void 0) {
        self = false;
    }
    if (shadow === void 0) {
        shadow = false;
    }
    var ancestor = self ? node : shadow && util_1.Guard.isShadowRoot(node) ? node._host : node._parent;
    while(ancestor !== null){
        if (ancestor === other) return true;
        ancestor = shadow && util_1.Guard.isShadowRoot(ancestor) ? ancestor._host : ancestor._parent;
    }
    return false;
}
exports.tree_isAncestorOf = tree_isAncestorOf;
/**
 * Determines whether `other` is a host-including ancestor of `node`. An
 * object A is a host-including inclusive ancestor of an object B, if either
 * A is an inclusive ancestor of B, or if B’s root has a non-null host and
 * A is a host-including inclusive ancestor of B’s root’s host.
 *
 * @param node - a node
 * @param other - the node to check
 * @param self - if `true`, traversal includes `node` itself
 */ function tree_isHostIncludingAncestorOf(node, other, self) {
    if (self === void 0) {
        self = false;
    }
    if (tree_isAncestorOf(node, other, self)) return true;
    var root = tree_rootNode(node);
    if (util_1.Guard.isDocumentFragmentNode(root) && root._host !== null && tree_isHostIncludingAncestorOf(root._host, other, self)) return true;
    return false;
}
exports.tree_isHostIncludingAncestorOf = tree_isHostIncludingAncestorOf;
/**
 * Determines whether `other` is a sibling of `node`. An object A is
 * called a sibling of an object B, if and only if B and A share
 * the same non-null parent.
 *
 * @param node - a node
 * @param other - the node to check
 * @param self - if `true`, traversal includes `node` itself
 */ function tree_isSiblingOf(node, other, self) {
    if (self === void 0) {
        self = false;
    }
    /**
        * An object A is called a sibling of an object B, if and only if B and A
        * share the same non-null parent.
        *
        * An inclusive sibling is an object or one of its siblings.
        */ if (node === other) {
        if (self) return true;
    } else {
        return node._parent !== null && node._parent === other._parent;
    }
    return false;
}
exports.tree_isSiblingOf = tree_isSiblingOf;
/**
 * Determines whether `other` is preceding `node`. An object A is
 * preceding an object B if A and B are in the same tree and A comes
 * before B in tree order.
 *
 * @param node - a node
 * @param other - the node to check
 */ function tree_isPreceding(node, other) {
    /**
        * An object A is preceding an object B if A and B are in the same tree and
        * A comes before B in tree order.
        */ var nodePos = tree_treePosition(node);
    var otherPos = tree_treePosition(other);
    if (nodePos === -1 || otherPos === -1) return false;
    else if (tree_rootNode(node) !== tree_rootNode(other)) return false;
    else return otherPos < nodePos;
}
exports.tree_isPreceding = tree_isPreceding;
/**
 * Determines whether `other` is following `node`. An object A is
 * following an object B if A and B are in the same tree and A comes
 * after B in tree order.
 *
 * @param node - a node
 * @param other - the node to check
 */ function tree_isFollowing(node, other) {
    /**
        * An object A is following an object B if A and B are in the same tree and
        * A comes after B in tree order.
        */ var nodePos = tree_treePosition(node);
    var otherPos = tree_treePosition(other);
    if (nodePos === -1 || otherPos === -1) return false;
    else if (tree_rootNode(node) !== tree_rootNode(other)) return false;
    else return otherPos > nodePos;
}
exports.tree_isFollowing = tree_isFollowing;
/**
 * Determines whether `other` is the parent node of `node`.
 *
 * @param node - a node
 * @param other - the node to check
 */ function tree_isParentOf(node, other) {
    /**
        * An object that participates in a tree has a parent, which is either
        * null or an object, and has children, which is an ordered set of objects.
        * An object A whose parent is object B is a child of B.
        */ return node._parent === other;
}
exports.tree_isParentOf = tree_isParentOf;
/**
 * Determines whether `other` is a child node of `node`.
 *
 * @param node - a node
 * @param other - the node to check
 */ function tree_isChildOf(node, other) {
    /**
        * An object that participates in a tree has a parent, which is either
        * null or an object, and has children, which is an ordered set of objects.
        * An object A whose parent is object B is a child of B.
        */ return other._parent === node;
}
exports.tree_isChildOf = tree_isChildOf;
/**
 * Returns the previous sibling node of `node` or null if it has no
 * preceding sibling.
 *
 * @param node
 */ function tree_previousSibling(node) {
    /**
        * The previous sibling of an object is its first preceding sibling or null
        * if it has no preceding sibling.
        */ return node._previousSibling;
}
exports.tree_previousSibling = tree_previousSibling;
/**
 * Returns the next sibling node of `node` or null if it has no
 * following sibling.
 *
 * @param node
 */ function tree_nextSibling(node) {
    /**
        * The next sibling of an object is its first following sibling or null
        * if it has no following sibling.
        */ return node._nextSibling;
}
exports.tree_nextSibling = tree_nextSibling;
/**
 * Returns the first child node of `node` or null if it has no
 * children.
 *
 * @param node
 */ function tree_firstChild(node) {
    /**
        * The first child of an object is its first child or null if it has no
        * children.
        */ return node._firstChild;
}
exports.tree_firstChild = tree_firstChild;
/**
 * Returns the last child node of `node` or null if it has no
 * children.
 *
 * @param node
 */ function tree_lastChild(node) {
    /**
        * The last child of an object is its last child or null if it has no
        * children.
        */ return node._lastChild;
}
exports.tree_lastChild = tree_lastChild;
/**
 * Returns the zero-based index of `node` when counted preorder in
 * the tree rooted at `root`. Returns `-1` if `node` is not in
 * the tree.
 *
 * @param node - the node to get the index of
 */ function tree_treePosition(node) {
    var root = tree_rootNode(node);
    var pos = 0;
    var childNode = tree_getFirstDescendantNode(root);
    while(childNode !== null){
        pos++;
        if (childNode === node) return pos;
        childNode = tree_getNextDescendantNode(root, childNode);
    }
    return -1;
}
exports.tree_treePosition = tree_treePosition;
/**
 * Determines the index of `node`. The index of an object is its number of
 * preceding siblings, or 0 if it has none.
 *
 * @param node - a node
 * @param other - the node to check
 */ function tree_index(node) {
    /**
        * The index of an object is its number of preceding siblings, or 0 if it
        * has none.
        */ var n = 0;
    while(node._previousSibling !== null){
        n++;
        node = node._previousSibling;
    }
    return n;
}
exports.tree_index = tree_index;
/**
 * Retargets an object against another object.
 *
 * @param a - an object to retarget
 * @param b - an object to retarget against
 */ function tree_retarget(a, b) {
    /**
        * To retarget an object A against an object B, repeat these steps until
        * they return an object:
        * 1. If one of the following is true
        * - A is not a node
        * - A's root is not a shadow root
        * - B is a node and A's root is a shadow-including inclusive ancestor
        * of B
        * then return A.
        * 2. Set A to A's root's host.
        */ while(true){
        if (!a || !util_1.Guard.isNode(a)) {
            return a;
        }
        var rootOfA = tree_rootNode(a);
        if (!util_1.Guard.isShadowRoot(rootOfA)) {
            return a;
        }
        if (b && util_1.Guard.isNode(b) && tree_isAncestorOf(rootOfA, b, true, true)) {
            return a;
        }
        a = rootOfA.host;
    }
}
exports.tree_retarget = tree_retarget; //# sourceMappingURL=TreeAlgorithm.js.map


/***/ }),

/***/ 46361:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
var TraversalAlgorithm_1 = __webpack_require__(24991);
/**
 * Returns the first or last child node, or `null` if there are none.
 *
 * @param walker - the `TreeWalker` instance
 * @param first - `true` to return the first child node, or `false` to
 * return the last child node.
 */ function treeWalker_traverseChildren(walker, first) {
    /**
     * 1. Let node be walker’s current.
     * 2. Set node to node’s first child if type is first, and node’s last child
     * if type is last.
     * 3. While node is non-null:
     */ var node = first ? walker._current._firstChild : walker._current._lastChild;
    while(node !== null){
        /**
         * 3.1. Let result be the result of filtering node within walker.
         */ var result = TraversalAlgorithm_1.traversal_filter(walker, node);
        if (result === interfaces_1.FilterResult.Accept) {
            /**
             * 3.2. If result is FILTER_ACCEPT, then set walker’s current to node and
             * return node.
             */ walker._current = node;
            return node;
        } else if (result === interfaces_1.FilterResult.Skip) {
            /**
             * 3.3. If result is FILTER_SKIP, then:
             * 3.3.1. Let child be node’s first child if type is first, and node’s
             * last child if type is last.
             * 3.3.2. If child is non-null, then set node to child and continue.
             */ var child = first ? node._firstChild : node._lastChild;
            if (child !== null) {
                node = child;
                continue;
            }
        }
        /**
         * 3.4. While node is non-null:
         */ while(node !== null){
            /**
             * 3.4.1. Let sibling be node’s next sibling if type is first, and
             * node’s previous sibling if type is last.
             * 3.4.2. If sibling is non-null, then set node to sibling and break.
             */ var sibling = first ? node._nextSibling : node._previousSibling;
            if (sibling !== null) {
                node = sibling;
                break;
            }
            /**
             * 3.4.3. Let parent be node’s parent.
             * 3.4.4. If parent is null, walker’s root, or walker’s current, then
             * return null.
             */ var parent = node._parent;
            if (parent === null || parent === walker._root || parent === walker._current) {
                return null;
            }
            /**
             * 3.4.5. Set node to parent.
             */ node = parent;
        }
    }
    /**
     * 5. Return null
     */ return null;
}
exports.treeWalker_traverseChildren = treeWalker_traverseChildren;
/**
 * Returns the next or previous sibling node, or `null` if there are none.
 *
 * @param walker - the `TreeWalker` instance
 * @param next - `true` to return the next sibling node, or `false` to
 * return the previous sibling node.
 */ function treeWalker_traverseSiblings(walker, next) {
    /**
     * 1. Let node be walker’s current.
     * 2. If node is root, then return null.
     * 3. While node is non-null:
     */ var node = walker._current;
    if (node === walker._root) return null;
    while(true){
        /**
         * 3.1. Let sibling be node’s next sibling if type is next, and node’s
         * previous sibling if type is previous.
         * 3.2. While sibling is non-null:
         */ var sibling = next ? node._nextSibling : node._previousSibling;
        while(sibling !== null){
            /**
             * 3.2.1. Set node to sibling.
             * 3.2.2. Let result be the result of filtering node within walker.
             * 3.2.3. If result is FILTER_ACCEPT, then set walker’s current to node
             * and return node.
             */ node = sibling;
            var result = TraversalAlgorithm_1.traversal_filter(walker, node);
            if (result === interfaces_1.FilterResult.Accept) {
                walker._current = node;
                return node;
            }
            /**
             * 3.2.4. Set sibling to node’s first child if type is next, and node’s
             * last child if type is previous.
             * 3.2.5. If result is FILTER_REJECT or sibling is null, then set
             * sibling to node’s next sibling if type is next, and node’s previous
             * sibling if type is previous.
             */ sibling = next ? node._firstChild : node._lastChild;
            if (result === interfaces_1.FilterResult.Reject || sibling === null) {
                sibling = next ? node._nextSibling : node._previousSibling;
            }
        }
        /**
         * 3.3. Set node to node’s parent.
         * 3.4. If node is null or walker’s root, then return null.
         */ node = node._parent;
        if (node === null || node === walker._root) {
            return null;
        }
        /**
         * 3.5. If the return value of filtering node within walker is FILTER_ACCEPT,
         * then return null.
         */ if (TraversalAlgorithm_1.traversal_filter(walker, node) === interfaces_1.FilterResult.Accept) {
            return null;
        }
    }
}
exports.treeWalker_traverseSiblings = treeWalker_traverseSiblings; //# sourceMappingURL=TreeWalkerAlgorithm.js.map


/***/ }),

/***/ 52510:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Defines a WebIDL `Const` property on the given object.
 *
 * @param o - object on which to add the property
 * @param name - property name
 * @param value - property value
 */ function idl_defineConst(o, name, value) {
    Object.defineProperty(o, name, {
        writable: false,
        enumerable: true,
        configurable: false,
        value: value
    });
}
exports.idl_defineConst = idl_defineConst; //# sourceMappingURL=WebIDLAlgorithm.js.map


/***/ }),

/***/ 12356:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Determines if the given string is valid for a `"Name"` construct.
 *
 * @param name - name string to test
 */ function xml_isName(name) {
    for(var i = 0; i < name.length; i++){
        var n = name.charCodeAt(i);
        // NameStartChar
        if (n >= 97 && n <= 122 || // [a-z]
        n >= 65 && n <= 90 || // [A-Z]
        n === 58 || n === 95 || // ':' or '_'
        n >= 0xC0 && n <= 0xD6 || n >= 0xD8 && n <= 0xF6 || n >= 0xF8 && n <= 0x2FF || n >= 0x370 && n <= 0x37D || n >= 0x37F && n <= 0x1FFF || n >= 0x200C && n <= 0x200D || n >= 0x2070 && n <= 0x218F || n >= 0x2C00 && n <= 0x2FEF || n >= 0x3001 && n <= 0xD7FF || n >= 0xF900 && n <= 0xFDCF || n >= 0xFDF0 && n <= 0xFFFD) {
            continue;
        } else if (i !== 0 && (n === 45 || n === 46 || // '-' or '.'
        n >= 48 && n <= 57 || // [0-9]
        n === 0xB7 || n >= 0x0300 && n <= 0x036F || n >= 0x203F && n <= 0x2040)) {
            continue;
        }
        if (n >= 0xD800 && n <= 0xDBFF && i < name.length - 1) {
            var n2 = name.charCodeAt(i + 1);
            if (n2 >= 0xDC00 && n2 <= 0xDFFF) {
                n = (n - 0xD800) * 0x400 + n2 - 0xDC00 + 0x10000;
                i++;
                if (n >= 0x10000 && n <= 0xEFFFF) {
                    continue;
                }
            }
        }
        return false;
    }
    return true;
}
exports.xml_isName = xml_isName;
/**
 * Determines if the given string is valid for a `"QName"` construct.
 *
 * @param name - name string to test
 */ function xml_isQName(name) {
    var colonFound = false;
    for(var i = 0; i < name.length; i++){
        var n = name.charCodeAt(i);
        // NameStartChar
        if (n >= 97 && n <= 122 || // [a-z]
        n >= 65 && n <= 90 || // [A-Z]
        n === 95 || // '_'
        n >= 0xC0 && n <= 0xD6 || n >= 0xD8 && n <= 0xF6 || n >= 0xF8 && n <= 0x2FF || n >= 0x370 && n <= 0x37D || n >= 0x37F && n <= 0x1FFF || n >= 0x200C && n <= 0x200D || n >= 0x2070 && n <= 0x218F || n >= 0x2C00 && n <= 0x2FEF || n >= 0x3001 && n <= 0xD7FF || n >= 0xF900 && n <= 0xFDCF || n >= 0xFDF0 && n <= 0xFFFD) {
            continue;
        } else if (i !== 0 && (n === 45 || n === 46 || // '-' or '.'
        n >= 48 && n <= 57 || // [0-9]
        n === 0xB7 || n >= 0x0300 && n <= 0x036F || n >= 0x203F && n <= 0x2040)) {
            continue;
        } else if (i !== 0 && n === 58) {
            if (colonFound) return false; // multiple colons in qname
            if (i === name.length - 1) return false; // colon at the end of qname
            colonFound = true;
            continue;
        }
        if (n >= 0xD800 && n <= 0xDBFF && i < name.length - 1) {
            var n2 = name.charCodeAt(i + 1);
            if (n2 >= 0xDC00 && n2 <= 0xDFFF) {
                n = (n - 0xD800) * 0x400 + n2 - 0xDC00 + 0x10000;
                i++;
                if (n >= 0x10000 && n <= 0xEFFFF) {
                    continue;
                }
            }
        }
        return false;
    }
    return true;
}
exports.xml_isQName = xml_isQName;
/**
 * Determines if the given string contains legal characters.
 *
 * @param chars - sequence of characters to test
 */ function xml_isLegalChar(chars) {
    for(var i = 0; i < chars.length; i++){
        var n = chars.charCodeAt(i);
        // #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
        if (n === 0x9 || n === 0xA || n === 0xD || n >= 0x20 && n <= 0xD7FF || n >= 0xE000 && n <= 0xFFFD) {
            continue;
        }
        if (n >= 0xD800 && n <= 0xDBFF && i < chars.length - 1) {
            var n2 = chars.charCodeAt(i + 1);
            if (n2 >= 0xDC00 && n2 <= 0xDFFF) {
                n = (n - 0xD800) * 0x400 + n2 - 0xDC00 + 0x10000;
                i++;
                if (n >= 0x10000 && n <= 0x10FFFF) {
                    continue;
                }
            }
        }
        return false;
    }
    return true;
}
exports.xml_isLegalChar = xml_isLegalChar;
/**
 * Determines if the given string contains legal characters for a public
 * identifier.
 *
 * @param chars - sequence of characters to test
 */ function xml_isPubidChar(chars) {
    for(var i = 0; i < chars.length; i++){
        // PubId chars are all in the ASCII range, no need to check surrogates
        var n = chars.charCodeAt(i);
        // #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]
        if (n >= 97 && n <= 122 || // [a-z]
        n >= 65 && n <= 90 || // [A-Z]
        n >= 39 && n <= 59 || // ['()*+,-./] | [0-9] | [:;]
        n === 0x20 || n === 0xD || n === 0xA || // #x20 | #xD | #xA
        n >= 35 && n <= 37 || // [#$%]
        n === 33 || // !
        n === 61 || n === 63 || n === 64 || n === 95) {
            continue;
        } else {
            return false;
        }
    }
    return true;
}
exports.xml_isPubidChar = xml_isPubidChar; //# sourceMappingURL=XMLAlgorithm.js.map


/***/ }),

/***/ 75306:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


function __export(m) {
    for(var p in m)if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
__export(__webpack_require__(59259));
__export(__webpack_require__(26092));
__export(__webpack_require__(35822));
__export(__webpack_require__(77901));
__export(__webpack_require__(21701));
__export(__webpack_require__(3381));
__export(__webpack_require__(81424));
__export(__webpack_require__(24473));
__export(__webpack_require__(87595));
__export(__webpack_require__(60077));
__export(__webpack_require__(12467));
__export(__webpack_require__(49221));
__export(__webpack_require__(31400));
__export(__webpack_require__(5742));
__export(__webpack_require__(47277));
__export(__webpack_require__(84056));
__export(__webpack_require__(82572));
__export(__webpack_require__(26072));
__export(__webpack_require__(62598));
__export(__webpack_require__(20031));
__export(__webpack_require__(33740));
__export(__webpack_require__(49576));
__export(__webpack_require__(712));
__export(__webpack_require__(24991));
__export(__webpack_require__(59614));
__export(__webpack_require__(46361));
__export(__webpack_require__(52510));
__export(__webpack_require__(12356)); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 64603:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var algorithm_1 = __webpack_require__(75306);
/**
 * Represents a controller that allows to abort DOM requests.
 */ var AbortControllerImpl = /** @class */ function() {
    /**
     * Initializes a new instance of `AbortController`.
     */ function AbortControllerImpl() {
        /**
         * 1. Let signal be a new AbortSignal object.
         * 2. Let controller be a new AbortController object whose signal is signal.
         * 3. Return controller.
         */ this._signal = algorithm_1.create_abortSignal();
    }
    Object.defineProperty(AbortControllerImpl.prototype, "signal", {
        /** @inheritdoc */ get: function() {
            return this._signal;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ AbortControllerImpl.prototype.abort = function() {
        algorithm_1.abort_signalAbort(this._signal);
    };
    return AbortControllerImpl;
}();
exports.AbortControllerImpl = AbortControllerImpl; //# sourceMappingURL=AbortControllerImpl.js.map


/***/ }),

/***/ 77719:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var EventTargetImpl_1 = __webpack_require__(73410);
var algorithm_1 = __webpack_require__(75306);
/**
 * Represents a signal object that communicates with a DOM request and abort
 * it through an AbortController.
 */ var AbortSignalImpl = /** @class */ function(_super) {
    __extends(AbortSignalImpl, _super);
    /**
     * Initializes a new instance of `AbortSignal`.
     */ function AbortSignalImpl() {
        var _this = _super.call(this) || this;
        _this._abortedFlag = false;
        _this._abortAlgorithms = new Set();
        return _this;
    }
    Object.defineProperty(AbortSignalImpl.prototype, "aborted", {
        /** @inheritdoc */ get: function() {
            return this._abortedFlag;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbortSignalImpl.prototype, "onabort", {
        /** @inheritdoc */ get: function() {
            return algorithm_1.event_getterEventHandlerIDLAttribute(this, "onabort");
        },
        set: function(val) {
            algorithm_1.event_setterEventHandlerIDLAttribute(this, "onabort", val);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new `AbortSignal`.
     */ AbortSignalImpl._create = function() {
        return new AbortSignalImpl();
    };
    return AbortSignalImpl;
}(EventTargetImpl_1.EventTargetImpl);
exports.AbortSignalImpl = AbortSignalImpl; //# sourceMappingURL=AbortSignalImpl.js.map


/***/ }),

/***/ 58209:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Represents an abstract range with a start and end boundary point.
 */ var AbstractRangeImpl = /** @class */ function() {
    function AbstractRangeImpl() {}
    Object.defineProperty(AbstractRangeImpl.prototype, "_startNode", {
        get: function() {
            return this._start[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "_startOffset", {
        get: function() {
            return this._start[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "_endNode", {
        get: function() {
            return this._end[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "_endOffset", {
        get: function() {
            return this._end[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "_collapsed", {
        get: function() {
            return this._start[0] === this._end[0] && this._start[1] === this._end[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "startContainer", {
        /** @inheritdoc */ get: function() {
            return this._startNode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "startOffset", {
        /** @inheritdoc */ get: function() {
            return this._startOffset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "endContainer", {
        /** @inheritdoc */ get: function() {
            return this._endNode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "endOffset", {
        /** @inheritdoc */ get: function() {
            return this._endOffset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractRangeImpl.prototype, "collapsed", {
        /** @inheritdoc */ get: function() {
            return this._collapsed;
        },
        enumerable: true,
        configurable: true
    });
    return AbstractRangeImpl;
}();
exports.AbstractRangeImpl = AbstractRangeImpl; //# sourceMappingURL=AbstractRangeImpl.js.map


/***/ }),

/***/ 15867:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
var NodeImpl_1 = __webpack_require__(37183);
var algorithm_1 = __webpack_require__(75306);
var WebIDLAlgorithm_1 = __webpack_require__(52510);
/**
 * Represents an attribute of an element node.
 */ var AttrImpl = /** @class */ function(_super) {
    __extends(AttrImpl, _super);
    /**
     * Initializes a new instance of `Attr`.
     *
     * @param localName - local name
     */ function AttrImpl(localName) {
        var _this = _super.call(this) || this;
        _this._namespace = null;
        _this._namespacePrefix = null;
        _this._element = null;
        _this._value = "";
        _this._localName = localName;
        return _this;
    }
    Object.defineProperty(AttrImpl.prototype, "ownerElement", {
        /** @inheritdoc */ get: function() {
            return this._element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "namespaceURI", {
        /** @inheritdoc */ get: function() {
            return this._namespace;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "prefix", {
        /** @inheritdoc */ get: function() {
            return this._namespacePrefix;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "localName", {
        /** @inheritdoc */ get: function() {
            return this._localName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "name", {
        /** @inheritdoc */ get: function() {
            return this._qualifiedName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "value", {
        /** @inheritdoc */ get: function() {
            return this._value;
        },
        set: function(value) {
            /**
             * The value attribute’s setter must set an existing attribute value with
             * context object and the given value.
             */ algorithm_1.attr_setAnExistingAttributeValue(this, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttrImpl.prototype, "_qualifiedName", {
        /**
         * Returns the qualified name.
         */ get: function() {
            /**
             * An attribute’s qualified name is its local name if its namespace prefix
             * is null, and its namespace prefix, followed by ":", followed by its
             * local name, otherwise.
             */ return this._namespacePrefix !== null ? this._namespacePrefix + ":" + this._localName : this._localName;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates an `Attr`.
     *
     * @param document - owner document
     * @param localName - local name
     */ AttrImpl._create = function(document, localName) {
        var node = new AttrImpl(localName);
        node._nodeDocument = document;
        return node;
    };
    return AttrImpl;
}(NodeImpl_1.NodeImpl);
exports.AttrImpl = AttrImpl;
/**
 * Initialize prototype properties
 */ WebIDLAlgorithm_1.idl_defineConst(AttrImpl.prototype, "_nodeType", interfaces_1.NodeType.Attribute);
WebIDLAlgorithm_1.idl_defineConst(AttrImpl.prototype, "specified", true); //# sourceMappingURL=AttrImpl.js.map


/***/ }),

/***/ 34950:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var TextImpl_1 = __webpack_require__(70098);
var interfaces_1 = __webpack_require__(52580);
var WebIDLAlgorithm_1 = __webpack_require__(52510);
/**
 * Represents a CDATA node.
 */ var CDATASectionImpl = /** @class */ function(_super) {
    __extends(CDATASectionImpl, _super);
    /**
     * Initializes a new instance of `CDATASection`.
     *
     * @param data - node contents
     */ function CDATASectionImpl(data) {
        return _super.call(this, data) || this;
    }
    /**
     * Creates a new `CDATASection`.
     *
     * @param document - owner document
     * @param data - node contents
     */ CDATASectionImpl._create = function(document, data) {
        if (data === void 0) {
            data = "";
        }
        var node = new CDATASectionImpl(data);
        node._nodeDocument = document;
        return node;
    };
    return CDATASectionImpl;
}(TextImpl_1.TextImpl);
exports.CDATASectionImpl = CDATASectionImpl;
/**
 * Initialize prototype properties
 */ WebIDLAlgorithm_1.idl_defineConst(CDATASectionImpl.prototype, "_nodeType", interfaces_1.NodeType.CData); //# sourceMappingURL=CDATASectionImpl.js.map


/***/ }),

/***/ 1753:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var NodeImpl_1 = __webpack_require__(37183);
var algorithm_1 = __webpack_require__(75306);
/**
 * Represents a generic text node.
 */ var CharacterDataImpl = /** @class */ function(_super) {
    __extends(CharacterDataImpl, _super);
    /**
     * Initializes a new instance of `CharacterData`.
     *
     * @param data - the text content
     */ function CharacterDataImpl(data) {
        var _this = _super.call(this) || this;
        _this._data = data;
        return _this;
    }
    Object.defineProperty(CharacterDataImpl.prototype, "data", {
        /** @inheritdoc */ get: function() {
            return this._data;
        },
        set: function(value) {
            algorithm_1.characterData_replaceData(this, 0, this._data.length, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CharacterDataImpl.prototype, "length", {
        /** @inheritdoc */ get: function() {
            return this._data.length;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ CharacterDataImpl.prototype.substringData = function(offset, count) {
        /**
         * The substringData(offset, count) method, when invoked, must return the
         * result of running substring data with node context object, offset offset, and count count.
         */ return algorithm_1.characterData_substringData(this, offset, count);
    };
    /** @inheritdoc */ CharacterDataImpl.prototype.appendData = function(data) {
        /**
         * The appendData(data) method, when invoked, must replace data with node
         * context object, offset context object’s length, count 0, and data data.
         */ return algorithm_1.characterData_replaceData(this, this._data.length, 0, data);
    };
    /** @inheritdoc */ CharacterDataImpl.prototype.insertData = function(offset, data) {
        /**
         * The insertData(offset, data) method, when invoked, must replace data with
         * node context object, offset offset, count 0, and data data.
         */ algorithm_1.characterData_replaceData(this, offset, 0, data);
    };
    /** @inheritdoc */ CharacterDataImpl.prototype.deleteData = function(offset, count) {
        /**
         * The deleteData(offset, count) method, when invoked, must replace data
         * with node context object, offset offset, count count, and data the
         * empty string.
         */ algorithm_1.characterData_replaceData(this, offset, count, "");
    };
    /** @inheritdoc */ CharacterDataImpl.prototype.replaceData = function(offset, count, data) {
        /**
         * The replaceData(offset, count, data) method, when invoked, must replace
         * data with node context object, offset offset, count count, and data data.
         */ algorithm_1.characterData_replaceData(this, offset, count, data);
    };
    Object.defineProperty(CharacterDataImpl.prototype, "previousElementSibling", {
        // MIXIN: NonDocumentTypeChildNode
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CharacterDataImpl.prototype, "nextElementSibling", {
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    // MIXIN: ChildNode
    /* istanbul ignore next */ CharacterDataImpl.prototype.before = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */ CharacterDataImpl.prototype.after = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */ CharacterDataImpl.prototype.replaceWith = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */ CharacterDataImpl.prototype.remove = function() {
        throw new Error("Mixin: ChildNode not implemented.");
    };
    return CharacterDataImpl;
}(NodeImpl_1.NodeImpl);
exports.CharacterDataImpl = CharacterDataImpl; //# sourceMappingURL=CharacterDataImpl.js.map


/***/ }),

/***/ 45958:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(57294);
var algorithm_1 = __webpack_require__(75306);
/**
 * Represents a mixin that extends child nodes that can have siblings
 * including doctypes. This mixin is implemented by {@link Element},
 * {@link CharacterData} and {@link DocumentType}.
 */ var ChildNodeImpl = /** @class */ function() {
    function ChildNodeImpl() {}
    /** @inheritdoc */ ChildNodeImpl.prototype.before = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        /**
         * 1. Let parent be context object’s parent.
         * 2. If parent is null, then return.
         */ var context = util_1.Cast.asNode(this);
        var parent = context._parent;
        if (parent === null) return;
        /**
         * 3. Let viablePreviousSibling be context object’s first preceding
         * sibling not in nodes, and null otherwise.
         */ var viablePreviousSibling = context._previousSibling;
        var flag = true;
        while(flag && viablePreviousSibling){
            flag = false;
            for(var i = 0; i < nodes.length; i++){
                var child = nodes[i];
                if (child === viablePreviousSibling) {
                    viablePreviousSibling = viablePreviousSibling._previousSibling;
                    flag = true;
                    break;
                }
            }
        }
        /**
         * 4. Let node be the result of converting nodes into a node, given nodes
         * and context object’s node document.
         */ var node = algorithm_1.parentNode_convertNodesIntoANode(nodes, context._nodeDocument);
        /**
         * 5. If viablePreviousSibling is null, set it to parent’s first child,
         * and to viablePreviousSibling’s next sibling otherwise.
         */ if (viablePreviousSibling === null) viablePreviousSibling = parent._firstChild;
        else viablePreviousSibling = viablePreviousSibling._nextSibling;
        /**
         * 6. Pre-insert node into parent before viablePreviousSibling.
         */ algorithm_1.mutation_preInsert(node, parent, viablePreviousSibling);
    };
    /** @inheritdoc */ ChildNodeImpl.prototype.after = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        /**
         * 1. Let parent be context object’s parent.
         * 2. If parent is null, then return.
         */ var context = util_1.Cast.asNode(this);
        var parent = context._parent;
        if (!parent) return;
        /**
         * 3. Let viableNextSibling be context object’s first following sibling not
         * in nodes, and null otherwise.
         */ var viableNextSibling = context._nextSibling;
        var flag = true;
        while(flag && viableNextSibling){
            flag = false;
            for(var i = 0; i < nodes.length; i++){
                var child = nodes[i];
                if (child === viableNextSibling) {
                    viableNextSibling = viableNextSibling._nextSibling;
                    flag = true;
                    break;
                }
            }
        }
        /**
         * 4. Let node be the result of converting nodes into a node, given nodes
         * and context object’s node document.
         */ var node = algorithm_1.parentNode_convertNodesIntoANode(nodes, context._nodeDocument);
        /**
         * 5. Pre-insert node into parent before viableNextSibling.
         */ algorithm_1.mutation_preInsert(node, parent, viableNextSibling);
    };
    /** @inheritdoc */ ChildNodeImpl.prototype.replaceWith = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        /**
         * 1. Let parent be context object’s parent.
         * 2. If parent is null, then return.
         */ var context = util_1.Cast.asNode(this);
        var parent = context._parent;
        if (!parent) return;
        /**
         * 3. Let viableNextSibling be context object’s first following sibling not
         * in nodes, and null otherwise.
         */ var viableNextSibling = context._nextSibling;
        var flag = true;
        while(flag && viableNextSibling){
            flag = false;
            for(var i = 0; i < nodes.length; i++){
                var child = nodes[i];
                if (child === viableNextSibling) {
                    viableNextSibling = viableNextSibling._nextSibling;
                    flag = true;
                    break;
                }
            }
        }
        /**
         * 4. Let node be the result of converting nodes into a node, given nodes
         * and context object’s node document.
         */ var node = algorithm_1.parentNode_convertNodesIntoANode(nodes, context._nodeDocument);
        /**
         * 5. If context object’s parent is parent, replace the context object with
         * node within parent.
         * _Note:_ Context object could have been inserted into node.
         * 6. Otherwise, pre-insert node into parent before viableNextSibling.
         */ if (context._parent === parent) algorithm_1.mutation_replace(context, node, parent);
        else algorithm_1.mutation_preInsert(node, parent, viableNextSibling);
    };
    /** @inheritdoc */ ChildNodeImpl.prototype.remove = function() {
        /**
         * 1. If context object’s parent is null, then return.
         * 2. Remove the context object from context object’s parent.
         */ var context = util_1.Cast.asNode(this);
        var parent = context._parent;
        if (!parent) return;
        algorithm_1.mutation_remove(context, parent);
    };
    return ChildNodeImpl;
}();
exports.ChildNodeImpl = ChildNodeImpl; //# sourceMappingURL=ChildNodeImpl.js.map


/***/ }),

/***/ 77616:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
var CharacterDataImpl_1 = __webpack_require__(1753);
var WebIDLAlgorithm_1 = __webpack_require__(52510);
/**
 * Represents a comment node.
 */ var CommentImpl = /** @class */ function(_super) {
    __extends(CommentImpl, _super);
    /**
     * Initializes a new instance of `Comment`.
     *
     * @param data - the text content
     */ function CommentImpl(data) {
        if (data === void 0) {
            data = "";
        }
        return _super.call(this, data) || this;
    }
    /**
     * Creates a new `Comment`.
     *
     * @param document - owner document
     * @param data - node contents
     */ CommentImpl._create = function(document, data) {
        if (data === void 0) {
            data = "";
        }
        var node = new CommentImpl(data);
        node._nodeDocument = document;
        return node;
    };
    return CommentImpl;
}(CharacterDataImpl_1.CharacterDataImpl);
exports.CommentImpl = CommentImpl;
/**
 * Initialize prototype properties
 */ WebIDLAlgorithm_1.idl_defineConst(CommentImpl.prototype, "_nodeType", interfaces_1.NodeType.Comment); //# sourceMappingURL=CommentImpl.js.map


/***/ }),

/***/ 80010:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var EventImpl_1 = __webpack_require__(38584);
var algorithm_1 = __webpack_require__(75306);
/**
 * Represents and event that carries custom data.
 */ var CustomEventImpl = /** @class */ function(_super) {
    __extends(CustomEventImpl, _super);
    /**
     * Initializes a new instance of `CustomEvent`.
     */ function CustomEventImpl(type, eventInit) {
        var _this = _super.call(this, type, eventInit) || this;
        _this._detail = null;
        _this._detail = eventInit && eventInit.detail || null;
        return _this;
    }
    Object.defineProperty(CustomEventImpl.prototype, "detail", {
        /** @inheritdoc */ get: function() {
            return this._detail;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ CustomEventImpl.prototype.initCustomEvent = function(type, bubbles, cancelable, detail) {
        if (bubbles === void 0) {
            bubbles = false;
        }
        if (cancelable === void 0) {
            cancelable = false;
        }
        if (detail === void 0) {
            detail = null;
        }
        /**
         * 1. If the context object’s dispatch flag is set, then return.
         */ if (this._dispatchFlag) return;
        /**
         * 2. Initialize the context object with type, bubbles, and cancelable.
         */ algorithm_1.event_initialize(this, type, bubbles, cancelable);
        /**
         * 3. Set the context object’s detail attribute to detail.
         */ this._detail = detail;
    };
    return CustomEventImpl;
}(EventImpl_1.EventImpl);
exports.CustomEventImpl = CustomEventImpl; //# sourceMappingURL=CustomEventImpl.js.map


/***/ }),

/***/ 28905:
/***/ ((__unused_webpack_module, exports) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Represents the base class of `Error` objects used by this module.
 */ var DOMException = /** @class */ function(_super) {
    __extends(DOMException, _super);
    /**
     *
     * @param name - message name
     * @param message - error message
     */ function DOMException(name, message) {
        if (message === void 0) {
            message = "";
        }
        var _this = _super.call(this, message) || this;
        _this.name = name;
        return _this;
    }
    return DOMException;
}(Error);
exports.DOMException = DOMException;
var DOMStringSizeError = /** @class */ function(_super) {
    __extends(DOMStringSizeError, _super);
    /**
    * @param message - error message
    */ function DOMStringSizeError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "DOMStringSizeError", message) || this;
    }
    return DOMStringSizeError;
}(DOMException);
exports.DOMStringSizeError = DOMStringSizeError;
var WrongDocumentError = /** @class */ function(_super) {
    __extends(WrongDocumentError, _super);
    /**
    * @param message - error message
    */ function WrongDocumentError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "WrongDocumentError", "The object is in the wrong document. " + message) || this;
    }
    return WrongDocumentError;
}(DOMException);
exports.WrongDocumentError = WrongDocumentError;
var NoDataAllowedError = /** @class */ function(_super) {
    __extends(NoDataAllowedError, _super);
    /**
    * @param message - error message
    */ function NoDataAllowedError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "NoDataAllowedError", message) || this;
    }
    return NoDataAllowedError;
}(DOMException);
exports.NoDataAllowedError = NoDataAllowedError;
var NoModificationAllowedError = /** @class */ function(_super) {
    __extends(NoModificationAllowedError, _super);
    /**
    * @param message - error message
    */ function NoModificationAllowedError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "NoModificationAllowedError", "The object can not be modified. " + message) || this;
    }
    return NoModificationAllowedError;
}(DOMException);
exports.NoModificationAllowedError = NoModificationAllowedError;
var NotSupportedError = /** @class */ function(_super) {
    __extends(NotSupportedError, _super);
    /**
    * @param message - error message
    */ function NotSupportedError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "NotSupportedError", "The operation is not supported. " + message) || this;
    }
    return NotSupportedError;
}(DOMException);
exports.NotSupportedError = NotSupportedError;
var InUseAttributeError = /** @class */ function(_super) {
    __extends(InUseAttributeError, _super);
    /**
    * @param message - error message
    */ function InUseAttributeError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "InUseAttributeError", message) || this;
    }
    return InUseAttributeError;
}(DOMException);
exports.InUseAttributeError = InUseAttributeError;
var InvalidStateError = /** @class */ function(_super) {
    __extends(InvalidStateError, _super);
    /**
    * @param message - error message
    */ function InvalidStateError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "InvalidStateError", "The object is in an invalid state. " + message) || this;
    }
    return InvalidStateError;
}(DOMException);
exports.InvalidStateError = InvalidStateError;
var InvalidModificationError = /** @class */ function(_super) {
    __extends(InvalidModificationError, _super);
    /**
    * @param message - error message
    */ function InvalidModificationError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "InvalidModificationError", "The object can not be modified in this way. " + message) || this;
    }
    return InvalidModificationError;
}(DOMException);
exports.InvalidModificationError = InvalidModificationError;
var NamespaceError = /** @class */ function(_super) {
    __extends(NamespaceError, _super);
    /**
    * @param message - error message
    */ function NamespaceError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "NamespaceError", "The operation is not allowed by Namespaces in XML. [XMLNS] " + message) || this;
    }
    return NamespaceError;
}(DOMException);
exports.NamespaceError = NamespaceError;
var InvalidAccessError = /** @class */ function(_super) {
    __extends(InvalidAccessError, _super);
    /**
    * @param message - error message
    */ function InvalidAccessError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "InvalidAccessError", "The object does not support the operation or argument. " + message) || this;
    }
    return InvalidAccessError;
}(DOMException);
exports.InvalidAccessError = InvalidAccessError;
var ValidationError = /** @class */ function(_super) {
    __extends(ValidationError, _super);
    /**
    * @param message - error message
    */ function ValidationError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "ValidationError", message) || this;
    }
    return ValidationError;
}(DOMException);
exports.ValidationError = ValidationError;
var TypeMismatchError = /** @class */ function(_super) {
    __extends(TypeMismatchError, _super);
    /**
    * @param message - error message
    */ function TypeMismatchError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "TypeMismatchError", message) || this;
    }
    return TypeMismatchError;
}(DOMException);
exports.TypeMismatchError = TypeMismatchError;
var SecurityError = /** @class */ function(_super) {
    __extends(SecurityError, _super);
    /**
    * @param message - error message
    */ function SecurityError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "SecurityError", "The operation is insecure. " + message) || this;
    }
    return SecurityError;
}(DOMException);
exports.SecurityError = SecurityError;
var NetworkError = /** @class */ function(_super) {
    __extends(NetworkError, _super);
    /**
    * @param message - error message
    */ function NetworkError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "NetworkError", "A network error occurred. " + message) || this;
    }
    return NetworkError;
}(DOMException);
exports.NetworkError = NetworkError;
var AbortError = /** @class */ function(_super) {
    __extends(AbortError, _super);
    /**
    * @param message - error message
    */ function AbortError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "AbortError", "The operation was aborted. " + message) || this;
    }
    return AbortError;
}(DOMException);
exports.AbortError = AbortError;
var URLMismatchError = /** @class */ function(_super) {
    __extends(URLMismatchError, _super);
    /**
    * @param message - error message
    */ function URLMismatchError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "URLMismatchError", "The given URL does not match another URL. " + message) || this;
    }
    return URLMismatchError;
}(DOMException);
exports.URLMismatchError = URLMismatchError;
var QuotaExceededError = /** @class */ function(_super) {
    __extends(QuotaExceededError, _super);
    /**
    * @param message - error message
    */ function QuotaExceededError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "QuotaExceededError", "The quota has been exceeded. " + message) || this;
    }
    return QuotaExceededError;
}(DOMException);
exports.QuotaExceededError = QuotaExceededError;
var TimeoutError = /** @class */ function(_super) {
    __extends(TimeoutError, _super);
    /**
    * @param message - error message
    */ function TimeoutError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "TimeoutError", "The operation timed out. " + message) || this;
    }
    return TimeoutError;
}(DOMException);
exports.TimeoutError = TimeoutError;
var InvalidNodeTypeError = /** @class */ function(_super) {
    __extends(InvalidNodeTypeError, _super);
    /**
    * @param message - error message
    */ function InvalidNodeTypeError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "InvalidNodeTypeError", "The supplied node is incorrect or has an incorrect ancestor for this operation. " + message) || this;
    }
    return InvalidNodeTypeError;
}(DOMException);
exports.InvalidNodeTypeError = InvalidNodeTypeError;
var DataCloneError = /** @class */ function(_super) {
    __extends(DataCloneError, _super);
    /**
    * @param message - error message
    */ function DataCloneError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "DataCloneError", "The object can not be cloned. " + message) || this;
    }
    return DataCloneError;
}(DOMException);
exports.DataCloneError = DataCloneError;
var NotImplementedError = /** @class */ function(_super) {
    __extends(NotImplementedError, _super);
    /**
    * @param message - error message
    */ function NotImplementedError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "NotImplementedError", "The DOM method is not implemented by this module. " + message) || this;
    }
    return NotImplementedError;
}(DOMException);
exports.NotImplementedError = NotImplementedError;
var HierarchyRequestError = /** @class */ function(_super) {
    __extends(HierarchyRequestError, _super);
    /**
     * @param message - error message
     */ function HierarchyRequestError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "HierarchyRequestError", "The operation would yield an incorrect node tree. " + message) || this;
    }
    return HierarchyRequestError;
}(DOMException);
exports.HierarchyRequestError = HierarchyRequestError;
var NotFoundError = /** @class */ function(_super) {
    __extends(NotFoundError, _super);
    /**
     * @param message - error message
     */ function NotFoundError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "NotFoundError", "The object can not be found here. " + message) || this;
    }
    return NotFoundError;
}(DOMException);
exports.NotFoundError = NotFoundError;
var IndexSizeError = /** @class */ function(_super) {
    __extends(IndexSizeError, _super);
    /**
     * @param message - error message
     */ function IndexSizeError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "IndexSizeError", "The index is not in the allowed range. " + message) || this;
    }
    return IndexSizeError;
}(DOMException);
exports.IndexSizeError = IndexSizeError;
var SyntaxError = /** @class */ function(_super) {
    __extends(SyntaxError, _super);
    /**
     * @param message - error message
     */ function SyntaxError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "SyntaxError", "The string did not match the expected pattern. " + message) || this;
    }
    return SyntaxError;
}(DOMException);
exports.SyntaxError = SyntaxError;
var InvalidCharacterError = /** @class */ function(_super) {
    __extends(InvalidCharacterError, _super);
    /**
     * @param message - error message
     */ function InvalidCharacterError(message) {
        if (message === void 0) {
            message = "";
        }
        return _super.call(this, "InvalidCharacterError", "The string contains invalid characters. " + message) || this;
    }
    return InvalidCharacterError;
}(DOMException);
exports.InvalidCharacterError = InvalidCharacterError; //# sourceMappingURL=DOMException.js.map


/***/ }),

/***/ 21436:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(96883);
var CreateAlgorithm_1 = __webpack_require__(21701);
/**
 * Represents an object implementing DOM algorithms.
 */ var DOMImpl = /** @class */ function() {
    /**
     * Initializes a new instance of `DOM`.
     */ function DOMImpl() {
        this._features = {
            mutationObservers: true,
            customElements: true,
            slots: true,
            steps: true
        };
        this._window = null;
        this._compareCache = new util_1.CompareCache();
        this._rangeList = new util_1.FixedSizeSet();
    }
    /**
     * Sets DOM algorithm features.
     *
     * @param features - DOM features supported by algorithms. All features are
     * enabled by default unless explicity disabled.
     */ DOMImpl.prototype.setFeatures = function(features) {
        if (features === undefined) features = true;
        if (util_1.isObject(features)) {
            for(var key in features){
                this._features[key] = features[key] || false;
            }
        } else {
            // enable/disable all features
            for(var key in this._features){
                this._features[key] = features;
            }
        }
    };
    Object.defineProperty(DOMImpl.prototype, "features", {
        /**
         * Gets DOM algorithm features.
         */ get: function() {
            return this._features;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMImpl.prototype, "window", {
        /**
         * Gets the DOM window.
         */ get: function() {
            if (this._window === null) {
                this._window = CreateAlgorithm_1.create_window();
            }
            return this._window;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMImpl.prototype, "compareCache", {
        /**
         * Gets the global node compare cache.
         */ get: function() {
            return this._compareCache;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMImpl.prototype, "rangeList", {
        /**
         * Gets the global range list.
         */ get: function() {
            return this._rangeList;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DOMImpl, "instance", {
        /**
         * Returns the instance of `DOM`.
         */ get: function() {
            if (!DOMImpl._instance) {
                DOMImpl._instance = new DOMImpl();
            }
            return DOMImpl._instance;
        },
        enumerable: true,
        configurable: true
    });
    return DOMImpl;
}();
/**
 * Represents an object implementing DOM algorithms.
 */ exports.dom = DOMImpl.instance; //# sourceMappingURL=DOMImpl.js.map


/***/ }),

/***/ 36152:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var infra_1 = __webpack_require__(94317);
var algorithm_1 = __webpack_require__(75306);
var WebIDLAlgorithm_1 = __webpack_require__(52510);
/**
 * Represents an object providing methods which are not dependent on
 * any particular document.
 */ var DOMImplementationImpl = /** @class */ function() {
    /**
     * Initializes a new instance of `DOMImplementation`.
     *
     * @param document - the associated document
     */ function DOMImplementationImpl(document) {
        this._associatedDocument = document || DOMImpl_1.dom.window.document;
    }
    /** @inheritdoc */ DOMImplementationImpl.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
        /**
         * 1. Validate qualifiedName.
         * 2. Return a new doctype, with qualifiedName as its name, publicId as its
         * public ID, and systemId as its system ID, and with its node document set
         * to the associated document of the context object.
         */ algorithm_1.namespace_validate(qualifiedName);
        return algorithm_1.create_documentType(this._associatedDocument, qualifiedName, publicId, systemId);
    };
    /** @inheritdoc */ DOMImplementationImpl.prototype.createDocument = function(namespace, qualifiedName, doctype) {
        if (doctype === void 0) {
            doctype = null;
        }
        /**
         * 1. Let document be a new XMLDocument.
         */ var document = algorithm_1.create_xmlDocument();
        /**
         * 2. Let element be null.
         * 3. If qualifiedName is not the empty string, then set element to
         * the result of running the internal createElementNS steps, given document,
         * namespace, qualifiedName, and an empty dictionary.
         */ var element = null;
        if (qualifiedName) {
            element = algorithm_1.document_internalCreateElementNS(document, namespace, qualifiedName);
        }
        /**
         * 4. If doctype is non-null, append doctype to document.
         * 5. If element is non-null, append element to document.
         */ if (doctype) document.appendChild(doctype);
        if (element) document.appendChild(element);
        /**
         * 6. document’s origin is context object’s associated document’s origin.
         */ document._origin = this._associatedDocument._origin;
        /**
         * 7. document’s content type is determined by namespace:
         * - HTML namespace
         * application/xhtml+xml
         * - SVG namespace
         * image/svg+xml
         * - Any other namespace
         * application/xml
         */ if (namespace === infra_1.namespace.HTML) document._contentType = "application/xhtml+xml";
        else if (namespace === infra_1.namespace.SVG) document._contentType = "image/svg+xml";
        else document._contentType = "application/xml";
        /**
         * 8. Return document.
         */ return document;
    };
    /** @inheritdoc */ DOMImplementationImpl.prototype.createHTMLDocument = function(title) {
        /**
         * 1. Let doc be a new document that is an HTML document.
         * 2. Set doc’s content type to "text/html".
         */ var doc = algorithm_1.create_document();
        doc._type = "html";
        doc._contentType = "text/html";
        /**
         * 3. Append a new doctype, with "html" as its name and with its node
         * document set to doc, to doc.
         */ doc.appendChild(algorithm_1.create_documentType(doc, "html", "", ""));
        /**
         * 4. Append the result of creating an element given doc, html, and the
         * HTML namespace, to doc.
         */ var htmlElement = algorithm_1.element_createAnElement(doc, "html", infra_1.namespace.HTML);
        doc.appendChild(htmlElement);
        /**
         * 5. Append the result of creating an element given doc, head, and the
         * HTML namespace, to the html element created earlier.
         */ var headElement = algorithm_1.element_createAnElement(doc, "head", infra_1.namespace.HTML);
        htmlElement.appendChild(headElement);
        /**
         * 6. If title is given:
         * 6.1. Append the result of creating an element given doc, title, and
         * the HTML namespace, to the head element created earlier.
         * 6.2. Append a new Text node, with its data set to title (which could
         * be the empty string) and its node document set to doc, to the title
         * element created earlier.
         */ if (title !== undefined) {
            var titleElement = algorithm_1.element_createAnElement(doc, "title", infra_1.namespace.HTML);
            headElement.appendChild(titleElement);
            var textElement = algorithm_1.create_text(doc, title);
            titleElement.appendChild(textElement);
        }
        /**
         * 7. Append the result of creating an element given doc, body, and the
         * HTML namespace, to the html element created earlier.
         */ var bodyElement = algorithm_1.element_createAnElement(doc, "body", infra_1.namespace.HTML);
        htmlElement.appendChild(bodyElement);
        /**
         * 8. doc’s origin is context object’s associated document’s origin.
         */ doc._origin = this._associatedDocument._origin;
        /**
         * 9. Return doc.
         */ return doc;
    };
    /** @inheritdoc */ DOMImplementationImpl.prototype.hasFeature = function() {
        return true;
    };
    /**
     * Creates a new `DOMImplementation`.
     *
     * @param document - owner document
     */ DOMImplementationImpl._create = function(document) {
        return new DOMImplementationImpl(document);
    };
    return DOMImplementationImpl;
}();
exports.DOMImplementationImpl = DOMImplementationImpl;
WebIDLAlgorithm_1.idl_defineConst(DOMImplementationImpl.prototype, "_ID", "@oozcitak/dom"); //# sourceMappingURL=DOMImplementationImpl.js.map


/***/ }),

/***/ 26858:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var DOMException_1 = __webpack_require__(28905);
var infra_1 = __webpack_require__(94317);
var algorithm_1 = __webpack_require__(75306);
/**
 * Represents a token set.
 */ var DOMTokenListImpl = /** @class */ function() {
    /**
     * Initializes a new instance of `DOMTokenList`.
     *
     * @param element - associated element
     * @param attribute - associated attribute
     */ function DOMTokenListImpl(element, attribute) {
        /**
         * 1. Let element be associated element.
         * 2. Let localName be associated attribute’s local name.
         * 3. Let value be the result of getting an attribute value given element
         * and localName.
         * 4. Run the attribute change steps for element, localName, value, value,
         * and null.
         */ this._element = element;
        this._attribute = attribute;
        this._tokenSet = new Set();
        var localName = attribute._localName;
        var value = algorithm_1.element_getAnAttributeValue(element, localName);
        // define a closure to be called when the associated attribute's value changes
        var thisObj = this;
        function updateTokenSet(element, localName, oldValue, value, namespace) {
            /**
             * 1. If localName is associated attribute’s local name, namespace is null,
             * and value is null, then empty token set.
             * 2. Otherwise, if localName is associated attribute’s local name,
             * namespace is null, then set token set to value, parsed.
             */ if (localName === thisObj._attribute._localName && namespace === null) {
                if (!value) thisObj._tokenSet.clear();
                else thisObj._tokenSet = algorithm_1.orderedSet_parse(value);
            }
        }
        // add the closure to the associated element's attribute change steps
        this._element._attributeChangeSteps.push(updateTokenSet);
        if (DOMImpl_1.dom.features.steps) {
            algorithm_1.dom_runAttributeChangeSteps(element, localName, value, value, null);
        }
    }
    Object.defineProperty(DOMTokenListImpl.prototype, "length", {
        /** @inheritdoc */ get: function() {
            /**
             * The length attribute' getter must return context object’s token set’s
             * size.
             */ return this._tokenSet.size;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ DOMTokenListImpl.prototype.item = function(index) {
        var e_1, _a;
        /**
         * 1. If index is equal to or greater than context object’s token set’s
         * size, then return null.
         * 2. Return context object’s token set[index].
         */ var i = 0;
        try {
            for(var _b = __values(this._tokenSet), _c = _b.next(); !_c.done; _c = _b.next()){
                var token = _c.value;
                if (i === index) return token;
                i++;
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        return null;
    };
    /** @inheritdoc */ DOMTokenListImpl.prototype.contains = function(token) {
        /**
         * The contains(token) method, when invoked, must return true if context
         * object’s token set[token] exists, and false otherwise.
         */ return this._tokenSet.has(token);
    };
    /** @inheritdoc */ DOMTokenListImpl.prototype.add = function() {
        var e_2, _a;
        var tokens = [];
        for(var _i = 0; _i < arguments.length; _i++){
            tokens[_i] = arguments[_i];
        }
        try {
            /**
             * 1. For each token in tokens:
             * 1.1. If token is the empty string, then throw a "SyntaxError"
             * DOMException.
             * 1.2. If token contains any ASCII whitespace, then throw an
             * "InvalidCharacterError" DOMException.
             * 2. For each token in tokens, append token to context object’s token set.
             * 3. Run the update steps.
             */ for(var tokens_1 = __values(tokens), tokens_1_1 = tokens_1.next(); !tokens_1_1.done; tokens_1_1 = tokens_1.next()){
                var token = tokens_1_1.value;
                if (token === "") {
                    throw new DOMException_1.SyntaxError("Cannot add an empty token.");
                } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
                    throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
                } else {
                    this._tokenSet.add(token);
                }
            }
        } catch (e_2_1) {
            e_2 = {
                error: e_2_1
            };
        } finally{
            try {
                if (tokens_1_1 && !tokens_1_1.done && (_a = tokens_1.return)) _a.call(tokens_1);
            } finally{
                if (e_2) throw e_2.error;
            }
        }
        algorithm_1.tokenList_updateSteps(this);
    };
    /** @inheritdoc */ DOMTokenListImpl.prototype.remove = function() {
        var e_3, _a;
        var tokens = [];
        for(var _i = 0; _i < arguments.length; _i++){
            tokens[_i] = arguments[_i];
        }
        try {
            /**
             * 1. For each token in tokens:
             * 1.1. If token is the empty string, then throw a "SyntaxError"
             * DOMException.
             * 1.2. If token contains any ASCII whitespace, then throw an
             * "InvalidCharacterError" DOMException.
             * 2. For each token in tokens, remove token from context object’s token set.
             * 3. Run the update steps.
             */ for(var tokens_2 = __values(tokens), tokens_2_1 = tokens_2.next(); !tokens_2_1.done; tokens_2_1 = tokens_2.next()){
                var token = tokens_2_1.value;
                if (token === "") {
                    throw new DOMException_1.SyntaxError("Cannot remove an empty token.");
                } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
                    throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
                } else {
                    this._tokenSet.delete(token);
                }
            }
        } catch (e_3_1) {
            e_3 = {
                error: e_3_1
            };
        } finally{
            try {
                if (tokens_2_1 && !tokens_2_1.done && (_a = tokens_2.return)) _a.call(tokens_2);
            } finally{
                if (e_3) throw e_3.error;
            }
        }
        algorithm_1.tokenList_updateSteps(this);
    };
    /** @inheritdoc */ DOMTokenListImpl.prototype.toggle = function(token, force) {
        if (force === void 0) {
            force = undefined;
        }
        /**
         * 1. If token is the empty string, then throw a "SyntaxError" DOMException.
         * 2. If token contains any ASCII whitespace, then throw an
         * "InvalidCharacterError" DOMException.
         */ if (token === "") {
            throw new DOMException_1.SyntaxError("Cannot toggle an empty token.");
        } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token)) {
            throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
        }
        /**
         * 3. If context object’s token set[token] exists, then:
         */ if (this._tokenSet.has(token)) {
            /**
             * 3.1. If force is either not given or is false, then remove token from
             * context object’s token set, run the update steps and return false.
             * 3.2. Return true.
             */ if (force === undefined || force === false) {
                this._tokenSet.delete(token);
                algorithm_1.tokenList_updateSteps(this);
                return false;
            }
            return true;
        }
        /**
         * 4. Otherwise, if force not given or is true, append token to context
         * object’s token set, run the update steps, and return true.
         */ if (force === undefined || force === true) {
            this._tokenSet.add(token);
            algorithm_1.tokenList_updateSteps(this);
            return true;
        }
        /**
         * 5. Return false.
         */ return false;
    };
    /** @inheritdoc */ DOMTokenListImpl.prototype.replace = function(token, newToken) {
        /**
         * 1. If either token or newToken is the empty string, then throw a
         * "SyntaxError" DOMException.
         * 2. If either token or newToken contains any ASCII whitespace, then throw
         * an "InvalidCharacterError" DOMException.
         */ if (token === "" || newToken === "") {
            throw new DOMException_1.SyntaxError("Cannot replace an empty token.");
        } else if (infra_1.codePoint.ASCIIWhiteSpace.test(token) || infra_1.codePoint.ASCIIWhiteSpace.test(newToken)) {
            throw new DOMException_1.InvalidCharacterError("Token cannot contain whitespace.");
        }
        /**
         * 3. If context object’s token set does not contain token, then return
         * false.
         */ if (!this._tokenSet.has(token)) return false;
        /**
         * 4. Replace token in context object’s token set with newToken.
         * 5. Run the update steps.
         * 6. Return true.
         */ infra_1.set.replace(this._tokenSet, token, newToken);
        algorithm_1.tokenList_updateSteps(this);
        return true;
    };
    /** @inheritdoc */ DOMTokenListImpl.prototype.supports = function(token) {
        /**
         * 1. Let result be the return value of validation steps called with token.
         * 2. Return result.
         */ return algorithm_1.tokenList_validationSteps(this, token);
    };
    Object.defineProperty(DOMTokenListImpl.prototype, "value", {
        /** @inheritdoc */ get: function() {
            /**
             * The value attribute must return the result of running context object’s
             * serialize steps.
             */ return algorithm_1.tokenList_serializeSteps(this);
        },
        set: function(value) {
            /**
             * Setting the value attribute must set an attribute value for the
             * associated element using associated attribute’s local name and the given
             * value.
             */ algorithm_1.element_setAnAttributeValue(this._element, this._attribute._localName, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns an iterator for the token set.
     */ DOMTokenListImpl.prototype[Symbol.iterator] = function() {
        var it = this._tokenSet[Symbol.iterator]();
        return {
            next: function() {
                return it.next();
            }
        };
    };
    /**
     * Creates a new `DOMTokenList`.
     *
     * @param element - associated element
     * @param attribute - associated attribute
     */ DOMTokenListImpl._create = function(element, attribute) {
        return new DOMTokenListImpl(element, attribute);
    };
    return DOMTokenListImpl;
}();
exports.DOMTokenListImpl = DOMTokenListImpl; //# sourceMappingURL=DOMTokenListImpl.js.map


/***/ }),

/***/ 14240:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
var NodeImpl_1 = __webpack_require__(37183);
var WebIDLAlgorithm_1 = __webpack_require__(52510);
/**
 * Represents a document fragment in the XML tree.
 */ var DocumentFragmentImpl = /** @class */ function(_super) {
    __extends(DocumentFragmentImpl, _super);
    /**
     * Initializes a new instance of `DocumentFragment`.
     *
     * @param host - shadow root's host element
     */ function DocumentFragmentImpl(host) {
        if (host === void 0) {
            host = null;
        }
        var _this = _super.call(this) || this;
        _this._children = new Set();
        _this._host = host;
        return _this;
    }
    // MIXIN: NonElementParentNode
    /* istanbul ignore next */ DocumentFragmentImpl.prototype.getElementById = function(elementId) {
        throw new Error("Mixin: NonElementParentNode not implemented.");
    };
    Object.defineProperty(DocumentFragmentImpl.prototype, "children", {
        // MIXIN: ParentNode
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentFragmentImpl.prototype, "firstElementChild", {
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentFragmentImpl.prototype, "lastElementChild", {
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentFragmentImpl.prototype, "childElementCount", {
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    /* istanbul ignore next */ DocumentFragmentImpl.prototype.prepend = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */ DocumentFragmentImpl.prototype.append = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */ DocumentFragmentImpl.prototype.querySelector = function(selectors) {
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */ DocumentFragmentImpl.prototype.querySelectorAll = function(selectors) {
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /**
     * Creates a new `DocumentFragment`.
     *
     * @param document - owner document
     * @param host - shadow root's host element
     */ DocumentFragmentImpl._create = function(document, host) {
        if (host === void 0) {
            host = null;
        }
        var node = new DocumentFragmentImpl(host);
        node._nodeDocument = document;
        return node;
    };
    return DocumentFragmentImpl;
}(NodeImpl_1.NodeImpl);
exports.DocumentFragmentImpl = DocumentFragmentImpl;
/**
 * Initialize prototype properties
 */ WebIDLAlgorithm_1.idl_defineConst(DocumentFragmentImpl.prototype, "_nodeType", interfaces_1.NodeType.DocumentFragment); //# sourceMappingURL=DocumentFragmentImpl.js.map


/***/ }),

/***/ 18927:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var interfaces_1 = __webpack_require__(52580);
var DOMException_1 = __webpack_require__(28905);
var NodeImpl_1 = __webpack_require__(37183);
var util_1 = __webpack_require__(57294);
var util_2 = __webpack_require__(96883);
var infra_1 = __webpack_require__(94317);
var URLAlgorithm_1 = __webpack_require__(89233);
var algorithm_1 = __webpack_require__(75306);
var WebIDLAlgorithm_1 = __webpack_require__(52510);
/**
 * Represents a document node.
 */ var DocumentImpl = /** @class */ function(_super) {
    __extends(DocumentImpl, _super);
    /**
     * Initializes a new instance of `Document`.
     */ function DocumentImpl() {
        var _this = _super.call(this) || this;
        _this._children = new Set();
        _this._encoding = {
            name: "UTF-8",
            labels: [
                "unicode-1-1-utf-8",
                "utf-8",
                "utf8"
            ]
        };
        _this._contentType = "application/xml";
        _this._URL = {
            scheme: "about",
            username: "",
            password: "",
            host: null,
            port: null,
            path: [
                "blank"
            ],
            query: null,
            fragment: null,
            _cannotBeABaseURLFlag: true,
            _blobURLEntry: null
        };
        _this._origin = null;
        _this._type = "xml";
        _this._mode = "no-quirks";
        _this._documentElement = null;
        _this._hasNamespaces = false;
        _this._nodeDocumentOverwrite = null;
        return _this;
    }
    Object.defineProperty(DocumentImpl.prototype, "_nodeDocument", {
        get: function() {
            return this._nodeDocumentOverwrite || this;
        },
        set: function(val) {
            this._nodeDocumentOverwrite = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "implementation", {
        /** @inheritdoc */ get: function() {
            /**
             * The implementation attribute’s getter must return the DOMImplementation
             * object that is associated with the document.
             */ return this._implementation || (this._implementation = algorithm_1.create_domImplementation(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "URL", {
        /** @inheritdoc */ get: function() {
            /**
             * The URL attribute’s getter and documentURI attribute’s getter must return
             * the URL, serialized.
             * See: https://url.spec.whatwg.org/#concept-url-serializer
             */ return URLAlgorithm_1.urlSerializer(this._URL);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "documentURI", {
        /** @inheritdoc */ get: function() {
            return this.URL;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "origin", {
        /** @inheritdoc */ get: function() {
            return "null";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "compatMode", {
        /** @inheritdoc */ get: function() {
            /**
             * The compatMode attribute’s getter must return "BackCompat" if context
             * object’s mode is "quirks", and "CSS1Compat" otherwise.
             */ return this._mode === "quirks" ? "BackCompat" : "CSS1Compat";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "characterSet", {
        /** @inheritdoc */ get: function() {
            /**
             * The characterSet attribute’s getter, charset attribute’s getter, and
             * inputEncoding attribute’s getter, must return context object’s
             * encoding’s name.
             */ return this._encoding.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "charset", {
        /** @inheritdoc */ get: function() {
            return this._encoding.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "inputEncoding", {
        /** @inheritdoc */ get: function() {
            return this._encoding.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "contentType", {
        /** @inheritdoc */ get: function() {
            /**
             * The contentType attribute’s getter must return the content type.
             */ return this._contentType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "doctype", {
        /** @inheritdoc */ get: function() {
            var e_1, _a;
            try {
                /**
                 * The doctype attribute’s getter must return the child of the document
                 * that is a doctype, and null otherwise.
                 */ for(var _b = __values(this._children), _c = _b.next(); !_c.done; _c = _b.next()){
                    var child = _c.value;
                    if (util_1.Guard.isDocumentTypeNode(child)) return child;
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "documentElement", {
        /** @inheritdoc */ get: function() {
            /**
             * The documentElement attribute’s getter must return the document element.
             */ return this._documentElement;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ DocumentImpl.prototype.getElementsByTagName = function(qualifiedName) {
        /**
         * The getElementsByTagName(qualifiedName) method, when invoked, must return
         * the list of elements with qualified name qualifiedName for the context object.
         */ return algorithm_1.node_listOfElementsWithQualifiedName(qualifiedName, this);
    };
    /** @inheritdoc */ DocumentImpl.prototype.getElementsByTagNameNS = function(namespace, localName) {
        /**
         * The getElementsByTagNameNS(namespace, localName) method, when invoked,
         * must return the list of elements with namespace namespace and local name
         * localName for the context object.
         */ return algorithm_1.node_listOfElementsWithNamespace(namespace, localName, this);
    };
    /** @inheritdoc */ DocumentImpl.prototype.getElementsByClassName = function(classNames) {
        /**
         * The getElementsByClassName(classNames) method, when invoked, must return
         * the list of elements with class names classNames for the context object.
         */ return algorithm_1.node_listOfElementsWithClassNames(classNames, this);
    };
    /** @inheritdoc */ DocumentImpl.prototype.createElement = function(localName, options) {
        /**
         * 1. If localName does not match the Name production, then throw an
         * "InvalidCharacterError" DOMException.
         * 2. If the context object is an HTML document, then set localName to
         * localName in ASCII lowercase.
         * 3. Let is be null.
         * 4. If options is a dictionary and options’s is is present, then set is
         * to it.
         * 5. Let namespace be the HTML namespace, if the context object is an
         * HTML document or context object’s content type is
         * "application/xhtml+xml", and null otherwise.
         * 6. Return the result of creating an element given the context object,
         * localName, namespace, null, is, and with the synchronous custom elements
         * flag set.
         */ if (!algorithm_1.xml_isName(localName)) throw new DOMException_1.InvalidCharacterError();
        if (this._type === "html") localName = localName.toLowerCase();
        var is = null;
        if (options !== undefined) {
            if (util_2.isString(options)) {
                is = options;
            } else {
                is = options.is;
            }
        }
        var namespace = this._type === "html" || this._contentType === "application/xhtml+xml" ? infra_1.namespace.HTML : null;
        return algorithm_1.element_createAnElement(this, localName, namespace, null, is, true);
    };
    /** @inheritdoc */ DocumentImpl.prototype.createElementNS = function(namespace, qualifiedName, options) {
        /**
         * The createElementNS(namespace, qualifiedName, options) method, when
         * invoked, must return the result of running the internal createElementNS
         * steps, given context object, namespace, qualifiedName, and options.
         */ return algorithm_1.document_internalCreateElementNS(this, namespace, qualifiedName, options);
    };
    /** @inheritdoc */ DocumentImpl.prototype.createDocumentFragment = function() {
        /**
         * The createDocumentFragment() method, when invoked, must return a new
         * DocumentFragment node with its node document set to the context object.
         */ return algorithm_1.create_documentFragment(this);
    };
    /** @inheritdoc */ DocumentImpl.prototype.createTextNode = function(data) {
        /**
         * The createTextNode(data) method, when invoked, must return a new Text
         * node with its data set to data and node document set to the context object.
         */ return algorithm_1.create_text(this, data);
    };
    /** @inheritdoc */ DocumentImpl.prototype.createCDATASection = function(data) {
        /**
         * 1. If context object is an HTML document, then throw a
         * "NotSupportedError" DOMException.
         * 2. If data contains the string "]]>", then throw an
         * "InvalidCharacterError" DOMException.
         * 3. Return a new CDATASection node with its data set to data and node
         * document set to the context object.
         */ if (this._type === "html") throw new DOMException_1.NotSupportedError();
        if (data.indexOf("]]>") !== -1) throw new DOMException_1.InvalidCharacterError();
        return algorithm_1.create_cdataSection(this, data);
    };
    /** @inheritdoc */ DocumentImpl.prototype.createComment = function(data) {
        /**
         * The createComment(data) method, when invoked, must return a new Comment
         * node with its data set to data and node document set to the context object.
         */ return algorithm_1.create_comment(this, data);
    };
    /** @inheritdoc */ DocumentImpl.prototype.createProcessingInstruction = function(target, data) {
        /**
         * 1. If target does not match the Name production, then throw an
         * "InvalidCharacterError" DOMException.
         * 2. If data contains the string "?>", then throw an
         * "InvalidCharacterError" DOMException.
         * 3. Return a new ProcessingInstruction node, with target set to target,
         * data set to data, and node document set to the context object.
         */ if (!algorithm_1.xml_isName(target)) throw new DOMException_1.InvalidCharacterError();
        if (data.indexOf("?>") !== -1) throw new DOMException_1.InvalidCharacterError();
        return algorithm_1.create_processingInstruction(this, target, data);
    };
    /** @inheritdoc */ DocumentImpl.prototype.importNode = function(node, deep) {
        if (deep === void 0) {
            deep = false;
        }
        /**
         * 1. If node is a document or shadow root, then throw a "NotSupportedError" DOMException.
         */ if (util_1.Guard.isDocumentNode(node) || util_1.Guard.isShadowRoot(node)) throw new DOMException_1.NotSupportedError();
        /**
         * 2. Return a clone of node, with context object and the clone children flag set if deep is true.
         */ return algorithm_1.node_clone(node, this, deep);
    };
    /** @inheritdoc */ DocumentImpl.prototype.adoptNode = function(node) {
        /**
         * 1. If node is a document, then throw a "NotSupportedError" DOMException.
         */ if (util_1.Guard.isDocumentNode(node)) throw new DOMException_1.NotSupportedError();
        /**
         * 2. If node is a shadow root, then throw a "HierarchyRequestError" DOMException.
         */ if (util_1.Guard.isShadowRoot(node)) throw new DOMException_1.HierarchyRequestError();
        /**
         * 3. Adopt node into the context object.
         * 4. Return node.
         */ algorithm_1.document_adopt(node, this);
        return node;
    };
    /** @inheritdoc */ DocumentImpl.prototype.createAttribute = function(localName) {
        /**
         * 1. If localName does not match the Name production in XML, then throw
         * an "InvalidCharacterError" DOMException.
         * 2. If the context object is an HTML document, then set localName to
         * localName in ASCII lowercase.
         * 3. Return a new attribute whose local name is localName and node document
         * is context object.
         */ if (!algorithm_1.xml_isName(localName)) throw new DOMException_1.InvalidCharacterError();
        if (this._type === "html") {
            localName = localName.toLowerCase();
        }
        var attr = algorithm_1.create_attr(this, localName);
        return attr;
    };
    /** @inheritdoc */ DocumentImpl.prototype.createAttributeNS = function(namespace, qualifiedName) {
        /**
         * 1. Let namespace, prefix, and localName be the result of passing
         * namespace and qualifiedName to validate and extract.
         * 2. Return a new attribute whose namespace is namespace, namespace prefix
         * is prefix, local name is localName, and node document is context object.
         */ var _a = __read(algorithm_1.namespace_validateAndExtract(namespace, qualifiedName), 3), ns = _a[0], prefix = _a[1], localName = _a[2];
        var attr = algorithm_1.create_attr(this, localName);
        attr._namespace = ns;
        attr._namespacePrefix = prefix;
        return attr;
    };
    /** @inheritdoc */ DocumentImpl.prototype.createEvent = function(eventInterface) {
        return algorithm_1.event_createLegacyEvent(eventInterface);
    };
    /** @inheritdoc */ DocumentImpl.prototype.createRange = function() {
        /**
         * The createRange() method, when invoked, must return a new live range
         * with (context object, 0) as its start and end.
         */ var range = algorithm_1.create_range();
        range._start = [
            this,
            0
        ];
        range._end = [
            this,
            0
        ];
        return range;
    };
    /** @inheritdoc */ DocumentImpl.prototype.createNodeIterator = function(root, whatToShow, filter) {
        if (whatToShow === void 0) {
            whatToShow = interfaces_1.WhatToShow.All;
        }
        if (filter === void 0) {
            filter = null;
        }
        /**
         * 1. Let iterator be a new NodeIterator object.
         * 2. Set iterator’s root and iterator’s reference to root.
         * 3. Set iterator’s pointer before reference to true.
         * 4. Set iterator’s whatToShow to whatToShow.
         * 5. Set iterator’s filter to filter.
         * 6. Return iterator.
         */ var iterator = algorithm_1.create_nodeIterator(root, root, true);
        iterator._whatToShow = whatToShow;
        iterator._iteratorCollection = algorithm_1.create_nodeList(root);
        if (util_2.isFunction(filter)) {
            iterator._filter = algorithm_1.create_nodeFilter();
            iterator._filter.acceptNode = filter;
        } else {
            iterator._filter = filter;
        }
        return iterator;
    };
    /** @inheritdoc */ DocumentImpl.prototype.createTreeWalker = function(root, whatToShow, filter) {
        if (whatToShow === void 0) {
            whatToShow = interfaces_1.WhatToShow.All;
        }
        if (filter === void 0) {
            filter = null;
        }
        /**
         * 1. Let walker be a new TreeWalker object.
         * 2. Set walker’s root and walker’s current to root.
         * 3. Set walker’s whatToShow to whatToShow.
         * 4. Set walker’s filter to filter.
         * 5. Return walker.
         */ var walker = algorithm_1.create_treeWalker(root, root);
        walker._whatToShow = whatToShow;
        if (util_2.isFunction(filter)) {
            walker._filter = algorithm_1.create_nodeFilter();
            walker._filter.acceptNode = filter;
        } else {
            walker._filter = filter;
        }
        return walker;
    };
    /**
     * Gets the parent event target for the given event.
     *
     * @param event - an event
     */ DocumentImpl.prototype._getTheParent = function(event) {
        /**
         * TODO: Implement realms
         * A document’s get the parent algorithm, given an event, returns null if
         * event’s type attribute value is "load" or document does not have a
         * browsing context, and the document’s relevant global object otherwise.
         */ if (event._type === "load") {
            return null;
        } else {
            return DOMImpl_1.dom.window;
        }
    };
    // MIXIN: NonElementParentNode
    /* istanbul ignore next */ DocumentImpl.prototype.getElementById = function(elementId) {
        throw new Error("Mixin: NonElementParentNode not implemented.");
    };
    Object.defineProperty(DocumentImpl.prototype, "children", {
        // MIXIN: DocumentOrShadowRoot
        // No elements
        // MIXIN: ParentNode
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "firstElementChild", {
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "lastElementChild", {
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentImpl.prototype, "childElementCount", {
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    /* istanbul ignore next */ DocumentImpl.prototype.prepend = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */ DocumentImpl.prototype.append = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */ DocumentImpl.prototype.querySelector = function(selectors) {
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */ DocumentImpl.prototype.querySelectorAll = function(selectors) {
        throw new Error("Mixin: ParentNode not implemented.");
    };
    return DocumentImpl;
}(NodeImpl_1.NodeImpl);
exports.DocumentImpl = DocumentImpl;
/**
 * Initialize prototype properties
 */ WebIDLAlgorithm_1.idl_defineConst(DocumentImpl.prototype, "_nodeType", interfaces_1.NodeType.Document); //# sourceMappingURL=DocumentImpl.js.map


/***/ }),

/***/ 19087:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Represents a mixin for an interface to be used to share APIs between
 * documents and shadow roots. This mixin is implemented by
 * {@link Document} and {@link ShadowRoot}.
 *
 * _Note:_ The DocumentOrShadowRoot mixin is expected to be used by other
 * standards that want to define APIs shared between documents and shadow roots.
 */ var DocumentOrShadowRootImpl = /** @class */ function() {
    function DocumentOrShadowRootImpl() {}
    return DocumentOrShadowRootImpl;
}();
exports.DocumentOrShadowRootImpl = DocumentOrShadowRootImpl; //# sourceMappingURL=DocumentOrShadowRootImpl.js.map


/***/ }),

/***/ 23331:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
var NodeImpl_1 = __webpack_require__(37183);
var WebIDLAlgorithm_1 = __webpack_require__(52510);
/**
 * Represents an object providing methods which are not dependent on
 * any particular document
 */ var DocumentTypeImpl = /** @class */ function(_super) {
    __extends(DocumentTypeImpl, _super);
    /**
     * Initializes a new instance of `DocumentType`.
     *
     * @param name - name of the node
     * @param publicId - `PUBLIC` identifier
     * @param systemId - `SYSTEM` identifier
     */ function DocumentTypeImpl(name, publicId, systemId) {
        var _this = _super.call(this) || this;
        _this._name = "";
        _this._publicId = "";
        _this._systemId = "";
        _this._name = name;
        _this._publicId = publicId;
        _this._systemId = systemId;
        return _this;
    }
    Object.defineProperty(DocumentTypeImpl.prototype, "name", {
        /** @inheritdoc */ get: function() {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentTypeImpl.prototype, "publicId", {
        /** @inheritdoc */ get: function() {
            return this._publicId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentTypeImpl.prototype, "systemId", {
        /** @inheritdoc */ get: function() {
            return this._systemId;
        },
        enumerable: true,
        configurable: true
    });
    // MIXIN: ChildNode
    /* istanbul ignore next */ DocumentTypeImpl.prototype.before = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */ DocumentTypeImpl.prototype.after = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */ DocumentTypeImpl.prototype.replaceWith = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */ DocumentTypeImpl.prototype.remove = function() {
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /**
     * Creates a new `DocumentType`.
     *
     * @param document - owner document
     * @param name - name of the node
     * @param publicId - `PUBLIC` identifier
     * @param systemId - `SYSTEM` identifier
     */ DocumentTypeImpl._create = function(document, name, publicId, systemId) {
        if (publicId === void 0) {
            publicId = "";
        }
        if (systemId === void 0) {
            systemId = "";
        }
        var node = new DocumentTypeImpl(name, publicId, systemId);
        node._nodeDocument = document;
        return node;
    };
    return DocumentTypeImpl;
}(NodeImpl_1.NodeImpl);
exports.DocumentTypeImpl = DocumentTypeImpl;
/**
 * Initialize prototype properties
 */ WebIDLAlgorithm_1.idl_defineConst(DocumentTypeImpl.prototype, "_nodeType", interfaces_1.NodeType.DocumentType); //# sourceMappingURL=DocumentTypeImpl.js.map


/***/ }),

/***/ 33086:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
var NodeImpl_1 = __webpack_require__(37183);
var DOMException_1 = __webpack_require__(28905);
var infra_1 = __webpack_require__(94317);
var algorithm_1 = __webpack_require__(75306);
var WebIDLAlgorithm_1 = __webpack_require__(52510);
/**
 * Represents an element node.
 */ var ElementImpl = /** @class */ function(_super) {
    __extends(ElementImpl, _super);
    /**
     * Initializes a new instance of `Element`.
     */ function ElementImpl() {
        var _this = _super.call(this) || this;
        _this._children = new Set();
        _this._namespace = null;
        _this._namespacePrefix = null;
        _this._localName = "";
        _this._customElementState = "undefined";
        _this._customElementDefinition = null;
        _this._is = null;
        _this._shadowRoot = null;
        _this._attributeList = algorithm_1.create_namedNodeMap(_this);
        _this._attributeChangeSteps = [];
        _this._name = "";
        _this._assignedSlot = null;
        return _this;
    }
    Object.defineProperty(ElementImpl.prototype, "namespaceURI", {
        /** @inheritdoc */ get: function() {
            return this._namespace;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "prefix", {
        /** @inheritdoc */ get: function() {
            return this._namespacePrefix;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "localName", {
        /** @inheritdoc */ get: function() {
            return this._localName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "tagName", {
        /** @inheritdoc */ get: function() {
            return this._htmlUppercasedQualifiedName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "id", {
        /** @inheritdoc */ get: function() {
            return algorithm_1.element_getAnAttributeValue(this, "id");
        },
        set: function(value) {
            algorithm_1.element_setAnAttributeValue(this, "id", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "className", {
        /** @inheritdoc */ get: function() {
            return algorithm_1.element_getAnAttributeValue(this, "class");
        },
        set: function(value) {
            algorithm_1.element_setAnAttributeValue(this, "class", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "classList", {
        /** @inheritdoc */ get: function() {
            var attr = algorithm_1.element_getAnAttributeByName("class", this);
            if (attr === null) {
                attr = algorithm_1.create_attr(this._nodeDocument, "class");
            }
            return algorithm_1.create_domTokenList(this, attr);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "slot", {
        /** @inheritdoc */ get: function() {
            return algorithm_1.element_getAnAttributeValue(this, "slot");
        },
        set: function(value) {
            algorithm_1.element_setAnAttributeValue(this, "slot", value);
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ ElementImpl.prototype.hasAttributes = function() {
        return this._attributeList.length !== 0;
    };
    Object.defineProperty(ElementImpl.prototype, "attributes", {
        /** @inheritdoc */ get: function() {
            return this._attributeList;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ ElementImpl.prototype.getAttributeNames = function() {
        var e_1, _a;
        /**
         * The getAttributeNames() method, when invoked, must return the qualified
         * names of the attributes in context object’s attribute list, in order,
         * and a new list otherwise.
         */ var names = [];
        try {
            for(var _b = __values(this._attributeList), _c = _b.next(); !_c.done; _c = _b.next()){
                var attr = _c.value;
                names.push(attr._qualifiedName);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        return names;
    };
    /** @inheritdoc */ ElementImpl.prototype.getAttribute = function(qualifiedName) {
        /**
         * 1. Let attr be the result of getting an attribute given qualifiedName
         * and the context object.
         * 2. If attr is null, return null.
         * 3. Return attr’s value.
         */ var attr = algorithm_1.element_getAnAttributeByName(qualifiedName, this);
        return attr ? attr._value : null;
    };
    /** @inheritdoc */ ElementImpl.prototype.getAttributeNS = function(namespace, localName) {
        /**
         * 1. Let attr be the result of getting an attribute given namespace,
         * localName, and the context object.
         * 2. If attr is null, return null.
         * 3. Return attr’s value.
         */ var attr = algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace, localName, this);
        return attr ? attr._value : null;
    };
    /** @inheritdoc */ ElementImpl.prototype.setAttribute = function(qualifiedName, value) {
        /**
         * 1. If qualifiedName does not match the Name production in XML, then
         * throw an "InvalidCharacterError" DOMException.
         */ if (!algorithm_1.xml_isName(qualifiedName)) throw new DOMException_1.InvalidCharacterError();
        /**
         * 2. If the context object is in the HTML namespace and its node document
         * is an HTML document, then set qualifiedName to qualifiedName in ASCII
         * lowercase.
         */ if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
            qualifiedName = qualifiedName.toLowerCase();
        }
        /**
         * 3. Let attribute be the first attribute in context object’s attribute
         * list whose qualified name is qualifiedName, and null otherwise.
         */ var attribute = null;
        for(var i = 0; i < this._attributeList.length; i++){
            var attr = this._attributeList[i];
            if (attr._qualifiedName === qualifiedName) {
                attribute = attr;
                break;
            }
        }
        /**
         * 4. If attribute is null, create an attribute whose local name is
         * qualifiedName, value is value, and node document is context object’s
         * node document, then append this attribute to context object, and
         * then return.
         */ if (attribute === null) {
            attribute = algorithm_1.create_attr(this._nodeDocument, qualifiedName);
            attribute._value = value;
            algorithm_1.element_append(attribute, this);
            return;
        }
        /**
         * 5. Change attribute from context object to value.
         */ algorithm_1.element_change(attribute, this, value);
    };
    /** @inheritdoc */ ElementImpl.prototype.setAttributeNS = function(namespace, qualifiedName, value) {
        /**
         * 1. Let namespace, prefix, and localName be the result of passing
         * namespace and qualifiedName to validate and extract.
         * 2. Set an attribute value for the context object using localName, value,
         * and also prefix and namespace.
         */ var _a = __read(algorithm_1.namespace_validateAndExtract(namespace, qualifiedName), 3), ns = _a[0], prefix = _a[1], localName = _a[2];
        algorithm_1.element_setAnAttributeValue(this, localName, value, prefix, ns);
    };
    /** @inheritdoc */ ElementImpl.prototype.removeAttribute = function(qualifiedName) {
        /**
         * The removeAttribute(qualifiedName) method, when invoked, must remove an
         * attribute given qualifiedName and the context object, and then return
         * undefined.
         */ algorithm_1.element_removeAnAttributeByName(qualifiedName, this);
    };
    /** @inheritdoc */ ElementImpl.prototype.removeAttributeNS = function(namespace, localName) {
        /**
         * The removeAttributeNS(namespace, localName) method, when invoked, must
         * remove an attribute given namespace, localName, and context object, and
         * then return undefined.
         */ algorithm_1.element_removeAnAttributeByNamespaceAndLocalName(namespace, localName, this);
    };
    /** @inheritdoc */ ElementImpl.prototype.hasAttribute = function(qualifiedName) {
        /**
         * 1. If the context object is in the HTML namespace and its node document
         * is an HTML document, then set qualifiedName to qualifiedName in ASCII
         * lowercase.
         * 2. Return true if the context object has an attribute whose qualified
         * name is qualifiedName, and false otherwise.
         */ if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
            qualifiedName = qualifiedName.toLowerCase();
        }
        for(var i = 0; i < this._attributeList.length; i++){
            var attr = this._attributeList[i];
            if (attr._qualifiedName === qualifiedName) {
                return true;
            }
        }
        return false;
    };
    /** @inheritdoc */ ElementImpl.prototype.toggleAttribute = function(qualifiedName, force) {
        /**
         * 1. If qualifiedName does not match the Name production in XML, then
         * throw an "InvalidCharacterError" DOMException.
         */ if (!algorithm_1.xml_isName(qualifiedName)) throw new DOMException_1.InvalidCharacterError();
        /**
         * 2. If the context object is in the HTML namespace and its node document
         * is an HTML document, then set qualifiedName to qualifiedName in ASCII
         * lowercase.
         */ if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
            qualifiedName = qualifiedName.toLowerCase();
        }
        /**
         * 3. Let attribute be the first attribute in the context object’s attribute
         * list whose qualified name is qualifiedName, and null otherwise.
         */ var attribute = null;
        for(var i = 0; i < this._attributeList.length; i++){
            var attr = this._attributeList[i];
            if (attr._qualifiedName === qualifiedName) {
                attribute = attr;
                break;
            }
        }
        if (attribute === null) {
            /**
             * 4. If attribute is null, then:
             * 4.1. If force is not given or is true, create an attribute whose local
             * name is qualifiedName, value is the empty string, and node document is
             * the context object’s node document, then append this attribute to the
             * context object, and then return true.
             * 4.2. Return false.
             */ if (force === undefined || force === true) {
                attribute = algorithm_1.create_attr(this._nodeDocument, qualifiedName);
                attribute._value = "";
                algorithm_1.element_append(attribute, this);
                return true;
            }
            return false;
        } else if (force === undefined || force === false) {
            /**
             * 5. Otherwise, if force is not given or is false, remove an attribute
             * given qualifiedName and the context object, and then return false.
             */ algorithm_1.element_removeAnAttributeByName(qualifiedName, this);
            return false;
        }
        /**
         * 6. Return true.
         */ return true;
    };
    /** @inheritdoc */ ElementImpl.prototype.hasAttributeNS = function(namespace, localName) {
        /**
         * 1. If namespace is the empty string, set it to null.
         * 2. Return true if the context object has an attribute whose namespace is
         * namespace and local name is localName, and false otherwise.
         */ var ns = namespace || null;
        for(var i = 0; i < this._attributeList.length; i++){
            var attr = this._attributeList[i];
            if (attr._namespace === ns && attr._localName === localName) {
                return true;
            }
        }
        return false;
    };
    /** @inheritdoc */ ElementImpl.prototype.getAttributeNode = function(qualifiedName) {
        /**
         * The getAttributeNode(qualifiedName) method, when invoked, must return the
         * result of getting an attribute given qualifiedName and context object.
         */ return algorithm_1.element_getAnAttributeByName(qualifiedName, this);
    };
    /** @inheritdoc */ ElementImpl.prototype.getAttributeNodeNS = function(namespace, localName) {
        /**
         * The getAttributeNodeNS(namespace, localName) method, when invoked, must
         * return the result of getting an attribute given namespace, localName, and
         * the context object.
         */ return algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace, localName, this);
    };
    /** @inheritdoc */ ElementImpl.prototype.setAttributeNode = function(attr) {
        /**
         * The setAttributeNode(attr) and setAttributeNodeNS(attr) methods, when
         * invoked, must return the result of setting an attribute given attr and
         * the context object.
         */ return algorithm_1.element_setAnAttribute(attr, this);
    };
    /** @inheritdoc */ ElementImpl.prototype.setAttributeNodeNS = function(attr) {
        return algorithm_1.element_setAnAttribute(attr, this);
    };
    /** @inheritdoc */ ElementImpl.prototype.removeAttributeNode = function(attr) {
        /**
         * 1. If context object’s attribute list does not contain attr, then throw
         * a "NotFoundError" DOMException.
         * 2. Remove attr from context object.
         * 3. Return attr.
         */ var found = false;
        for(var i = 0; i < this._attributeList.length; i++){
            var attribute = this._attributeList[i];
            if (attribute === attr) {
                found = true;
                break;
            }
        }
        if (!found) throw new DOMException_1.NotFoundError();
        algorithm_1.element_remove(attr, this);
        return attr;
    };
    /** @inheritdoc */ ElementImpl.prototype.attachShadow = function(init) {
        /**
         * 1. If context object’s namespace is not the HTML namespace, then throw a
         * "NotSupportedError" DOMException.
         */ if (this._namespace !== infra_1.namespace.HTML) throw new DOMException_1.NotSupportedError();
        /**
         * 2. If context object’s local name is not a valid custom element name,
         * "article", "aside", "blockquote", "body", "div", "footer", "h1", "h2",
         * "h3", "h4", "h5", "h6", "header", "main" "nav", "p", "section",
         * or "span", then throw a "NotSupportedError" DOMException.
         */ if (!algorithm_1.customElement_isValidCustomElementName(this._localName) && !algorithm_1.customElement_isValidShadowHostName(this._localName)) throw new DOMException_1.NotSupportedError();
        /**
         * 3. If context object’s local name is a valid custom element name,
         * or context object’s is value is not null, then:
         * 3.1. Let definition be the result of looking up a custom element
         * definition given context object’s node document, its namespace, its
         * local name, and its is value.
         * 3.2. If definition is not null and definition’s disable shadow is true,
         *  then throw a "NotSupportedError" DOMException.
         */ if (algorithm_1.customElement_isValidCustomElementName(this._localName) || this._is !== null) {
            var definition = algorithm_1.customElement_lookUpACustomElementDefinition(this._nodeDocument, this._namespace, this._localName, this._is);
            if (definition !== null && definition.disableShadow === true) {
                throw new DOMException_1.NotSupportedError();
            }
        }
        /**
         * 4. If context object is a shadow host, then throw an "NotSupportedError"
         * DOMException.
         */ if (this._shadowRoot !== null) throw new DOMException_1.NotSupportedError();
        /**
         * 5. Let shadow be a new shadow root whose node document is context
         * object’s node document, host is context object, and mode is init’s mode.
         * 6. Set context object’s shadow root to shadow.
         * 7. Return shadow.
         */ var shadow = algorithm_1.create_shadowRoot(this._nodeDocument, this);
        shadow._mode = init.mode;
        this._shadowRoot = shadow;
        return shadow;
    };
    Object.defineProperty(ElementImpl.prototype, "shadowRoot", {
        /** @inheritdoc */ get: function() {
            /**
             * 1. Let shadow be context object’s shadow root.
             * 2. If shadow is null or its mode is "closed", then return null.
             * 3. Return shadow.
             */ var shadow = this._shadowRoot;
            if (shadow === null || shadow.mode === "closed") return null;
            else return shadow;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ ElementImpl.prototype.closest = function(selectors) {
        /**
         * TODO: Selectors
         * 1. Let s be the result of parse a selector from selectors. [SELECTORS4]
         * 2. If s is failure, throw a "SyntaxError" DOMException.
         * 3. Let elements be context object’s inclusive ancestors that are
         * elements, in reverse tree order.
         * 4. For each element in elements, if match a selector against an element,
         * using s, element, and :scope element context object, returns success,
         * return element. [SELECTORS4]
         * 5. Return null.
         */ throw new DOMException_1.NotImplementedError();
    };
    /** @inheritdoc */ ElementImpl.prototype.matches = function(selectors) {
        /**
         * TODO: Selectors
         * 1. Let s be the result of parse a selector from selectors. [SELECTORS4]
         * 2. If s is failure, throw a "SyntaxError" DOMException.
         * 3. Return true if the result of match a selector against an element,
         * using s, element, and :scope element context object, returns success,
         * and false otherwise. [SELECTORS4]
         */ throw new DOMException_1.NotImplementedError();
    };
    /** @inheritdoc */ ElementImpl.prototype.webkitMatchesSelector = function(selectors) {
        return this.matches(selectors);
    };
    /** @inheritdoc */ ElementImpl.prototype.getElementsByTagName = function(qualifiedName) {
        /**
         * The getElementsByTagName(qualifiedName) method, when invoked, must return
         * the list of elements with qualified name qualifiedName for context
         * object.
         */ return algorithm_1.node_listOfElementsWithQualifiedName(qualifiedName, this);
    };
    /** @inheritdoc */ ElementImpl.prototype.getElementsByTagNameNS = function(namespace, localName) {
        /**
         * The getElementsByTagNameNS(namespace, localName) method, when invoked,
         * must return the list of elements with namespace namespace and local name
         * localName for context object.
         */ return algorithm_1.node_listOfElementsWithNamespace(namespace, localName, this);
    };
    /** @inheritdoc */ ElementImpl.prototype.getElementsByClassName = function(classNames) {
        /**
         * The getElementsByClassName(classNames) method, when invoked, must return
         * the list of elements with class names classNames for context object.
         */ return algorithm_1.node_listOfElementsWithClassNames(classNames, this);
    };
    /** @inheritdoc */ ElementImpl.prototype.insertAdjacentElement = function(where, element) {
        /**
         * The insertAdjacentElement(where, element) method, when invoked, must
         * return the result of running insert adjacent, given context object,
         *  where, and element.
         */ return algorithm_1.element_insertAdjacent(this, where, element);
    };
    /** @inheritdoc */ ElementImpl.prototype.insertAdjacentText = function(where, data) {
        /**
         * 1. Let text be a new Text node whose data is data and node document is
         * context object’s node document.
         * 2. Run insert adjacent, given context object, where, and text.
         */ var text = algorithm_1.create_text(this._nodeDocument, data);
        algorithm_1.element_insertAdjacent(this, where, text);
    };
    Object.defineProperty(ElementImpl.prototype, "_qualifiedName", {
        /**
         * Returns the qualified name.
         */ get: function() {
            /**
             * An element’s qualified name is its local name if its namespace prefix is
             * null, and its namespace prefix, followed by ":", followed by its
             * local name, otherwise.
             */ return this._namespacePrefix ? this._namespacePrefix + ":" + this._localName : this._localName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "_htmlUppercasedQualifiedName", {
        /**
         * Returns the upper-cased qualified name for a html element.
         */ get: function() {
            /**
             * 1. Let qualifiedName be context object’s qualified name.
             * 2. If the context object is in the HTML namespace and its node document
             * is an HTML document, then set qualifiedName to qualifiedName in ASCII
             * uppercase.
             * 3. Return qualifiedName.
             */ var qualifiedName = this._qualifiedName;
            if (this._namespace === infra_1.namespace.HTML && this._nodeDocument._type === "html") {
                qualifiedName = qualifiedName.toUpperCase();
            }
            return qualifiedName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "children", {
        // MIXIN: ParentNode
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "firstElementChild", {
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "lastElementChild", {
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "childElementCount", {
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: ParentNode not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    /* istanbul ignore next */ ElementImpl.prototype.prepend = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */ ElementImpl.prototype.append = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */ ElementImpl.prototype.querySelector = function(selectors) {
        throw new Error("Mixin: ParentNode not implemented.");
    };
    /* istanbul ignore next */ ElementImpl.prototype.querySelectorAll = function(selectors) {
        throw new Error("Mixin: ParentNode not implemented.");
    };
    Object.defineProperty(ElementImpl.prototype, "previousElementSibling", {
        // MIXIN: NonDocumentTypeChildNode
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementImpl.prototype, "nextElementSibling", {
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: NonDocumentTypeChildNode not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    // MIXIN: ChildNode
    /* istanbul ignore next */ ElementImpl.prototype.before = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */ ElementImpl.prototype.after = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */ ElementImpl.prototype.replaceWith = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        throw new Error("Mixin: ChildNode not implemented.");
    };
    /* istanbul ignore next */ ElementImpl.prototype.remove = function() {
        throw new Error("Mixin: ChildNode not implemented.");
    };
    Object.defineProperty(ElementImpl.prototype, "assignedSlot", {
        // MIXIN: Slotable
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: Slotable not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new `Element`.
     *
     * @param document - owner document
     * @param localName - local name
     * @param namespace - namespace
     * @param prefix - namespace prefix
     */ ElementImpl._create = function(document, localName, namespace, namespacePrefix) {
        if (namespace === void 0) {
            namespace = null;
        }
        if (namespacePrefix === void 0) {
            namespacePrefix = null;
        }
        var node = new ElementImpl();
        node._localName = localName;
        node._namespace = namespace;
        node._namespacePrefix = namespacePrefix;
        node._nodeDocument = document;
        return node;
    };
    return ElementImpl;
}(NodeImpl_1.NodeImpl);
exports.ElementImpl = ElementImpl;
/**
 * Initialize prototype properties
 */ WebIDLAlgorithm_1.idl_defineConst(ElementImpl.prototype, "_nodeType", interfaces_1.NodeType.Element); //# sourceMappingURL=ElementImpl.js.map


/***/ }),

/***/ 38584:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
var algorithm_1 = __webpack_require__(75306);
var WebIDLAlgorithm_1 = __webpack_require__(52510);
/**
 * Represents a DOM event.
 */ var EventImpl = /** @class */ function() {
    /**
     * Initializes a new instance of `Event`.
     */ function EventImpl(type, eventInit) {
        this._target = null;
        this._relatedTarget = null;
        this._touchTargetList = [];
        this._path = [];
        this._currentTarget = null;
        this._eventPhase = interfaces_1.EventPhase.None;
        this._stopPropagationFlag = false;
        this._stopImmediatePropagationFlag = false;
        this._canceledFlag = false;
        this._inPassiveListenerFlag = false;
        this._composedFlag = false;
        this._initializedFlag = false;
        this._dispatchFlag = false;
        this._isTrusted = false;
        this._bubbles = false;
        this._cancelable = false;
        /**
         * When a constructor of the Event interface, or of an interface that
         * inherits from the Event interface, is invoked, these steps must be run,
         * given the arguments type and eventInitDict:
         * 1. Let event be the result of running the inner event creation steps with
         * this interface, null, now, and eventInitDict.
         * 2. Initialize event’s type attribute to type.
         * 3. Return event.
         */ this._type = type;
        if (eventInit) {
            this._bubbles = eventInit.bubbles || false;
            this._cancelable = eventInit.cancelable || false;
            this._composedFlag = eventInit.composed || false;
        }
        this._initializedFlag = true;
        this._timeStamp = new Date().getTime();
    }
    Object.defineProperty(EventImpl.prototype, "type", {
        /** @inheritdoc */ get: function() {
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "target", {
        /** @inheritdoc */ get: function() {
            return this._target;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "srcElement", {
        /** @inheritdoc */ get: function() {
            return this._target;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "currentTarget", {
        /** @inheritdoc */ get: function() {
            return this._currentTarget;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ EventImpl.prototype.composedPath = function() {
        /**
         * 1. Let composedPath be an empty list.
         * 2. Let path be the context object’s path.
         * 3. If path is empty, then return composedPath.
         * 4. Let currentTarget be the context object’s currentTarget attribute
         * value.
         * 5. Append currentTarget to composedPath.
         * 6. Let currentTargetIndex be 0.
         * 7. Let currentTargetHiddenSubtreeLevel be 0.
         */ var composedPath = [];
        var path = this._path;
        if (path.length === 0) return composedPath;
        var currentTarget = this._currentTarget;
        if (currentTarget === null) {
            throw new Error("Event currentTarget is null.");
        }
        composedPath.push(currentTarget);
        var currentTargetIndex = 0;
        var currentTargetHiddenSubtreeLevel = 0;
        /**
         * 8. Let index be path’s size − 1.
         * 9. While index is greater than or equal to 0:
         */ var index = path.length - 1;
        while(index >= 0){
            /**
             * 9.1. If path[index]'s root-of-closed-tree is true, then increase
             * currentTargetHiddenSubtreeLevel by 1.
             * 9.2. If path[index]'s invocation target is currentTarget, then set
             * currentTargetIndex to index and break.
             * 9.3. If path[index]'s slot-in-closed-tree is true, then decrease
             * currentTargetHiddenSubtreeLevel by 1.
             * 9.4. Decrease index by 1.
             */ if (path[index].rootOfClosedTree) {
                currentTargetHiddenSubtreeLevel++;
            }
            if (path[index].invocationTarget === currentTarget) {
                currentTargetIndex = index;
                break;
            }
            if (path[index].slotInClosedTree) {
                currentTargetHiddenSubtreeLevel--;
            }
            index--;
        }
        /**
         * 10. Let currentHiddenLevel and maxHiddenLevel be
         * currentTargetHiddenSubtreeLevel.
         */ var currentHiddenLevel = currentTargetHiddenSubtreeLevel;
        var maxHiddenLevel = currentTargetHiddenSubtreeLevel;
        /**
         * 11. Set index to currentTargetIndex − 1.
         * 12. While index is greater than or equal to 0:
         */ index = currentTargetIndex - 1;
        while(index >= 0){
            /**
             * 12.1. If path[index]'s root-of-closed-tree is true, then increase
             * currentHiddenLevel by 1.
             * 12.2. If currentHiddenLevel is less than or equal to maxHiddenLevel,
             * then prepend path[index]'s invocation target to composedPath.
             */ if (path[index].rootOfClosedTree) {
                currentHiddenLevel++;
            }
            if (currentHiddenLevel <= maxHiddenLevel) {
                composedPath.unshift(path[index].invocationTarget);
            }
            /**
             * 12.3. If path[index]'s slot-in-closed-tree is true, then:
             */ if (path[index].slotInClosedTree) {
                /**
                 * 12.3.1. Decrease currentHiddenLevel by 1.
                 * 12.3.2. If currentHiddenLevel is less than maxHiddenLevel, then set
                 * maxHiddenLevel to currentHiddenLevel.
                 */ currentHiddenLevel--;
                if (currentHiddenLevel < maxHiddenLevel) {
                    maxHiddenLevel = currentHiddenLevel;
                }
            }
            /**
             * 12.4. Decrease index by 1.
             */ index--;
        }
        /**
         * 13. Set currentHiddenLevel and maxHiddenLevel to
         * currentTargetHiddenSubtreeLevel.
         */ currentHiddenLevel = currentTargetHiddenSubtreeLevel;
        maxHiddenLevel = currentTargetHiddenSubtreeLevel;
        /**
         * 14. Set index to currentTargetIndex + 1.
         * 15. While index is less than path’s size:
         */ index = currentTargetIndex + 1;
        while(index < path.length){
            /**
             * 15.1. If path[index]'s slot-in-closed-tree is true, then increase
             * currentHiddenLevel by 1.
             * 15.2. If currentHiddenLevel is less than or equal to maxHiddenLevel,
             * then append path[index]'s invocation target to composedPath.
             */ if (path[index].slotInClosedTree) {
                currentHiddenLevel++;
            }
            if (currentHiddenLevel <= maxHiddenLevel) {
                composedPath.push(path[index].invocationTarget);
            }
            /**
             * 15.3. If path[index]'s root-of-closed-tree is true, then:
             */ if (path[index].rootOfClosedTree) {
                /**
                 * 15.3.1. Decrease currentHiddenLevel by 1.
                 * 15.3.2. If currentHiddenLevel is less than maxHiddenLevel, then set
                 * maxHiddenLevel to currentHiddenLevel.
                 */ currentHiddenLevel--;
                if (currentHiddenLevel < maxHiddenLevel) {
                    maxHiddenLevel = currentHiddenLevel;
                }
            }
            /**
             * 15.4. Increase index by 1.
             */ index++;
        }
        /**
         * 16. Return composedPath.
         */ return composedPath;
    };
    Object.defineProperty(EventImpl.prototype, "eventPhase", {
        /** @inheritdoc */ get: function() {
            return this._eventPhase;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ EventImpl.prototype.stopPropagation = function() {
        this._stopPropagationFlag = true;
    };
    Object.defineProperty(EventImpl.prototype, "cancelBubble", {
        /** @inheritdoc */ get: function() {
            return this._stopPropagationFlag;
        },
        set: function(value) {
            if (value) this.stopPropagation();
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ EventImpl.prototype.stopImmediatePropagation = function() {
        this._stopPropagationFlag = true;
        this._stopImmediatePropagationFlag = true;
    };
    Object.defineProperty(EventImpl.prototype, "bubbles", {
        /** @inheritdoc */ get: function() {
            return this._bubbles;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "cancelable", {
        /** @inheritdoc */ get: function() {
            return this._cancelable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "returnValue", {
        /** @inheritdoc */ get: function() {
            return !this._canceledFlag;
        },
        set: function(value) {
            if (!value) {
                algorithm_1.event_setTheCanceledFlag(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ EventImpl.prototype.preventDefault = function() {
        algorithm_1.event_setTheCanceledFlag(this);
    };
    Object.defineProperty(EventImpl.prototype, "defaultPrevented", {
        /** @inheritdoc */ get: function() {
            return this._canceledFlag;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "composed", {
        /** @inheritdoc */ get: function() {
            return this._composedFlag;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "isTrusted", {
        /** @inheritdoc */ get: function() {
            return this._isTrusted;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventImpl.prototype, "timeStamp", {
        /** @inheritdoc */ get: function() {
            return this._timeStamp;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ EventImpl.prototype.initEvent = function(type, bubbles, cancelable) {
        if (bubbles === void 0) {
            bubbles = false;
        }
        if (cancelable === void 0) {
            cancelable = false;
        }
        /**
         * 1. If the context object’s dispatch flag is set, then return.
         */ if (this._dispatchFlag) return;
        /**
         * 2. Initialize the context object with type, bubbles, and cancelable.
         */ algorithm_1.event_initialize(this, type, bubbles, cancelable);
    };
    EventImpl.NONE = 0;
    EventImpl.CAPTURING_PHASE = 1;
    EventImpl.AT_TARGET = 2;
    EventImpl.BUBBLING_PHASE = 3;
    return EventImpl;
}();
exports.EventImpl = EventImpl;
/**
 * Define constants on prototype.
 */ WebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, "NONE", 0);
WebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, "CAPTURING_PHASE", 1);
WebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, "AT_TARGET", 2);
WebIDLAlgorithm_1.idl_defineConst(EventImpl.prototype, "BUBBLING_PHASE", 3); //# sourceMappingURL=EventImpl.js.map


/***/ }),

/***/ 73410:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMException_1 = __webpack_require__(28905);
var util_1 = __webpack_require__(57294);
var algorithm_1 = __webpack_require__(75306);
/**
 * Represents a target to which an event can be dispatched.
 */ var EventTargetImpl = /** @class */ function() {
    /**
     * Initializes a new instance of `EventTarget`.
     */ function EventTargetImpl() {}
    Object.defineProperty(EventTargetImpl.prototype, "_eventListenerList", {
        get: function() {
            return this.__eventListenerList || (this.__eventListenerList = []);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventTargetImpl.prototype, "_eventHandlerMap", {
        get: function() {
            return this.__eventHandlerMap || (this.__eventHandlerMap = {});
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ EventTargetImpl.prototype.addEventListener = function(type, callback, options) {
        if (options === void 0) {
            options = {
                passive: false,
                once: false,
                capture: false
            };
        }
        /**
         * 1. Let capture, passive, and once be the result of flattening more options.
         */ var _a = __read(algorithm_1.eventTarget_flattenMore(options), 3), capture = _a[0], passive = _a[1], once = _a[2];
        // convert callback function to EventListener, return if null
        var listenerCallback;
        if (!callback) {
            return;
        } else if (util_1.Guard.isEventListener(callback)) {
            listenerCallback = callback;
        } else {
            listenerCallback = {
                handleEvent: callback
            };
        }
        /**
         * 2. Add an event listener with the context object and an event listener
         * whose type is type, callback is callback, capture is capture, passive is
         * passive, and once is once.
         */ algorithm_1.eventTarget_addEventListener(this, {
            type: type,
            callback: listenerCallback,
            capture: capture,
            passive: passive,
            once: once,
            removed: false
        });
    };
    /** @inheritdoc */ EventTargetImpl.prototype.removeEventListener = function(type, callback, options) {
        /**
         * TODO: Implement realms
         * 1. If the context object’s relevant global object is a
         * ServiceWorkerGlobalScope object and its associated service worker’s
         * script resource’s has ever been evaluated flag is set, then throw
         * a TypeError. [SERVICE-WORKERS]
         */ if (options === void 0) {
            options = {
                capture: false
            };
        }
        /**
         * 2. Let capture be the result of flattening options.
         */ var capture = algorithm_1.eventTarget_flatten(options);
        if (!callback) return;
        /**
         * 3. If the context object’s event listener list contains an event listener
         * whose type is type, callback is callback, and capture is capture, then
         * remove an event listener with the context object and that event listener.
         */ for(var i = 0; i < this._eventListenerList.length; i++){
            var entry = this._eventListenerList[i];
            if (entry.type !== type || entry.capture !== capture) continue;
            if (util_1.Guard.isEventListener(callback) && entry.callback === callback) {
                algorithm_1.eventTarget_removeEventListener(this, entry, i);
                break;
            } else if (callback && entry.callback.handleEvent === callback) {
                algorithm_1.eventTarget_removeEventListener(this, entry, i);
                break;
            }
        }
    };
    /** @inheritdoc */ EventTargetImpl.prototype.dispatchEvent = function(event) {
        /**
         * 1. If event’s dispatch flag is set, or if its initialized flag is not
         * set, then throw an "InvalidStateError" DOMException.
         * 2. Initialize event’s isTrusted attribute to false.
         * 3. Return the result of dispatching event to the context object.
         */ if (event._dispatchFlag || !event._initializedFlag) {
            throw new DOMException_1.InvalidStateError();
        }
        event._isTrusted = false;
        return algorithm_1.event_dispatch(event, this);
    };
    /** @inheritdoc */ EventTargetImpl.prototype._getTheParent = function(event) {
        return null;
    };
    return EventTargetImpl;
}();
exports.EventTargetImpl = EventTargetImpl; //# sourceMappingURL=EventTargetImpl.js.map


/***/ }),

/***/ 31403:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var infra_1 = __webpack_require__(94317);
var algorithm_1 = __webpack_require__(75306);
var util_1 = __webpack_require__(57294);
var util_2 = __webpack_require__(96883);
/**
 * Represents a collection of elements.
 */ var HTMLCollectionImpl = /** @class */ function() {
    /**
     * Initializes a new instance of `HTMLCollection`.
     *
     * @param root - root node
     * @param filter - node filter
     */ function HTMLCollectionImpl(root, filter) {
        this._live = true;
        this._root = root;
        this._filter = filter;
        return new Proxy(this, this);
    }
    Object.defineProperty(HTMLCollectionImpl.prototype, "length", {
        /** @inheritdoc */ get: function() {
            var _this = this;
            /**
             * The length attribute’s getter must return the number of nodes
             * represented by the collection.
             */ var count = 0;
            var node = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, function(e) {
                return util_1.Guard.isElementNode(e) && _this._filter(e);
            });
            while(node !== null){
                count++;
                node = algorithm_1.tree_getNextDescendantNode(this._root, node, false, false, function(e) {
                    return util_1.Guard.isElementNode(e) && _this._filter(e);
                });
            }
            return count;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ HTMLCollectionImpl.prototype.item = function(index) {
        var _this = this;
        /**
         * The item(index) method, when invoked, must return the indexth element
         * in the collection. If there is no indexth element in the collection,
         * then the method must return null.
         */ var i = 0;
        var node = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, function(e) {
            return util_1.Guard.isElementNode(e) && _this._filter(e);
        });
        while(node !== null){
            if (i === index) return node;
            else i++;
            node = algorithm_1.tree_getNextDescendantNode(this._root, node, false, false, function(e) {
                return util_1.Guard.isElementNode(e) && _this._filter(e);
            });
        }
        return null;
    };
    /** @inheritdoc */ HTMLCollectionImpl.prototype.namedItem = function(key) {
        var _this = this;
        /**
         * 1. If key is the empty string, return null.
         * 2. Return the first element in the collection for which at least one of
         * the following is true:
         * - it has an ID which is key;
         * - it is in the HTML namespace and has a name attribute whose value is key;
         * or null if there is no such element.
         */ if (key === "") return null;
        var ele = algorithm_1.tree_getFirstDescendantNode(this._root, false, false, function(e) {
            return util_1.Guard.isElementNode(e) && _this._filter(e);
        });
        while(ele != null){
            if (ele._uniqueIdentifier === key) {
                return ele;
            } else if (ele._namespace === infra_1.namespace.HTML) {
                for(var i = 0; i < ele._attributeList.length; i++){
                    var attr = ele._attributeList[i];
                    if (attr._localName === "name" && attr._namespace === null && attr._namespacePrefix === null && attr._value === key) return ele;
                }
            }
            ele = algorithm_1.tree_getNextDescendantNode(this._root, ele, false, false, function(e) {
                return util_1.Guard.isElementNode(e) && _this._filter(e);
            });
        }
        return null;
    };
    /** @inheritdoc */ HTMLCollectionImpl.prototype[Symbol.iterator] = function() {
        var root = this._root;
        var filter = this._filter;
        var currentNode = algorithm_1.tree_getFirstDescendantNode(root, false, false, function(e) {
            return util_1.Guard.isElementNode(e) && filter(e);
        });
        return {
            next: function() {
                if (currentNode === null) {
                    return {
                        done: true,
                        value: null
                    };
                } else {
                    var result = {
                        done: false,
                        value: currentNode
                    };
                    currentNode = algorithm_1.tree_getNextDescendantNode(root, currentNode, false, false, function(e) {
                        return util_1.Guard.isElementNode(e) && filter(e);
                    });
                    return result;
                }
            }
        };
    };
    /**
     * Implements a proxy get trap to provide array-like access.
     */ HTMLCollectionImpl.prototype.get = function(target, key, receiver) {
        if (!util_2.isString(key) || HTMLCollectionImpl.reservedNames.indexOf(key) !== -1) {
            return Reflect.get(target, key, receiver);
        }
        var index = Number(key);
        if (isNaN(index)) {
            return target.namedItem(key) || undefined;
        } else {
            return target.item(index) || undefined;
        }
    };
    /**
     * Implements a proxy set trap to provide array-like access.
     */ HTMLCollectionImpl.prototype.set = function(target, key, value, receiver) {
        if (!util_2.isString(key) || HTMLCollectionImpl.reservedNames.indexOf(key) !== -1) {
            return Reflect.set(target, key, value, receiver);
        }
        var index = Number(key);
        var node = isNaN(index) ? target.namedItem(key) || undefined : target.item(index) || undefined;
        if (node && node._parent) {
            algorithm_1.mutation_replace(node, value, node._parent);
            return true;
        } else {
            return false;
        }
    };
    /**
     * Creates a new `HTMLCollection`.
     *
     * @param root - root node
     * @param filter - node filter
     */ HTMLCollectionImpl._create = function(root, filter) {
        if (filter === void 0) {
            filter = function() {
                return true;
            };
        }
        return new HTMLCollectionImpl(root, filter);
    };
    HTMLCollectionImpl.reservedNames = [
        "_root",
        "_live",
        "_filter",
        "length",
        "item",
        "namedItem",
        "get",
        "set"
    ];
    return HTMLCollectionImpl;
}();
exports.HTMLCollectionImpl = HTMLCollectionImpl; //# sourceMappingURL=HTMLCollectionImpl.js.map


/***/ }),

/***/ 62359:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var util_1 = __webpack_require__(57294);
var infra_1 = __webpack_require__(94317);
/**
 * Represents an object that can be used to observe mutations to the tree of
 * nodes.
 */ var MutationObserverImpl = /** @class */ function() {
    /**
     * Initializes a new instance of `MutationObserver`.
     *
     * @param callback - the callback function
     */ function MutationObserverImpl(callback) {
        this._nodeList = [];
        this._recordQueue = [];
        /**
         * 1. Let mo be a new MutationObserver object whose callback is callback.
         * 2. Append mo to mo’s relevant agent’s mutation observers.
         * 3. Return mo.
         */ this._callback = callback;
        var window = DOMImpl_1.dom.window;
        infra_1.set.append(window._mutationObservers, this);
    }
    /** @inheritdoc */ MutationObserverImpl.prototype.observe = function(target, options) {
        var e_1, _a;
        options = options || {
            childList: false,
            subtree: false
        };
        /**
         * 1. If either options’s attributeOldValue or attributeFilter is present
         * and options’s attributes is omitted, then set options’s attributes
         * to true.
         * 2. If options’s characterDataOldValue is present and options’s
         * characterData is omitted, then set options’s characterData to true.
         * 3. If none of options’s childList, attributes, and characterData is
         * true, then throw a TypeError.
         * 4. If options’s attributeOldValue is true and options’s attributes is
         * false, then throw a TypeError.
         * 5. If options’s attributeFilter is present and options’s attributes is
         *  false, then throw a TypeError.
         * 6. If options’s characterDataOldValue is true and options’s characterData
         * is false, then throw a TypeError.
         */ if ((options.attributeOldValue !== undefined || options.attributeFilter !== undefined) && options.attributes === undefined) {
            options.attributes = true;
        }
        if (options.characterDataOldValue !== undefined && options.characterData === undefined) {
            options.characterData = true;
        }
        if (!options.childList && !options.attributes && !options.characterData) {
            throw new TypeError();
        }
        if (options.attributeOldValue && !options.attributes) {
            throw new TypeError();
        }
        if (options.attributeFilter !== undefined && !options.attributes) {
            throw new TypeError();
        }
        if (options.characterDataOldValue && !options.characterData) {
            throw new TypeError();
        }
        /**
         * 7. For each registered of target’s registered observer list, if
         * registered’s observer is the context object:
         */ var isRegistered = false;
        var coptions = options;
        var _loop_1 = function(registered) {
            var e_2, _a;
            if (registered.observer === this_1) {
                isRegistered = true;
                try {
                    /**
                     * 7.1. For each node of the context object’s node list, remove all
                     * transient registered observers whose source is registered from node’s
                     * registered observer list.
                     */ for(var _b = (e_2 = void 0, __values(this_1._nodeList)), _c = _b.next(); !_c.done; _c = _b.next()){
                        var node = _c.value;
                        infra_1.list.remove(node._registeredObserverList, function(ob) {
                            return util_1.Guard.isTransientRegisteredObserver(ob) && ob.source === registered;
                        });
                    }
                } catch (e_2_1) {
                    e_2 = {
                        error: e_2_1
                    };
                } finally{
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    } finally{
                        if (e_2) throw e_2.error;
                    }
                }
                /**
                 * 7.2. Set registered’s options to options.
                 */ registered.options = coptions;
            }
        };
        var this_1 = this;
        try {
            for(var _b = __values(target._registeredObserverList), _c = _b.next(); !_c.done; _c = _b.next()){
                var registered = _c.value;
                _loop_1(registered);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        /**
         * 8. Otherwise:
         * 8.1. Append a new registered observer whose observer is the context
         * object and options is options to target’s registered observer list.
         * 8.2. Append target to the context object’s node list.
         */ if (!isRegistered) {
            target._registeredObserverList.push({
                observer: this,
                options: options
            });
            this._nodeList.push(target);
        }
    };
    /** @inheritdoc */ MutationObserverImpl.prototype.disconnect = function() {
        var e_3, _a;
        var _this = this;
        try {
            /**
             * 1. For each node of the context object’s node list, remove any
             * registered observer from node’s registered observer list for which the
             * context object is the observer.
             */ for(var _b = __values(this._nodeList), _c = _b.next(); !_c.done; _c = _b.next()){
                var node = _c.value;
                infra_1.list.remove(node._registeredObserverList, function(ob) {
                    return ob.observer === _this;
                });
            }
        } catch (e_3_1) {
            e_3 = {
                error: e_3_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_3) throw e_3.error;
            }
        }
        /**
         * 2. Empty the context object’s record queue.
         */ this._recordQueue = [];
    };
    /** @inheritdoc */ MutationObserverImpl.prototype.takeRecords = function() {
        /**
         * 1. Let records be a clone of the context object’s record queue.
         * 2. Empty the context object’s record queue.
         * 3. Return records.
         */ var records = this._recordQueue;
        this._recordQueue = [];
        return records;
    };
    return MutationObserverImpl;
}();
exports.MutationObserverImpl = MutationObserverImpl; //# sourceMappingURL=MutationObserverImpl.js.map


/***/ }),

/***/ 68967:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Represents a mutation record.
 */ var MutationRecordImpl = /** @class */ function() {
    /**
     * Initializes a new instance of `MutationRecord`.
     *
     * @param type - type of mutation: `"attributes"` for an attribute
     * mutation, `"characterData"` for a mutation to a CharacterData node
     * and `"childList"` for a mutation to the tree of nodes.
     * @param target - node affected by the mutation.
     * @param addedNodes - list of added nodes.
     * @param removedNodes - list of removed nodes.
     * @param previousSibling - previous sibling of added or removed nodes.
     * @param nextSibling - next sibling of added or removed nodes.
     * @param attributeName - local name of the changed attribute,
     * and `null` otherwise.
     * @param attributeNamespace - namespace of the changed attribute,
     * and `null` otherwise.
     * @param oldValue - value before mutation: attribute value for an attribute
     * mutation, node `data` for a mutation to a CharacterData node and `null`
     * for a mutation to the tree of nodes.
     */ function MutationRecordImpl(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
        this._type = type;
        this._target = target;
        this._addedNodes = addedNodes;
        this._removedNodes = removedNodes;
        this._previousSibling = previousSibling;
        this._nextSibling = nextSibling;
        this._attributeName = attributeName;
        this._attributeNamespace = attributeNamespace;
        this._oldValue = oldValue;
    }
    Object.defineProperty(MutationRecordImpl.prototype, "type", {
        /** @inheritdoc */ get: function() {
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "target", {
        /** @inheritdoc */ get: function() {
            return this._target;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "addedNodes", {
        /** @inheritdoc */ get: function() {
            return this._addedNodes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "removedNodes", {
        /** @inheritdoc */ get: function() {
            return this._removedNodes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "previousSibling", {
        /** @inheritdoc */ get: function() {
            return this._previousSibling;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "nextSibling", {
        /** @inheritdoc */ get: function() {
            return this._nextSibling;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "attributeName", {
        /** @inheritdoc */ get: function() {
            return this._attributeName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "attributeNamespace", {
        /** @inheritdoc */ get: function() {
            return this._attributeNamespace;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationRecordImpl.prototype, "oldValue", {
        /** @inheritdoc */ get: function() {
            return this._oldValue;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new `MutationRecord`.
     *
     * @param type - type of mutation: `"attributes"` for an attribute
     * mutation, `"characterData"` for a mutation to a CharacterData node
     * and `"childList"` for a mutation to the tree of nodes.
     * @param target - node affected by the mutation.
     * @param addedNodes - list of added nodes.
     * @param removedNodes - list of removed nodes.
     * @param previousSibling - previous sibling of added or removed nodes.
     * @param nextSibling - next sibling of added or removed nodes.
     * @param attributeName - local name of the changed attribute,
     * and `null` otherwise.
     * @param attributeNamespace - namespace of the changed attribute,
     * and `null` otherwise.
     * @param oldValue - value before mutation: attribute value for an attribute
     * mutation, node `data` for a mutation to a CharacterData node and `null`
     * for a mutation to the tree of nodes.
     */ MutationRecordImpl._create = function(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue) {
        return new MutationRecordImpl(type, target, addedNodes, removedNodes, previousSibling, nextSibling, attributeName, attributeNamespace, oldValue);
    };
    return MutationRecordImpl;
}();
exports.MutationRecordImpl = MutationRecordImpl; //# sourceMappingURL=MutationRecordImpl.js.map


/***/ }),

/***/ 9846:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMException_1 = __webpack_require__(28905);
var algorithm_1 = __webpack_require__(75306);
/**
 * Represents a collection of attributes.
 */ var NamedNodeMapImpl = /** @class */ function(_super) {
    __extends(NamedNodeMapImpl, _super);
    /**
     * Initializes a new instance of `NamedNodeMap`.
     *
     * @param element - parent element
     */ function NamedNodeMapImpl(element) {
        var _this = _super.call(this) || this;
        _this._element = element;
        // TODO: This workaround is needed to extend Array in ES5
        Object.setPrototypeOf(_this, NamedNodeMapImpl.prototype);
        return _this;
    }
    NamedNodeMapImpl.prototype._asArray = function() {
        return this;
    };
    /** @inheritdoc */ NamedNodeMapImpl.prototype.item = function(index) {
        /**
         * 1. If index is equal to or greater than context object’s attribute list’s
         * size, then return null.
         * 2. Otherwise, return context object’s attribute list[index].
         *
         */ return this[index] || null;
    };
    /** @inheritdoc */ NamedNodeMapImpl.prototype.getNamedItem = function(qualifiedName) {
        /**
         * The getNamedItem(qualifiedName) method, when invoked, must return the
         * result of getting an attribute given qualifiedName and element.
         */ return algorithm_1.element_getAnAttributeByName(qualifiedName, this._element);
    };
    /** @inheritdoc */ NamedNodeMapImpl.prototype.getNamedItemNS = function(namespace, localName) {
        /**
         * The getNamedItemNS(namespace, localName) method, when invoked, must
         * return the result of getting an attribute given namespace, localName,
         * and element.
         */ return algorithm_1.element_getAnAttributeByNamespaceAndLocalName(namespace || "", localName, this._element);
    };
    /** @inheritdoc */ NamedNodeMapImpl.prototype.setNamedItem = function(attr) {
        /**
         * The setNamedItem(attr) and setNamedItemNS(attr) methods, when invoked,
         * must return the result of setting an attribute given attr and element.
         */ return algorithm_1.element_setAnAttribute(attr, this._element);
    };
    /** @inheritdoc */ NamedNodeMapImpl.prototype.setNamedItemNS = function(attr) {
        return algorithm_1.element_setAnAttribute(attr, this._element);
    };
    /** @inheritdoc */ NamedNodeMapImpl.prototype.removeNamedItem = function(qualifiedName) {
        /**
         * 1. Let attr be the result of removing an attribute given qualifiedName
         * and element.
         * 2. If attr is null, then throw a "NotFoundError" DOMException.
         * 3. Return attr.
         */ var attr = algorithm_1.element_removeAnAttributeByName(qualifiedName, this._element);
        if (attr === null) throw new DOMException_1.NotFoundError();
        return attr;
    };
    /** @inheritdoc */ NamedNodeMapImpl.prototype.removeNamedItemNS = function(namespace, localName) {
        /**
         * 1. Let attr be the result of removing an attribute given namespace,
         * localName, and element.
         * 2. If attr is null, then throw a "NotFoundError" DOMException.
         * 3. Return attr.
         */ var attr = algorithm_1.element_removeAnAttributeByNamespaceAndLocalName(namespace || "", localName, this._element);
        if (attr === null) throw new DOMException_1.NotFoundError();
        return attr;
    };
    /**
     * Creates a new `NamedNodeMap`.
     *
     * @param element - parent element
     */ NamedNodeMapImpl._create = function(element) {
        return new NamedNodeMapImpl(element);
    };
    return NamedNodeMapImpl;
}(Array);
exports.NamedNodeMapImpl = NamedNodeMapImpl; //# sourceMappingURL=NamedNodeMapImpl.js.map


/***/ }),

/***/ 32482:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
var WebIDLAlgorithm_1 = __webpack_require__(52510);
/**
 * Represents a node filter.
 */ var NodeFilterImpl = /** @class */ function() {
    /**
     * Initializes a new instance of `NodeFilter`.
     */ function NodeFilterImpl() {}
    /**
     * Callback function.
     */ NodeFilterImpl.prototype.acceptNode = function(node) {
        return interfaces_1.FilterResult.Accept;
    };
    /**
     * Creates a new `NodeFilter`.
     */ NodeFilterImpl._create = function() {
        return new NodeFilterImpl();
    };
    NodeFilterImpl.FILTER_ACCEPT = 1;
    NodeFilterImpl.FILTER_REJECT = 2;
    NodeFilterImpl.FILTER_SKIP = 3;
    NodeFilterImpl.SHOW_ALL = 0xffffffff;
    NodeFilterImpl.SHOW_ELEMENT = 0x1;
    NodeFilterImpl.SHOW_ATTRIBUTE = 0x2;
    NodeFilterImpl.SHOW_TEXT = 0x4;
    NodeFilterImpl.SHOW_CDATA_SECTION = 0x8;
    NodeFilterImpl.SHOW_ENTITY_REFERENCE = 0x10;
    NodeFilterImpl.SHOW_ENTITY = 0x20;
    NodeFilterImpl.SHOW_PROCESSING_INSTRUCTION = 0x40;
    NodeFilterImpl.SHOW_COMMENT = 0x80;
    NodeFilterImpl.SHOW_DOCUMENT = 0x100;
    NodeFilterImpl.SHOW_DOCUMENT_TYPE = 0x200;
    NodeFilterImpl.SHOW_DOCUMENT_FRAGMENT = 0x400;
    NodeFilterImpl.SHOW_NOTATION = 0x800;
    return NodeFilterImpl;
}();
exports.NodeFilterImpl = NodeFilterImpl;
/**
 * Define constants on prototype.
 */ WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "FILTER_ACCEPT", 1);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "FILTER_REJECT", 2);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "FILTER_SKIP", 3);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ALL", 0xffffffff);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ELEMENT", 0x1);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ATTRIBUTE", 0x2);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_TEXT", 0x4);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_CDATA_SECTION", 0x8);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ENTITY_REFERENCE", 0x10);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_ENTITY", 0x20);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_PROCESSING_INSTRUCTION", 0x40);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_COMMENT", 0x80);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_DOCUMENT", 0x100);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_DOCUMENT_TYPE", 0x200);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_DOCUMENT_FRAGMENT", 0x400);
WebIDLAlgorithm_1.idl_defineConst(NodeFilterImpl.prototype, "SHOW_NOTATION", 0x800); //# sourceMappingURL=NodeFilterImpl.js.map


/***/ }),

/***/ 37183:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var interfaces_1 = __webpack_require__(52580);
var EventTargetImpl_1 = __webpack_require__(73410);
var util_1 = __webpack_require__(57294);
var DOMException_1 = __webpack_require__(28905);
var algorithm_1 = __webpack_require__(75306);
var URLAlgorithm_1 = __webpack_require__(89233);
var WebIDLAlgorithm_1 = __webpack_require__(52510);
/**
 * Represents a generic XML node.
 */ var NodeImpl = /** @class */ function(_super) {
    __extends(NodeImpl, _super);
    /**
     * Initializes a new instance of `Node`.
     */ function NodeImpl() {
        var _this = _super.call(this) || this;
        _this._parent = null;
        _this._firstChild = null;
        _this._lastChild = null;
        _this._previousSibling = null;
        _this._nextSibling = null;
        return _this;
    }
    Object.defineProperty(NodeImpl.prototype, "_childNodes", {
        get: function() {
            return this.__childNodes || (this.__childNodes = algorithm_1.create_nodeList(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "_nodeDocument", {
        get: function() {
            return this._nodeDocumentOverride || DOMImpl_1.dom.window._associatedDocument;
        },
        set: function(val) {
            this._nodeDocumentOverride = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "_registeredObserverList", {
        get: function() {
            return this.__registeredObserverList || (this.__registeredObserverList = []);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "nodeType", {
        /** @inheritdoc */ get: function() {
            return this._nodeType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "nodeName", {
        /**
         * Returns a string appropriate for the type of node.
         */ get: function() {
            if (util_1.Guard.isElementNode(this)) {
                return this._htmlUppercasedQualifiedName;
            } else if (util_1.Guard.isAttrNode(this)) {
                return this._qualifiedName;
            } else if (util_1.Guard.isExclusiveTextNode(this)) {
                return "#text";
            } else if (util_1.Guard.isCDATASectionNode(this)) {
                return "#cdata-section";
            } else if (util_1.Guard.isProcessingInstructionNode(this)) {
                return this._target;
            } else if (util_1.Guard.isCommentNode(this)) {
                return "#comment";
            } else if (util_1.Guard.isDocumentNode(this)) {
                return "#document";
            } else if (util_1.Guard.isDocumentTypeNode(this)) {
                return this._name;
            } else if (util_1.Guard.isDocumentFragmentNode(this)) {
                return "#document-fragment";
            } else {
                return "";
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "baseURI", {
        /**
         * Gets the absolute base URL of the node.
         */ get: function() {
            /**
             * The baseURI attribute’s getter must return node document’s document
             * base URL, serialized.
             * TODO: Implement in HTML DOM
             * https://html.spec.whatwg.org/multipage/urls-and-fetching.html#document-base-url
             */ return URLAlgorithm_1.urlSerializer(this._nodeDocument._URL);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "isConnected", {
        /**
         * Returns whether the node is rooted to a document node.
         */ get: function() {
            /**
             * The isConnected attribute’s getter must return true, if context object
             * is connected, and false otherwise.
             */ return util_1.Guard.isElementNode(this) && algorithm_1.shadowTree_isConnected(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "ownerDocument", {
        /**
         * Returns the parent document.
         */ get: function() {
            /**
             * The ownerDocument attribute’s getter must return null, if the context
             * object is a document, and the context object’s node document otherwise.
             * _Note:_ The node document of a document is that document itself. All
             * nodes have a node document at all times.
             */ if (this._nodeType === interfaces_1.NodeType.Document) return null;
            else return this._nodeDocument;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the root node.
     *
     * @param options - if options has `composed = true` this function
     * returns the node's shadow-including root, otherwise it returns
     * the node's root node.
     */ NodeImpl.prototype.getRootNode = function(options) {
        /**
         * The getRootNode(options) method, when invoked, must return context
         * object’s shadow-including root if options’s composed is true,
         * and context object’s root otherwise.
         */ return algorithm_1.tree_rootNode(this, !!options && options.composed);
    };
    Object.defineProperty(NodeImpl.prototype, "parentNode", {
        /**
         * Returns the parent node.
         */ get: function() {
            /**
             * The parentNode attribute’s getter must return the context object’s parent.
             * _Note:_ An Attr node has no parent.
             */ if (this._nodeType === interfaces_1.NodeType.Attribute) {
                return null;
            } else {
                return this._parent;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "parentElement", {
        /**
         * Returns the parent element.
         */ get: function() {
            /**
             * The parentElement attribute’s getter must return the context object’s
             * parent element.
             */ if (this._parent && util_1.Guard.isElementNode(this._parent)) {
                return this._parent;
            } else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Determines whether a node has any children.
     */ NodeImpl.prototype.hasChildNodes = function() {
        /**
         * The hasChildNodes() method, when invoked, must return true if the context
         * object has children, and false otherwise.
         */ return this._firstChild !== null;
    };
    Object.defineProperty(NodeImpl.prototype, "childNodes", {
        /**
         * Returns a {@link NodeList} of child nodes.
         */ get: function() {
            /**
             * The childNodes attribute’s getter must return a NodeList rooted at the
             * context object matching only children.
             */ return this._childNodes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "firstChild", {
        /**
         * Returns the first child node.
         */ get: function() {
            /**
             * The firstChild attribute’s getter must return the context object’s first
             * child.
             */ return this._firstChild;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "lastChild", {
        /**
         * Returns the last child node.
         */ get: function() {
            /**
             * The lastChild attribute’s getter must return the context object’s last
             * child.
             */ return this._lastChild;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "previousSibling", {
        /**
         * Returns the previous sibling node.
         */ get: function() {
            /**
             * The previousSibling attribute’s getter must return the context object’s
             * previous sibling.
             * _Note:_ An Attr node has no siblings.
             */ return this._previousSibling;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "nextSibling", {
        /**
         * Returns the next sibling node.
         */ get: function() {
            /**
             * The nextSibling attribute’s getter must return the context object’s
             * next sibling.
             */ return this._nextSibling;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "nodeValue", {
        /**
         * Gets or sets the data associated with a {@link CharacterData} node or the
         * value of an {@link @Attr} node. For other node types returns `null`.
         */ get: function() {
            if (util_1.Guard.isAttrNode(this)) {
                return this._value;
            } else if (util_1.Guard.isCharacterDataNode(this)) {
                return this._data;
            } else {
                return null;
            }
        },
        set: function(value) {
            if (value === null) {
                value = "";
            }
            if (util_1.Guard.isAttrNode(this)) {
                algorithm_1.attr_setAnExistingAttributeValue(this, value);
            } else if (util_1.Guard.isCharacterDataNode(this)) {
                algorithm_1.characterData_replaceData(this, 0, this._data.length, value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeImpl.prototype, "textContent", {
        /**
         * Returns the concatenation of data of all the {@link Text}
         * node descendants in tree order. When set, replaces the text
         * contents of the node with the given value.
         */ get: function() {
            if (util_1.Guard.isDocumentFragmentNode(this) || util_1.Guard.isElementNode(this)) {
                return algorithm_1.text_descendantTextContent(this);
            } else if (util_1.Guard.isAttrNode(this)) {
                return this._value;
            } else if (util_1.Guard.isCharacterDataNode(this)) {
                return this._data;
            } else {
                return null;
            }
        },
        set: function(value) {
            if (value === null) {
                value = "";
            }
            if (util_1.Guard.isDocumentFragmentNode(this) || util_1.Guard.isElementNode(this)) {
                algorithm_1.node_stringReplaceAll(value, this);
            } else if (util_1.Guard.isAttrNode(this)) {
                algorithm_1.attr_setAnExistingAttributeValue(this, value);
            } else if (util_1.Guard.isCharacterDataNode(this)) {
                algorithm_1.characterData_replaceData(this, 0, algorithm_1.tree_nodeLength(this), value);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Puts all {@link Text} nodes in the full depth of the sub-tree
     * underneath this node into a "normal" form where only markup
     * (e.g., tags, comments, processing instructions, CDATA sections,
     * and entity references) separates {@link Text} nodes, i.e., there
     * are no adjacent Text nodes.
     */ NodeImpl.prototype.normalize = function() {
        var e_1, _a, e_2, _b;
        /**
         * The normalize() method, when invoked, must run these steps for each
         * descendant exclusive Text node node of context object:
         */ var descendantNodes = [];
        var node = algorithm_1.tree_getFirstDescendantNode(this, false, false, function(e) {
            return util_1.Guard.isExclusiveTextNode(e);
        });
        while(node !== null){
            descendantNodes.push(node);
            node = algorithm_1.tree_getNextDescendantNode(this, node, false, false, function(e) {
                return util_1.Guard.isExclusiveTextNode(e);
            });
        }
        for(var i = 0; i < descendantNodes.length; i++){
            var node_1 = descendantNodes[i];
            if (node_1._parent === null) continue;
            /**
             * 1. Let length be node’s length.
             * 2. If length is zero, then remove node and continue with the next
             * exclusive Text node, if any.
             */ var length = algorithm_1.tree_nodeLength(node_1);
            if (length === 0) {
                algorithm_1.mutation_remove(node_1, node_1._parent);
                continue;
            }
            /**
             * 3. Let data be the concatenation of the data of node’s contiguous
             * exclusive Text nodes (excluding itself), in tree order.
             */ var textSiblings = [];
            var data = "";
            try {
                for(var _c = (e_1 = void 0, __values(algorithm_1.text_contiguousExclusiveTextNodes(node_1))), _d = _c.next(); !_d.done; _d = _c.next()){
                    var sibling = _d.value;
                    textSiblings.push(sibling);
                    data += sibling._data;
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            /**
             * 4. Replace data with node node, offset length, count 0, and data data.
             */ algorithm_1.characterData_replaceData(node_1, length, 0, data);
            /**
             * 5. Let currentNode be node’s next sibling.
             * 6. While currentNode is an exclusive Text node:
             */ if (DOMImpl_1.dom.rangeList.size !== 0) {
                var currentNode = node_1._nextSibling;
                while(currentNode !== null && util_1.Guard.isExclusiveTextNode(currentNode)){
                    /**
                     * 6.1. For each live range whose start node is currentNode, add length
                     * to its start offset and set its start node to node.
                     * 6.2. For each live range whose end node is currentNode, add length to
                     * its end offset and set its end node to node.
                     * 6.3. For each live range whose start node is currentNode’s parent and
                     * start offset is currentNode’s index, set its start node to node and
                     * its start offset to length.
                     * 6.4. For each live range whose end node is currentNode’s parent and
                     * end offset is currentNode’s index, set its end node to node and its
                     * end offset to length.
                     */ var cn = currentNode;
                    var index = algorithm_1.tree_index(cn);
                    try {
                        for(var _e = (e_2 = void 0, __values(DOMImpl_1.dom.rangeList)), _f = _e.next(); !_f.done; _f = _e.next()){
                            var range = _f.value;
                            if (range._start[0] === cn) {
                                range._start[0] = node_1;
                                range._start[1] += length;
                            }
                            if (range._end[0] === cn) {
                                range._end[0] = node_1;
                                range._end[1] += length;
                            }
                            if (range._start[0] === cn._parent && range._start[1] === index) {
                                range._start[0] = node_1;
                                range._start[1] = length;
                            }
                            if (range._end[0] === cn._parent && range._end[1] === index) {
                                range._end[0] = node_1;
                                range._end[1] = length;
                            }
                        }
                    } catch (e_2_1) {
                        e_2 = {
                            error: e_2_1
                        };
                    } finally{
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        } finally{
                            if (e_2) throw e_2.error;
                        }
                    }
                    /**
                     * 6.5. Add currentNode’s length to length.
                     * 6.6. Set currentNode to its next sibling.
                     */ length += algorithm_1.tree_nodeLength(currentNode);
                    currentNode = currentNode._nextSibling;
                }
            }
            /**
             * 7. Remove node’s contiguous exclusive Text nodes (excluding itself),
             * in tree order.
             */ for(var i_1 = 0; i_1 < textSiblings.length; i_1++){
                var sibling = textSiblings[i_1];
                if (sibling._parent === null) continue;
                algorithm_1.mutation_remove(sibling, sibling._parent);
            }
        }
    };
    /**
     * Returns a duplicate of this node, i.e., serves as a generic copy
     * constructor for nodes. The duplicate node has no parent
     * ({@link parentNode} returns `null`).
     *
     * @param deep - if `true`, recursively clone the subtree under the
     * specified node. If `false`, clone only the node itself (and its
     * attributes, if it is an {@link Element}).
     */ NodeImpl.prototype.cloneNode = function(deep) {
        if (deep === void 0) {
            deep = false;
        }
        /**
         * 1. If context object is a shadow root, then throw a "NotSupportedError"
         * DOMException.
         * 2. Return a clone of the context object, with the clone children flag set
         * if deep is true.
         */ if (util_1.Guard.isShadowRoot(this)) throw new DOMException_1.NotSupportedError();
        return algorithm_1.node_clone(this, null, deep);
    };
    /**
     * Determines if the given node is equal to this one.
     *
     * @param node - the node to compare with
     */ NodeImpl.prototype.isEqualNode = function(node) {
        if (node === void 0) {
            node = null;
        }
        /**
         * The isEqualNode(otherNode) method, when invoked, must return true if
         * otherNode is non-null and context object equals otherNode, and false
         * otherwise.
         */ return node !== null && algorithm_1.node_equals(this, node);
    };
    /**
     * Determines if the given node is reference equal to this one.
     *
     * @param node - the node to compare with
     */ NodeImpl.prototype.isSameNode = function(node) {
        if (node === void 0) {
            node = null;
        }
        /**
         * The isSameNode(otherNode) method, when invoked, must return true if
         * otherNode is context object, and false otherwise.
         */ return this === node;
    };
    /**
     * Returns a bitmask indicating the position of the given `node`
     * relative to this node.
     */ NodeImpl.prototype.compareDocumentPosition = function(other) {
        /**
         * 1. If context object is other, then return zero.
         * 2. Let node1 be other and node2 be context object.
         * 3. Let attr1 and attr2 be null.
         * attr1’s element.
         */ if (other === this) return 0;
        var node1 = other;
        var node2 = this;
        var attr1 = null;
        var attr2 = null;
        /**
         * 4. If node1 is an attribute, then set attr1 to node1 and node1 to
         * attr1’s element.
         */ if (util_1.Guard.isAttrNode(node1)) {
            attr1 = node1;
            node1 = attr1._element;
        }
        /**
         * 5. If node2 is an attribute, then:
         */ if (util_1.Guard.isAttrNode(node2)) {
            /**
             * 5.1. Set attr2 to node2 and node2 to attr2’s element.
             */ attr2 = node2;
            node2 = attr2._element;
            /**
             * 5.2. If attr1 and node1 are non-null, and node2 is node1, then:
             */ if (attr1 && node1 && node1 === node2) {
                /**
                 * 5.2. For each attr in node2’s attribute list:
                 */ for(var i = 0; i < node2._attributeList.length; i++){
                    var attr = node2._attributeList[i];
                    /**
                     * 5.2.1. If attr equals attr1, then return the result of adding
                     * DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and
                     * DOCUMENT_POSITION_PRECEDING.
                     * 5.2.2. If attr equals attr2, then return the result of adding
                     * DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and
                     * DOCUMENT_POSITION_FOLLOWING.
                     */ if (algorithm_1.node_equals(attr, attr1)) {
                        return interfaces_1.Position.ImplementationSpecific | interfaces_1.Position.Preceding;
                    } else if (algorithm_1.node_equals(attr, attr2)) {
                        return interfaces_1.Position.ImplementationSpecific | interfaces_1.Position.Following;
                    }
                }
            }
        }
        /**
         * 6. If node1 or node2 is null, or node1’s root is not node2’s root, then
         * return the result of adding DOCUMENT_POSITION_DISCONNECTED,
         * DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either
         * DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING,
         * with the constraint that this is to be consistent, together.
         */ if (node1 === null || node2 === null || algorithm_1.tree_rootNode(node1) !== algorithm_1.tree_rootNode(node2)) {
            // nodes are disconnected
            // return a random result but cache the value for consistency
            return interfaces_1.Position.Disconnected | interfaces_1.Position.ImplementationSpecific | (DOMImpl_1.dom.compareCache.check(this, other) ? interfaces_1.Position.Preceding : interfaces_1.Position.Following);
        }
        /**
         * 7. If node1 is an ancestor of node2 and attr1 is null, or node1 is node2
         * and attr2 is non-null, then return the result of adding
         * DOCUMENT_POSITION_CONTAINS to DOCUMENT_POSITION_PRECEDING.
         */ if (!attr1 && algorithm_1.tree_isAncestorOf(node2, node1) || attr2 && node1 === node2) {
            return interfaces_1.Position.Contains | interfaces_1.Position.Preceding;
        }
        /**
         * 8. If node1 is a descendant of node2 and attr2 is null, or node1 is node2
         * and attr1 is non-null, then return the result of adding
         * DOCUMENT_POSITION_CONTAINED_BY to DOCUMENT_POSITION_FOLLOWING.
         */ if (!attr2 && algorithm_1.tree_isDescendantOf(node2, node1) || attr1 && node1 === node2) {
            return interfaces_1.Position.ContainedBy | interfaces_1.Position.Following;
        }
        /**
         * 9. If node1 is preceding node2, then return DOCUMENT_POSITION_PRECEDING.
         */ if (algorithm_1.tree_isPreceding(node2, node1)) return interfaces_1.Position.Preceding;
        /**
         * 10. Return DOCUMENT_POSITION_FOLLOWING.
         */ return interfaces_1.Position.Following;
    };
    /**
     * Returns `true` if given node is an inclusive descendant of this
     * node, and `false` otherwise (including when other node is `null`).
     *
     * @param other - the node to check
     */ NodeImpl.prototype.contains = function(other) {
        /**
         * The contains(other) method, when invoked, must return true if other is an
         * inclusive descendant of context object, and false otherwise (including
         * when other is null).
         */ if (other === null) return false;
        return algorithm_1.tree_isDescendantOf(this, other, true);
    };
    /**
     * Returns the prefix for a given namespace URI, if present, and
     * `null` if not.
     *
     * @param namespace - the namespace to search
     */ NodeImpl.prototype.lookupPrefix = function(namespace) {
        /**
         * 1. If namespace is null or the empty string, then return null.
         * 2. Switch on the context object:
         */ if (!namespace) return null;
        if (util_1.Guard.isElementNode(this)) {
            /**
             * Return the result of locating a namespace prefix for it using
             * namespace.
             */ return algorithm_1.node_locateANamespacePrefix(this, namespace);
        } else if (util_1.Guard.isDocumentNode(this)) {
            /**
             * Return the result of locating a namespace prefix for its document
             * element, if its document element is non-null, and null otherwise.
             */ if (this.documentElement === null) {
                return null;
            } else {
                return algorithm_1.node_locateANamespacePrefix(this.documentElement, namespace);
            }
        } else if (util_1.Guard.isDocumentTypeNode(this) || util_1.Guard.isDocumentFragmentNode(this)) {
            return null;
        } else if (util_1.Guard.isAttrNode(this)) {
            /**
             * Return the result of locating a namespace prefix for its element,
             * if its element is non-null, and null otherwise.
             */ if (this._element === null) {
                return null;
            } else {
                return algorithm_1.node_locateANamespacePrefix(this._element, namespace);
            }
        } else {
            /**
             * Return the result of locating a namespace prefix for its parent
             * element, if its parent element is non-null, and null otherwise.
             */ if (this._parent !== null && util_1.Guard.isElementNode(this._parent)) {
                return algorithm_1.node_locateANamespacePrefix(this._parent, namespace);
            } else {
                return null;
            }
        }
    };
    /**
     * Returns the namespace URI for a given prefix if present, and `null`
     * if not.
     *
     * @param prefix - the prefix to search
     */ NodeImpl.prototype.lookupNamespaceURI = function(prefix) {
        /**
         * 1. If prefix is the empty string, then set it to null.
         * 2. Return the result of running locate a namespace for the context object
         * using prefix.
         */ return algorithm_1.node_locateANamespace(this, prefix || null);
    };
    /**
     * Returns `true` if the namespace is the default namespace on this
     * node or `false` if not.
     *
     * @param namespace - the namespace to check
     */ NodeImpl.prototype.isDefaultNamespace = function(namespace) {
        /**
         * 1. If namespace is the empty string, then set it to null.
         * 2. Let defaultNamespace be the result of running locate a namespace for
         * context object using null.
         * 3. Return true if defaultNamespace is the same as namespace, and false otherwise.
         */ if (!namespace) namespace = null;
        var defaultNamespace = algorithm_1.node_locateANamespace(this, null);
        return defaultNamespace === namespace;
    };
    /**
     * Inserts the node `newChild` before the existing child node
     * `refChild`. If `refChild` is `null`, inserts `newChild` at the end
     * of the list of children.
     *
     * If `newChild` is a {@link DocumentFragment} object, all of its
     * children are inserted, in the same order, before `refChild`.
     *
     * If `newChild` is already in the tree, it is first removed.
     *
     * @param newChild - the node to insert
     * @param refChild - the node before which the new node must be
     *   inserted
     *
     * @returns the newly inserted child node
     */ NodeImpl.prototype.insertBefore = function(newChild, refChild) {
        /**
         * The insertBefore(node, child) method, when invoked, must return the
         * result of pre-inserting node into context object before child.
         */ return algorithm_1.mutation_preInsert(newChild, this, refChild);
    };
    /**
     * Adds the node `newChild` to the end of the list of children of this
     * node, and returns it. If `newChild` is already in the tree, it is
     * first removed.
     *
     * If `newChild` is a {@link DocumentFragment} object, the entire
     * contents of the document fragment are moved into the child list of
     * this node.
     *
     * @param newChild - the node to add
     *
     * @returns the newly inserted child node
     */ NodeImpl.prototype.appendChild = function(newChild) {
        /**
         * The appendChild(node) method, when invoked, must return the result of
         * appending node to context object.
         */ return algorithm_1.mutation_append(newChild, this);
    };
    /**
     * Replaces the child node `oldChild` with `newChild` in the list of
     * children, and returns the `oldChild` node. If `newChild` is already
     * in the tree, it is first removed.
     *
     * @param newChild - the new node to put in the child list
     * @param oldChild - the node being replaced in the list
     *
     * @returns the removed child node
     */ NodeImpl.prototype.replaceChild = function(newChild, oldChild) {
        /**
         * The replaceChild(node, child) method, when invoked, must return the
         * result of replacing child with node within context object.
         */ return algorithm_1.mutation_replace(oldChild, newChild, this);
    };
    /**
    * Removes the child node indicated by `oldChild` from the list of
    * children, and returns it.
    *
    * @param oldChild - the node being removed from the list
    *
    * @returns the removed child node
    */ NodeImpl.prototype.removeChild = function(oldChild) {
        /**
         * The removeChild(child) method, when invoked, must return the result of
         * pre-removing child from context object.
         */ return algorithm_1.mutation_preRemove(oldChild, this);
    };
    /**
     * Gets the parent event target for the given event.
     *
     * @param event - an event
     */ NodeImpl.prototype._getTheParent = function(event) {
        /**
         * A node’s get the parent algorithm, given an event, returns the node’s
         * assigned slot, if node is assigned, and node’s parent otherwise.
         */ if (util_1.Guard.isSlotable(this) && algorithm_1.shadowTree_isAssigned(this)) {
            return this._assignedSlot;
        } else {
            return this._parent;
        }
    };
    NodeImpl.ELEMENT_NODE = 1;
    NodeImpl.ATTRIBUTE_NODE = 2;
    NodeImpl.TEXT_NODE = 3;
    NodeImpl.CDATA_SECTION_NODE = 4;
    NodeImpl.ENTITY_REFERENCE_NODE = 5;
    NodeImpl.ENTITY_NODE = 6;
    NodeImpl.PROCESSING_INSTRUCTION_NODE = 7;
    NodeImpl.COMMENT_NODE = 8;
    NodeImpl.DOCUMENT_NODE = 9;
    NodeImpl.DOCUMENT_TYPE_NODE = 10;
    NodeImpl.DOCUMENT_FRAGMENT_NODE = 11;
    NodeImpl.NOTATION_NODE = 12;
    NodeImpl.DOCUMENT_POSITION_DISCONNECTED = 0x01;
    NodeImpl.DOCUMENT_POSITION_PRECEDING = 0x02;
    NodeImpl.DOCUMENT_POSITION_FOLLOWING = 0x04;
    NodeImpl.DOCUMENT_POSITION_CONTAINS = 0x08;
    NodeImpl.DOCUMENT_POSITION_CONTAINED_BY = 0x10;
    NodeImpl.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
    return NodeImpl;
}(EventTargetImpl_1.EventTargetImpl);
exports.NodeImpl = NodeImpl;
/**
 * A performance tweak to share an empty set between all node classes. This will
 * be overwritten by element, document and document fragment nodes to supply an
 * actual set of nodes.
 */ NodeImpl.prototype._children = new util_1.EmptySet();
/**
 * Define constants on prototype.
 */ WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "ELEMENT_NODE", 1);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "ATTRIBUTE_NODE", 2);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "TEXT_NODE", 3);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "CDATA_SECTION_NODE", 4);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "ENTITY_REFERENCE_NODE", 5);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "ENTITY_NODE", 6);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "PROCESSING_INSTRUCTION_NODE", 7);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "COMMENT_NODE", 8);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_NODE", 9);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_TYPE_NODE", 10);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_FRAGMENT_NODE", 11);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "NOTATION_NODE", 12);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_DISCONNECTED", 0x01);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_PRECEDING", 0x02);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_FOLLOWING", 0x04);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_CONTAINS", 0x08);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_CONTAINED_BY", 0x10);
WebIDLAlgorithm_1.idl_defineConst(NodeImpl.prototype, "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC", 0x20); //# sourceMappingURL=NodeImpl.js.map


/***/ }),

/***/ 70971:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var TraverserImpl_1 = __webpack_require__(85864);
var algorithm_1 = __webpack_require__(75306);
/**
 * Represents an object which can be used to iterate through the nodes
 * of a subtree.
 */ var NodeIteratorImpl = /** @class */ function(_super) {
    __extends(NodeIteratorImpl, _super);
    /**
     * Initializes a new instance of `NodeIterator`.
     */ function NodeIteratorImpl(root, reference, pointerBeforeReference) {
        var _this = _super.call(this, root) || this;
        _this._iteratorCollection = undefined;
        _this._reference = reference;
        _this._pointerBeforeReference = pointerBeforeReference;
        algorithm_1.nodeIterator_iteratorList().add(_this);
        return _this;
    }
    Object.defineProperty(NodeIteratorImpl.prototype, "referenceNode", {
        /** @inheritdoc */ get: function() {
            return this._reference;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeIteratorImpl.prototype, "pointerBeforeReferenceNode", {
        /** @inheritdoc */ get: function() {
            return this._pointerBeforeReference;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ NodeIteratorImpl.prototype.nextNode = function() {
        /**
         * The nextNode() method, when invoked, must return the result of
         * traversing with the context object and next.
         */ return algorithm_1.nodeIterator_traverse(this, true);
    };
    /** @inheritdoc */ NodeIteratorImpl.prototype.previousNode = function() {
        /**
         * The previousNode() method, when invoked, must return the result of
         * traversing with the context object and previous.
         */ return algorithm_1.nodeIterator_traverse(this, false);
    };
    /** @inheritdoc */ NodeIteratorImpl.prototype.detach = function() {
        /**
         * The detach() method, when invoked, must do nothing.
         *
         * since JS lacks weak references, we still use detach
         */ algorithm_1.nodeIterator_iteratorList().delete(this);
    };
    /**
     * Creates a new `NodeIterator`.
     *
     * @param root - iterator's root node
     * @param reference - reference node
     * @param pointerBeforeReference - whether the iterator is before or after the
     * reference node
     */ NodeIteratorImpl._create = function(root, reference, pointerBeforeReference) {
        return new NodeIteratorImpl(root, reference, pointerBeforeReference);
    };
    return NodeIteratorImpl;
}(TraverserImpl_1.TraverserImpl);
exports.NodeIteratorImpl = NodeIteratorImpl; //# sourceMappingURL=NodeIteratorImpl.js.map


/***/ }),

/***/ 37148:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var util_1 = __webpack_require__(96883);
var algorithm_1 = __webpack_require__(75306);
/**
 * Represents an ordered set of nodes.
 */ var NodeListImpl = /** @class */ function() {
    /**
     * Initializes a new instance of `NodeList`.
     *
     * @param root - root node
     */ function NodeListImpl(root) {
        this._live = true;
        this._filter = null;
        this._length = 0;
        this._root = root;
        return new Proxy(this, this);
    }
    Object.defineProperty(NodeListImpl.prototype, "length", {
        /** @inheritdoc */ get: function() {
            /**
             * The length attribute must return the number of nodes represented
             * by the collection.
             */ return this._root._children.size;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ NodeListImpl.prototype.item = function(index) {
        /**
         * The item(index) method must return the indexth node in the collection.
         * If there is no indexth node in the collection, then the method must
         * return null.
         */ if (index < 0 || index > this.length - 1) return null;
        if (index < this.length / 2) {
            var i = 0;
            var node = this._root._firstChild;
            while(node !== null && i !== index){
                node = node._nextSibling;
                i++;
            }
            return node;
        } else {
            var i = this.length - 1;
            var node = this._root._lastChild;
            while(node !== null && i !== index){
                node = node._previousSibling;
                i--;
            }
            return node;
        }
    };
    /** @inheritdoc */ NodeListImpl.prototype.keys = function() {
        var _a;
        return _a = {}, _a[Symbol.iterator] = (function() {
            var index = 0;
            return {
                next: (function() {
                    if (index === this.length) {
                        return {
                            done: true,
                            value: null
                        };
                    } else {
                        return {
                            done: false,
                            value: index++
                        };
                    }
                }).bind(this)
            };
        }).bind(this), _a;
    };
    /** @inheritdoc */ NodeListImpl.prototype.values = function() {
        var _a;
        return _a = {}, _a[Symbol.iterator] = (function() {
            var it = this[Symbol.iterator]();
            return {
                next: function() {
                    return it.next();
                }
            };
        }).bind(this), _a;
    };
    /** @inheritdoc */ NodeListImpl.prototype.entries = function() {
        var _a;
        return _a = {}, _a[Symbol.iterator] = (function() {
            var it = this[Symbol.iterator]();
            var index = 0;
            return {
                next: function() {
                    var itResult = it.next();
                    if (itResult.done) {
                        return {
                            done: true,
                            value: null
                        };
                    } else {
                        return {
                            done: false,
                            value: [
                                index++,
                                itResult.value
                            ]
                        };
                    }
                }
            };
        }).bind(this), _a;
    };
    /** @inheritdoc */ NodeListImpl.prototype[Symbol.iterator] = function() {
        return this._root._children[Symbol.iterator]();
    };
    /** @inheritdoc */ NodeListImpl.prototype.forEach = function(callback, thisArg) {
        var e_1, _a;
        if (thisArg === undefined) {
            thisArg = DOMImpl_1.dom.window;
        }
        var index = 0;
        try {
            for(var _b = __values(this._root._children), _c = _b.next(); !_c.done; _c = _b.next()){
                var node = _c.value;
                callback.call(thisArg, node, index++, this);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
    };
    /**
     * Implements a proxy get trap to provide array-like access.
     */ NodeListImpl.prototype.get = function(target, key, receiver) {
        if (!util_1.isString(key)) {
            return Reflect.get(target, key, receiver);
        }
        var index = Number(key);
        if (isNaN(index)) {
            return Reflect.get(target, key, receiver);
        }
        return target.item(index) || undefined;
    };
    /**
     * Implements a proxy set trap to provide array-like access.
     */ NodeListImpl.prototype.set = function(target, key, value, receiver) {
        if (!util_1.isString(key)) {
            return Reflect.set(target, key, value, receiver);
        }
        var index = Number(key);
        if (isNaN(index)) {
            return Reflect.set(target, key, value, receiver);
        }
        var node = target.item(index) || undefined;
        if (!node) return false;
        if (node._parent) {
            algorithm_1.mutation_replace(node, value, node._parent);
            return true;
        } else {
            return false;
        }
    };
    /**
     * Creates a new `NodeList`.
     *
     * @param root - root node
     */ NodeListImpl._create = function(root) {
        return new NodeListImpl(root);
    };
    return NodeListImpl;
}();
exports.NodeListImpl = NodeListImpl; //# sourceMappingURL=NodeListImpl.js.map


/***/ }),

/***/ 22020:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var util_1 = __webpack_require__(96883);
/**
 * Represents an ordered list of nodes.
 * This is a static implementation of `NodeList`.
 */ var NodeListStaticImpl = /** @class */ function() {
    /**
     * Initializes a new instance of `NodeList`.
     *
     * @param root - root node
     */ function NodeListStaticImpl(root) {
        this._live = false;
        this._items = [];
        this._length = 0;
        this._root = root;
        this._items = [];
        this._filter = function(node) {
            return true;
        };
        return new Proxy(this, this);
    }
    Object.defineProperty(NodeListStaticImpl.prototype, "length", {
        /** @inheritdoc */ get: function() {
            /**
             * The length attribute must return the number of nodes represented by
             * the collection.
             */ return this._items.length;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ NodeListStaticImpl.prototype.item = function(index) {
        /**
         * The item(index) method must return the indexth node in the collection.
         * If there is no indexth node in the collection, then the method must
         * return null.
         */ if (index < 0 || index > this.length - 1) return null;
        return this._items[index];
    };
    /** @inheritdoc */ NodeListStaticImpl.prototype.keys = function() {
        var _a;
        return _a = {}, _a[Symbol.iterator] = (function() {
            var index = 0;
            return {
                next: (function() {
                    if (index === this.length) {
                        return {
                            done: true,
                            value: null
                        };
                    } else {
                        return {
                            done: false,
                            value: index++
                        };
                    }
                }).bind(this)
            };
        }).bind(this), _a;
    };
    /** @inheritdoc */ NodeListStaticImpl.prototype.values = function() {
        var _a;
        return _a = {}, _a[Symbol.iterator] = (function() {
            var it = this[Symbol.iterator]();
            return {
                next: function() {
                    return it.next();
                }
            };
        }).bind(this), _a;
    };
    /** @inheritdoc */ NodeListStaticImpl.prototype.entries = function() {
        var _a;
        return _a = {}, _a[Symbol.iterator] = (function() {
            var it = this[Symbol.iterator]();
            var index = 0;
            return {
                next: function() {
                    var itResult = it.next();
                    if (itResult.done) {
                        return {
                            done: true,
                            value: null
                        };
                    } else {
                        return {
                            done: false,
                            value: [
                                index++,
                                itResult.value
                            ]
                        };
                    }
                }
            };
        }).bind(this), _a;
    };
    /** @inheritdoc */ NodeListStaticImpl.prototype[Symbol.iterator] = function() {
        var it = this._items[Symbol.iterator]();
        return {
            next: function() {
                return it.next();
            }
        };
    };
    /** @inheritdoc */ NodeListStaticImpl.prototype.forEach = function(callback, thisArg) {
        var e_1, _a;
        if (thisArg === undefined) {
            thisArg = DOMImpl_1.dom.window;
        }
        var index = 0;
        try {
            for(var _b = __values(this._items), _c = _b.next(); !_c.done; _c = _b.next()){
                var node = _c.value;
                callback.call(thisArg, node, index++, this);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
    };
    /**
     * Implements a proxy get trap to provide array-like access.
     */ NodeListStaticImpl.prototype.get = function(target, key, receiver) {
        if (!util_1.isString(key)) {
            return Reflect.get(target, key, receiver);
        }
        var index = Number(key);
        if (isNaN(index)) {
            return Reflect.get(target, key, receiver);
        }
        return target._items[index] || undefined;
    };
    /**
     * Implements a proxy set trap to provide array-like access.
     */ NodeListStaticImpl.prototype.set = function(target, key, value, receiver) {
        if (!util_1.isString(key)) {
            return Reflect.set(target, key, value, receiver);
        }
        var index = Number(key);
        if (isNaN(index)) {
            return Reflect.set(target, key, value, receiver);
        }
        if (index >= 0 && index < target._items.length) {
            target._items[index] = value;
            return true;
        } else {
            return false;
        }
    };
    /**
     * Creates a new `NodeList`.
     *
     * @param root - root node
     * @param items - a list of items to initialize the list
     */ NodeListStaticImpl._create = function(root, items) {
        var list = new NodeListStaticImpl(root);
        list._items = items;
        return list;
    };
    return NodeListStaticImpl;
}();
exports.NodeListStaticImpl = NodeListStaticImpl; //# sourceMappingURL=NodeListStaticImpl.js.map


/***/ }),

/***/ 45145:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(57294);
/**
 * Represents a mixin that extends child nodes that can have siblings
 * other than doctypes. This mixin is implemented by {@link Element} and
 * {@link CharacterData}.
 */ var NonDocumentTypeChildNodeImpl = /** @class */ function() {
    function NonDocumentTypeChildNodeImpl() {}
    Object.defineProperty(NonDocumentTypeChildNodeImpl.prototype, "previousElementSibling", {
        /** @inheritdoc */ get: function() {
            /**
             * The previousElementSibling attribute’s getter must return the first
             * preceding sibling that is an element, and null otherwise.
             */ var node = util_1.Cast.asNode(this)._previousSibling;
            while(node){
                if (util_1.Guard.isElementNode(node)) return node;
                else node = node._previousSibling;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NonDocumentTypeChildNodeImpl.prototype, "nextElementSibling", {
        /** @inheritdoc */ get: function() {
            /**
             * The nextElementSibling attribute’s getter must return the first
             * following sibling that is an element, and null otherwise.
             */ var node = util_1.Cast.asNode(this)._nextSibling;
            while(node){
                if (util_1.Guard.isElementNode(node)) return node;
                else node = node._nextSibling;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    return NonDocumentTypeChildNodeImpl;
}();
exports.NonDocumentTypeChildNodeImpl = NonDocumentTypeChildNodeImpl; //# sourceMappingURL=NonDocumentTypeChildNodeImpl.js.map


/***/ }),

/***/ 33437:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(57294);
var algorithm_1 = __webpack_require__(75306);
/**
 * Represents a mixin that extends non-element parent nodes. This mixin
 * is implemented by {@link Document} and {@link DocumentFragment}.
 */ var NonElementParentNodeImpl = /** @class */ function() {
    function NonElementParentNodeImpl() {}
    /** @inheritdoc */ NonElementParentNodeImpl.prototype.getElementById = function(id) {
        /**
         * The getElementById(elementId) method, when invoked, must return the first
         * element, in tree order, within the context object’s descendants,
         * whose ID is elementId, and null if there is no such element otherwise.
         */ var ele = algorithm_1.tree_getFirstDescendantNode(util_1.Cast.asNode(this), false, false, function(e) {
            return util_1.Guard.isElementNode(e);
        });
        while(ele !== null){
            if (ele._uniqueIdentifier === id) {
                return ele;
            }
            ele = algorithm_1.tree_getNextDescendantNode(util_1.Cast.asNode(this), ele, false, false, function(e) {
                return util_1.Guard.isElementNode(e);
            });
        }
        return null;
    };
    return NonElementParentNodeImpl;
}();
exports.NonElementParentNodeImpl = NonElementParentNodeImpl; //# sourceMappingURL=NonElementParentNodeImpl.js.map


/***/ }),

/***/ 3349:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(57294);
var algorithm_1 = __webpack_require__(75306);
/**
 * Represents a mixin that extends parent nodes that can have children.
 * This mixin is implemented by {@link Element}, {@link Document} and
 * {@link DocumentFragment}.
 */ var ParentNodeImpl = /** @class */ function() {
    function ParentNodeImpl() {}
    Object.defineProperty(ParentNodeImpl.prototype, "children", {
        /** @inheritdoc */ get: function() {
            /**
             * The children attribute’s getter must return an HTMLCollection collection
             * rooted at context object matching only element children.
             */ return algorithm_1.create_htmlCollection(util_1.Cast.asNode(this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParentNodeImpl.prototype, "firstElementChild", {
        /** @inheritdoc */ get: function() {
            /**
             * The firstElementChild attribute’s getter must return the first child
             * that is an element, and null otherwise.
             */ var node = util_1.Cast.asNode(this)._firstChild;
            while(node){
                if (util_1.Guard.isElementNode(node)) return node;
                else node = node._nextSibling;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParentNodeImpl.prototype, "lastElementChild", {
        /** @inheritdoc */ get: function() {
            /**
             * The lastElementChild attribute’s getter must return the last child that
             * is an element, and null otherwise.
             */ var node = util_1.Cast.asNode(this)._lastChild;
            while(node){
                if (util_1.Guard.isElementNode(node)) return node;
                else node = node._previousSibling;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParentNodeImpl.prototype, "childElementCount", {
        /** @inheritdoc */ get: function() {
            var e_1, _a;
            /**
             * The childElementCount attribute’s getter must return the number of
             * children of context object that are elements.
             */ var count = 0;
            try {
                for(var _b = __values(util_1.Cast.asNode(this)._children), _c = _b.next(); !_c.done; _c = _b.next()){
                    var childNode = _c.value;
                    if (util_1.Guard.isElementNode(childNode)) count++;
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            return count;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ ParentNodeImpl.prototype.prepend = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        /**
         * 1. Let node be the result of converting nodes into a node given nodes
         * and context object’s node document.
         * 2. Pre-insert node into context object before the context object’s first
         * child.
         */ var node = util_1.Cast.asNode(this);
        var childNode = algorithm_1.parentNode_convertNodesIntoANode(nodes, node._nodeDocument);
        algorithm_1.mutation_preInsert(childNode, node, node._firstChild);
    };
    /** @inheritdoc */ ParentNodeImpl.prototype.append = function() {
        var nodes = [];
        for(var _i = 0; _i < arguments.length; _i++){
            nodes[_i] = arguments[_i];
        }
        /**
         * 1. Let node be the result of converting nodes into a node given nodes
         * and context object’s node document.
         * 2. Append node to context object.
         */ var node = util_1.Cast.asNode(this);
        var childNode = algorithm_1.parentNode_convertNodesIntoANode(nodes, node._nodeDocument);
        algorithm_1.mutation_append(childNode, node);
    };
    /** @inheritdoc */ ParentNodeImpl.prototype.querySelector = function(selectors) {
        /**
         * The querySelector(selectors) method, when invoked, must return the first
         * result of running scope-match a selectors string selectors against
         * context object, if the result is not an empty list, and null otherwise.
         */ var node = util_1.Cast.asNode(this);
        var result = algorithm_1.selectors_scopeMatchASelectorsString(selectors, node);
        return result.length === 0 ? null : result[0];
    };
    /** @inheritdoc */ ParentNodeImpl.prototype.querySelectorAll = function(selectors) {
        /**
         * The querySelectorAll(selectors) method, when invoked, must return the
         * static result of running scope-match a selectors string selectors against
         * context object.
         */ var node = util_1.Cast.asNode(this);
        var result = algorithm_1.selectors_scopeMatchASelectorsString(selectors, node);
        return algorithm_1.create_nodeListStatic(node, result);
    };
    return ParentNodeImpl;
}();
exports.ParentNodeImpl = ParentNodeImpl; //# sourceMappingURL=ParentNodeImpl.js.map


/***/ }),

/***/ 66617:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
var CharacterDataImpl_1 = __webpack_require__(1753);
var WebIDLAlgorithm_1 = __webpack_require__(52510);
/**
 * Represents a processing instruction node.
 */ var ProcessingInstructionImpl = /** @class */ function(_super) {
    __extends(ProcessingInstructionImpl, _super);
    /**
     * Initializes a new instance of `ProcessingInstruction`.
     */ function ProcessingInstructionImpl(target, data) {
        var _this = _super.call(this, data) || this;
        _this._target = target;
        return _this;
    }
    Object.defineProperty(ProcessingInstructionImpl.prototype, "target", {
        /**
         * Gets the target of the {@link ProcessingInstruction} node.
         */ get: function() {
            return this._target;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new `ProcessingInstruction`.
     *
     * @param document - owner document
     * @param target - instruction target
     * @param data - node contents
     */ ProcessingInstructionImpl._create = function(document, target, data) {
        var node = new ProcessingInstructionImpl(target, data);
        node._nodeDocument = document;
        return node;
    };
    return ProcessingInstructionImpl;
}(CharacterDataImpl_1.CharacterDataImpl);
exports.ProcessingInstructionImpl = ProcessingInstructionImpl;
/**
 * Initialize prototype properties
 */ WebIDLAlgorithm_1.idl_defineConst(ProcessingInstructionImpl.prototype, "_nodeType", interfaces_1.NodeType.ProcessingInstruction); //# sourceMappingURL=ProcessingInstructionImpl.js.map


/***/ }),

/***/ 39694:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DOMImpl_1 = __webpack_require__(21436);
var interfaces_1 = __webpack_require__(52580);
var AbstractRangeImpl_1 = __webpack_require__(58209);
var DOMException_1 = __webpack_require__(28905);
var algorithm_1 = __webpack_require__(75306);
var WebIDLAlgorithm_1 = __webpack_require__(52510);
var util_1 = __webpack_require__(57294);
/**
 * Represents a live range.
 */ var RangeImpl = /** @class */ function(_super) {
    __extends(RangeImpl, _super);
    /**
     * Initializes a new instance of `Range`.
     */ function RangeImpl() {
        var _this = _super.call(this) || this;
        /**
         * The Range() constructor, when invoked, must return a new live range with
         * (current global object’s associated Document, 0) as its start and end.
         */ var doc = DOMImpl_1.dom.window._associatedDocument;
        _this._start = [
            doc,
            0
        ];
        _this._end = [
            doc,
            0
        ];
        DOMImpl_1.dom.rangeList.add(_this);
        return _this;
    }
    Object.defineProperty(RangeImpl.prototype, "commonAncestorContainer", {
        /** @inheritdoc */ get: function() {
            /**
             * 1. Let container be start node.
             * 2. While container is not an inclusive ancestor of end node, let
             * container be container’s parent.
             * 3. Return container.
             */ var container = this._start[0];
            while(!algorithm_1.tree_isAncestorOf(this._end[0], container, true)){
                if (container._parent === null) {
                    throw new Error("Parent node  is null.");
                }
                container = container._parent;
            }
            return container;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ RangeImpl.prototype.setStart = function(node, offset) {
        /**
         * The setStart(node, offset) method, when invoked, must set the start of
         * context object to boundary point (node, offset).
         */ algorithm_1.range_setTheStart(this, node, offset);
    };
    /** @inheritdoc */ RangeImpl.prototype.setEnd = function(node, offset) {
        /**
         * The setEnd(node, offset) method, when invoked, must set the end of
         * context object to boundary point (node, offset).
         */ algorithm_1.range_setTheEnd(this, node, offset);
    };
    /** @inheritdoc */ RangeImpl.prototype.setStartBefore = function(node) {
        /**
         * 1. Let parent be node’s parent.
         * 2. If parent is null, then throw an "InvalidNodeTypeError" DOMException.
         * 3. Set the start of the context object to boundary point
         * (parent, node’s index).
         */ var parent = node._parent;
        if (parent === null) throw new DOMException_1.InvalidNodeTypeError();
        algorithm_1.range_setTheStart(this, parent, algorithm_1.tree_index(node));
    };
    /** @inheritdoc */ RangeImpl.prototype.setStartAfter = function(node) {
        /**
         * 1. Let parent be node’s parent.
         * 2. If parent is null, then throw an "InvalidNodeTypeError" DOMException.
         * 3. Set the start of the context object to boundary point
         * (parent, node’s index plus 1).
         */ var parent = node._parent;
        if (parent === null) throw new DOMException_1.InvalidNodeTypeError();
        algorithm_1.range_setTheStart(this, parent, algorithm_1.tree_index(node) + 1);
    };
    /** @inheritdoc */ RangeImpl.prototype.setEndBefore = function(node) {
        /**
         * 1. Let parent be node’s parent.
         * 2. If parent is null, then throw an "InvalidNodeTypeError" DOMException.
         * 3. Set the end of the context object to boundary point
         * (parent, node’s index).
         */ var parent = node._parent;
        if (parent === null) throw new DOMException_1.InvalidNodeTypeError();
        algorithm_1.range_setTheEnd(this, parent, algorithm_1.tree_index(node));
    };
    /** @inheritdoc */ RangeImpl.prototype.setEndAfter = function(node) {
        /**
         * 1. Let parent be node’s parent.
         * 2. If parent is null, then throw an "InvalidNodeTypeError" DOMException.
         * 3. Set the end of the context object to boundary point
         * (parent, node’s index plus 1).
         */ var parent = node._parent;
        if (parent === null) throw new DOMException_1.InvalidNodeTypeError();
        algorithm_1.range_setTheEnd(this, parent, algorithm_1.tree_index(node) + 1);
    };
    /** @inheritdoc */ RangeImpl.prototype.collapse = function(toStart) {
        /**
         * The collapse(toStart) method, when invoked, must if toStart is true,
         * set end to start, and set start to end otherwise.
         */ if (toStart) {
            this._end = this._start;
        } else {
            this._start = this._end;
        }
    };
    /** @inheritdoc */ RangeImpl.prototype.selectNode = function(node) {
        /**
         * The selectNode(node) method, when invoked, must select node within
         * context object.
         */ algorithm_1.range_select(node, this);
    };
    /** @inheritdoc */ RangeImpl.prototype.selectNodeContents = function(node) {
        /**
         * 1. If node is a doctype, throw an "InvalidNodeTypeError" DOMException.
         * 2. Let length be the length of node.
         * 3. Set start to the boundary point (node, 0).
         * 4. Set end to the boundary point (node, length).
         */ if (util_1.Guard.isDocumentTypeNode(node)) throw new DOMException_1.InvalidNodeTypeError();
        var length = algorithm_1.tree_nodeLength(node);
        this._start = [
            node,
            0
        ];
        this._end = [
            node,
            length
        ];
    };
    /** @inheritdoc */ RangeImpl.prototype.compareBoundaryPoints = function(how, sourceRange) {
        /**
         * 1. If how is not one of
         * - START_TO_START,
         * - START_TO_END,
         * - END_TO_END, and
         * - END_TO_START,
         * then throw a "NotSupportedError" DOMException.
         */ if (how !== interfaces_1.HowToCompare.StartToStart && how !== interfaces_1.HowToCompare.StartToEnd && how !== interfaces_1.HowToCompare.EndToEnd && how !== interfaces_1.HowToCompare.EndToStart) throw new DOMException_1.NotSupportedError();
        /**
         * 2. If context object’s root is not the same as sourceRange’s root,
         * then throw a "WrongDocumentError" DOMException.
         */ if (algorithm_1.range_root(this) !== algorithm_1.range_root(sourceRange)) throw new DOMException_1.WrongDocumentError();
        /**
         * 3. If how is:
         * - START_TO_START:
         * Let this point be the context object’s start. Let other point be
         * sourceRange’s start.
         * - START_TO_END:
         * Let this point be the context object’s end. Let other point be
         * sourceRange’s start.
         * - END_TO_END:
         * Let this point be the context object’s end. Let other point be
         * sourceRange’s end.
         * - END_TO_START:
         * Let this point be the context object’s start. Let other point be
         * sourceRange’s end.
         */ var thisPoint;
        var otherPoint;
        switch(how){
            case interfaces_1.HowToCompare.StartToStart:
                thisPoint = this._start;
                otherPoint = sourceRange._start;
                break;
            case interfaces_1.HowToCompare.StartToEnd:
                thisPoint = this._end;
                otherPoint = sourceRange._start;
                break;
            case interfaces_1.HowToCompare.EndToEnd:
                thisPoint = this._end;
                otherPoint = sourceRange._end;
                break;
            case interfaces_1.HowToCompare.EndToStart:
                thisPoint = this._start;
                otherPoint = sourceRange._end;
                break;
            /* istanbul ignore next */ default:
                throw new DOMException_1.NotSupportedError();
        }
        /**
         * 4. If the position of this point relative to other point is
         * - before
         * Return −1.
         * - equal
         * Return 0.
         * - after
         * Return 1.
         */ var position = algorithm_1.boundaryPoint_position(thisPoint, otherPoint);
        if (position === interfaces_1.BoundaryPosition.Before) {
            return -1;
        } else if (position === interfaces_1.BoundaryPosition.After) {
            return 1;
        } else {
            return 0;
        }
    };
    /** @inheritdoc */ RangeImpl.prototype.deleteContents = function() {
        var e_1, _a, e_2, _b;
        /**
         * 1. If the context object is collapsed, then return.
         * 2. Let original start node, original start offset, original end node,
         * and original end offset be the context object’s start node,
         * start offset, end node, and end offset, respectively.
         */ if (algorithm_1.range_collapsed(this)) return;
        var originalStartNode = this._startNode;
        var originalStartOffset = this._startOffset;
        var originalEndNode = this._endNode;
        var originalEndOffset = this._endOffset;
        /**
         * 3. If original start node and original end node are the same, and they
         * are a Text, ProcessingInstruction, or Comment node, replace data with
         * node original start node, offset original start offset, count original
         * end offset minus original start offset, and data the empty string,
         * and then return.
         */ if (originalStartNode === originalEndNode && util_1.Guard.isCharacterDataNode(originalStartNode)) {
            algorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, originalEndOffset - originalStartOffset, "");
            return;
        }
        /**
         * 4. Let nodes to remove be a list of all the nodes that are contained in
         * the context object, in tree order, omitting any node whose parent is also
         * contained in the context object.
         */ var nodesToRemove = [];
        try {
            for(var _c = __values(algorithm_1.range_getContainedNodes(this)), _d = _c.next(); !_d.done; _d = _c.next()){
                var node = _d.value;
                var parent = node._parent;
                if (parent !== null && algorithm_1.range_isContained(parent, this)) {
                    continue;
                }
                nodesToRemove.push(node);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        var newNode;
        var newOffset;
        if (algorithm_1.tree_isAncestorOf(originalEndNode, originalStartNode, true)) {
            /**
             * 5. If original start node is an inclusive ancestor of original end
             * node, set new node to original start node and new offset to original
             * start offset.
             */ newNode = originalStartNode;
            newOffset = originalStartOffset;
        } else {
            /**
             * 6. Otherwise:
             * 6.1. Let reference node equal original start node.
             * 6.2. While reference node’s parent is not null and is not an inclusive
             * ancestor of original end node, set reference node to its parent.
             * 6.3. Set new node to the parent of reference node, and new offset to
             * one plus the index of reference node.
             */ var referenceNode = originalStartNode;
            while(referenceNode._parent !== null && !algorithm_1.tree_isAncestorOf(originalEndNode, referenceNode._parent, true)){
                referenceNode = referenceNode._parent;
            }
            /* istanbul ignore next */ if (referenceNode._parent === null) {
                throw new Error("Parent node is null.");
            }
            newNode = referenceNode._parent;
            newOffset = algorithm_1.tree_index(referenceNode) + 1;
        }
        /**
         * 7. If original start node is a Text, ProcessingInstruction, or Comment
         * node, replace data with node original start node, offset original start
         * offset, count original start node’s length minus original start offset,
         * data the empty string.
         */ if (util_1.Guard.isCharacterDataNode(originalStartNode)) {
            algorithm_1.characterData_replaceData(originalStartNode, originalStartOffset, algorithm_1.tree_nodeLength(originalStartNode) - originalStartOffset, "");
        }
        try {
            /**
             * 8. For each node in nodes to remove, in tree order, remove node from its
             * parent.
             */ for(var nodesToRemove_1 = __values(nodesToRemove), nodesToRemove_1_1 = nodesToRemove_1.next(); !nodesToRemove_1_1.done; nodesToRemove_1_1 = nodesToRemove_1.next()){
                var node = nodesToRemove_1_1.value;
                /* istanbul ignore else */ if (node._parent) {
                    algorithm_1.mutation_remove(node, node._parent);
                }
            }
        } catch (e_2_1) {
            e_2 = {
                error: e_2_1
            };
        } finally{
            try {
                if (nodesToRemove_1_1 && !nodesToRemove_1_1.done && (_b = nodesToRemove_1.return)) _b.call(nodesToRemove_1);
            } finally{
                if (e_2) throw e_2.error;
            }
        }
        /**
         * 9. If original end node is a Text, ProcessingInstruction, or Comment
         * node, replace data with node original end node, offset 0, count original
         * end offset and data the empty string.
         */ if (util_1.Guard.isCharacterDataNode(originalEndNode)) {
            algorithm_1.characterData_replaceData(originalEndNode, 0, originalEndOffset, "");
        }
        /**
         * 10. Set start and end to (new node, new offset).
         */ this._start = [
            newNode,
            newOffset
        ];
        this._end = [
            newNode,
            newOffset
        ];
    };
    /** @inheritdoc */ RangeImpl.prototype.extractContents = function() {
        /**
         * The extractContents() method, when invoked, must return the result of
         * extracting the context object.
         */ return algorithm_1.range_extract(this);
    };
    /** @inheritdoc */ RangeImpl.prototype.cloneContents = function() {
        /**
         * The cloneContents() method, when invoked, must return the result of
         * cloning the contents of the context object.
         */ return algorithm_1.range_cloneTheContents(this);
    };
    /** @inheritdoc */ RangeImpl.prototype.insertNode = function(node) {
        /**
         * The insertNode(node) method, when invoked, must insert node into the
         * context object.
         */ return algorithm_1.range_insert(node, this);
    };
    /** @inheritdoc */ RangeImpl.prototype.surroundContents = function(newParent) {
        var e_3, _a;
        try {
            /**
             * 1. If a non-Text node is partially contained in the context object, then
             * throw an "InvalidStateError" DOMException.
             */ for(var _b = __values(algorithm_1.range_getPartiallyContainedNodes(this)), _c = _b.next(); !_c.done; _c = _b.next()){
                var node = _c.value;
                if (!util_1.Guard.isTextNode(node)) {
                    throw new DOMException_1.InvalidStateError();
                }
            }
        } catch (e_3_1) {
            e_3 = {
                error: e_3_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_3) throw e_3.error;
            }
        }
        /**
         * 2. If newParent is a Document, DocumentType, or DocumentFragment node,
         * then throw an "InvalidNodeTypeError" DOMException.
         */ if (util_1.Guard.isDocumentNode(newParent) || util_1.Guard.isDocumentTypeNode(newParent) || util_1.Guard.isDocumentFragmentNode(newParent)) {
            throw new DOMException_1.InvalidNodeTypeError();
        }
        /**
         * 3. Let fragment be the result of extracting the context object.
         */ var fragment = algorithm_1.range_extract(this);
        /**
         * 4. If newParent has children, then replace all with null within newParent.
         */ if (newParent._children.size !== 0) {
            algorithm_1.mutation_replaceAll(null, newParent);
        }
        /**
         * 5. Insert newParent into the context object.
         * 6. Append fragment to newParent.
         */ algorithm_1.range_insert(newParent, this);
        algorithm_1.mutation_append(fragment, newParent);
        /**
         * 7. Select newParent within the context object.
         */ algorithm_1.range_select(newParent, this);
    };
    /** @inheritdoc */ RangeImpl.prototype.cloneRange = function() {
        /**
         * The cloneRange() method, when invoked, must return a new live range with
         * the same start and end as the context object.
         */ return algorithm_1.create_range(this._start, this._end);
    };
    /** @inheritdoc */ RangeImpl.prototype.detach = function() {
        /**
         * The detach() method, when invoked, must do nothing.
         *
         * since JS lacks weak references, we still use detach
         */ DOMImpl_1.dom.rangeList.delete(this);
    };
    /** @inheritdoc */ RangeImpl.prototype.isPointInRange = function(node, offset) {
        /**
         * 1. If node’s root is different from the context object’s root, return false.
         */ if (algorithm_1.tree_rootNode(node) !== algorithm_1.range_root(this)) {
            return false;
        }
        /**
         * 2. If node is a doctype, then throw an "InvalidNodeTypeError" DOMException.
         * 3. If offset is greater than node’s length, then throw an
         * "IndexSizeError" DOMException.
         */ if (util_1.Guard.isDocumentTypeNode(node)) throw new DOMException_1.InvalidNodeTypeError();
        if (offset > algorithm_1.tree_nodeLength(node)) throw new DOMException_1.IndexSizeError();
        /**
         * 4. If (node, offset) is before start or after end, return false.
         */ var bp = [
            node,
            offset
        ];
        if (algorithm_1.boundaryPoint_position(bp, this._start) === interfaces_1.BoundaryPosition.Before || algorithm_1.boundaryPoint_position(bp, this._end) === interfaces_1.BoundaryPosition.After) {
            return false;
        }
        /**
         * 5. Return true.
         */ return true;
    };
    /** @inheritdoc */ RangeImpl.prototype.comparePoint = function(node, offset) {
        /**
         * 1. If node’s root is different from the context object’s root, then throw
         * a "WrongDocumentError" DOMException.
         * 2. If node is a doctype, then throw an "InvalidNodeTypeError" DOMException.
         * 3. If offset is greater than node’s length, then throw an
         * "IndexSizeError" DOMException.
         */ if (algorithm_1.tree_rootNode(node) !== algorithm_1.range_root(this)) throw new DOMException_1.WrongDocumentError();
        if (util_1.Guard.isDocumentTypeNode(node)) throw new DOMException_1.InvalidNodeTypeError();
        if (offset > algorithm_1.tree_nodeLength(node)) throw new DOMException_1.IndexSizeError();
        /**
         * 4. If (node, offset) is before start, return −1.
         * 5. If (node, offset) is after end, return 1.
         * 6. Return 0.
         */ var bp = [
            node,
            offset
        ];
        if (algorithm_1.boundaryPoint_position(bp, this._start) === interfaces_1.BoundaryPosition.Before) {
            return -1;
        } else if (algorithm_1.boundaryPoint_position(bp, this._end) === interfaces_1.BoundaryPosition.After) {
            return 1;
        } else {
            return 0;
        }
    };
    /** @inheritdoc */ RangeImpl.prototype.intersectsNode = function(node) {
        /**
         * 1. If node’s root is different from the context object’s root, return false.
         */ if (algorithm_1.tree_rootNode(node) !== algorithm_1.range_root(this)) {
            return false;
        }
        /**
         * 2. Let parent be node’s parent.
         * 3. If parent is null, return true.
         */ var parent = node._parent;
        if (parent === null) return true;
        /**
         * 4. Let offset be node’s index.
         */ var offset = algorithm_1.tree_index(node);
        /**
         * 5. If (parent, offset) is before end and (parent, offset plus 1) is
         * after start, return true.
         */ if (algorithm_1.boundaryPoint_position([
            parent,
            offset
        ], this._end) === interfaces_1.BoundaryPosition.Before && algorithm_1.boundaryPoint_position([
            parent,
            offset + 1
        ], this._start) === interfaces_1.BoundaryPosition.After) {
            return true;
        }
        /**
         * 6. Return false.
         */ return false;
    };
    RangeImpl.prototype.toString = function() {
        var e_4, _a;
        /**
         * 1. Let s be the empty string.
         */ var s = "";
        /**
         * 2. If the context object’s start node is the context object’s end node
         * and it is a Text node, then return the substring of that Text node’s data
         * beginning at the context object’s start offset and ending at the context
         * object’s end offset.
         */ if (this._startNode === this._endNode && util_1.Guard.isTextNode(this._startNode)) {
            return this._startNode._data.substring(this._startOffset, this._endOffset);
        }
        /**
         * 3. If the context object’s start node is a Text node, then append the
         * substring of that node’s data from the context object’s start offset
         * until the end to s.
         */ if (util_1.Guard.isTextNode(this._startNode)) {
            s += this._startNode._data.substring(this._startOffset);
        }
        try {
            /**
             * 4. Append the concatenation of the data of all Text nodes that are
             * contained in the context object, in tree order, to s.
             */ for(var _b = __values(algorithm_1.range_getContainedNodes(this)), _c = _b.next(); !_c.done; _c = _b.next()){
                var child = _c.value;
                if (util_1.Guard.isTextNode(child)) {
                    s += child._data;
                }
            }
        } catch (e_4_1) {
            e_4 = {
                error: e_4_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_4) throw e_4.error;
            }
        }
        /**
         * 5. If the context object’s end node is a Text node, then append the
         * substring of that node’s data from its start until the context object’s
         * end offset to s.
         */ if (util_1.Guard.isTextNode(this._endNode)) {
            s += this._endNode._data.substring(0, this._endOffset);
        }
        /**
         * 6. Return s.
         */ return s;
    };
    /**
     * Creates a new `Range`.
     *
     * @param start - start point
     * @param end - end point
     */ RangeImpl._create = function(start, end) {
        var range = new RangeImpl();
        if (start) range._start = start;
        if (end) range._end = end;
        return range;
    };
    RangeImpl.START_TO_START = 0;
    RangeImpl.START_TO_END = 1;
    RangeImpl.END_TO_END = 2;
    RangeImpl.END_TO_START = 3;
    return RangeImpl;
}(AbstractRangeImpl_1.AbstractRangeImpl);
exports.RangeImpl = RangeImpl;
/**
 * Define constants on prototype.
 */ WebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, "START_TO_START", 0);
WebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, "START_TO_END", 1);
WebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, "END_TO_END", 2);
WebIDLAlgorithm_1.idl_defineConst(RangeImpl.prototype, "END_TO_START", 3); //# sourceMappingURL=RangeImpl.js.map


/***/ }),

/***/ 40018:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DocumentFragmentImpl_1 = __webpack_require__(14240);
var util_1 = __webpack_require__(96883);
var algorithm_1 = __webpack_require__(75306);
/**
 * Represents a shadow root.
 */ var ShadowRootImpl = /** @class */ function(_super) {
    __extends(ShadowRootImpl, _super);
    /**
     * Initializes a new instance of `ShadowRoot`.
     *
     * @param host - shadow root's host element
     * @param mode - shadow root's mode
     */ function ShadowRootImpl(host, mode) {
        var _this = _super.call(this) || this;
        _this._host = host;
        _this._mode = mode;
        return _this;
    }
    Object.defineProperty(ShadowRootImpl.prototype, "mode", {
        /** @inheritdoc */ get: function() {
            return this._mode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowRootImpl.prototype, "host", {
        /** @inheritdoc */ get: function() {
            return this._host;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the parent event target for the given event.
     *
     * @param event - an event
     */ ShadowRootImpl.prototype._getTheParent = function(event) {
        /**
         * A shadow root’s get the parent algorithm, given an event, returns null
         * if event’s composed flag is unset and shadow root is the root of
         * event’s path’s first struct’s invocation target, and shadow root’s host
         * otherwise.
         */ if (!event._composedFlag && !util_1.isEmpty(event._path) && algorithm_1.tree_rootNode(event._path[0].invocationTarget) === this) {
            return null;
        } else {
            return this._host;
        }
    };
    // MIXIN: DocumentOrShadowRoot
    // No elements
    /**
     * Creates a new `ShadowRoot`.
     *
     * @param document - owner document
     * @param host - shadow root's host element
     */ ShadowRootImpl._create = function(document, host) {
        return new ShadowRootImpl(host, "closed");
    };
    return ShadowRootImpl;
}(DocumentFragmentImpl_1.DocumentFragmentImpl);
exports.ShadowRootImpl = ShadowRootImpl; //# sourceMappingURL=ShadowRootImpl.js.map


/***/ }),

/***/ 75829:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var algorithm_1 = __webpack_require__(75306);
/**
 * Represents a mixin that allows nodes to become the contents of
 * a <slot> element. This mixin is implemented by {@link Element} and
 * {@link Text}.
 */ var SlotableImpl = /** @class */ function() {
    function SlotableImpl() {}
    Object.defineProperty(SlotableImpl.prototype, "_name", {
        get: function() {
            return this.__name || "";
        },
        set: function(val) {
            this.__name = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SlotableImpl.prototype, "_assignedSlot", {
        get: function() {
            return this.__assignedSlot || null;
        },
        set: function(val) {
            this.__assignedSlot = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SlotableImpl.prototype, "assignedSlot", {
        /** @inheritdoc */ get: function() {
            return algorithm_1.shadowTree_findASlot(this, true);
        },
        enumerable: true,
        configurable: true
    });
    return SlotableImpl;
}();
exports.SlotableImpl = SlotableImpl; //# sourceMappingURL=SlotableImpl.js.map


/***/ }),

/***/ 26709:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var AbstractRangeImpl_1 = __webpack_require__(58209);
var DOMException_1 = __webpack_require__(28905);
var util_1 = __webpack_require__(57294);
/**
 * Represents a static range.
 */ var StaticRangeImpl = /** @class */ function(_super) {
    __extends(StaticRangeImpl, _super);
    /**
     * Initializes a new instance of `StaticRange`.
     */ function StaticRangeImpl(init) {
        var _this = _super.call(this) || this;
        /**
         * 1. If init’s startContainer or endContainer is a DocumentType or Attr
         * node, then throw an "InvalidNodeTypeError" DOMException.
         * 2. Let staticRange be a new StaticRange object.
         * 3. Set staticRange’s start to (init’s startContainer, init’s startOffset)
         * and end to (init’s endContainer, init’s endOffset).
         * 4. Return staticRange.
         */ if (util_1.Guard.isDocumentTypeNode(init.startContainer) || util_1.Guard.isAttrNode(init.startContainer) || util_1.Guard.isDocumentTypeNode(init.endContainer) || util_1.Guard.isAttrNode(init.endContainer)) {
            throw new DOMException_1.InvalidNodeTypeError();
        }
        _this._start = [
            init.startContainer,
            init.startOffset
        ];
        _this._end = [
            init.endContainer,
            init.endOffset
        ];
        return _this;
    }
    return StaticRangeImpl;
}(AbstractRangeImpl_1.AbstractRangeImpl);
exports.StaticRangeImpl = StaticRangeImpl; //# sourceMappingURL=StaticRangeImpl.js.map


/***/ }),

/***/ 70098:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
var CharacterDataImpl_1 = __webpack_require__(1753);
var algorithm_1 = __webpack_require__(75306);
var WebIDLAlgorithm_1 = __webpack_require__(52510);
/**
 * Represents a text node.
 */ var TextImpl = /** @class */ function(_super) {
    __extends(TextImpl, _super);
    /**
     * Initializes a new instance of `Text`.
     *
     * @param data - the text content
     */ function TextImpl(data) {
        if (data === void 0) {
            data = "";
        }
        var _this = _super.call(this, data) || this;
        _this._name = "";
        _this._assignedSlot = null;
        return _this;
    }
    Object.defineProperty(TextImpl.prototype, "wholeText", {
        /** @inheritdoc */ get: function() {
            var e_1, _a;
            /**
             * The wholeText attribute’s getter must return the concatenation of the
             * data of the contiguous Text nodes of the context object, in tree order.
             */ var text = "";
            try {
                for(var _b = __values(algorithm_1.text_contiguousTextNodes(this, true)), _c = _b.next(); !_c.done; _c = _b.next()){
                    var node = _c.value;
                    text = text + node._data;
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            return text;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ TextImpl.prototype.splitText = function(offset) {
        /**
         * The splitText(offset) method, when invoked, must split context object
         * with offset offset.
         */ return algorithm_1.text_split(this, offset);
    };
    Object.defineProperty(TextImpl.prototype, "assignedSlot", {
        // MIXIN: Slotable
        /* istanbul ignore next */ get: function() {
            throw new Error("Mixin: Slotable not implemented.");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a `Text`.
     *
     * @param document - owner document
     * @param data - the text content
     */ TextImpl._create = function(document, data) {
        if (data === void 0) {
            data = "";
        }
        var node = new TextImpl(data);
        node._nodeDocument = document;
        return node;
    };
    return TextImpl;
}(CharacterDataImpl_1.CharacterDataImpl);
exports.TextImpl = TextImpl;
/**
 * Initialize prototype properties
 */ WebIDLAlgorithm_1.idl_defineConst(TextImpl.prototype, "_nodeType", interfaces_1.NodeType.Text); //# sourceMappingURL=TextImpl.js.map


/***/ }),

/***/ 85864:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
/**
 * Represents an object which can be used to iterate through the nodes
 * of a subtree.
 */ var TraverserImpl = /** @class */ function() {
    /**
     * Initializes a new instance of `Traverser`.
     *
     * @param root - root node
     */ function TraverserImpl(root) {
        this._activeFlag = false;
        this._root = root;
        this._whatToShow = interfaces_1.WhatToShow.All;
        this._filter = null;
    }
    Object.defineProperty(TraverserImpl.prototype, "root", {
        /** @inheritdoc */ get: function() {
            return this._root;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TraverserImpl.prototype, "whatToShow", {
        /** @inheritdoc */ get: function() {
            return this._whatToShow;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TraverserImpl.prototype, "filter", {
        /** @inheritdoc */ get: function() {
            return this._filter;
        },
        enumerable: true,
        configurable: true
    });
    return TraverserImpl;
}();
exports.TraverserImpl = TraverserImpl; //# sourceMappingURL=TraverserImpl.js.map


/***/ }),

/***/ 31642:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
var TraverserImpl_1 = __webpack_require__(85864);
var algorithm_1 = __webpack_require__(75306);
/**
 * Represents the nodes of a subtree and a position within them.
 */ var TreeWalkerImpl = /** @class */ function(_super) {
    __extends(TreeWalkerImpl, _super);
    /**
     * Initializes a new instance of `TreeWalker`.
     */ function TreeWalkerImpl(root, current) {
        var _this = _super.call(this, root) || this;
        _this._current = current;
        return _this;
    }
    Object.defineProperty(TreeWalkerImpl.prototype, "currentNode", {
        /** @inheritdoc */ get: function() {
            return this._current;
        },
        set: function(value) {
            this._current = value;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ TreeWalkerImpl.prototype.parentNode = function() {
        /**
         * 1. Let node be the context object’s current.
         * 2. While node is non-null and is not the context object’s root:
         */ var node = this._current;
        while(node !== null && node !== this._root){
            /**
             * 2.1. Set node to node’s parent.
             * 2.2. If node is non-null and filtering node within the context object
             * returns FILTER_ACCEPT, then set the context object’s current to node
             * and return node.
             */ node = node._parent;
            if (node !== null && algorithm_1.traversal_filter(this, node) === interfaces_1.FilterResult.Accept) {
                this._current = node;
                return node;
            }
        }
        /**
         * 3. Return null.
         */ return null;
    };
    /** @inheritdoc */ TreeWalkerImpl.prototype.firstChild = function() {
        /**
         * The firstChild() method, when invoked, must traverse children with the
         * context object and first.
         */ return algorithm_1.treeWalker_traverseChildren(this, true);
    };
    /** @inheritdoc */ TreeWalkerImpl.prototype.lastChild = function() {
        /**
         * The lastChild() method, when invoked, must traverse children with the
         * context object and last.
         */ return algorithm_1.treeWalker_traverseChildren(this, false);
    };
    /** @inheritdoc */ TreeWalkerImpl.prototype.nextSibling = function() {
        /**
         * The nextSibling() method, when invoked, must traverse siblings with the
         * context object and next.
         */ return algorithm_1.treeWalker_traverseSiblings(this, true);
    };
    /** @inheritdoc */ TreeWalkerImpl.prototype.previousNode = function() {
        /**
         * 1. Let node be the context object’s current.
         * 2. While node is not the context object’s root:
         */ var node = this._current;
        while(node !== this._root){
            /**
             * 2.1. Let sibling be node’s previous sibling.
             * 2.2. While sibling is non-null:
             */ var sibling = node._previousSibling;
            while(sibling){
                /**
                 * 2.2.1. Set node to sibling.
                 * 2.2.2. Let result be the result of filtering node within the context
                 * object.
                 */ node = sibling;
                var result = algorithm_1.traversal_filter(this, node);
                /**
                 * 2.2.3. While result is not FILTER_REJECT and node has a child:
                 */ while(result !== interfaces_1.FilterResult.Reject && node._lastChild){
                    /**
                     * 2.2.3.1. Set node to node’s last child.
                     * 2.2.3.2. Set result to the result of filtering node within the
                     * context object.
                     */ node = node._lastChild;
                    result = algorithm_1.traversal_filter(this, node);
                }
                /**
                 * 2.2.4. If result is FILTER_ACCEPT, then set the context object’s
                 * current to node and return node.
                 */ if (result === interfaces_1.FilterResult.Accept) {
                    this._current = node;
                    return node;
                }
                /**
                 * 2.2.5. Set sibling to node’s previous sibling.
                 */ sibling = node._previousSibling;
            }
            /**
             * 2.3. If node is the context object’s root or node’s parent is null,
             * then return null.
             */ if (node === this._root || node._parent === null) {
                return null;
            }
            /**
             * 2.4. Set node to node’s parent.
             */ node = node._parent;
            /**
             * 2.5. If the return value of filtering node within the context object is
             * FILTER_ACCEPT, then set the context object’s current to node and
             * return node.
             */ if (algorithm_1.traversal_filter(this, node) === interfaces_1.FilterResult.Accept) {
                this._current = node;
                return node;
            }
        }
        /**
         * 3. Return null.
         */ return null;
    };
    /** @inheritdoc */ TreeWalkerImpl.prototype.previousSibling = function() {
        /**
         * The previousSibling() method, when invoked, must traverse siblings with
         * the context object and previous.
         */ return algorithm_1.treeWalker_traverseSiblings(this, false);
    };
    /** @inheritdoc */ TreeWalkerImpl.prototype.nextNode = function() {
        /**
         * 1. Let node be the context object’s current.
         * 2. Let result be FILTER_ACCEPT.
         * 3. While true:
         */ var node = this._current;
        var result = interfaces_1.FilterResult.Accept;
        while(true){
            /**
             * 3.1. While result is not FILTER_REJECT and node has a child:
             */ while(result !== interfaces_1.FilterResult.Reject && node._firstChild){
                /**
                 * 3.1.1. Set node to its first child.
                 * 3.1.2. Set result to the result of filtering node within the context
                 * object.
                 * 3.1.3. If result is FILTER_ACCEPT, then set the context object’s
                 * current to node and return node.
                 */ node = node._firstChild;
                result = algorithm_1.traversal_filter(this, node);
                if (result === interfaces_1.FilterResult.Accept) {
                    this._current = node;
                    return node;
                }
            }
            /**
             * 3.2. Let sibling be null.
             * 3.3. Let temporary be node.
             * 3.4. While temporary is non-null:
             */ var sibling = null;
            var temporary = node;
            while(temporary !== null){
                /**
                 * 3.4.1. If temporary is the context object’s root, then return null.
                 */ if (temporary === this._root) {
                    return null;
                }
                /**
                 * 3.4.2. Set sibling to temporary’s next sibling.
                 * 3.4.3. If sibling is non-null, then break.
                 */ sibling = temporary._nextSibling;
                if (sibling !== null) {
                    node = sibling;
                    break;
                }
                /**
                 * 3.4.4. Set temporary to temporary’s parent.
                 */ temporary = temporary._parent;
            }
            /**
             * 3.5. Set result to the result of filtering node within the context object.
             * 3.6. If result is FILTER_ACCEPT, then set the context object’s current
             * to node and return node.
             */ result = algorithm_1.traversal_filter(this, node);
            if (result === interfaces_1.FilterResult.Accept) {
                this._current = node;
                return node;
            }
        }
    };
    /**
     * Creates a new `TreeWalker`.
     *
     * @param root - iterator's root node
     * @param current - current node
     */ TreeWalkerImpl._create = function(root, current) {
        return new TreeWalkerImpl(root, current);
    };
    return TreeWalkerImpl;
}(TraverserImpl_1.TraverserImpl);
exports.TreeWalkerImpl = TreeWalkerImpl; //# sourceMappingURL=TreeWalkerImpl.js.map


/***/ }),

/***/ 32130:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var EventTargetImpl_1 = __webpack_require__(73410);
var util_1 = __webpack_require__(96883);
var algorithm_1 = __webpack_require__(75306);
/**
 * Represents a window containing a DOM document.
 */ var WindowImpl = /** @class */ function(_super) {
    __extends(WindowImpl, _super);
    /**
     * Initializes a new instance of `Window`.
     */ function WindowImpl() {
        var _this = _super.call(this) || this;
        _this._signalSlots = new Set();
        _this._mutationObserverMicrotaskQueued = false;
        _this._mutationObservers = new Set();
        _this._iteratorList = new util_1.FixedSizeSet();
        _this._associatedDocument = algorithm_1.create_document();
        return _this;
    }
    Object.defineProperty(WindowImpl.prototype, "document", {
        /** @inheritdoc */ get: function() {
            return this._associatedDocument;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WindowImpl.prototype, "event", {
        /** @inheritdoc */ get: function() {
            return this._currentEvent;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new window with a blank document.
     */ WindowImpl._create = function() {
        return new WindowImpl();
    };
    return WindowImpl;
}(EventTargetImpl_1.EventTargetImpl);
exports.WindowImpl = WindowImpl; //# sourceMappingURL=WindowImpl.js.map


/***/ }),

/***/ 68111:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var DocumentImpl_1 = __webpack_require__(18927);
/**
 * Represents an XML document.
 */ var XMLDocumentImpl = /** @class */ function(_super) {
    __extends(XMLDocumentImpl, _super);
    /**
     * Initializes a new instance of `XMLDocument`.
     */ function XMLDocumentImpl() {
        return _super.call(this) || this;
    }
    return XMLDocumentImpl;
}(DocumentImpl_1.DocumentImpl);
exports.XMLDocumentImpl = XMLDocumentImpl; //# sourceMappingURL=XMLDocumentImpl.js.map


/***/ }),

/***/ 20937:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(96883);
// Import implementation classes
var AbortControllerImpl_1 = __webpack_require__(64603);
exports.AbortController = AbortControllerImpl_1.AbortControllerImpl;
var AbortSignalImpl_1 = __webpack_require__(77719);
exports.AbortSignal = AbortSignalImpl_1.AbortSignalImpl;
var AbstractRangeImpl_1 = __webpack_require__(58209);
exports.AbstractRange = AbstractRangeImpl_1.AbstractRangeImpl;
var AttrImpl_1 = __webpack_require__(15867);
exports.Attr = AttrImpl_1.AttrImpl;
var CDATASectionImpl_1 = __webpack_require__(34950);
exports.CDATASection = CDATASectionImpl_1.CDATASectionImpl;
var CharacterDataImpl_1 = __webpack_require__(1753);
exports.CharacterData = CharacterDataImpl_1.CharacterDataImpl;
var ChildNodeImpl_1 = __webpack_require__(45958);
var CommentImpl_1 = __webpack_require__(77616);
exports.Comment = CommentImpl_1.CommentImpl;
var CustomEventImpl_1 = __webpack_require__(80010);
exports.CustomEvent = CustomEventImpl_1.CustomEventImpl;
var DocumentFragmentImpl_1 = __webpack_require__(14240);
exports.DocumentFragment = DocumentFragmentImpl_1.DocumentFragmentImpl;
var DocumentImpl_1 = __webpack_require__(18927);
exports.Document = DocumentImpl_1.DocumentImpl;
var DocumentOrShadowRootImpl_1 = __webpack_require__(19087);
var DocumentTypeImpl_1 = __webpack_require__(23331);
exports.DocumentType = DocumentTypeImpl_1.DocumentTypeImpl;
var DOMImpl_1 = __webpack_require__(21436);
exports.dom = DOMImpl_1.dom;
var DOMImplementationImpl_1 = __webpack_require__(36152);
exports.DOMImplementation = DOMImplementationImpl_1.DOMImplementationImpl;
var DOMTokenListImpl_1 = __webpack_require__(26858);
exports.DOMTokenList = DOMTokenListImpl_1.DOMTokenListImpl;
var ElementImpl_1 = __webpack_require__(33086);
exports.Element = ElementImpl_1.ElementImpl;
var EventImpl_1 = __webpack_require__(38584);
exports.Event = EventImpl_1.EventImpl;
var EventTargetImpl_1 = __webpack_require__(73410);
exports.EventTarget = EventTargetImpl_1.EventTargetImpl;
var HTMLCollectionImpl_1 = __webpack_require__(31403);
exports.HTMLCollection = HTMLCollectionImpl_1.HTMLCollectionImpl;
var MutationObserverImpl_1 = __webpack_require__(62359);
exports.MutationObserver = MutationObserverImpl_1.MutationObserverImpl;
var MutationRecordImpl_1 = __webpack_require__(68967);
exports.MutationRecord = MutationRecordImpl_1.MutationRecordImpl;
var NamedNodeMapImpl_1 = __webpack_require__(9846);
exports.NamedNodeMap = NamedNodeMapImpl_1.NamedNodeMapImpl;
var NodeFilterImpl_1 = __webpack_require__(32482);
exports.NodeFilter = NodeFilterImpl_1.NodeFilterImpl;
var NodeImpl_1 = __webpack_require__(37183);
exports.Node = NodeImpl_1.NodeImpl;
var NodeIteratorImpl_1 = __webpack_require__(70971);
exports.NodeIterator = NodeIteratorImpl_1.NodeIteratorImpl;
var NodeListImpl_1 = __webpack_require__(37148);
exports.NodeList = NodeListImpl_1.NodeListImpl;
var NodeListStaticImpl_1 = __webpack_require__(22020);
exports.NodeListStatic = NodeListStaticImpl_1.NodeListStaticImpl;
var NonDocumentTypeChildNodeImpl_1 = __webpack_require__(45145);
var NonElementParentNodeImpl_1 = __webpack_require__(33437);
var ParentNodeImpl_1 = __webpack_require__(3349);
var ProcessingInstructionImpl_1 = __webpack_require__(66617);
exports.ProcessingInstruction = ProcessingInstructionImpl_1.ProcessingInstructionImpl;
var RangeImpl_1 = __webpack_require__(39694);
exports.Range = RangeImpl_1.RangeImpl;
var ShadowRootImpl_1 = __webpack_require__(40018);
exports.ShadowRoot = ShadowRootImpl_1.ShadowRootImpl;
var SlotableImpl_1 = __webpack_require__(75829);
var StaticRangeImpl_1 = __webpack_require__(26709);
exports.StaticRange = StaticRangeImpl_1.StaticRangeImpl;
var TextImpl_1 = __webpack_require__(70098);
exports.Text = TextImpl_1.TextImpl;
var TraverserImpl_1 = __webpack_require__(85864);
exports.Traverser = TraverserImpl_1.TraverserImpl;
var TreeWalkerImpl_1 = __webpack_require__(31642);
exports.TreeWalker = TreeWalkerImpl_1.TreeWalkerImpl;
var WindowImpl_1 = __webpack_require__(32130);
exports.Window = WindowImpl_1.WindowImpl;
var XMLDocumentImpl_1 = __webpack_require__(68111);
exports.XMLDocument = XMLDocumentImpl_1.XMLDocumentImpl;
// Apply mixins
// ChildNode
util_1.applyMixin(ElementImpl_1.ElementImpl, ChildNodeImpl_1.ChildNodeImpl);
util_1.applyMixin(CharacterDataImpl_1.CharacterDataImpl, ChildNodeImpl_1.ChildNodeImpl);
util_1.applyMixin(DocumentTypeImpl_1.DocumentTypeImpl, ChildNodeImpl_1.ChildNodeImpl);
// DocumentOrShadowRoot
util_1.applyMixin(DocumentImpl_1.DocumentImpl, DocumentOrShadowRootImpl_1.DocumentOrShadowRootImpl);
util_1.applyMixin(ShadowRootImpl_1.ShadowRootImpl, DocumentOrShadowRootImpl_1.DocumentOrShadowRootImpl);
// NonDocumentTypeChildNode
util_1.applyMixin(ElementImpl_1.ElementImpl, NonDocumentTypeChildNodeImpl_1.NonDocumentTypeChildNodeImpl);
util_1.applyMixin(CharacterDataImpl_1.CharacterDataImpl, NonDocumentTypeChildNodeImpl_1.NonDocumentTypeChildNodeImpl);
// NonElementParentNode
util_1.applyMixin(DocumentImpl_1.DocumentImpl, NonElementParentNodeImpl_1.NonElementParentNodeImpl);
util_1.applyMixin(DocumentFragmentImpl_1.DocumentFragmentImpl, NonElementParentNodeImpl_1.NonElementParentNodeImpl);
// ParentNode
util_1.applyMixin(DocumentImpl_1.DocumentImpl, ParentNodeImpl_1.ParentNodeImpl);
util_1.applyMixin(DocumentFragmentImpl_1.DocumentFragmentImpl, ParentNodeImpl_1.ParentNodeImpl);
util_1.applyMixin(ElementImpl_1.ElementImpl, ParentNodeImpl_1.ParentNodeImpl);
// Slotable
util_1.applyMixin(TextImpl_1.TextImpl, SlotableImpl_1.SlotableImpl);
util_1.applyMixin(ElementImpl_1.ElementImpl, SlotableImpl_1.SlotableImpl); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 52580:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Defines the position of a boundary point relative to another.
 */ var BoundaryPosition;
(function(BoundaryPosition) {
    BoundaryPosition[BoundaryPosition["Before"] = 0] = "Before";
    BoundaryPosition[BoundaryPosition["Equal"] = 1] = "Equal";
    BoundaryPosition[BoundaryPosition["After"] = 2] = "After";
})(BoundaryPosition = exports.BoundaryPosition || (exports.BoundaryPosition = {}));
/**
 * Defines the event phase.
 */ var EventPhase;
(function(EventPhase) {
    EventPhase[EventPhase["None"] = 0] = "None";
    EventPhase[EventPhase["Capturing"] = 1] = "Capturing";
    EventPhase[EventPhase["AtTarget"] = 2] = "AtTarget";
    EventPhase[EventPhase["Bubbling"] = 3] = "Bubbling";
})(EventPhase = exports.EventPhase || (exports.EventPhase = {}));
/**
 * Defines the type of a node object.
 */ var NodeType;
(function(NodeType) {
    NodeType[NodeType["Element"] = 1] = "Element";
    NodeType[NodeType["Attribute"] = 2] = "Attribute";
    NodeType[NodeType["Text"] = 3] = "Text";
    NodeType[NodeType["CData"] = 4] = "CData";
    NodeType[NodeType["EntityReference"] = 5] = "EntityReference";
    NodeType[NodeType["Entity"] = 6] = "Entity";
    NodeType[NodeType["ProcessingInstruction"] = 7] = "ProcessingInstruction";
    NodeType[NodeType["Comment"] = 8] = "Comment";
    NodeType[NodeType["Document"] = 9] = "Document";
    NodeType[NodeType["DocumentType"] = 10] = "DocumentType";
    NodeType[NodeType["DocumentFragment"] = 11] = "DocumentFragment";
    NodeType[NodeType["Notation"] = 12] = "Notation"; // historical
})(NodeType = exports.NodeType || (exports.NodeType = {}));
/**
 * Defines the position of a node in the document relative to another
 * node.
 */ var Position;
(function(Position) {
    Position[Position["Disconnected"] = 1] = "Disconnected";
    Position[Position["Preceding"] = 2] = "Preceding";
    Position[Position["Following"] = 4] = "Following";
    Position[Position["Contains"] = 8] = "Contains";
    Position[Position["ContainedBy"] = 16] = "ContainedBy";
    Position[Position["ImplementationSpecific"] = 32] = "ImplementationSpecific";
})(Position = exports.Position || (exports.Position = {}));
/**
 * Defines the return value of a filter callback.
 */ var FilterResult;
(function(FilterResult) {
    FilterResult[FilterResult["Accept"] = 1] = "Accept";
    FilterResult[FilterResult["Reject"] = 2] = "Reject";
    FilterResult[FilterResult["Skip"] = 3] = "Skip";
})(FilterResult = exports.FilterResult || (exports.FilterResult = {}));
/**
 * Defines what to show in node filter.
 */ var WhatToShow;
(function(WhatToShow) {
    WhatToShow[WhatToShow["All"] = 4294967295] = "All";
    WhatToShow[WhatToShow["Element"] = 1] = "Element";
    WhatToShow[WhatToShow["Attribute"] = 2] = "Attribute";
    WhatToShow[WhatToShow["Text"] = 4] = "Text";
    WhatToShow[WhatToShow["CDataSection"] = 8] = "CDataSection";
    WhatToShow[WhatToShow["EntityReference"] = 16] = "EntityReference";
    WhatToShow[WhatToShow["Entity"] = 32] = "Entity";
    WhatToShow[WhatToShow["ProcessingInstruction"] = 64] = "ProcessingInstruction";
    WhatToShow[WhatToShow["Comment"] = 128] = "Comment";
    WhatToShow[WhatToShow["Document"] = 256] = "Document";
    WhatToShow[WhatToShow["DocumentType"] = 512] = "DocumentType";
    WhatToShow[WhatToShow["DocumentFragment"] = 1024] = "DocumentFragment";
    WhatToShow[WhatToShow["Notation"] = 2048] = "Notation";
})(WhatToShow = exports.WhatToShow || (exports.WhatToShow = {}));
/**
 * Defines how boundary points are compared.
 */ var HowToCompare;
(function(HowToCompare) {
    HowToCompare[HowToCompare["StartToStart"] = 0] = "StartToStart";
    HowToCompare[HowToCompare["StartToEnd"] = 1] = "StartToEnd";
    HowToCompare[HowToCompare["EndToEnd"] = 2] = "EndToEnd";
    HowToCompare[HowToCompare["EndToStart"] = 3] = "EndToStart";
})(HowToCompare = exports.HowToCompare || (exports.HowToCompare = {})); //# sourceMappingURL=interfaces.js.map


/***/ }),

/***/ 10064:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var dom_1 = __webpack_require__(20937);
dom_1.dom.setFeatures(true);
var dom_2 = __webpack_require__(20937);
exports.DOMImplementation = dom_2.DOMImplementation;
var parser_1 = __webpack_require__(13445);
exports.DOMParser = parser_1.DOMParser;
var serializer_1 = __webpack_require__(57651);
exports.XMLSerializer = serializer_1.XMLSerializer; //# sourceMappingURL=index.js.map


/***/ }),

/***/ 19685:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var algorithm_1 = __webpack_require__(75306);
var XMLParserImpl_1 = __webpack_require__(90523);
/**
 * Represents a parser for XML and HTML content.
 *
 * See: https://w3c.github.io/DOM-Parsing/#the-domparser-interface
 */ var DOMParserImpl = /** @class */ function() {
    function DOMParserImpl() {}
    /** @inheritdoc */ DOMParserImpl.prototype.parseFromString = function(source, mimeType) {
        if (mimeType === "text/html") throw new Error("HTML parser not implemented.");
        try {
            var parser = new XMLParserImpl_1.XMLParserImpl();
            var doc = parser.parse(source);
            doc._contentType = mimeType;
            return doc;
        } catch (e) {
            var errorNS = "http://www.mozilla.org/newlayout/xml/parsererror.xml";
            var doc = algorithm_1.create_xmlDocument();
            var root = doc.createElementNS(errorNS, "parsererror");
            var ele = doc.createElementNS(errorNS, "error");
            ele.setAttribute("message", e.message);
            root.appendChild(ele);
            doc.appendChild(root);
            return doc;
        }
    };
    return DOMParserImpl;
}();
exports.DOMParserImpl = DOMParserImpl; //# sourceMappingURL=DOMParserImpl.js.map


/***/ }),

/***/ 90523:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var XMLStringLexer_1 = __webpack_require__(28998);
var interfaces_1 = __webpack_require__(3279);
var infra_1 = __webpack_require__(94317);
var algorithm_1 = __webpack_require__(75306);
var LocalNameSet_1 = __webpack_require__(3367);
/**
 * Represents a parser for XML content.
 *
 * See: https://html.spec.whatwg.org/#xml-parser
 */ var XMLParserImpl = /** @class */ function() {
    function XMLParserImpl() {}
    /**
     * Parses XML content.
     *
     * @param source - a string containing XML content
     */ XMLParserImpl.prototype.parse = function(source) {
        var e_1, _a, e_2, _b;
        var lexer = new XMLStringLexer_1.XMLStringLexer(source, {
            skipWhitespaceOnlyText: true
        });
        var doc = algorithm_1.create_document();
        var context = doc;
        var token = lexer.nextToken();
        while(token.type !== interfaces_1.TokenType.EOF){
            switch(token.type){
                case interfaces_1.TokenType.Declaration:
                    var declaration = token;
                    if (declaration.version !== "1.0") {
                        throw new Error("Invalid xml version: " + declaration.version);
                    }
                    break;
                case interfaces_1.TokenType.DocType:
                    var doctype = token;
                    if (!algorithm_1.xml_isPubidChar(doctype.pubId)) {
                        throw new Error("DocType public identifier does not match PubidChar construct.");
                    }
                    if (!algorithm_1.xml_isLegalChar(doctype.sysId) || doctype.sysId.indexOf('"') !== -1 && doctype.sysId.indexOf("'") !== -1) {
                        throw new Error("DocType system identifier contains invalid characters.");
                    }
                    context.appendChild(doc.implementation.createDocumentType(doctype.name, doctype.pubId, doctype.sysId));
                    break;
                case interfaces_1.TokenType.CDATA:
                    var cdata = token;
                    if (!algorithm_1.xml_isLegalChar(cdata.data) || cdata.data.indexOf("]]>") !== -1) {
                        throw new Error("CDATA contains invalid characters.");
                    }
                    context.appendChild(doc.createCDATASection(cdata.data));
                    break;
                case interfaces_1.TokenType.Comment:
                    var comment = token;
                    if (!algorithm_1.xml_isLegalChar(comment.data) || comment.data.indexOf("--") !== -1 || comment.data.endsWith("-")) {
                        throw new Error("Comment data contains invalid characters.");
                    }
                    context.appendChild(doc.createComment(comment.data));
                    break;
                case interfaces_1.TokenType.PI:
                    var pi = token;
                    if (pi.target.indexOf(":") !== -1 || /^xml$/i.test(pi.target)) {
                        throw new Error("Processing instruction target contains invalid characters.");
                    }
                    if (!algorithm_1.xml_isLegalChar(pi.data) || pi.data.indexOf("?>") !== -1) {
                        throw new Error("Processing instruction data contains invalid characters.");
                    }
                    context.appendChild(doc.createProcessingInstruction(pi.target, pi.data));
                    break;
                case interfaces_1.TokenType.Text:
                    var text = token;
                    if (!algorithm_1.xml_isLegalChar(text.data)) {
                        throw new Error("Text data contains invalid characters.");
                    }
                    context.appendChild(doc.createTextNode(this._decodeText(text.data)));
                    break;
                case interfaces_1.TokenType.Element:
                    var element = token;
                    // inherit namespace from parent
                    var _c = __read(algorithm_1.namespace_extractQName(element.name), 2), prefix = _c[0], localName = _c[1];
                    if (localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(localName)) {
                        throw new Error("Node local name contains invalid characters.");
                    }
                    if (prefix === "xmlns") {
                        throw new Error("An element cannot have the 'xmlns' prefix.");
                    }
                    var namespace = context.lookupNamespaceURI(prefix);
                    // override namespace if there is a namespace declaration
                    // attribute
                    // also lookup namespace declaration attributes
                    var nsDeclarations = {};
                    try {
                        for(var _d = (e_1 = void 0, __values(element.attributes)), _e = _d.next(); !_e.done; _e = _d.next()){
                            var _f = __read(_e.value, 2), attName = _f[0], attValue = _f[1];
                            if (attName === "xmlns") {
                                namespace = attValue;
                            } else {
                                var _g = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _g[0], attLocalName = _g[1];
                                if (attPrefix === "xmlns") {
                                    if (attLocalName === prefix) {
                                        namespace = attValue;
                                    }
                                    nsDeclarations[attLocalName] = attValue;
                                }
                            }
                        }
                    } catch (e_1_1) {
                        e_1 = {
                            error: e_1_1
                        };
                    } finally{
                        try {
                            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                        } finally{
                            if (e_1) throw e_1.error;
                        }
                    }
                    // create the DOM element node
                    var elementNode = namespace !== null ? doc.createElementNS(namespace, element.name) : doc.createElement(element.name);
                    context.appendChild(elementNode);
                    // assign attributes
                    var localNameSet = new LocalNameSet_1.LocalNameSet();
                    try {
                        for(var _h = (e_2 = void 0, __values(element.attributes)), _j = _h.next(); !_j.done; _j = _h.next()){
                            var _k = __read(_j.value, 2), attName = _k[0], attValue = _k[1];
                            var _l = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _l[0], attLocalName = _l[1];
                            var attNamespace = null;
                            if (attPrefix === "xmlns" || attPrefix === null && attLocalName === "xmlns") {
                                // namespace declaration attribute
                                attNamespace = infra_1.namespace.XMLNS;
                            } else {
                                attNamespace = elementNode.lookupNamespaceURI(attPrefix);
                                if (attNamespace !== null && elementNode.isDefaultNamespace(attNamespace)) {
                                    attNamespace = null;
                                } else if (attNamespace === null && attPrefix !== null) {
                                    attNamespace = nsDeclarations[attPrefix] || null;
                                }
                            }
                            if (localNameSet.has(attNamespace, attLocalName)) {
                                throw new Error("Element contains duplicate attributes.");
                            }
                            localNameSet.set(attNamespace, attLocalName);
                            if (attNamespace === infra_1.namespace.XMLNS) {
                                if (attValue === infra_1.namespace.XMLNS) {
                                    throw new Error("XMLNS namespace is reserved.");
                                }
                            }
                            if (attLocalName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attLocalName)) {
                                throw new Error("Attribute local name contains invalid characters.");
                            }
                            if (attPrefix === "xmlns" && attValue === "") {
                                throw new Error("Empty XML namespace is not allowed.");
                            }
                            if (attNamespace !== null) elementNode.setAttributeNS(attNamespace, attName, this._decodeAttributeValue(attValue));
                            else elementNode.setAttribute(attName, this._decodeAttributeValue(attValue));
                        }
                    } catch (e_2_1) {
                        e_2 = {
                            error: e_2_1
                        };
                    } finally{
                        try {
                            if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
                        } finally{
                            if (e_2) throw e_2.error;
                        }
                    }
                    if (!element.selfClosing) {
                        context = elementNode;
                    }
                    break;
                case interfaces_1.TokenType.ClosingTag:
                    var closingTag = token;
                    if (closingTag.name !== context.nodeName) {
                        throw new Error("Closing tag name does not match opening tag name.");
                    }
                    /* istanbul ignore else */ if (context._parent) {
                        context = context._parent;
                    }
                    break;
            }
            token = lexer.nextToken();
        }
        return doc;
    };
    /**
     * Decodes serialized text.
     *
     * @param text - text value to serialize
     */ XMLParserImpl.prototype._decodeText = function(text) {
        return text == null ? text : text.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
    };
    /**
     * Decodes serialized attribute value.
     *
     * @param text - attribute value to serialize
     */ XMLParserImpl.prototype._decodeAttributeValue = function(text) {
        return text == null ? text : text.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
    };
    return XMLParserImpl;
}();
exports.XMLParserImpl = XMLParserImpl; //# sourceMappingURL=XMLParserImpl.js.map


/***/ }),

/***/ 28998:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(3279);
/**
 * Represents a lexer for XML content in a string.
 */ var XMLStringLexer = /** @class */ function() {
    /**
     * Initializes a new instance of `XMLStringLexer`.
     *
     * @param str - the string to tokenize and lex
     * @param options - lexer options
     */ function XMLStringLexer(str, options) {
        this._options = {
            skipWhitespaceOnlyText: false
        };
        this.err = {
            line: -1,
            col: -1,
            index: -1,
            str: ""
        };
        this._str = str;
        this._index = 0;
        this._length = str.length;
        if (options) {
            this._options.skipWhitespaceOnlyText = options.skipWhitespaceOnlyText || false;
        }
    }
    /**
     * Returns the next token.
     */ XMLStringLexer.prototype.nextToken = function() {
        if (this.eof()) {
            return {
                type: interfaces_1.TokenType.EOF
            };
        }
        var token = this.skipIfStartsWith("<") ? this.openBracket() : this.text();
        if (this._options.skipWhitespaceOnlyText) {
            if (token.type === interfaces_1.TokenType.Text && XMLStringLexer.isWhiteSpaceToken(token)) {
                token = this.nextToken();
            }
        }
        return token;
    };
    /**
     * Branches from an opening bracket (`<`).
     */ XMLStringLexer.prototype.openBracket = function() {
        if (this.skipIfStartsWith("?")) {
            if (this.skipIfStartsWith("xml")) {
                if (XMLStringLexer.isSpace(this._str[this._index])) {
                    return this.declaration();
                } else {
                    // a processing instruction starting with xml. e.g. <?xml-stylesheet href="doc.xsl" type="text/xsl"?>
                    this.seek(-3);
                    return this.pi();
                }
            } else {
                return this.pi();
            }
        } else if (this.skipIfStartsWith("!")) {
            if (this.skipIfStartsWith("--")) {
                return this.comment();
            } else if (this.skipIfStartsWith("[CDATA[")) {
                return this.cdata();
            } else if (this.skipIfStartsWith("DOCTYPE")) {
                return this.doctype();
            } else {
                this.throwError("Invalid '!' in opening tag.");
            }
        } else if (this.skipIfStartsWith("/")) {
            return this.closeTag();
        } else {
            return this.openTag();
        }
    };
    /**
     * Produces an XML declaration token.
     */ XMLStringLexer.prototype.declaration = function() {
        var version = "";
        var encoding = "";
        var standalone = "";
        while(!this.eof()){
            this.skipSpace();
            if (this.skipIfStartsWith("?>")) {
                return {
                    type: interfaces_1.TokenType.Declaration,
                    version: version,
                    encoding: encoding,
                    standalone: standalone
                };
            } else {
                // attribute name
                var _a = __read(this.attribute(), 2), attName = _a[0], attValue = _a[1];
                if (attName === "version") version = attValue;
                else if (attName === "encoding") encoding = attValue;
                else if (attName === "standalone") standalone = attValue;
                else this.throwError("Invalid attribute name: " + attName);
            }
        }
        this.throwError("Missing declaration end symbol `?>`");
    };
    /**
     * Produces a doc type token.
     */ XMLStringLexer.prototype.doctype = function() {
        var pubId = "";
        var sysId = "";
        // name
        this.skipSpace();
        var name = this.takeUntil2("[", ">", true);
        this.skipSpace();
        if (this.skipIfStartsWith("PUBLIC")) {
            pubId = this.quotedString();
            sysId = this.quotedString();
        } else if (this.skipIfStartsWith("SYSTEM")) {
            sysId = this.quotedString();
        }
        // skip internal subset
        this.skipSpace();
        if (this.skipIfStartsWith("[")) {
            // skip internal subset nodes
            this.skipUntil("]");
            if (!this.skipIfStartsWith("]")) {
                this.throwError("Missing end bracket of DTD internal subset");
            }
        }
        this.skipSpace();
        if (!this.skipIfStartsWith(">")) {
            this.throwError("Missing doctype end symbol `>`");
        }
        return {
            type: interfaces_1.TokenType.DocType,
            name: name,
            pubId: pubId,
            sysId: sysId
        };
    };
    /**
     * Produces a processing instruction token.
     */ XMLStringLexer.prototype.pi = function() {
        var target = this.takeUntilStartsWith("?>", true);
        if (this.eof()) {
            this.throwError("Missing processing instruction end symbol `?>`");
        }
        this.skipSpace();
        if (this.skipIfStartsWith("?>")) {
            return {
                type: interfaces_1.TokenType.PI,
                target: target,
                data: ""
            };
        }
        var data = this.takeUntilStartsWith("?>");
        if (this.eof()) {
            this.throwError("Missing processing instruction end symbol `?>`");
        }
        this.seek(2);
        return {
            type: interfaces_1.TokenType.PI,
            target: target,
            data: data
        };
    };
    /**
     * Produces a text token.
     *
     */ XMLStringLexer.prototype.text = function() {
        var data = this.takeUntil("<");
        return {
            type: interfaces_1.TokenType.Text,
            data: data
        };
    };
    /**
     * Produces a comment token.
     *
     */ XMLStringLexer.prototype.comment = function() {
        var data = this.takeUntilStartsWith("-->");
        if (this.eof()) {
            this.throwError("Missing comment end symbol `-->`");
        }
        this.seek(3);
        return {
            type: interfaces_1.TokenType.Comment,
            data: data
        };
    };
    /**
     * Produces a CDATA token.
     *
     */ XMLStringLexer.prototype.cdata = function() {
        var data = this.takeUntilStartsWith("]]>");
        if (this.eof()) {
            this.throwError("Missing CDATA end symbol `]>`");
        }
        this.seek(3);
        return {
            type: interfaces_1.TokenType.CDATA,
            data: data
        };
    };
    /**
     * Produces an element token.
     */ XMLStringLexer.prototype.openTag = function() {
        // element name
        this.skipSpace();
        var name = this.takeUntil2(">", "/", true);
        this.skipSpace();
        if (this.skipIfStartsWith(">")) {
            return {
                type: interfaces_1.TokenType.Element,
                name: name,
                attributes: [],
                selfClosing: false
            };
        } else if (this.skipIfStartsWith("/>")) {
            return {
                type: interfaces_1.TokenType.Element,
                name: name,
                attributes: [],
                selfClosing: true
            };
        }
        // attributes
        var attributes = [];
        while(!this.eof()){
            // end tag
            this.skipSpace();
            if (this.skipIfStartsWith(">")) {
                return {
                    type: interfaces_1.TokenType.Element,
                    name: name,
                    attributes: attributes,
                    selfClosing: false
                };
            } else if (this.skipIfStartsWith("/>")) {
                return {
                    type: interfaces_1.TokenType.Element,
                    name: name,
                    attributes: attributes,
                    selfClosing: true
                };
            }
            var attr = this.attribute();
            attributes.push(attr);
        }
        this.throwError("Missing opening element tag end symbol `>`");
    };
    /**
     * Produces a closing tag token.
     *
     */ XMLStringLexer.prototype.closeTag = function() {
        this.skipSpace();
        var name = this.takeUntil(">", true);
        this.skipSpace();
        if (!this.skipIfStartsWith(">")) {
            this.throwError("Missing closing element tag end symbol `>`");
        }
        return {
            type: interfaces_1.TokenType.ClosingTag,
            name: name
        };
    };
    /**
     * Reads an attribute name, value pair
     */ XMLStringLexer.prototype.attribute = function() {
        // attribute name
        this.skipSpace();
        var name = this.takeUntil("=", true);
        this.skipSpace();
        if (!this.skipIfStartsWith("=")) {
            this.throwError("Missing equals sign before attribute value");
        }
        // attribute value
        var value = this.quotedString();
        return [
            name,
            value
        ];
    };
    /**
     * Reads a string between double or single quotes.
     */ XMLStringLexer.prototype.quotedString = function() {
        this.skipSpace();
        var startQuote = this.take(1);
        if (!XMLStringLexer.isQuote(startQuote)) {
            this.throwError("Missing start quote character before quoted value");
        }
        var value = this.takeUntil(startQuote);
        if (!this.skipIfStartsWith(startQuote)) {
            this.throwError("Missing end quote character after quoted value");
        }
        return value;
    };
    /**
     * Determines if the current index is at or past the end of input string.
     */ XMLStringLexer.prototype.eof = function() {
        return this._index >= this._length;
    };
    /**
     * Skips the length of the given string if the string from current position
     * starts with the given string.
     *
     * @param str - the string to match
     */ XMLStringLexer.prototype.skipIfStartsWith = function(str) {
        var strLength = str.length;
        if (strLength === 1) {
            if (this._str[this._index] === str) {
                this._index++;
                return true;
            } else {
                return false;
            }
        }
        for(var i = 0; i < strLength; i++){
            if (this._str[this._index + i] !== str[i]) return false;
        }
        this._index += strLength;
        return true;
    };
    /**
     * Seeks a number of character codes.
     *
     * @param count - number of characters to skip
     */ XMLStringLexer.prototype.seek = function(count) {
        this._index += count;
        if (this._index < 0) this._index = 0;
        if (this._index > this._length) this._index = this._length;
    };
    /**
     * Skips space characters.
     */ XMLStringLexer.prototype.skipSpace = function() {
        while(!this.eof() && XMLStringLexer.isSpace(this._str[this._index])){
            this._index++;
        }
    };
    /**
     * Takes a given number of characters.
     *
     * @param count - character count
     */ XMLStringLexer.prototype.take = function(count) {
        if (count === 1) {
            return this._str[this._index++];
        }
        var startIndex = this._index;
        this.seek(count);
        return this._str.slice(startIndex, this._index);
    };
    /**
     * Takes characters until the next character matches `char`.
     *
     * @param char - a character to match
     * @param space - whether a space character stops iteration
     */ XMLStringLexer.prototype.takeUntil = function(char, space) {
        if (space === void 0) {
            space = false;
        }
        var startIndex = this._index;
        while(this._index < this._length){
            var c = this._str[this._index];
            if (c !== char && (!space || !XMLStringLexer.isSpace(c))) {
                this._index++;
            } else {
                break;
            }
        }
        return this._str.slice(startIndex, this._index);
    };
    /**
     * Takes characters until the next character matches `char1` or `char1`.
     *
     * @param char1 - a character to match
     * @param char2 - a character to match
     * @param space - whether a space character stops iteration
     */ XMLStringLexer.prototype.takeUntil2 = function(char1, char2, space) {
        if (space === void 0) {
            space = false;
        }
        var startIndex = this._index;
        while(this._index < this._length){
            var c = this._str[this._index];
            if (c !== char1 && c !== char2 && (!space || !XMLStringLexer.isSpace(c))) {
                this._index++;
            } else {
                break;
            }
        }
        return this._str.slice(startIndex, this._index);
    };
    /**
     * Takes characters until the next characters matches `str`.
     *
     * @param str - a string to match
     * @param space - whether a space character stops iteration
     */ XMLStringLexer.prototype.takeUntilStartsWith = function(str, space) {
        if (space === void 0) {
            space = false;
        }
        var startIndex = this._index;
        var strLength = str.length;
        while(this._index < this._length){
            var match = true;
            for(var i = 0; i < strLength; i++){
                var c = this._str[this._index + i];
                var char = str[i];
                if (space && XMLStringLexer.isSpace(c)) {
                    return this._str.slice(startIndex, this._index);
                } else if (c !== char) {
                    this._index++;
                    match = false;
                    break;
                }
            }
            if (match) return this._str.slice(startIndex, this._index);
        }
        this._index = this._length;
        return this._str.slice(startIndex);
    };
    /**
     * Skips characters until the next character matches `char`.
     *
     * @param char - a character to match
     */ XMLStringLexer.prototype.skipUntil = function(char) {
        while(this._index < this._length){
            var c = this._str[this._index];
            if (c !== char) {
                this._index++;
            } else {
                break;
            }
        }
    };
    /**
     * Determines if the given token is entirely whitespace.
     *
     * @param token - the token to check
     */ XMLStringLexer.isWhiteSpaceToken = function(token) {
        var str = token.data;
        for(var i = 0; i < str.length; i++){
            var c = str[i];
            if (c !== " " && c !== "\n" && c !== "\r" && c !== "	" && c !== "\f") return false;
        }
        return true;
    };
    /**
     * Determines if the given character is whitespace.
     *
     * @param char - the character to check
     */ XMLStringLexer.isSpace = function(char) {
        return char === " " || char === "\n" || char === "\r" || char === "	";
    };
    /**
     * Determines if the given character is a quote character.
     *
     * @param char - the character to check
     */ XMLStringLexer.isQuote = function(char) {
        return char === '"' || char === "'";
    };
    /**
     * Throws a parser error and records the line and column numbers in the parsed
     * string.
     *
     * @param msg - error message
     */ XMLStringLexer.prototype.throwError = function(msg) {
        var regexp = /\r\n|\r|\n/g;
        var match = null;
        var line = 0;
        var firstNewLineIndex = 0;
        var lastNewlineIndex = this._str.length;
        while((match = regexp.exec(this._str)) !== null){
            if (match === null) break;
            line++;
            if (match.index < this._index) firstNewLineIndex = regexp.lastIndex;
            if (match.index > this._index) {
                lastNewlineIndex = match.index;
                break;
            }
        }
        this.err = {
            line: line,
            col: this._index - firstNewLineIndex,
            index: this._index,
            str: this._str.substring(firstNewLineIndex, lastNewlineIndex)
        };
        throw new Error(msg + "\nIndex: " + this.err.index + "\nLn: " + this.err.line + ", Col: " + this.err.col + "\nInput: " + this.err.str);
    };
    /**
     * Returns an iterator for the lexer.
     */ XMLStringLexer.prototype[Symbol.iterator] = function() {
        this._index = 0;
        return {
            next: (function() {
                var token = this.nextToken();
                if (token.type === interfaces_1.TokenType.EOF) {
                    return {
                        done: true,
                        value: null
                    };
                } else {
                    return {
                        done: false,
                        value: token
                    };
                }
            }).bind(this)
        };
    };
    return XMLStringLexer;
}();
exports.XMLStringLexer = XMLStringLexer; //# sourceMappingURL=XMLStringLexer.js.map


/***/ }),

/***/ 13445:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
// Export classes
var DOMParserImpl_1 = __webpack_require__(19685);
exports.DOMParser = DOMParserImpl_1.DOMParserImpl; //# sourceMappingURL=index.js.map


/***/ }),

/***/ 3279:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Defines the type of a token.
 */ var TokenType;
(function(TokenType) {
    TokenType[TokenType["EOF"] = 0] = "EOF";
    TokenType[TokenType["Declaration"] = 1] = "Declaration";
    TokenType[TokenType["DocType"] = 2] = "DocType";
    TokenType[TokenType["Element"] = 3] = "Element";
    TokenType[TokenType["Text"] = 4] = "Text";
    TokenType[TokenType["CDATA"] = 5] = "CDATA";
    TokenType[TokenType["PI"] = 6] = "PI";
    TokenType[TokenType["Comment"] = 7] = "Comment";
    TokenType[TokenType["ClosingTag"] = 8] = "ClosingTag";
})(TokenType = exports.TokenType || (exports.TokenType = {})); //# sourceMappingURL=interfaces.js.map


/***/ }),

/***/ 3367:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Represents a set of unique attribute namespaceURI and localName pairs.
 * This set will contain tuples of unique attribute namespaceURI and
 * localName pairs, and is populated as each attr is processed. This set is
 * used to [optionally] enforce the well-formed constraint that an element
 * cannot have two attributes with the same namespaceURI and localName.
 * This can occur when two otherwise identical attributes on the same
 * element differ only by their prefix values.
 */ var LocalNameSet = /** @class */ function() {
    function LocalNameSet() {
        // tuple storage
        this._items = {};
        this._nullItems = {};
    }
    /**
     * Adds or replaces a tuple.
     *
     * @param ns - namespace URI
     * @param localName - attribute local name
     */ LocalNameSet.prototype.set = function(ns, localName) {
        if (ns === null) {
            this._nullItems[localName] = true;
        } else if (this._items[ns]) {
            this._items[ns][localName] = true;
        } else {
            this._items[ns] = {};
            this._items[ns][localName] = true;
        }
    };
    /**
     * Determines if the given tuple exists in the set.
     *
     * @param ns - namespace URI
     * @param localName - attribute local name
     */ LocalNameSet.prototype.has = function(ns, localName) {
        if (ns === null) {
            return this._nullItems[localName] === true;
        } else if (this._items[ns]) {
            return this._items[ns][localName] === true;
        } else {
            return false;
        }
    };
    return LocalNameSet;
}();
exports.LocalNameSet = LocalNameSet; //# sourceMappingURL=LocalNameSet.js.map


/***/ }),

/***/ 83771:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * A namespace prefix map is a map that associates namespaceURI and namespace
 * prefix lists, where namespaceURI values are the map's unique keys (which can
 * include the null value representing no namespace), and ordered lists of
 * associated prefix values are the map's key values. The namespace prefix map
 * will be populated by previously seen namespaceURIs and all their previously
 * encountered prefix associations for a given node and its ancestors.
 *
 * _Note:_ The last seen prefix for a given namespaceURI is at the end of its
 * respective list. The list is searched to find potentially matching prefixes,
 * and if no matches are found for the given namespaceURI, then the last prefix
 * in the list is used. See copy a namespace prefix map and retrieve a preferred
 * prefix string for additional details.
 *
 * See: https://w3c.github.io/DOM-Parsing/#the-namespace-prefix-map
 */ var NamespacePrefixMap = /** @class */ function() {
    function NamespacePrefixMap() {
        this._items = {};
        this._nullItems = [];
    }
    /**
     * Creates a copy of the map.
     */ NamespacePrefixMap.prototype.copy = function() {
        /**
         * To copy a namespace prefix map map means to copy the map's keys into a
         * new empty namespace prefix map, and to copy each of the values in the
         * namespace prefix list associated with each keys' value into a new list
         * which should be associated with the respective key in the new map.
         */ var mapCopy = new NamespacePrefixMap();
        for(var key in this._items){
            mapCopy._items[key] = this._items[key].slice(0);
        }
        mapCopy._nullItems = this._nullItems.slice(0);
        return mapCopy;
    };
    /**
     * Retrieves a preferred prefix string from the namespace prefix map.
     *
     * @param preferredPrefix - preferred prefix string
     * @param ns - namespace
     */ NamespacePrefixMap.prototype.get = function(preferredPrefix, ns) {
        /**
         * 1. Let candidates list be the result of retrieving a list from map where
         * there exists a key in map that matches the value of ns or if there is no
         * such key, then stop running these steps, and return the null value.
         */ var candidatesList = ns === null ? this._nullItems : this._items[ns] || null;
        if (candidatesList === null) {
            return null;
        }
        /**
         * 2. Otherwise, for each prefix value prefix in candidates list, iterating
         * from beginning to end:
         *
         * _Note:_ There will always be at least one prefix value in the list.
         */ var prefix = null;
        for(var i = 0; i < candidatesList.length; i++){
            prefix = candidatesList[i];
            /**
             * 2.1. If prefix matches preferred prefix, then stop running these steps
             * and return prefix.
             */ if (prefix === preferredPrefix) {
                return prefix;
            }
        }
        /**
        * 2.2. If prefix is the last item in the candidates list, then stop
        * running these steps and return prefix.
        */ return prefix;
    };
    /**
     * Checks if a prefix string is found in the namespace prefix map associated
     * with the given namespace.
     *
     * @param prefix - prefix string
     * @param ns - namespace
     */ NamespacePrefixMap.prototype.has = function(prefix, ns) {
        /**
         * 1. Let candidates list be the result of retrieving a list from map where
         * there exists a key in map that matches the value of ns or if there is
         * no such key, then stop running these steps, and return false.
         */ var candidatesList = ns === null ? this._nullItems : this._items[ns] || null;
        if (candidatesList === null) {
            return false;
        }
        /**
         * 2. If the value of prefix occurs at least once in candidates list,
         * return true, otherwise return false.
         */ return candidatesList.indexOf(prefix) !== -1;
    };
    /**
     * Checks if a prefix string is found in the namespace prefix map.
     *
     * @param prefix - prefix string
     */ NamespacePrefixMap.prototype.hasPrefix = function(prefix) {
        if (this._nullItems.indexOf(prefix) !== -1) return true;
        for(var key in this._items){
            if (this._items[key].indexOf(prefix) !== -1) return true;
        }
        return false;
    };
    /**
     * Adds a prefix string associated with a namespace to the prefix map.
     *
     * @param prefix - prefix string
     * @param ns - namespace
     */ NamespacePrefixMap.prototype.set = function(prefix, ns) {
        /**
         * 1. Let candidates list be the result of retrieving a list from map where
         * there exists a key in map that matches the value of ns or if there is
         * no such key, then let candidates list be null.
         */ var candidatesList = ns === null ? this._nullItems : this._items[ns] || null;
        /**
         * 2. If candidates list is null, then create a new list with prefix as the
         * only item in the list, and associate that list with a new key ns in map.
         * 3. Otherwise, append prefix to the end of candidates list.
         *
         * _Note:_ The steps in retrieve a preferred prefix string use the list to
         * track the most recently used (MRU) prefix associated with a given
         * namespace, which will be the prefix at the end of the list. This list
         * may contain duplicates of the same prefix value seen earlier
         * (and that's OK).
         */ if (ns !== null && candidatesList === null) {
            this._items[ns] = [
                prefix
            ];
        } else {
            candidatesList.push(prefix);
        }
    };
    return NamespacePrefixMap;
}();
exports.NamespacePrefixMap = NamespacePrefixMap; //# sourceMappingURL=NamespacePrefixMap.js.map


/***/ }),

/***/ 54374:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
var LocalNameSet_1 = __webpack_require__(3367);
var NamespacePrefixMap_1 = __webpack_require__(83771);
var DOMException_1 = __webpack_require__(28905);
var infra_1 = __webpack_require__(94317);
var algorithm_1 = __webpack_require__(75306);
/**
 * Represents an XML serializer.
 *
 * Implements: https://www.w3.org/TR/DOM-Parsing/#serializing
 */ var XMLSerializerImpl = /** @class */ function() {
    function XMLSerializerImpl() {}
    /** @inheritdoc */ XMLSerializerImpl.prototype.serializeToString = function(root) {
        /**
         * The serializeToString(root) method must produce an XML serialization
         * of root passing a value of false for the require well-formed parameter,
         * and return the result.
         */ return this._xmlSerialization(root, false);
    };
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ XMLSerializerImpl.prototype._xmlSerialization = function(node, requireWellFormed) {
        // To increase performance, use a namespace-aware serializer only if the
        // document has namespaced elements
        if (node._nodeDocument === undefined || node._nodeDocument._hasNamespaces) {
            /** From: https://w3c.github.io/DOM-Parsing/#xml-serialization
             *
             * 1. Let namespace be a context namespace with value null.
             * The context namespace tracks the XML serialization algorithm's current
             * default namespace. The context namespace is changed when either an Element
             * Node has a default namespace declaration, or the algorithm generates a
             * default namespace declaration for the Element Node to match its own
             * namespace. The algorithm assumes no namespace (null) to start.
             * 2. Let prefix map be a new namespace prefix map.
             * 3. Add the XML namespace with prefix value "xml" to prefix map.
             * 4. Let prefix index be a generated namespace prefix index with value 1.
             * The generated namespace prefix index is used to generate a new unique
             * prefix value when no suitable existing namespace prefix is available to
             * serialize a node's namespaceURI (or the namespaceURI of one of node's
             * attributes). See the generate a prefix algorithm.
             */ var namespace = null;
            var prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();
            prefixMap.set("xml", infra_1.namespace.XML);
            var prefixIndex = {
                value: 1
            };
            /**
             * 5. Return the result of running the XML serialization algorithm on node
             * passing the context namespace namespace, namespace prefix map prefix map,
             * generated namespace prefix index reference to prefix index, and the
             * flag require well-formed. If an exception occurs during the execution
             * of the algorithm, then catch that exception and throw an
             * "InvalidStateError" DOMException.
             */ try {
                return this._serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
            } catch (_a) {
                throw new DOMException_1.InvalidStateError();
            }
        } else {
            try {
                return this._serializeNode(node, requireWellFormed);
            } catch (_b) {
                throw new DOMException_1.InvalidStateError();
            }
        }
    };
    /**
     * Produces an XML serialization of a node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */ XMLSerializerImpl.prototype._serializeNodeNS = function(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        switch(node.nodeType){
            case interfaces_1.NodeType.Element:
                return this._serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
            case interfaces_1.NodeType.Document:
                return this._serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
            case interfaces_1.NodeType.Comment:
                return this._serializeComment(node, requireWellFormed);
            case interfaces_1.NodeType.Text:
                return this._serializeText(node, requireWellFormed);
            case interfaces_1.NodeType.DocumentFragment:
                return this._serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
            case interfaces_1.NodeType.DocumentType:
                return this._serializeDocumentType(node, requireWellFormed);
            case interfaces_1.NodeType.ProcessingInstruction:
                return this._serializeProcessingInstruction(node, requireWellFormed);
            case interfaces_1.NodeType.CData:
                return this._serializeCData(node, requireWellFormed);
            default:
                throw new Error("Unknown node type: " + node.nodeType);
        }
    };
    /**
     * Produces an XML serialization of a node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ XMLSerializerImpl.prototype._serializeNode = function(node, requireWellFormed) {
        switch(node.nodeType){
            case interfaces_1.NodeType.Element:
                return this._serializeElement(node, requireWellFormed);
            case interfaces_1.NodeType.Document:
                return this._serializeDocument(node, requireWellFormed);
            case interfaces_1.NodeType.Comment:
                return this._serializeComment(node, requireWellFormed);
            case interfaces_1.NodeType.Text:
                return this._serializeText(node, requireWellFormed);
            case interfaces_1.NodeType.DocumentFragment:
                return this._serializeDocumentFragment(node, requireWellFormed);
            case interfaces_1.NodeType.DocumentType:
                return this._serializeDocumentType(node, requireWellFormed);
            case interfaces_1.NodeType.ProcessingInstruction:
                return this._serializeProcessingInstruction(node, requireWellFormed);
            case interfaces_1.NodeType.CData:
                return this._serializeCData(node, requireWellFormed);
            default:
                throw new Error("Unknown node type: " + node.nodeType);
        }
    };
    /**
     * Produces an XML serialization of an element node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */ XMLSerializerImpl.prototype._serializeElementNS = function(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_1, _a;
        /**
         * From: https://w3c.github.io/DOM-Parsing/#xml-serializing-an-element-node
         *
         * 1. If the require well-formed flag is set (its value is true), and this
         * node's localName attribute contains the character ":" (U+003A COLON) or
         * does not match the XML Name production, then throw an exception; the
         * serialization of this node would not be a well-formed element.
         */ if (requireWellFormed && (node.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(node.localName))) {
            throw new Error("Node local name contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the string "<" (U+003C LESS-THAN SIGN).
         * 3. Let qualified name be an empty string.
         * 4. Let skip end tag be a boolean flag with value false.
         * 5. Let ignore namespace definition attribute be a boolean flag with value
         * false.
         * 6. Given prefix map, copy a namespace prefix map and let map be the
         * result.
         * 7. Let local prefixes map be an empty map. The map has unique Node prefix
         * strings as its keys, with corresponding namespaceURI Node values as the
         * map's key values (in this map, the null namespace is represented by the
         * empty string).
         *
         * _Note:_ This map is local to each element. It is used to ensure there
         * are no conflicting prefixes should a new namespace prefix attribute need
         * to be generated. It is also used to enable skipping of duplicate prefix
         * definitions when writing an element's attributes: the map allows the
         * algorithm to distinguish between a prefix in the namespace prefix map
         * that might be locally-defined (to the current Element) and one that is
         * not.
         * 8. Let local default namespace be the result of recording the namespace
         * information for node given map and local prefixes map.
         *
         * _Note:_ The above step will update map with any found namespace prefix
         * definitions, add the found prefix definitions to the local prefixes map
         * and return a local default namespace value defined by a default namespace
         * attribute if one exists. Otherwise it returns null.
         * 9. Let inherited ns be a copy of namespace.
         * 10. Let ns be the value of node's namespaceURI attribute.
         */ var markup = "<";
        var qualifiedName = "";
        var skipEndTag = false;
        var ignoreNamespaceDefinitionAttribute = false;
        var map = prefixMap.copy();
        var localPrefixesMap = {};
        var localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
        var inheritedNS = namespace;
        var ns = node.namespaceURI;
        /** 11. If inherited ns is equal to ns, then: */ if (inheritedNS === ns) {
            /**
             * 11.1. If local default namespace is not null, then set ignore
             * namespace definition attribute to true.
             */ if (localDefaultNamespace !== null) {
                ignoreNamespaceDefinitionAttribute = true;
            }
            /**
             * 11.2. If ns is the XML namespace, then append to qualified name the
             * concatenation of the string "xml:" and the value of node's localName.
             * 11.3. Otherwise, append to qualified name the value of node's
             * localName. The node's prefix if it exists, is dropped.
             */ if (ns === infra_1.namespace.XML) {
                qualifiedName = "xml:" + node.localName;
            } else {
                qualifiedName = node.localName;
            }
            /** 11.4. Append the value of qualified name to markup. */ markup += qualifiedName;
        } else {
            /**
             * 12. Otherwise, inherited ns is not equal to ns (the node's own
             * namespace is different from the context namespace of its parent).
             * Run these sub-steps:
             *
             * 12.1. Let prefix be the value of node's prefix attribute.
             * 12.2. Let candidate prefix be the result of retrieving a preferred
             * prefix string prefix from map given namespace ns. The above may return
             * null if no namespace key ns exists in map.
             */ var prefix = node.prefix;
            /**
             * We don't need to run "retrieving a preferred prefix string" algorithm if
             * the element has no prefix and its namespace matches to the default
             * namespace.
             * See: https://github.com/web-platform-tests/wpt/pull/16703
             */ var candidatePrefix = null;
            if (prefix !== null || ns !== localDefaultNamespace) {
                candidatePrefix = map.get(prefix, ns);
            }
            /**
             * 12.3. If the value of prefix matches "xmlns", then run the following
             * steps:
             */ if (prefix === "xmlns") {
                /**
                 * 12.3.1. If the require well-formed flag is set, then throw an error.
                 * An Element with prefix "xmlns" will not legally round-trip in a
                 * conforming XML parser.
                 */ if (requireWellFormed) {
                    throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
                }
                /**
                 * 12.3.2. Let candidate prefix be the value of prefix.
                 */ candidatePrefix = prefix;
            }
            /**
             * 12.4.Found a suitable namespace prefix: if candidate prefix is not
             * null (a namespace prefix is defined which maps to ns), then:
             */ if (candidatePrefix !== null) {
                /**
                 * The following may serialize a different prefix than the Element's
                 * existing prefix if it already had one. However, the retrieving a
                 * preferred prefix string algorithm already tried to match the
                 * existing prefix if possible.
                 *
                 * 12.4.1. Append to qualified name the concatenation of candidate
                 * prefix, ":" (U+003A COLON), and node's localName. There exists on
                 * this node or the node's ancestry a namespace prefix definition that
                 * defines the node's namespace.
                 * 12.4.2. If the local default namespace is not null (there exists a
                 * locally-defined default namespace declaration attribute) and its
                 * value is not the XML namespace, then let inherited ns get the value
                 * of local default namespace unless the local default namespace is the
                 * empty string in which case let it get null (the context namespace
                 * is changed to the declared default, rather than this node's own
                 * namespace).
                 *
                 * _Note:_ Any default namespace definitions or namespace prefixes that
                 * define the XML namespace are omitted when serializing this node's
                 * attributes.
                 */ qualifiedName = candidatePrefix + ":" + node.localName;
                if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
                    inheritedNS = localDefaultNamespace || null;
                }
                /**
                 * 12.4.3. Append the value of qualified name to markup.
                 */ markup += qualifiedName;
            /** 12.5. Otherwise, if prefix is not null, then: */ } else if (prefix !== null) {
                /**
                 * _Note:_ By this step, there is no namespace or prefix mapping
                 * declaration in this node (or any parent node visited by this
                 * algorithm) that defines prefix otherwise the step labelled Found
                 * a suitable namespace prefix would have been followed. The sub-steps
                 * that follow will create a new namespace prefix declaration for prefix
                 * and ensure that prefix does not conflict with an existing namespace
                 * prefix declaration of the same localName in node's attribute list.
                 *
                 * 12.5.1. If the local prefixes map contains a key matching prefix,
                 * then let prefix be the result of generating a prefix providing as
                 * input map, ns, and prefix index.
                 */ if (prefix in localPrefixesMap) {
                    prefix = this._generatePrefix(ns, map, prefixIndex);
                }
                /**
                 * 12.5.2. Add prefix to map given namespace ns.
                 * 12.5.3. Append to qualified name the concatenation of prefix, ":"
                 * (U+003A COLON), and node's localName.
                 * 12.5.4. Append the value of qualified name to markup.
                 */ map.set(prefix, ns);
                qualifiedName += prefix + ":" + node.localName;
                markup += qualifiedName;
                /**
                 * 12.5.5. Append the following to markup, in the order listed:
                 *
                 * _Note:_ The following serializes a namespace prefix declaration for
                 * prefix which was just added to the map.
                 *
                 * 12.5.5.1. " " (U+0020 SPACE);
                 * 12.5.5.2. The string "xmlns:";
                 * 12.5.5.3. The value of prefix;
                 * 12.5.5.4. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 12.5.5.5. The result of serializing an attribute value given ns and
                 * the require well-formed flag as input;
                 * 12.5.5.6. """ (U+0022 QUOTATION MARK).
                 */ markup += " xmlns:" + prefix + '="' + this._serializeAttributeValue(ns, requireWellFormed) + '"';
                /**
                 * 12.5.5.7. If local default namespace is not null (there exists a
                 * locally-defined default namespace declaration attribute), then
                 * let inherited ns get the value of local default namespace unless the
                 * local default namespace is the empty string in which case let it get
                 * null.
                 */ if (localDefaultNamespace !== null) {
                    inheritedNS = localDefaultNamespace || null;
                }
            /**
                 * 12.6. Otherwise, if local default namespace is null, or local
                 * default namespace is not null and its value is not equal to ns, then:
                 */ } else if (localDefaultNamespace === null || localDefaultNamespace !== null && localDefaultNamespace !== ns) {
                /**
                 * _Note:_ At this point, the namespace for this node still needs to be
                 * serialized, but there's no prefix (or candidate prefix) available; the
                 * following uses the default namespace declaration to define the
                 * namespace--optionally replacing an existing default declaration
                 * if present.
                 *
                 * 12.6.1. Set the ignore namespace definition attribute flag to true.
                 * 12.6.2. Append to qualified name the value of node's localName.
                 * 12.6.3. Let the value of inherited ns be ns.
                 *
                 * _Note:_ The new default namespace will be used in the serialization
                 * to define this node's namespace and act as the context namespace for
                 * its children.
                 */ ignoreNamespaceDefinitionAttribute = true;
                qualifiedName += node.localName;
                inheritedNS = ns;
                /**
                 * 12.6.4. Append the value of qualified name to markup.
                 */ markup += qualifiedName;
                /**
                 * 12.6.5. Append the following to markup, in the order listed:
                 *
                 * _Note:_ The following serializes the new (or replacement) default
                 * namespace definition.
                 *
                 * 12.6.5.1. " " (U+0020 SPACE);
                 * 12.6.5.2. The string "xmlns";
                 * 12.6.5.3. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 12.6.5.4. The result of serializing an attribute value given ns
                 * and the require well-formed flag as input;
                 * 12.6.5.5. """ (U+0022 QUOTATION MARK).
                 */ markup += " xmlns" + '="' + this._serializeAttributeValue(ns, requireWellFormed) + '"';
            /**
                 * 12.7. Otherwise, the node has a local default namespace that matches
                 * ns. Append to qualified name the value of node's localName, let the
                 * value of inherited ns be ns, and append the value of qualified name
                 * to markup.
                 */ } else {
                qualifiedName += node.localName;
                inheritedNS = ns;
                markup += qualifiedName;
            }
        }
        /**
         * 13. Append to markup the result of the XML serialization of node's
         * attributes given map, prefix index, local prefixes map, ignore namespace
         * definition attribute flag, and require well-formed flag.
         */ markup += this._serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed);
        /**
         * 14. If ns is the HTML namespace, and the node's list of children is
         * empty, and the node's localName matches any one of the following void
         * elements: "area", "base", "basefont", "bgsound", "br", "col", "embed",
         * "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta",
         * "param", "source", "track", "wbr"; then append the following to markup,
         * in the order listed:
         * 14.1. " " (U+0020 SPACE);
         * 14.2. "/" (U+002F SOLIDUS).
         * and set the skip end tag flag to true.
         * 15. If ns is not the HTML namespace, and the node's list of children is
         * empty, then append "/" (U+002F SOLIDUS) to markup and set the skip end
         * tag flag to true.
         * 16. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         */ var isHTML = ns === infra_1.namespace.HTML;
        if (isHTML && node.childNodes.length === 0 && XMLSerializerImpl._VoidElementNames.has(node.localName)) {
            markup += " /";
            skipEndTag = true;
        } else if (!isHTML && node.childNodes.length === 0) {
            markup += "/";
            skipEndTag = true;
        }
        markup += ">";
        /**
         * 17. If the value of skip end tag is true, then return the value of markup
         * and skip the remaining steps. The node is a leaf-node.
         */ if (skipEndTag) return markup;
        /**
         * 18. If ns is the HTML namespace, and the node's localName matches the
         * string "template", then this is a template element. Append to markup the
         * result of XML serializing a DocumentFragment node given the template
         * element's template contents (a DocumentFragment), providing inherited
         * ns, map, prefix index, and the require well-formed flag.
         *
         * _Note:_ This allows template content to round-trip, given the rules for
         * parsing XHTML documents.
         *
         * 19. Otherwise, append to markup the result of running the XML
         * serialization algorithm on each of node's children, in tree order,
         * providing inherited ns, map, prefix index, and the require well-formed
         * flag.
         */ if (isHTML && node.localName === "template") {
        // TODO: serialize template contents
        } else {
            try {
                for(var _b = __values(node._children || node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()){
                    var childNode = _c.value;
                    markup += this._serializeNodeNS(childNode, inheritedNS, map, prefixIndex, requireWellFormed);
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
        }
        /**
         * 20. Append the following to markup, in the order listed:
         * 20.1. "</" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);
         * 20.2. The value of qualified name;
         * 20.3. ">" (U+003E GREATER-THAN SIGN).
         */ markup += "</" + qualifiedName + ">";
        /**
         * 21. Return the value of markup.
         */ return markup;
    };
    /**
     * Produces an XML serialization of a document node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */ XMLSerializerImpl.prototype._serializeDocumentNS = function(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_2, _a;
        /**
         * If the require well-formed flag is set (its value is true), and this node
         * has no documentElement (the documentElement attribute's value is null),
         * then throw an exception; the serialization of this node would not be a
         * well-formed document.
         */ if (requireWellFormed && node.documentElement === null) {
            throw new Error("Missing document element (well-formed required).");
        }
        /**
         * Otherwise, run the following steps:
         * 1. Let serialized document be an empty string.
         * 2. For each child child of node, in tree order, run the XML
         * serialization algorithm on the child passing along the provided
         * arguments, and append the result to serialized document.
         *
         * _Note:_ This will serialize any number of ProcessingInstruction and
         * Comment nodes both before and after the Document's documentElement node,
         * including at most one DocumentType node. (Text nodes are not allowed as
         * children of the Document.)
         *
         * 3. Return the value of serialized document.
        */ var serializedDocument = "";
        try {
            for(var _b = __values(node._children || node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()){
                var childNode = _c.value;
                serializedDocument += this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
            }
        } catch (e_2_1) {
            e_2 = {
                error: e_2_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_2) throw e_2.error;
            }
        }
        return serializedDocument;
    };
    /**
     * Produces an XML serialization of a comment node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ XMLSerializerImpl.prototype._serializeComment = function(node, requireWellFormed) {
        /**
         * If the require well-formed flag is set (its value is true), and node's
         * data contains characters that are not matched by the XML Char production
         * or contains "--" (two adjacent U+002D HYPHEN-MINUS characters) or that
         * ends with a "-" (U+002D HYPHEN-MINUS) character, then throw an exception;
         * the serialization of this node's data would not be well-formed.
         */ if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) || node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
            throw new Error("Comment data contains invalid characters (well-formed required).");
        }
        /**
         * Otherwise, return the concatenation of "<!--", node's data, and "-->".
         */ return "<!--" + node.data + "-->";
    };
    /**
     * Produces an XML serialization of a text node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     * @param level - current depth of the XML tree
     */ XMLSerializerImpl.prototype._serializeText = function(node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is set (its value is true), and
         * node's data contains characters that are not matched by the XML Char
         * production, then throw an exception; the serialization of this node's
         * data would not be well-formed.
         */ if (requireWellFormed && !algorithm_1.xml_isLegalChar(node.data)) {
            throw new Error("Text data contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the value of node's data.
         * 3. Replace any occurrences of "&" in markup by "&amp;".
         * 4. Replace any occurrences of "<" in markup by "&lt;".
         * 5. Replace any occurrences of ">" in markup by "&gt;".
         * 6. Return the value of markup.
         */ var result = "";
        for(var i = 0; i < node.data.length; i++){
            var c = node.data[i];
            if (c === "&") result += "&amp;";
            else if (c === "<") result += "&lt;";
            else if (c === ">") result += "&gt;";
            else result += c;
        }
        return result;
    };
    /**
     * Produces an XML serialization of a document fragment node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */ XMLSerializerImpl.prototype._serializeDocumentFragmentNS = function(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_3, _a;
        /**
         * 1. Let markup the empty string.
         * 2. For each child child of node, in tree order, run the XML serialization
         * algorithm on the child given namespace, prefix map, a reference to prefix
         * index, and flag require well-formed. Concatenate the result to markup.
         * 3. Return the value of markup.
         */ var markup = "";
        try {
            for(var _b = __values(node._children || node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()){
                var childNode = _c.value;
                markup += this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
            }
        } catch (e_3_1) {
            e_3 = {
                error: e_3_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_3) throw e_3.error;
            }
        }
        return markup;
    };
    /**
     * Produces an XML serialization of a document type node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ XMLSerializerImpl.prototype._serializeDocumentType = function(node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is true and the node's publicId
         * attribute contains characters that are not matched by the XML PubidChar
         *  production, then throw an exception; the serialization of this node
         * would not be a well-formed document type declaration.
         */ if (requireWellFormed && !algorithm_1.xml_isPubidChar(node.publicId)) {
            throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
        }
        /**
         * 2. If the require well-formed flag is true and the node's systemId
         * attribute contains characters that are not matched by the XML Char
         * production or that contains both a """ (U+0022 QUOTATION MARK) and a
         * "'" (U+0027 APOSTROPHE), then throw an exception; the serialization
         * of this node would not be a well-formed document type declaration.
         */ if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.systemId) || node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1)) {
            throw new Error("DocType system identifier contains invalid characters (well-formed required).");
        }
        /**
         * 3. Let markup be an empty string.
         * 4. Append the string "<!DOCTYPE" to markup.
         * 5. Append " " (U+0020 SPACE) to markup.
         * 6. Append the value of the node's name attribute to markup. For a node
         * belonging to an HTML document, the value will be all lowercase.
         * 7. If the node's publicId is not the empty string then append the
         * following, in the order listed, to markup:
         * 7.1. " " (U+0020 SPACE);
         * 7.2. The string "PUBLIC";
         * 7.3. " " (U+0020 SPACE);
         * 7.4. """ (U+0022 QUOTATION MARK);
         * 7.5. The value of the node's publicId attribute;
         * 7.6. """ (U+0022 QUOTATION MARK).
         * 8. If the node's systemId is not the empty string and the node's publicId
         * is set to the empty string, then append the following, in the order
         * listed, to markup:
         * 8.1. " " (U+0020 SPACE);
         * 8.2. The string "SYSTEM".
         * 9. If the node's systemId is not the empty string then append the
         * following, in the order listed, to markup:
         * 9.2. " " (U+0020 SPACE);
         * 9.3. """ (U+0022 QUOTATION MARK);
         * 9.3. The value of the node's systemId attribute;
         * 9.4. """ (U+0022 QUOTATION MARK).
         * 10. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         * 11. Return the value of markup.
         */ return node.publicId && node.systemId ? "<!DOCTYPE " + node.name + ' PUBLIC "' + node.publicId + '" "' + node.systemId + '">' : node.publicId ? "<!DOCTYPE " + node.name + ' PUBLIC "' + node.publicId + '">' : node.systemId ? "<!DOCTYPE " + node.name + ' SYSTEM "' + node.systemId + '">' : "<!DOCTYPE " + node.name + ">";
    };
    /**
     * Produces an XML serialization of a processing instruction node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ XMLSerializerImpl.prototype._serializeProcessingInstruction = function(node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is set (its value is true), and node's
         * target contains a ":" (U+003A COLON) character or is an ASCII
         * case-insensitive match for the string "xml", then throw an exception;
         * the serialization of this node's target would not be well-formed.
         */ if (requireWellFormed && (node.target.indexOf(":") !== -1 || /^xml$/i.test(node.target))) {
            throw new Error("Processing instruction target contains invalid characters (well-formed required).");
        }
        /**
         * 2. If the require well-formed flag is set (its value is true), and node's
         * data contains characters that are not matched by the XML Char production
         * or contains the string "?>" (U+003F QUESTION MARK,
         * U+003E GREATER-THAN SIGN), then throw an exception; the serialization of
         * this node's data would not be well-formed.
         */ if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) || node.data.indexOf("?>") !== -1)) {
            throw new Error("Processing instruction data contains invalid characters (well-formed required).");
        }
        /**
         * 3. Let markup be the concatenation of the following, in the order listed:
         * 3.1. "<?" (U+003C LESS-THAN SIGN, U+003F QUESTION MARK);
         * 3.2. The value of node's target;
         * 3.3. " " (U+0020 SPACE);
         * 3.4. The value of node's data;
         * 3.5. "?>" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN).
         * 4. Return the value of markup.
         */ return "<?" + (node.data === "" ? node.target : node.target + " " + node.data) + "?>";
    };
    /**
     * Produces an XML serialization of a CDATA node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ XMLSerializerImpl.prototype._serializeCData = function(node, requireWellFormed) {
        if (requireWellFormed && node.data.indexOf("]]>") !== -1) {
            throw new Error("CDATA contains invalid characters (well-formed required).");
        }
        return "<![CDATA[" + node.data + "]]>";
    };
    /**
    * Produces an XML serialization of the attributes of an element node.
    *
     * @param node - node to serialize
     * @param map - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param localPrefixesMap - local prefixes map
     * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace
     * attributes
     * @param requireWellFormed - whether to check conformance
    */ XMLSerializerImpl.prototype._serializeAttributesNS = function(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
        var e_4, _a;
        /**
         * 1. Let result be the empty string.
         * 2. Let localname set be a new empty namespace localname set. This
         * localname set will contain tuples of unique attribute namespaceURI and
         * localName pairs, and is populated as each attr is processed. This set is
         * used to [optionally] enforce the well-formed constraint that an element
         * cannot have two attributes with the same namespaceURI and localName.
         * This can occur when two otherwise identical attributes on the same
         * element differ only by their prefix values.
         */ var result = "";
        var localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : undefined;
        try {
            /**
             * 3. Loop: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */ for(var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()){
                var attr = _c.value;
                // Optimize common case
                if (!ignoreNamespaceDefinitionAttribute && !requireWellFormed && attr.namespaceURI === null) {
                    result += " " + attr.localName + '="' + this._serializeAttributeValue(attr.value, requireWellFormed) + '"';
                    continue;
                }
                /**
                 * 3.1. If the require well-formed flag is set (its value is true), and the
                 * localname set contains a tuple whose values match those of a new tuple
                 * consisting of attr's namespaceURI attribute and localName attribute,
                 * then throw an exception; the serialization of this attr would fail to
                 * produce a well-formed element serialization.
                 */ if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
                    throw new Error("Element contains duplicate attributes (well-formed required).");
                }
                /**
                 * 3.2. Create a new tuple consisting of attr's namespaceURI attribute and
                 * localName attribute, and add it to the localname set.
                 * 3.3. Let attribute namespace be the value of attr's namespaceURI value.
                 * 3.4. Let candidate prefix be null.
                 */ if (requireWellFormed && localNameSet) localNameSet.set(attr.namespaceURI, attr.localName);
                var attributeNamespace = attr.namespaceURI;
                var candidatePrefix = null;
                /** 3.5. If attribute namespace is not null, then run these sub-steps: */ if (attributeNamespace !== null) {
                    /**
                     * 3.5.1. Let candidate prefix be the result of retrieving a preferred
                     * prefix string from map given namespace attribute namespace with
                     * preferred prefix being attr's prefix value.
                     */ candidatePrefix = map.get(attr.prefix, attributeNamespace);
                    /**
                     * 3.5.2. If the value of attribute namespace is the XMLNS namespace,
                     * then run these steps:
                     */ if (attributeNamespace === infra_1.namespace.XMLNS) {
                        /**
                         * 3.5.2.1. If any of the following are true, then stop running these
                         * steps and goto Loop to visit the next attribute:
                         * - the attr's value is the XML namespace;
                         * _Note:_ The XML namespace cannot be redeclared and survive
                         * round-tripping (unless it defines the prefix "xml"). To avoid this
                         * problem, this algorithm always prefixes elements in the XML
                         * namespace with "xml" and drops any related definitions as seen
                         * in the above condition.
                         * - the attr's prefix is null and the ignore namespace definition
                         * attribute flag is true (the Element's default namespace attribute
                         * should be skipped);
                         * - the attr's prefix is not null and either
                         *   * the attr's localName is not a key contained in the local
                         *     prefixes map, or
                         *   * the attr's localName is present in the local prefixes map but
                         *     the value of the key does not match attr's value
                         * and furthermore that the attr's localName (as the prefix to find)
                         * is found in the namespace prefix map given the namespace consisting
                         * of the attr's value (the current namespace prefix definition was
                         * exactly defined previously--on an ancestor element not the current
                         * element whose attributes are being processed).
                         */ if (attr.value === infra_1.namespace.XML || attr.prefix === null && ignoreNamespaceDefinitionAttribute || attr.prefix !== null && (!(attr.localName in localPrefixesMap) || localPrefixesMap[attr.localName] !== attr.value) && map.has(attr.localName, attr.value)) continue;
                        /**
                         * 3.5.2.2. If the require well-formed flag is set (its value is true),
                         * and the value of attr's value attribute matches the XMLNS
                         * namespace, then throw an exception; the serialization of this
                         * attribute would produce invalid XML because the XMLNS namespace
                         * is reserved and cannot be applied as an element's namespace via
                         * XML parsing.
                         *
                         * _Note:_ DOM APIs do allow creation of elements in the XMLNS
                         * namespace but with strict qualifications.
                         */ if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
                            throw new Error("XMLNS namespace is reserved (well-formed required).");
                        }
                        /**
                         * 3.5.2.3. If the require well-formed flag is set (its value is true),
                         * and the value of attr's value attribute is the empty string, then
                         * throw an exception; namespace prefix declarations cannot be used
                         * to undeclare a namespace (use a default namespace declaration
                         * instead).
                         */ if (requireWellFormed && attr.value === "") {
                            throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
                        }
                        /**
                         * 3.5.2.4. the attr's prefix matches the string "xmlns", then let
                         * candidate prefix be the string "xmlns".
                         */ if (attr.prefix === "xmlns") candidatePrefix = "xmlns";
                    /**
                         * 3.5.3. Otherwise, the attribute namespace is not the XMLNS namespace.
                         * Run these steps:
                         *
                         * _Note:_ The (candidatePrefix === null) check is not in the spec.
                         * We deviate from the spec here. Otherwise a prefix is generated for
                         * all attributes with namespaces.
                         */ } else if (candidatePrefix === null) {
                        if (attr.prefix !== null && (!map.hasPrefix(attr.prefix) || map.has(attr.prefix, attributeNamespace))) {
                            /**
                             * Check if we can use the attribute's own prefix.
                             * We deviate from the spec here.
                             * TODO: This is not an efficient way of searching for prefixes.
                             * Follow developments to the spec.
                             */ candidatePrefix = attr.prefix;
                        } else {
                            /**
                             * 3.5.3.1. Let candidate prefix be the result of generating a prefix
                             * providing map, attribute namespace, and prefix index as input.
                             */ candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
                        }
                        /**
                         * 3.5.3.2. Append the following to result, in the order listed:
                         * 3.5.3.2.1. " " (U+0020 SPACE);
                         * 3.5.3.2.2. The string "xmlns:";
                         * 3.5.3.2.3. The value of candidate prefix;
                         * 3.5.3.2.4. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                         * 3.5.3.2.5. The result of serializing an attribute value given
                         * attribute namespace and the require well-formed flag as input;
                         * 3.5.3.2.6. """ (U+0022 QUOTATION MARK).
                        */ result += " xmlns:" + candidatePrefix + '="' + this._serializeAttributeValue(attributeNamespace, requireWellFormed) + '"';
                    }
                }
                /**
                 * 3.6. Append a " " (U+0020 SPACE) to result.
                 * 3.7. If candidate prefix is not null, then append to result the
                 * concatenation of candidate prefix with ":" (U+003A COLON).
                 */ result += " ";
                if (candidatePrefix !== null) {
                    result += candidatePrefix + ":";
                }
                /**
                 * 3.8. If the require well-formed flag is set (its value is true), and
                 * this attr's localName attribute contains the character
                 * ":" (U+003A COLON) or does not match the XML Name production or
                 * equals "xmlns" and attribute namespace is null, then throw an
                 * exception; the serialization of this attr would not be a
                 * well-formed attribute.
                 */ if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attr.localName) || attr.localName === "xmlns" && attributeNamespace === null)) {
                    throw new Error("Attribute local name contains invalid characters (well-formed required).");
                }
                /**
                 * 3.9. Append the following strings to result, in the order listed:
                 * 3.9.1. The value of attr's localName;
                 * 3.9.2. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 3.9.3. The result of serializing an attribute value given attr's value
                 * attribute and the require well-formed flag as input;
                 * 3.9.4. """ (U+0022 QUOTATION MARK).
                 */ result += attr.localName + '="' + this._serializeAttributeValue(attr.value, requireWellFormed) + '"';
            }
        } catch (e_4_1) {
            e_4 = {
                error: e_4_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_4) throw e_4.error;
            }
        }
        /**
         * 4. Return the value of result.
         */ return result;
    };
    /**
    * Records namespace information for the given element and returns the
    * default namespace attribute value.
    *
    * @param node - element node to process
    * @param map - namespace prefix map
    * @param localPrefixesMap - local prefixes map
    */ XMLSerializerImpl.prototype._recordNamespaceInformation = function(node, map, localPrefixesMap) {
        var e_5, _a;
        /**
         * 1. Let default namespace attr value be null.
         */ var defaultNamespaceAttrValue = null;
        try {
            /**
             * 2. Main: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */ for(var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()){
                var attr = _c.value;
                /**
                 * _Note:_ The following conditional steps find namespace prefixes. Only
                 * attributes in the XMLNS namespace are considered (e.g., attributes made
                 * to look like namespace declarations via
                 * setAttribute("xmlns:pretend-prefix", "pretend-namespace") are not
                 * included).
                 */ /** 2.1. Let attribute namespace be the value of attr's namespaceURI value. */ var attributeNamespace = attr.namespaceURI;
                /** 2.2. Let attribute prefix be the value of attr's prefix. */ var attributePrefix = attr.prefix;
                /** 2.3. If the attribute namespace is the XMLNS namespace, then: */ if (attributeNamespace === infra_1.namespace.XMLNS) {
                    /**
                     * 2.3.1. If attribute prefix is null, then attr is a default namespace
                     * declaration. Set the default namespace attr value to attr's value and
                     * stop running these steps, returning to Main to visit the next
                     * attribute.
                     */ if (attributePrefix === null) {
                        defaultNamespaceAttrValue = attr.value;
                        continue;
                    /**
                         * 2.3.2. Otherwise, the attribute prefix is not null and attr is a
                         * namespace prefix definition. Run the following steps:
                         */ } else {
                        /** 2.3.2.1. Let prefix definition be the value of attr's localName. */ var prefixDefinition = attr.localName;
                        /** 2.3.2.2. Let namespace definition be the value of attr's value. */ var namespaceDefinition = attr.value;
                        /**
                         * 2.3.2.3. If namespace definition is the XML namespace, then stop
                         * running these steps, and return to Main to visit the next
                         * attribute.
                         *
                         * _Note:_ XML namespace definitions in prefixes are completely
                         * ignored (in order to avoid unnecessary work when there might be
                         * prefix conflicts). XML namespaced elements are always handled
                         * uniformly by prefixing (and overriding if necessary) the element's
                         * localname with the reserved "xml" prefix.
                         */ if (namespaceDefinition === infra_1.namespace.XML) {
                            continue;
                        }
                        /**
                         * 2.3.2.4. If namespace definition is the empty string (the
                         * declarative form of having no namespace), then let namespace
                         * definition be null instead.
                         */ if (namespaceDefinition === "") {
                            namespaceDefinition = null;
                        }
                        /**
                         * 2.3.2.5. If prefix definition is found in map given the namespace
                         * namespace definition, then stop running these steps, and return to
                         * Main to visit the next attribute.
                         *
                         * _Note:_ This step avoids adding duplicate prefix definitions for
                         * the same namespace in the map. This has the side-effect of avoiding
                         * later serialization of duplicate namespace prefix declarations in
                         * any descendant nodes.
                         */ if (map.has(prefixDefinition, namespaceDefinition)) {
                            continue;
                        }
                        /**
                         * 2.3.2.6. Add the prefix prefix definition to map given namespace
                         * namespace definition.
                         */ map.set(prefixDefinition, namespaceDefinition);
                        /**
                         * 2.3.2.7. Add the value of prefix definition as a new key to the
                         * local prefixes map, with the namespace definition as the key's
                         * value replacing the value of null with the empty string if
                         * applicable.
                         */ localPrefixesMap[prefixDefinition] = namespaceDefinition || "";
                    }
                }
            }
        } catch (e_5_1) {
            e_5 = {
                error: e_5_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_5) throw e_5.error;
            }
        }
        /**
         * 3. Return the value of default namespace attr value.
         *
         * _Note:_ The empty string is a legitimate return value and is not
         * converted to null.
         */ return defaultNamespaceAttrValue;
    };
    /**
    * Generates a new prefix for the given namespace.
    *
    * @param newNamespace - a namespace to generate prefix for
    * @param prefixMap - namespace prefix map
    * @param prefixIndex - generated namespace prefix index
    */ XMLSerializerImpl.prototype._generatePrefix = function(newNamespace, prefixMap, prefixIndex) {
        /**
         * 1. Let generated prefix be the concatenation of the string "ns" and the
         * current numerical value of prefix index.
         * 2. Let the value of prefix index be incremented by one.
         * 3. Add to map the generated prefix given the new namespace namespace.
         * 4. Return the value of generated prefix.
         */ var generatedPrefix = "ns" + prefixIndex.value;
        prefixIndex.value++;
        prefixMap.set(generatedPrefix, newNamespace);
        return generatedPrefix;
    };
    /**
     * Produces an XML serialization of an attribute value.
     *
     * @param value - attribute value
     * @param requireWellFormed - whether to check conformance
     */ XMLSerializerImpl.prototype._serializeAttributeValue = function(value, requireWellFormed) {
        /**
         * From: https://w3c.github.io/DOM-Parsing/#dfn-serializing-an-attribute-value
         *
         * 1. If the require well-formed flag is set (its value is true), and
         * attribute value contains characters that are not matched by the XML Char
         * production, then throw an exception; the serialization of this attribute
         * value would fail to produce a well-formed element serialization.
         */ if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {
            throw new Error("Invalid characters in attribute value.");
        }
        /**
         * 2. If attribute value is null, then return the empty string.
         */ if (value === null) return "";
        /**
         * 3. Otherwise, attribute value is a string. Return the value of attribute
         * value, first replacing any occurrences of the following:
         * - "&" with "&amp;"
         * - """ with "&quot;"
         * - "<" with "&lt;"
         * - ">" with "&gt;"
         * NOTE
         * This matches behavior present in browsers, and goes above and beyond the
         * grammar requirement in the XML specification's AttValue production by
         * also replacing ">" characters.
         */ var result = "";
        for(var i = 0; i < value.length; i++){
            var c = value[i];
            if (c === '"') result += "&quot;";
            else if (c === "&") result += "&amp;";
            else if (c === "<") result += "&lt;";
            else if (c === ">") result += "&gt;";
            else result += c;
        }
        return result;
    };
    /**
     * Produces an XML serialization of an element node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ XMLSerializerImpl.prototype._serializeElement = function(node, requireWellFormed) {
        var e_6, _a;
        /**
         * From: https://w3c.github.io/DOM-Parsing/#xml-serializing-an-element-node
         *
         * 1. If the require well-formed flag is set (its value is true), and this
         * node's localName attribute contains the character ":" (U+003A COLON) or
         * does not match the XML Name production, then throw an exception; the
         * serialization of this node would not be a well-formed element.
         */ if (requireWellFormed && (node.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(node.localName))) {
            throw new Error("Node local name contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the string "<" (U+003C LESS-THAN SIGN).
         * 3. Let qualified name be an empty string.
         * 4. Let skip end tag be a boolean flag with value false.
         * 5. Let ignore namespace definition attribute be a boolean flag with value
         * false.
         * 6. Given prefix map, copy a namespace prefix map and let map be the
         * result.
         * 7. Let local prefixes map be an empty map. The map has unique Node prefix
         * strings as its keys, with corresponding namespaceURI Node values as the
         * map's key values (in this map, the null namespace is represented by the
         * empty string).
         *
         * _Note:_ This map is local to each element. It is used to ensure there
         * are no conflicting prefixes should a new namespace prefix attribute need
         * to be generated. It is also used to enable skipping of duplicate prefix
         * definitions when writing an element's attributes: the map allows the
         * algorithm to distinguish between a prefix in the namespace prefix map
         * that might be locally-defined (to the current Element) and one that is
         * not.
         * 8. Let local default namespace be the result of recording the namespace
         * information for node given map and local prefixes map.
         *
         * _Note:_ The above step will update map with any found namespace prefix
         * definitions, add the found prefix definitions to the local prefixes map
         * and return a local default namespace value defined by a default namespace
         * attribute if one exists. Otherwise it returns null.
         * 9. Let inherited ns be a copy of namespace.
         * 10. Let ns be the value of node's namespaceURI attribute.
         */ var skipEndTag = false;
        /** 11. If inherited ns is equal to ns, then: */ /**
         * 11.1. If local default namespace is not null, then set ignore
         * namespace definition attribute to true.
         * 11.2. If ns is the XML namespace, then append to qualified name the
         * concatenation of the string "xml:" and the value of node's localName.
         * 11.3. Otherwise, append to qualified name the value of node's
         * localName. The node's prefix if it exists, is dropped.
         */ var qualifiedName = node.localName;
        /** 11.4. Append the value of qualified name to markup. */ var markup = "<" + qualifiedName;
        /**
         * 13. Append to markup the result of the XML serialization of node's
         * attributes given map, prefix index, local prefixes map, ignore namespace
         * definition attribute flag, and require well-formed flag.
         */ markup += this._serializeAttributes(node, requireWellFormed);
        /**
         * 14. If ns is the HTML namespace, and the node's list of children is
         * empty, and the node's localName matches any one of the following void
         * elements: "area", "base", "basefont", "bgsound", "br", "col", "embed",
         * "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta",
         * "param", "source", "track", "wbr"; then append the following to markup,
         * in the order listed:
         * 14.1. " " (U+0020 SPACE);
         * 14.2. "/" (U+002F SOLIDUS).
         * and set the skip end tag flag to true.
         * 15. If ns is not the HTML namespace, and the node's list of children is
         * empty, then append "/" (U+002F SOLIDUS) to markup and set the skip end
         * tag flag to true.
         * 16. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         */ if (node._children.size === 0) {
            markup += "/";
            skipEndTag = true;
        }
        markup += ">";
        /**
         * 17. If the value of skip end tag is true, then return the value of markup
         * and skip the remaining steps. The node is a leaf-node.
         */ if (skipEndTag) return markup;
        try {
            /**
             * 18. If ns is the HTML namespace, and the node's localName matches the
             * string "template", then this is a template element. Append to markup the
             * result of XML serializing a DocumentFragment node given the template
             * element's template contents (a DocumentFragment), providing inherited
             * ns, map, prefix index, and the require well-formed flag.
             *
             * _Note:_ This allows template content to round-trip, given the rules for
             * parsing XHTML documents.
             *
             * 19. Otherwise, append to markup the result of running the XML
             * serialization algorithm on each of node's children, in tree order,
             * providing inherited ns, map, prefix index, and the require well-formed
             * flag.
             */ for(var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()){
                var childNode = _c.value;
                markup += this._serializeNode(childNode, requireWellFormed);
            }
        } catch (e_6_1) {
            e_6 = {
                error: e_6_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_6) throw e_6.error;
            }
        }
        /**
         * 20. Append the following to markup, in the order listed:
         * 20.1. "</" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);
         * 20.2. The value of qualified name;
         * 20.3. ">" (U+003E GREATER-THAN SIGN).
         */ markup += "</" + qualifiedName + ">";
        /**
         * 21. Return the value of markup.
         */ return markup;
    };
    /**
     * Produces an XML serialization of a document node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ XMLSerializerImpl.prototype._serializeDocument = function(node, requireWellFormed) {
        var e_7, _a;
        /**
         * If the require well-formed flag is set (its value is true), and this node
         * has no documentElement (the documentElement attribute's value is null),
         * then throw an exception; the serialization of this node would not be a
         * well-formed document.
         */ if (requireWellFormed && node.documentElement === null) {
            throw new Error("Missing document element (well-formed required).");
        }
        /**
         * Otherwise, run the following steps:
         * 1. Let serialized document be an empty string.
         * 2. For each child child of node, in tree order, run the XML
         * serialization algorithm on the child passing along the provided
         * arguments, and append the result to serialized document.
         *
         * _Note:_ This will serialize any number of ProcessingInstruction and
         * Comment nodes both before and after the Document's documentElement node,
         * including at most one DocumentType node. (Text nodes are not allowed as
         * children of the Document.)
         *
         * 3. Return the value of serialized document.
        */ var serializedDocument = "";
        try {
            for(var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()){
                var childNode = _c.value;
                serializedDocument += this._serializeNode(childNode, requireWellFormed);
            }
        } catch (e_7_1) {
            e_7 = {
                error: e_7_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_7) throw e_7.error;
            }
        }
        return serializedDocument;
    };
    /**
     * Produces an XML serialization of a document fragment node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ XMLSerializerImpl.prototype._serializeDocumentFragment = function(node, requireWellFormed) {
        var e_8, _a;
        /**
         * 1. Let markup the empty string.
         * 2. For each child child of node, in tree order, run the XML serialization
         * algorithm on the child given namespace, prefix map, a reference to prefix
         * index, and flag require well-formed. Concatenate the result to markup.
         * 3. Return the value of markup.
         */ var markup = "";
        try {
            for(var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()){
                var childNode = _c.value;
                markup += this._serializeNode(childNode, requireWellFormed);
            }
        } catch (e_8_1) {
            e_8 = {
                error: e_8_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_8) throw e_8.error;
            }
        }
        return markup;
    };
    /**
     * Produces an XML serialization of the attributes of an element node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ XMLSerializerImpl.prototype._serializeAttributes = function(node, requireWellFormed) {
        var e_9, _a;
        /**
         * 1. Let result be the empty string.
         * 2. Let localname set be a new empty namespace localname set. This
         * localname set will contain tuples of unique attribute namespaceURI and
         * localName pairs, and is populated as each attr is processed. This set is
         * used to [optionally] enforce the well-formed constraint that an element
         * cannot have two attributes with the same namespaceURI and localName.
         * This can occur when two otherwise identical attributes on the same
         * element differ only by their prefix values.
         */ var result = "";
        var localNameSet = requireWellFormed ? {} : undefined;
        try {
            /**
             * 3. Loop: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */ for(var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()){
                var attr = _c.value;
                /**
                 * 3.1. If the require well-formed flag is set (its value is true), and the
                 * localname set contains a tuple whose values match those of a new tuple
                 * consisting of attr's namespaceURI attribute and localName attribute,
                 * then throw an exception; the serialization of this attr would fail to
                 * produce a well-formed element serialization.
                 */ if (requireWellFormed && localNameSet && attr.localName in localNameSet) {
                    throw new Error("Element contains duplicate attributes (well-formed required).");
                }
                /**
                 * 3.2. Create a new tuple consisting of attr's namespaceURI attribute and
                 * localName attribute, and add it to the localname set.
                 * 3.3. Let attribute namespace be the value of attr's namespaceURI value.
                 * 3.4. Let candidate prefix be null.
                 */ if (requireWellFormed && localNameSet) localNameSet[attr.localName] = true;
                /** 3.5. If attribute namespace is not null, then run these sub-steps: */ /**
                 * 3.6. Append a " " (U+0020 SPACE) to result.
                 * 3.7. If candidate prefix is not null, then append to result the
                 * concatenation of candidate prefix with ":" (U+003A COLON).
                 */ /**
                 * 3.8. If the require well-formed flag is set (its value is true), and
                 * this attr's localName attribute contains the character
                 * ":" (U+003A COLON) or does not match the XML Name production or
                 * equals "xmlns" and attribute namespace is null, then throw an
                 * exception; the serialization of this attr would not be a
                 * well-formed attribute.
                 */ if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attr.localName))) {
                    throw new Error("Attribute local name contains invalid characters (well-formed required).");
                }
                /**
                 * 3.9. Append the following strings to result, in the order listed:
                 * 3.9.1. The value of attr's localName;
                 * 3.9.2. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 3.9.3. The result of serializing an attribute value given attr's value
                 * attribute and the require well-formed flag as input;
                 * 3.9.4. """ (U+0022 QUOTATION MARK).
                 */ result += " " + attr.localName + '="' + this._serializeAttributeValue(attr.value, requireWellFormed) + '"';
            }
        } catch (e_9_1) {
            e_9 = {
                error: e_9_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_9) throw e_9.error;
            }
        }
        /**
         * 4. Return the value of result.
         */ return result;
    };
    XMLSerializerImpl._VoidElementNames = new Set([
        "area",
        "base",
        "basefont",
        "bgsound",
        "br",
        "col",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "keygen",
        "link",
        "menuitem",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
    ]);
    return XMLSerializerImpl;
}();
exports.XMLSerializerImpl = XMLSerializerImpl; //# sourceMappingURL=XMLSerializerImpl.js.map


/***/ }),

/***/ 57651:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
// Export classes
var XMLSerializerImpl_1 = __webpack_require__(54374);
exports.XMLSerializer = XMLSerializerImpl_1.XMLSerializerImpl; //# sourceMappingURL=index.js.map


/***/ }),

/***/ 97189:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var Guard_1 = __webpack_require__(66475);
/**
 * Contains type casts for DOM objects.
 */ var Cast = /** @class */ function() {
    function Cast() {}
    /**
     * Casts the given object to a `Node`.
     *
     * @param a - the object to cast
     */ Cast.asNode = function(a) {
        if (Guard_1.Guard.isNode(a)) {
            return a;
        } else {
            throw new Error("Invalid object. Node expected.");
        }
    };
    return Cast;
}();
exports.Cast = Cast; //# sourceMappingURL=Cast.js.map


/***/ }),

/***/ 84256:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var EmptySet = /** @class */ function() {
    function EmptySet() {}
    Object.defineProperty(EmptySet.prototype, "size", {
        get: function() {
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    EmptySet.prototype.add = function(value) {
        throw new Error("Cannot add to an empty set.");
    };
    EmptySet.prototype.clear = function() {
    // no-op
    };
    EmptySet.prototype.delete = function(value) {
        return false;
    };
    EmptySet.prototype.forEach = function(callbackfn, thisArg) {
    // no-op
    };
    EmptySet.prototype.has = function(value) {
        return false;
    };
    EmptySet.prototype[Symbol.iterator] = function() {
        return new EmptySetIterator();
    };
    EmptySet.prototype.entries = function() {
        return new EmptySetIterator();
    };
    EmptySet.prototype.keys = function() {
        return new EmptySetIterator();
    };
    EmptySet.prototype.values = function() {
        return new EmptySetIterator();
    };
    Object.defineProperty(EmptySet.prototype, Symbol.toStringTag, {
        get: function() {
            return "EmptySet";
        },
        enumerable: true,
        configurable: true
    });
    return EmptySet;
}();
exports.EmptySet = EmptySet;
var EmptySetIterator = /** @class */ function() {
    function EmptySetIterator() {}
    EmptySetIterator.prototype[Symbol.iterator] = function() {
        return this;
    };
    EmptySetIterator.prototype.next = function() {
        return {
            done: true,
            value: null
        };
    };
    return EmptySetIterator;
}(); //# sourceMappingURL=EmptySet.js.map


/***/ }),

/***/ 66475:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
/**
 * Contains user-defined type guards for DOM objects.
 */ var Guard = /** @class */ function() {
    function Guard() {}
    /**
     * Determines if the given object is a `Node`.
     *
     * @param a - the object to check
     */ Guard.isNode = function(a) {
        return !!a && a._nodeType !== undefined;
    };
    /**
     * Determines if the given object is a `Document`.
     *
     * @param a - the object to check
     */ Guard.isDocumentNode = function(a) {
        return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Document;
    };
    /**
     * Determines if the given object is a `DocumentType`.
     *
     * @param a - the object to check
     */ Guard.isDocumentTypeNode = function(a) {
        return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.DocumentType;
    };
    /**
     * Determines if the given object is a `DocumentFragment`.
     *
     * @param a - the object to check
     */ Guard.isDocumentFragmentNode = function(a) {
        return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.DocumentFragment;
    };
    /**
     * Determines if the given object is a `Attr`.
     *
     * @param a - the object to check
     */ Guard.isAttrNode = function(a) {
        return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Attribute;
    };
    /**
     * Determines if the given node is a `CharacterData` node.
     *
     * @param a - the object to check
     */ Guard.isCharacterDataNode = function(a) {
        if (!Guard.isNode(a)) return false;
        var type = a._nodeType;
        return type === interfaces_1.NodeType.Text || type === interfaces_1.NodeType.ProcessingInstruction || type === interfaces_1.NodeType.Comment || type === interfaces_1.NodeType.CData;
    };
    /**
     * Determines if the given object is a `Text` or a `CDATASection`.
     *
     * @param a - the object to check
     */ Guard.isTextNode = function(a) {
        return Guard.isNode(a) && (a._nodeType === interfaces_1.NodeType.Text || a._nodeType === interfaces_1.NodeType.CData);
    };
    /**
     * Determines if the given object is a `Text`.
     *
     * @param a - the object to check
     */ Guard.isExclusiveTextNode = function(a) {
        return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Text;
    };
    /**
     * Determines if the given object is a `CDATASection`.
     *
     * @param a - the object to check
     */ Guard.isCDATASectionNode = function(a) {
        return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.CData;
    };
    /**
     * Determines if the given object is a `Comment`.
     *
     * @param a - the object to check
     */ Guard.isCommentNode = function(a) {
        return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Comment;
    };
    /**
     * Determines if the given object is a `ProcessingInstruction`.
     *
     * @param a - the object to check
     */ Guard.isProcessingInstructionNode = function(a) {
        return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.ProcessingInstruction;
    };
    /**
     * Determines if the given object is an `Element`.
     *
     * @param a - the object to check
     */ Guard.isElementNode = function(a) {
        return Guard.isNode(a) && a._nodeType === interfaces_1.NodeType.Element;
    };
    /**
     * Determines if the given object is a custom `Element`.
     *
     * @param a - the object to check
     */ Guard.isCustomElementNode = function(a) {
        return Guard.isElementNode(a) && a._customElementState === "custom";
    };
    /**
     * Determines if the given object is a `ShadowRoot`.
     *
     * @param a - the object to check
     */ Guard.isShadowRoot = function(a) {
        return !!a && a.host !== undefined;
    };
    /**
     * Determines if the given object is a `MouseEvent`.
     *
     * @param a - the object to check
     */ Guard.isMouseEvent = function(a) {
        return !!a && a.screenX !== undefined && a.screenY != undefined;
    };
    /**
     * Determines if the given object is a slotable.
     *
     * Element and Text nodes are slotables. A slotable has an associated name
     * (a string).
     *
     * @param a - the object to check
     */ Guard.isSlotable = function(a) {
        return !!a && a._name !== undefined && a._assignedSlot !== undefined && (Guard.isTextNode(a) || Guard.isElementNode(a));
    };
    /**
     * Determines if the given object is a slot.
     *
     * @param a - the object to check
     */ Guard.isSlot = function(a) {
        return !!a && a._name !== undefined && a._assignedNodes !== undefined && Guard.isElementNode(a);
    };
    /**
     * Determines if the given object is a `Window`.
     *
     * @param a - the object to check
     */ Guard.isWindow = function(a) {
        return !!a && a.navigator !== undefined;
    };
    /**
     * Determines if the given object is an `EventListener`.
     *
     * @param a - the object to check
     */ Guard.isEventListener = function(a) {
        return !!a && a.handleEvent !== undefined;
    };
    /**
     * Determines if the given object is a `RegisteredObserver`.
     *
     * @param a - the object to check
     */ Guard.isRegisteredObserver = function(a) {
        return !!a && a.observer !== undefined && a.options !== undefined;
    };
    /**
   * Determines if the given object is a `TransientRegisteredObserver`.
   *
   * @param a - the object to check
   */ Guard.isTransientRegisteredObserver = function(a) {
        return !!a && a.source !== undefined && Guard.isRegisteredObserver(a);
    };
    return Guard;
}();
exports.Guard = Guard; //# sourceMappingURL=Guard.js.map


/***/ }),

/***/ 57294:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var Cast_1 = __webpack_require__(97189);
exports.Cast = Cast_1.Cast;
var Guard_1 = __webpack_require__(66475);
exports.Guard = Guard_1.Guard;
var EmptySet_1 = __webpack_require__(84256);
exports.EmptySet = EmptySet_1.EmptySet; //# sourceMappingURL=index.js.map


/***/ }),

/***/ 1606:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var CodePoints_1 = __webpack_require__(96030);
/**
 * Base-64 encodes the given string.
 *
 * @param input - a string
 */ function forgivingBase64Encode(input) {
    /**
     * To forgiving-base64 encode given a byte sequence data, apply the base64
     * algorithm defined in section 4 of RFC 4648 to data and return the result.
     * [RFC4648]
     */ return Buffer.from(input).toString("base64");
}
exports.forgivingBase64Encode = forgivingBase64Encode;
/**
 * Decodes a base-64 string.
 *
 * @param input - a string
 */ function forgivingBase64Decode(input) {
    if (input === "") return "";
    /**
     * 1. Remove all ASCII whitespace from data.
     */ input = input.replace(CodePoints_1.ASCIIWhiteSpace, "");
    /**
     * 2. If data’s length divides by 4 leaving no remainder, then:
     * 2.1. If data ends with one or two U+003D (=) code points, then remove them from data.
     */ if (input.length % 4 === 0) {
        if (input.endsWith("==")) {
            input = input.substr(0, input.length - 2);
        } else if (input.endsWith("=")) {
            input = input.substr(0, input.length - 1);
        }
    }
    /**
     * 3. If data’s length divides by 4 leaving a remainder of 1, then return failure.
     */ if (input.length % 4 === 1) return null;
    /**
     * 4. If data contains a code point that is not one of
     * - U+002B (+)
     * - U+002F (/)
     * - ASCII alphanumeric
     * then return failure.
     */ if (!/[0-9A-Za-z+/]/.test(input)) return null;
    /**
     * 5. Let output be an empty byte sequence.
     * 6. Let buffer be an empty buffer that can have bits appended to it.
     * 7. Let position be a position variable for data, initially pointing at the
     * start of data.
     * 8. While position does not point past the end of data:
     * 8.1. Find the code point pointed to by position in the second column of
     * Table 1: The Base 64 Alphabet of RFC 4648. Let n be the number given in the
     * first cell of the same row. [RFC4648]
     * 8.2. Append the six bits corresponding to n, most significant bit first,
     * to buffer.
     * 8.3. If buffer has accumulated 24 bits, interpret them as three 8-bit
     * big-endian numbers. Append three bytes with values equal to those numbers
     * to output, in the same order, and then empty buffer.
     * 8.4. Advance position by 1.
     * 9. If buffer is not empty, it contains either 12 or 18 bits. If it contains
     * 12 bits, then discard the last four and interpret the remaining eight as an
     * 8-bit big-endian number. If it contains 18 bits, then discard the last two
     * and interpret the remaining 16 as two 8-bit big-endian numbers. Append the
     * one or two bytes with values equal to those one or two numbers to output,
     * in the same order.
     * 10. Return output.
     */ return Buffer.from(input, "base64").toString("utf8");
}
exports.forgivingBase64Decode = forgivingBase64Decode; //# sourceMappingURL=Base64.js.map


/***/ }),

/***/ 47192:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Determines if the given number is an ASCII byte.
 *
 * @param byte - a byte
 */ function isASCIIByte(byte) {
    /**
     * An ASCII byte is a byte in the range 0x00 (NUL) to 0x7F (DEL), inclusive.
     */ return byte >= 0x00 && byte <= 0x7F;
}
exports.isASCIIByte = isASCIIByte; //# sourceMappingURL=Byte.js.map


/***/ }),

/***/ 96768:
/***/ ((__unused_webpack_module, exports) => {


var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = (void 0) && (void 0).__spread || function() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Returns the count of bytes in a sequence.
 *
 * @param list - a byte sequence
 */ function length(list) {
    /**
     * A byte sequence’s length is the number of bytes it contains.
     */ return list.length;
}
exports.length = length;
/**
 * Converts each byte to lowercase.
 *
 * @param list - a byte sequence
 */ function byteLowercase(list) {
    /**
     * To byte-lowercase a byte sequence, increase each byte it contains, in the
     * range 0x41 (A) to 0x5A (Z), inclusive, by 0x20.
     */ for(var i = 0; i < list.length; i++){
        var c = list[i];
        if (c >= 0x41 && c <= 0x5A) {
            list[i] = c + 0x20;
        }
    }
}
exports.byteLowercase = byteLowercase;
/**
 * Converts each byte to uppercase.
 *
 * @param list - a byte sequence
 */ function byteUppercase(list) {
    /**
     * To byte-uppercase a byte sequence, subtract each byte it contains, in the
     * range 0x61 (a) to 0x7A (z), inclusive, by 0x20.
     */ for(var i = 0; i < list.length; i++){
        var c = list[i];
        if (c >= 0x61 && c <= 0x7A) {
            list[i] = c - 0x20;
        }
    }
}
exports.byteUppercase = byteUppercase;
/**
 * Compares two byte sequences.
 *
 * @param listA - a byte sequence
 * @param listB - a byte sequence
 */ function byteCaseInsensitiveMatch(listA, listB) {
    /**
     * A byte sequence A is a byte-case-insensitive match for a byte sequence B,
     * if the byte-lowercase of A is the byte-lowercase of B.
     */ if (listA.length !== listB.length) return false;
    for(var i = 0; i < listA.length; i++){
        var a = listA[i];
        var b = listB[i];
        if (a >= 0x41 && a <= 0x5A) a += 0x20;
        if (b >= 0x41 && b <= 0x5A) b += 0x20;
        if (a !== b) return false;
    }
    return true;
}
exports.byteCaseInsensitiveMatch = byteCaseInsensitiveMatch;
/**
 * Determines if `listA` starts with `listB`.
 *
 * @param listA - a byte sequence
 * @param listB - a byte sequence
 */ function startsWith(listA, listB) {
    /**
     * 1. Let i be 0.
     * 2. While true:
     * 2.1. Let aByte be the ith byte of a if i is less than a’s length; otherwise null.
     * 2.3. Let bByte be the ith byte of b if i is less than b’s length; otherwise null.
     * 2.4. If bByte is null, then return true.
     * 2.5. Return false if aByte is not bByte.
     * 2.6. Set i to i + 1.
     */ var i = 0;
    while(true){
        if (i >= listA.length) return false;
        if (i >= listB.length) return true;
        if (listA[i] !== listB[i]) return false;
        i++;
    }
}
exports.startsWith = startsWith;
/**
 * Determines if `listA` is less than `listB`.
 *
 * @param listA - a byte sequence
 * @param listB - a byte sequence
 */ function byteLessThan(listA, listB) {
    /**
     * 1. If b starts with a, then return false.
     * 2. If a starts with b, then return true.
     * 3. Let n be the smallest index such that the nth byte of a is different
     * from the nth byte of b. (There has to be such an index, since neither byte
     * sequence starts with the other.)
     * 4. If the nth byte of a is less than the nth byte of b, then return true.
     * 5. Return false.
     */ var i = 0;
    while(true){
        if (i >= listA.length) return false;
        if (i >= listB.length) return true;
        var a = listA[i];
        var b = listB[i];
        if (a < b) return true;
        else if (a > b) return false;
        i++;
    }
}
exports.byteLessThan = byteLessThan;
/**
 * Decodes a byte sequence into a string.
 *
 * @param list - a byte sequence
 */ function isomorphicDecode(list) {
    /**
     * To isomorphic decode a byte sequence input, return a string whose length is
     * equal to input’s length and whose code points have the same values as
     * input’s bytes, in the same order.
     */ return String.fromCodePoint.apply(String, __spread(list));
}
exports.isomorphicDecode = isomorphicDecode; //# sourceMappingURL=ByteSequence.js.map


/***/ }),

/***/ 96030:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * A surrogate is a code point that is in the range U+D800 to U+DFFF, inclusive.
 */ exports.Surrogate = /[\uD800-\uDFFF]/;
/**
 * A scalar value is a code point that is not a surrogate.
 */ exports.ScalarValue = /[\uD800-\uDFFF]/;
/**
 * A noncharacter is a code point that is in the range U+FDD0 to U+FDEF,
 * inclusive, or U+FFFE, U+FFFF, U+1FFFE, U+1FFFF, U+2FFFE, U+2FFFF, U+3FFFE,
 * U+3FFFF, U+4FFFE, U+4FFFF, U+5FFFE, U+5FFFF, U+6FFFE, U+6FFFF, U+7FFFE,
 * U+7FFFF, U+8FFFE, U+8FFFF, U+9FFFE, U+9FFFF, U+AFFFE, U+AFFFF, U+BFFFE,
 * U+BFFFF, U+CFFFE, U+CFFFF, U+DFFFE, U+DFFFF, U+EFFFE, U+EFFFF, U+FFFFE,
 * U+FFFFF, U+10FFFE, or U+10FFFF.
 */ exports.NonCharacter = /[\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]/;
/**
 * An ASCII code point is a code point in the range U+0000 NULL to U+007F
 * DELETE, inclusive.
 */ exports.ASCIICodePoint = /[\u0000-\u007F]/;
/**
 * An ASCII tab or newline is U+0009 TAB, U+000A LF, or U+000D CR.
 */ exports.ASCIITabOrNewLine = /[\t\n\r]/;
/**
 * ASCII whitespace is U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, or
 * U+0020 SPACE.
 */ exports.ASCIIWhiteSpace = /[\t\n\f\r ]/;
/**
 * A C0 control is a code point in the range U+0000 NULL to U+001F
 * INFORMATION SEPARATOR ONE, inclusive.
 */ exports.C0Control = /[\u0000-\u001F]/;
/**
 * A C0 control or space is a C0 control or U+0020 SPACE.
 */ exports.C0ControlOrSpace = /[\u0000-\u001F ]/;
/**
 * A control is a C0 control or a code point in the range U+007F DELETE to
 * U+009F APPLICATION PROGRAM COMMAND, inclusive.
 */ exports.Control = /[\u0000-\u001F\u007F-\u009F]/;
/**
 * An ASCII digit is a code point in the range U+0030 (0) to U+0039 (9),
 * inclusive.
 */ exports.ASCIIDigit = /[0-9]/;
/**
 * An ASCII upper hex digit is an ASCII digit or a code point in the range
 * U+0041 (A) to U+0046 (F), inclusive.
 */ exports.ASCIIUpperHexDigit = /[0-9A-F]/;
/**
 * An ASCII lower hex digit is an ASCII digit or a code point in the range
 * U+0061 (a) to U+0066 (f), inclusive.
 */ exports.ASCIILowerHexDigit = /[0-9a-f]/;
/**
 * An ASCII hex digit is an ASCII upper hex digit or ASCII lower hex digit.
 */ exports.ASCIIHexDigit = /[0-9A-Fa-f]/;
/**
 * An ASCII upper alpha is a code point in the range U+0041 (A) to U+005A (Z),
 * inclusive.
 */ exports.ASCIIUpperAlpha = /[A-Z]/;
/**
 * An ASCII lower alpha is a code point in the range U+0061 (a) to U+007A (z),
 * inclusive.
 */ exports.ASCIILowerAlpha = /[a-z]/;
/**
 * An ASCII alpha is an ASCII upper alpha or ASCII lower alpha.
 */ exports.ASCIIAlpha = /[A-Za-z]/;
/**
 * An ASCII alphanumeric is an ASCII digit or ASCII alpha.
 */ exports.ASCIIAlphanumeric = /[0-9A-Za-z]/; //# sourceMappingURL=CodePoints.js.map


/***/ }),

/***/ 19002:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(96883);
/**
 * Parses the given byte sequence representing a JSON string into an object.
 *
 * @param bytes - a byte sequence
 */ function parseJSONFromBytes(bytes) {
    /**
     * 1. Let jsonText be the result of running UTF-8 decode on bytes. [ENCODING]
     * 2. Return ? Call(%JSONParse%, undefined, « jsonText »).
     */ var jsonText = util_1.utf8Decode(bytes);
    return JSON.parse.call(undefined, jsonText);
}
exports.parseJSONFromBytes = parseJSONFromBytes;
/**
 * Serialize the given JavaScript value into a byte sequence.
 *
 * @param value - a JavaScript value
 */ function serializeJSONToBytes(value) {
    /**
     * 1. Let jsonString be ? Call(%JSONStringify%, undefined, « value »).
     * 2. Return the result of running UTF-8 encode on jsonString. [ENCODING]
     */ var jsonString = JSON.stringify.call(undefined, value);
    return util_1.utf8Encode(jsonString);
}
exports.serializeJSONToBytes = serializeJSONToBytes;
/**
 * Parses the given JSON string into a Realm-independent JavaScript value.
 *
 * @param jsonText - a JSON string
 */ function parseJSONIntoInfraValues(jsonText) {
    /**
     * 1. Let jsValue be ? Call(%JSONParse%, undefined, « jsonText »).
     * 2. Return the result of converting a JSON-derived JavaScript value to an
     * Infra value, given jsValue.
     */ var jsValue = JSON.parse.call(undefined, jsonText);
    return convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue);
}
exports.parseJSONIntoInfraValues = parseJSONIntoInfraValues;
/**
 * Parses the value into a Realm-independent JavaScript value.
 *
 * @param jsValue - a JavaScript value
 */ function convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValue) {
    var e_1, _a;
    /**
     * 1. If Type(jsValue) is Null, String, or Number, then return jsValue.
     */ if (jsValue === null || util_1.isString(jsValue) || util_1.isNumber(jsValue)) return jsValue;
    /**
     * 2. If IsArray(jsValue) is true, then:
     * 2.1. Let result be an empty list.
     * 2.2. Let length be ! ToLength(! Get(jsValue, "length")).
     * 2.3. For each index of the range 0 to length − 1, inclusive:
     * 2.3.1. Let indexName be ! ToString(index).
     * 2.3.2. Let jsValueAtIndex be ! Get(jsValue, indexName).
     * 2.3.3. Let infraValueAtIndex be the result of converting a JSON-derived
     * JavaScript value to an Infra value, given jsValueAtIndex.
     * 2.3.4. Append infraValueAtIndex to result.
     * 2.8. Return result.
     */ if (util_1.isArray(jsValue)) {
        var result = new Array();
        try {
            for(var jsValue_1 = __values(jsValue), jsValue_1_1 = jsValue_1.next(); !jsValue_1_1.done; jsValue_1_1 = jsValue_1.next()){
                var jsValueAtIndex = jsValue_1_1.value;
                result.push(convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtIndex));
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (jsValue_1_1 && !jsValue_1_1.done && (_a = jsValue_1.return)) _a.call(jsValue_1);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        return result;
    } else if (util_1.isObject(jsValue)) {
        /**
         * 3. Let result be an empty ordered map.
         * 4. For each key of ! jsValue.[[OwnPropertyKeys]]():
         * 4.1. Let jsValueAtKey be ! Get(jsValue, key).
         * 4.2. Let infraValueAtKey be the result of converting a JSON-derived
         * JavaScript value to an Infra value, given jsValueAtKey.
         * 4.3. Set result[key] to infraValueAtKey.
         * 5. Return result.
         */ var result = new Map();
        for(var key in jsValue){
            /* istanbul ignore else */ if (jsValue.hasOwnProperty(key)) {
                var jsValueAtKey = jsValue[key];
                result.set(key, convertAJSONDerivedJavaScriptValueToAnInfraValue(jsValueAtKey));
            }
        }
        return result;
    }
    /* istanbul ignore next */ return jsValue;
}
exports.convertAJSONDerivedJavaScriptValueToAnInfraValue = convertAJSONDerivedJavaScriptValueToAnInfraValue; //# sourceMappingURL=JSON.js.map


/***/ }),

/***/ 42299:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __generator = (void 0) && (void 0).__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = (void 0) && (void 0).__spread || function() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(96883);
/**
 * Adds the given item to the end of the list.
 *
 * @param list - a list
 * @param item - an item
 */ function append(list, item) {
    list.push(item);
}
exports.append = append;
/**
 * Extends a list by appending all items from another list.
 *
 * @param listA - a list to extend
 * @param listB - a list containing items to append to `listA`
 */ function extend(listA, listB) {
    listA.push.apply(listA, __spread(listB));
}
exports.extend = extend;
/**
 * Inserts the given item to the start of the list.
 *
 * @param list - a list
 * @param item - an item
 */ function prepend(list, item) {
    list.unshift(item);
}
exports.prepend = prepend;
/**
 * Replaces the given item or all items matching condition with a new item.
 *
 * @param list - a list
 * @param conditionOrItem - an item to replace or a condition matching items
 * to replace
 * @param item - an item
 */ function replace(list, conditionOrItem, newItem) {
    var e_1, _a;
    var i = 0;
    try {
        for(var list_1 = __values(list), list_1_1 = list_1.next(); !list_1_1.done; list_1_1 = list_1.next()){
            var oldItem = list_1_1.value;
            if (util_1.isFunction(conditionOrItem)) {
                if (!!conditionOrItem.call(null, oldItem)) {
                    list[i] = newItem;
                }
            } else if (oldItem === conditionOrItem) {
                list[i] = newItem;
                return;
            }
            i++;
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (list_1_1 && !list_1_1.done && (_a = list_1.return)) _a.call(list_1);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
}
exports.replace = replace;
/**
 * Inserts the given item before the given index.
 *
 * @param list - a list
 * @param item - an item
 */ function insert(list, item, index) {
    list.splice(index, 0, item);
}
exports.insert = insert;
/**
 * Removes the given item or all items matching condition.
 *
 * @param list - a list
 * @param conditionOrItem - an item to remove or a condition matching items
 * to remove
 */ function remove(list, conditionOrItem) {
    var i = list.length;
    while(i--){
        var oldItem = list[i];
        if (util_1.isFunction(conditionOrItem)) {
            if (!!conditionOrItem.call(null, oldItem)) {
                list.splice(i, 1);
            }
        } else if (oldItem === conditionOrItem) {
            list.splice(i, 1);
            return;
        }
    }
}
exports.remove = remove;
/**
 * Removes all items from the list.
 */ function empty(list) {
    list.length = 0;
}
exports.empty = empty;
/**
 * Determines if the list contains the given item or any items matching
 * condition.
 *
 * @param list - a list
 * @param conditionOrItem - an item to a condition to match
 */ function contains(list, conditionOrItem) {
    var e_2, _a;
    try {
        for(var list_2 = __values(list), list_2_1 = list_2.next(); !list_2_1.done; list_2_1 = list_2.next()){
            var oldItem = list_2_1.value;
            if (util_1.isFunction(conditionOrItem)) {
                if (!!conditionOrItem.call(null, oldItem)) {
                    return true;
                }
            } else if (oldItem === conditionOrItem) {
                return true;
            }
        }
    } catch (e_2_1) {
        e_2 = {
            error: e_2_1
        };
    } finally{
        try {
            if (list_2_1 && !list_2_1.done && (_a = list_2.return)) _a.call(list_2);
        } finally{
            if (e_2) throw e_2.error;
        }
    }
    return false;
}
exports.contains = contains;
/**
 * Returns the count of items in the list matching the given condition.
 *
 * @param list - a list
 * @param condition - an optional condition to match
 */ function size(list, condition) {
    var e_3, _a;
    if (condition === undefined) {
        return list.length;
    } else {
        var count = 0;
        try {
            for(var list_3 = __values(list), list_3_1 = list_3.next(); !list_3_1.done; list_3_1 = list_3.next()){
                var item = list_3_1.value;
                if (!!condition.call(null, item)) {
                    count++;
                }
            }
        } catch (e_3_1) {
            e_3 = {
                error: e_3_1
            };
        } finally{
            try {
                if (list_3_1 && !list_3_1.done && (_a = list_3.return)) _a.call(list_3);
            } finally{
                if (e_3) throw e_3.error;
            }
        }
        return count;
    }
}
exports.size = size;
/**
 * Determines if the list is empty.
 *
 * @param list - a list
 */ function isEmpty(list) {
    return list.length === 0;
}
exports.isEmpty = isEmpty;
/**
 * Returns an iterator for the items of the list.
 *
 * @param list - a list
 * @param condition - an optional condition to match
 */ function forEach(list, condition) {
    var list_4, list_4_1, item, e_4_1;
    var e_4, _a;
    return __generator(this, function(_b) {
        switch(_b.label){
            case 0:
                if (!(condition === undefined)) return [
                    3 /*break*/ ,
                    2
                ];
                return [
                    5 /*yield**/ ,
                    __values(list)
                ];
            case 1:
                _b.sent();
                return [
                    3 /*break*/ ,
                    9
                ];
            case 2:
                _b.trys.push([
                    2,
                    7,
                    8,
                    9
                ]);
                list_4 = __values(list), list_4_1 = list_4.next();
                _b.label = 3;
            case 3:
                if (!!list_4_1.done) return [
                    3 /*break*/ ,
                    6
                ];
                item = list_4_1.value;
                if (!!!condition.call(null, item)) return [
                    3 /*break*/ ,
                    5
                ];
                return [
                    4 /*yield*/ ,
                    item
                ];
            case 4:
                _b.sent();
                _b.label = 5;
            case 5:
                list_4_1 = list_4.next();
                return [
                    3 /*break*/ ,
                    3
                ];
            case 6:
                return [
                    3 /*break*/ ,
                    9
                ];
            case 7:
                e_4_1 = _b.sent();
                e_4 = {
                    error: e_4_1
                };
                return [
                    3 /*break*/ ,
                    9
                ];
            case 8:
                try {
                    if (list_4_1 && !list_4_1.done && (_a = list_4.return)) _a.call(list_4);
                } finally{
                    if (e_4) throw e_4.error;
                }
                return [
                    7 /*endfinally*/ 
                ];
            case 9:
                return [
                    2 /*return*/ 
                ];
        }
    });
}
exports.forEach = forEach;
/**
 * Creates and returns a shallow clone of list.
 *
 * @param list - a list
 */ function clone(list) {
    return new (Array.bind.apply(Array, __spread([
        void 0
    ], list)))();
}
exports.clone = clone;
/**
 * Returns a new list containing items from the list sorted in ascending
 * order.
 *
 * @param list - a list
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */ function sortInAscendingOrder(list, lessThanAlgo) {
    return list.sort(function(itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? -1 : 1;
    });
}
exports.sortInAscendingOrder = sortInAscendingOrder;
/**
 * Returns a new list containing items from the list sorted in descending
 * order.
 *
 * @param list - a list
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */ function sortInDescendingOrder(list, lessThanAlgo) {
    return list.sort(function(itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? 1 : -1;
    });
}
exports.sortInDescendingOrder = sortInDescendingOrder; //# sourceMappingURL=List.js.map


/***/ }),

/***/ 55307:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __generator = (void 0) && (void 0).__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = (void 0) && (void 0).__spread || function() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(96883);
/**
 * Gets the value corresponding to the given key.
 *
 * @param map - a map
 * @param key - a key
 */ function get(map, key) {
    return map.get(key);
}
exports.get = get;
/**
 * Sets the value corresponding to the given key.
 *
 * @param map - a map
 * @param key - a key
 * @param val - a value
 */ function set(map, key, val) {
    map.set(key, val);
}
exports.set = set;
/**
 * Removes the item with the given key or all items matching condition.
 *
 * @param map - a map
 * @param conditionOrItem - the key of an item to remove or a condition matching
 * items to remove
 */ function remove(map, conditionOrItem) {
    var e_1, _a, e_2, _b;
    if (!util_1.isFunction(conditionOrItem)) {
        map.delete(conditionOrItem);
    } else {
        var toRemove = [];
        try {
            for(var map_1 = __values(map), map_1_1 = map_1.next(); !map_1_1.done; map_1_1 = map_1.next()){
                var item = map_1_1.value;
                if (!!conditionOrItem.call(null, item)) {
                    toRemove.push(item[0]);
                }
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (map_1_1 && !map_1_1.done && (_a = map_1.return)) _a.call(map_1);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        try {
            for(var toRemove_1 = __values(toRemove), toRemove_1_1 = toRemove_1.next(); !toRemove_1_1.done; toRemove_1_1 = toRemove_1.next()){
                var key = toRemove_1_1.value;
                map.delete(key);
            }
        } catch (e_2_1) {
            e_2 = {
                error: e_2_1
            };
        } finally{
            try {
                if (toRemove_1_1 && !toRemove_1_1.done && (_b = toRemove_1.return)) _b.call(toRemove_1);
            } finally{
                if (e_2) throw e_2.error;
            }
        }
    }
}
exports.remove = remove;
/**
 * Determines if the map contains a value with the given key.
 *
 * @param map - a map
 * @param conditionOrItem - the key of an item to match or a condition matching
 * items
 */ function contains(map, conditionOrItem) {
    var e_3, _a;
    if (!util_1.isFunction(conditionOrItem)) {
        return map.has(conditionOrItem);
    } else {
        try {
            for(var map_2 = __values(map), map_2_1 = map_2.next(); !map_2_1.done; map_2_1 = map_2.next()){
                var item = map_2_1.value;
                if (!!conditionOrItem.call(null, item)) {
                    return true;
                }
            }
        } catch (e_3_1) {
            e_3 = {
                error: e_3_1
            };
        } finally{
            try {
                if (map_2_1 && !map_2_1.done && (_a = map_2.return)) _a.call(map_2);
            } finally{
                if (e_3) throw e_3.error;
            }
        }
        return false;
    }
}
exports.contains = contains;
/**
 * Gets the keys of the map.
 *
 * @param map - a map
 */ function keys(map) {
    return new Set(map.keys());
}
exports.keys = keys;
/**
 * Gets the values of the map.
 *
 * @param map - a map
 */ function values(map) {
    return __spread(map.values());
}
exports.values = values;
/**
 * Gets the size of the map.
 *
 * @param map - a map
 * @param condition - an optional condition to match
 */ function size(map, condition) {
    var e_4, _a;
    if (condition === undefined) {
        return map.size;
    } else {
        var count = 0;
        try {
            for(var map_3 = __values(map), map_3_1 = map_3.next(); !map_3_1.done; map_3_1 = map_3.next()){
                var item = map_3_1.value;
                if (!!condition.call(null, item)) {
                    count++;
                }
            }
        } catch (e_4_1) {
            e_4 = {
                error: e_4_1
            };
        } finally{
            try {
                if (map_3_1 && !map_3_1.done && (_a = map_3.return)) _a.call(map_3);
            } finally{
                if (e_4) throw e_4.error;
            }
        }
        return count;
    }
}
exports.size = size;
/**
 * Determines if the map is empty.
 *
 * @param map - a map
 */ function isEmpty(map) {
    return map.size === 0;
}
exports.isEmpty = isEmpty;
/**
 * Returns an iterator for the items of the map.
 *
 * @param map - a map
 * @param condition - an optional condition to match
 */ function forEach(map, condition) {
    var map_4, map_4_1, item, e_5_1;
    var e_5, _a;
    return __generator(this, function(_b) {
        switch(_b.label){
            case 0:
                if (!(condition === undefined)) return [
                    3 /*break*/ ,
                    2
                ];
                return [
                    5 /*yield**/ ,
                    __values(map)
                ];
            case 1:
                _b.sent();
                return [
                    3 /*break*/ ,
                    9
                ];
            case 2:
                _b.trys.push([
                    2,
                    7,
                    8,
                    9
                ]);
                map_4 = __values(map), map_4_1 = map_4.next();
                _b.label = 3;
            case 3:
                if (!!map_4_1.done) return [
                    3 /*break*/ ,
                    6
                ];
                item = map_4_1.value;
                if (!!!condition.call(null, item)) return [
                    3 /*break*/ ,
                    5
                ];
                return [
                    4 /*yield*/ ,
                    item
                ];
            case 4:
                _b.sent();
                _b.label = 5;
            case 5:
                map_4_1 = map_4.next();
                return [
                    3 /*break*/ ,
                    3
                ];
            case 6:
                return [
                    3 /*break*/ ,
                    9
                ];
            case 7:
                e_5_1 = _b.sent();
                e_5 = {
                    error: e_5_1
                };
                return [
                    3 /*break*/ ,
                    9
                ];
            case 8:
                try {
                    if (map_4_1 && !map_4_1.done && (_a = map_4.return)) _a.call(map_4);
                } finally{
                    if (e_5) throw e_5.error;
                }
                return [
                    7 /*endfinally*/ 
                ];
            case 9:
                return [
                    2 /*return*/ 
                ];
        }
    });
}
exports.forEach = forEach;
/**
 * Creates and returns a shallow clone of map.
 *
 * @param map - a map
 */ function clone(map) {
    return new Map(map);
}
exports.clone = clone;
/**
 * Returns a new map containing items from the map sorted in ascending
 * order.
 *
 * @param map - a map
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */ function sortInAscendingOrder(map, lessThanAlgo) {
    var list = new (Array.bind.apply(Array, __spread([
        void 0
    ], map)))();
    list.sort(function(itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? -1 : 1;
    });
    return new Map(list);
}
exports.sortInAscendingOrder = sortInAscendingOrder;
/**
 * Returns a new map containing items from the map sorted in descending
 * order.
 *
 * @param map - a map
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */ function sortInDescendingOrder(map, lessThanAlgo) {
    var list = new (Array.bind.apply(Array, __spread([
        void 0
    ], map)))();
    list.sort(function(itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? 1 : -1;
    });
    return new Map(list);
}
exports.sortInDescendingOrder = sortInDescendingOrder; //# sourceMappingURL=Map.js.map


/***/ }),

/***/ 21417:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.HTML = "http://www.w3.org/1999/xhtml";
exports.XML = "http://www.w3.org/XML/1998/namespace";
exports.XMLNS = "http://www.w3.org/2000/xmlns/";
exports.MathML = "http://www.w3.org/1998/Math/MathML";
exports.SVG = "http://www.w3.org/2000/svg";
exports.XLink = "http://www.w3.org/1999/xlink"; //# sourceMappingURL=Namespace.js.map


/***/ }),

/***/ 95961:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Appends the given item to the queue.
 *
 * @param list - a list
 * @param item - an item
 */ function enqueue(list, item) {
    list.push(item);
}
exports.enqueue = enqueue;
/**
 * Removes and returns an item from the queue.
 *
 * @param list - a list
 */ function dequeue(list) {
    return list.shift() || null;
}
exports.dequeue = dequeue; //# sourceMappingURL=Queue.js.map


/***/ }),

/***/ 14440:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __generator = (void 0) && (void 0).__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = (void 0) && (void 0).__spread || function() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(96883);
/**
 * Adds the given item to the end of the set.
 *
 * @param set - a set
 * @param item - an item
 */ function append(set, item) {
    set.add(item);
}
exports.append = append;
/**
 * Extends a set by appending all items from another set.
 *
 * @param setA - a list to extend
 * @param setB - a list containing items to append to `setA`
 */ function extend(setA, setB) {
    setB.forEach(setA.add, setA);
}
exports.extend = extend;
/**
 * Inserts the given item to the start of the set.
 *
 * @param set - a set
 * @param item - an item
 */ function prepend(set, item) {
    var cloned = new Set(set);
    set.clear();
    set.add(item);
    cloned.forEach(set.add, set);
}
exports.prepend = prepend;
/**
 * Replaces the given item or all items matching condition with a new item.
 *
 * @param set - a set
 * @param conditionOrItem - an item to replace or a condition matching items
 * to replace
 * @param item - an item
 */ function replace(set, conditionOrItem, newItem) {
    var e_1, _a;
    var newSet = new Set();
    try {
        for(var set_1 = __values(set), set_1_1 = set_1.next(); !set_1_1.done; set_1_1 = set_1.next()){
            var oldItem = set_1_1.value;
            if (util_1.isFunction(conditionOrItem)) {
                if (!!conditionOrItem.call(null, oldItem)) {
                    newSet.add(newItem);
                } else {
                    newSet.add(oldItem);
                }
            } else if (oldItem === conditionOrItem) {
                newSet.add(newItem);
            } else {
                newSet.add(oldItem);
            }
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (set_1_1 && !set_1_1.done && (_a = set_1.return)) _a.call(set_1);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    set.clear();
    newSet.forEach(set.add, set);
}
exports.replace = replace;
/**
 * Inserts the given item before the given index.
 *
 * @param set - a set
 * @param item - an item
 */ function insert(set, item, index) {
    var e_2, _a;
    var newSet = new Set();
    var i = 0;
    try {
        for(var set_2 = __values(set), set_2_1 = set_2.next(); !set_2_1.done; set_2_1 = set_2.next()){
            var oldItem = set_2_1.value;
            if (i === index) newSet.add(item);
            newSet.add(oldItem);
            i++;
        }
    } catch (e_2_1) {
        e_2 = {
            error: e_2_1
        };
    } finally{
        try {
            if (set_2_1 && !set_2_1.done && (_a = set_2.return)) _a.call(set_2);
        } finally{
            if (e_2) throw e_2.error;
        }
    }
    set.clear();
    newSet.forEach(set.add, set);
}
exports.insert = insert;
/**
 * Removes the given item or all items matching condition.
 *
 * @param set - a set
 * @param conditionOrItem - an item to remove or a condition matching items
 * to remove
 */ function remove(set, conditionOrItem) {
    var e_3, _a, e_4, _b;
    if (!util_1.isFunction(conditionOrItem)) {
        set.delete(conditionOrItem);
    } else {
        var toRemove = [];
        try {
            for(var set_3 = __values(set), set_3_1 = set_3.next(); !set_3_1.done; set_3_1 = set_3.next()){
                var item = set_3_1.value;
                if (!!conditionOrItem.call(null, item)) {
                    toRemove.push(item);
                }
            }
        } catch (e_3_1) {
            e_3 = {
                error: e_3_1
            };
        } finally{
            try {
                if (set_3_1 && !set_3_1.done && (_a = set_3.return)) _a.call(set_3);
            } finally{
                if (e_3) throw e_3.error;
            }
        }
        try {
            for(var toRemove_1 = __values(toRemove), toRemove_1_1 = toRemove_1.next(); !toRemove_1_1.done; toRemove_1_1 = toRemove_1.next()){
                var oldItem = toRemove_1_1.value;
                set.delete(oldItem);
            }
        } catch (e_4_1) {
            e_4 = {
                error: e_4_1
            };
        } finally{
            try {
                if (toRemove_1_1 && !toRemove_1_1.done && (_b = toRemove_1.return)) _b.call(toRemove_1);
            } finally{
                if (e_4) throw e_4.error;
            }
        }
    }
}
exports.remove = remove;
/**
 * Removes all items from the set.
 */ function empty(set) {
    set.clear();
}
exports.empty = empty;
/**
 * Determines if the set contains the given item or any items matching
 * condition.
 *
 * @param set - a set
 * @param conditionOrItem - an item to a condition to match
 */ function contains(set, conditionOrItem) {
    var e_5, _a;
    if (!util_1.isFunction(conditionOrItem)) {
        return set.has(conditionOrItem);
    } else {
        try {
            for(var set_4 = __values(set), set_4_1 = set_4.next(); !set_4_1.done; set_4_1 = set_4.next()){
                var oldItem = set_4_1.value;
                if (!!conditionOrItem.call(null, oldItem)) {
                    return true;
                }
            }
        } catch (e_5_1) {
            e_5 = {
                error: e_5_1
            };
        } finally{
            try {
                if (set_4_1 && !set_4_1.done && (_a = set_4.return)) _a.call(set_4);
            } finally{
                if (e_5) throw e_5.error;
            }
        }
    }
    return false;
}
exports.contains = contains;
/**
 * Returns the count of items in the set matching the given condition.
 *
 * @param set - a set
 * @param condition - an optional condition to match
 */ function size(set, condition) {
    var e_6, _a;
    if (condition === undefined) {
        return set.size;
    } else {
        var count = 0;
        try {
            for(var set_5 = __values(set), set_5_1 = set_5.next(); !set_5_1.done; set_5_1 = set_5.next()){
                var item = set_5_1.value;
                if (!!condition.call(null, item)) {
                    count++;
                }
            }
        } catch (e_6_1) {
            e_6 = {
                error: e_6_1
            };
        } finally{
            try {
                if (set_5_1 && !set_5_1.done && (_a = set_5.return)) _a.call(set_5);
            } finally{
                if (e_6) throw e_6.error;
            }
        }
        return count;
    }
}
exports.size = size;
/**
 * Determines if the set is empty.
 *
 * @param set - a set
 */ function isEmpty(set) {
    return set.size === 0;
}
exports.isEmpty = isEmpty;
/**
 * Returns an iterator for the items of the set.
 *
 * @param set - a set
 * @param condition - an optional condition to match
 */ function forEach(set, condition) {
    var set_6, set_6_1, item, e_7_1;
    var e_7, _a;
    return __generator(this, function(_b) {
        switch(_b.label){
            case 0:
                if (!(condition === undefined)) return [
                    3 /*break*/ ,
                    2
                ];
                return [
                    5 /*yield**/ ,
                    __values(set)
                ];
            case 1:
                _b.sent();
                return [
                    3 /*break*/ ,
                    9
                ];
            case 2:
                _b.trys.push([
                    2,
                    7,
                    8,
                    9
                ]);
                set_6 = __values(set), set_6_1 = set_6.next();
                _b.label = 3;
            case 3:
                if (!!set_6_1.done) return [
                    3 /*break*/ ,
                    6
                ];
                item = set_6_1.value;
                if (!!!condition.call(null, item)) return [
                    3 /*break*/ ,
                    5
                ];
                return [
                    4 /*yield*/ ,
                    item
                ];
            case 4:
                _b.sent();
                _b.label = 5;
            case 5:
                set_6_1 = set_6.next();
                return [
                    3 /*break*/ ,
                    3
                ];
            case 6:
                return [
                    3 /*break*/ ,
                    9
                ];
            case 7:
                e_7_1 = _b.sent();
                e_7 = {
                    error: e_7_1
                };
                return [
                    3 /*break*/ ,
                    9
                ];
            case 8:
                try {
                    if (set_6_1 && !set_6_1.done && (_a = set_6.return)) _a.call(set_6);
                } finally{
                    if (e_7) throw e_7.error;
                }
                return [
                    7 /*endfinally*/ 
                ];
            case 9:
                return [
                    2 /*return*/ 
                ];
        }
    });
}
exports.forEach = forEach;
/**
 * Creates and returns a shallow clone of set.
 *
 * @param set - a set
 */ function clone(set) {
    return new Set(set);
}
exports.clone = clone;
/**
 * Returns a new set containing items from the set sorted in ascending
 * order.
 *
 * @param set - a set
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */ function sortInAscendingOrder(set, lessThanAlgo) {
    var list = new (Array.bind.apply(Array, __spread([
        void 0
    ], set)))();
    list.sort(function(itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? -1 : 1;
    });
    return new Set(list);
}
exports.sortInAscendingOrder = sortInAscendingOrder;
/**
 * Returns a new set containing items from the set sorted in descending
 * order.
 *
 * @param set - a set
 * @param lessThanAlgo - a function that returns `true` if its first argument
 * is less than its second argument, and `false` otherwise.
 */ function sortInDescendingOrder(set, lessThanAlgo) {
    var list = new (Array.bind.apply(Array, __spread([
        void 0
    ], set)))();
    list.sort(function(itemA, itemB) {
        return lessThanAlgo.call(null, itemA, itemB) ? 1 : -1;
    });
    return new Set(list);
}
exports.sortInDescendingOrder = sortInDescendingOrder;
/**
 * Determines if a set is a subset of another set.
 *
 * @param subset - a set
 * @param superset - a superset possibly containing all items from `subset`.
 */ function isSubsetOf(subset, superset) {
    var e_8, _a;
    try {
        for(var subset_1 = __values(subset), subset_1_1 = subset_1.next(); !subset_1_1.done; subset_1_1 = subset_1.next()){
            var item = subset_1_1.value;
            if (!superset.has(item)) return false;
        }
    } catch (e_8_1) {
        e_8 = {
            error: e_8_1
        };
    } finally{
        try {
            if (subset_1_1 && !subset_1_1.done && (_a = subset_1.return)) _a.call(subset_1);
        } finally{
            if (e_8) throw e_8.error;
        }
    }
    return true;
}
exports.isSubsetOf = isSubsetOf;
/**
 * Determines if a set is a superset of another set.
 *
 * @param superset - a set
 * @param subset - a subset possibly contained within `superset`.
 */ function isSupersetOf(superset, subset) {
    return isSubsetOf(subset, superset);
}
exports.isSupersetOf = isSupersetOf;
/**
 * Returns a new set with items that are contained in both sets.
 *
 * @param setA - a set
 * @param setB - a set
 */ function intersection(setA, setB) {
    var e_9, _a;
    var newSet = new Set();
    try {
        for(var setA_1 = __values(setA), setA_1_1 = setA_1.next(); !setA_1_1.done; setA_1_1 = setA_1.next()){
            var item = setA_1_1.value;
            if (setB.has(item)) newSet.add(item);
        }
    } catch (e_9_1) {
        e_9 = {
            error: e_9_1
        };
    } finally{
        try {
            if (setA_1_1 && !setA_1_1.done && (_a = setA_1.return)) _a.call(setA_1);
        } finally{
            if (e_9) throw e_9.error;
        }
    }
    return newSet;
}
exports.intersection = intersection;
/**
 * Returns a new set with items from both sets.
 *
 * @param setA - a set
 * @param setB - a set
 */ function union(setA, setB) {
    var newSet = new Set(setA);
    setB.forEach(newSet.add, newSet);
    return newSet;
}
exports.union = union;
/**
 * Returns a set of integers from `n` to `m` inclusive.
 *
 * @param n - starting number
 * @param m - ending number
 */ function range(n, m) {
    var newSet = new Set();
    for(var i = n; i <= m; i++){
        newSet.add(i);
    }
    return newSet;
}
exports.range = range; //# sourceMappingURL=Set.js.map


/***/ }),

/***/ 28957:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Pushes the given item to the stack.
 *
 * @param list - a list
 * @param item - an item
 */ function push(list, item) {
    list.push(item);
}
exports.push = push;
/**
 * Pops and returns an item from the stack.
 *
 * @param list - a list
 */ function pop(list) {
    return list.pop() || null;
}
exports.pop = pop; //# sourceMappingURL=Stack.js.map


/***/ }),

/***/ 44911:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var CodePoints_1 = __webpack_require__(96030);
var ByteSequence_1 = __webpack_require__(96768);
var Byte_1 = __webpack_require__(47192);
var util_1 = __webpack_require__(96883);
/**
 * Determines if the string `a` is a code unit prefix of string `b`.
 *
 * @param a - a string
 * @param b - a string
 */ function isCodeUnitPrefix(a, b) {
    /**
     * 1. Let i be 0.
     * 2. While true:
     * 2.1. Let aCodeUnit be the ith code unit of a if i is less than a’s length;
     * otherwise null.
     * 2.2. Let bCodeUnit be the ith code unit of b if i is less than b’s length;
     * otherwise null.
     * 2.3. If bCodeUnit is null, then return true.
     * 2.4. Return false if aCodeUnit is different from bCodeUnit.
     * 2.5. Set i to i + 1.
     */ var i = 0;
    while(true){
        var aCodeUnit = i < a.length ? a.charCodeAt(i) : null;
        var bCodeUnit = i < b.length ? b.charCodeAt(i) : null;
        if (aCodeUnit === null) return true;
        if (aCodeUnit !== bCodeUnit) return false;
        i++;
    }
}
exports.isCodeUnitPrefix = isCodeUnitPrefix;
/**
 * Determines if the string `a` is a code unit less than string `b`.
 *
 * @param a - a string
 * @param b - a string
 */ function isCodeUnitLessThan(a, b) {
    /**
     * 1. If b is a code unit prefix of a, then return false.
     * 2. If a is a code unit prefix of b, then return true.
     * 3. Let n be the smallest index such that the nth code unit of a is
     * different from the nth code unit of b. (There has to be such an index,
     * since neither string is a prefix of the other.)
     * 4. If the nth code unit of a is less than the nth code unit of b, then
     * return true.
     * 5. Return false.
     */ if (isCodeUnitPrefix(b, a)) return false;
    if (isCodeUnitPrefix(a, b)) return true;
    for(var i = 0; i < Math.min(a.length, b.length); i++){
        var aCodeUnit = a.charCodeAt(i);
        var bCodeUnit = b.charCodeAt(i);
        if (aCodeUnit === bCodeUnit) continue;
        return aCodeUnit < bCodeUnit;
    }
    /* istanbul ignore next */ return false;
}
exports.isCodeUnitLessThan = isCodeUnitLessThan;
/**
 * Isomorphic encodes the given string.
 *
 * @param str - a string
 */ function isomorphicEncode(str) {
    var e_1, _a;
    /**
     * 1. Assert: input contains no code points greater than U+00FF.
     * 2. Return a byte sequence whose length is equal to input’s length and whose
     * bytes have the same values as input’s code points, in the same order.
     */ var codePoints = Array.from(str);
    var bytes = new Uint8Array(codePoints.length);
    var i = 0;
    try {
        for(var str_1 = __values(str), str_1_1 = str_1.next(); !str_1_1.done; str_1_1 = str_1.next()){
            var codePoint = str_1_1.value;
            var byte = codePoint.codePointAt(0);
            console.assert(byte !== undefined && byte <= 0x00FF, "isomorphicEncode requires string bytes to be less than or equal to 0x00FF.");
            if (byte !== undefined && byte <= 0x00FF) {
                bytes[i++] = byte;
            }
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (str_1_1 && !str_1_1.done && (_a = str_1.return)) _a.call(str_1);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    return bytes;
}
exports.isomorphicEncode = isomorphicEncode;
/**
 * Determines if the given string is An ASCII string.
 *
 * @param str - a string
 */ function isASCIIString(str) {
    /**
     * An ASCII string is a string whose code points are all ASCII code points.
     */ return /^[\u0000-\u007F]*$/.test(str);
}
exports.isASCIIString = isASCIIString;
/**
 * Converts all uppercase ASCII code points to lowercase.
 *
 * @param str - a string
 */ function asciiLowercase(str) {
    var e_2, _a;
    /**
     * To ASCII lowercase a string, replace all ASCII upper alphas in the string
     * with their corresponding code point in ASCII lower alpha.
     */ var result = "";
    try {
        for(var str_2 = __values(str), str_2_1 = str_2.next(); !str_2_1.done; str_2_1 = str_2.next()){
            var c = str_2_1.value;
            var code = c.codePointAt(0);
            if (code !== undefined && code >= 0x41 && code <= 0x5A) {
                result += String.fromCodePoint(code + 0x20);
            } else {
                result += c;
            }
        }
    } catch (e_2_1) {
        e_2 = {
            error: e_2_1
        };
    } finally{
        try {
            if (str_2_1 && !str_2_1.done && (_a = str_2.return)) _a.call(str_2);
        } finally{
            if (e_2) throw e_2.error;
        }
    }
    return result;
}
exports.asciiLowercase = asciiLowercase;
/**
 * Converts all uppercase ASCII code points to uppercase.
 *
 * @param str - a string
 */ function asciiUppercase(str) {
    var e_3, _a;
    /**
     * To ASCII uppercase a string, replace all ASCII lower alphas in the string
     * with their corresponding code point in ASCII upper alpha.
     */ var result = "";
    try {
        for(var str_3 = __values(str), str_3_1 = str_3.next(); !str_3_1.done; str_3_1 = str_3.next()){
            var c = str_3_1.value;
            var code = c.codePointAt(0);
            if (code !== undefined && code >= 0x61 && code <= 0x7A) {
                result += String.fromCodePoint(code - 0x20);
            } else {
                result += c;
            }
        }
    } catch (e_3_1) {
        e_3 = {
            error: e_3_1
        };
    } finally{
        try {
            if (str_3_1 && !str_3_1.done && (_a = str_3.return)) _a.call(str_3);
        } finally{
            if (e_3) throw e_3.error;
        }
    }
    return result;
}
exports.asciiUppercase = asciiUppercase;
/**
 * Compares two ASCII strings case-insensitively.
 *
 * @param a - a string
 * @param b - a string
 */ function asciiCaseInsensitiveMatch(a, b) {
    /**
     * A string A is an ASCII case-insensitive match for a string B, if the ASCII
     * lowercase of A is the ASCII lowercase of B.
     */ return asciiLowercase(a) === asciiLowercase(b);
}
exports.asciiCaseInsensitiveMatch = asciiCaseInsensitiveMatch;
/**
 * ASCII encodes a string.
 *
 * @param str - a string
 */ function asciiEncode(str) {
    /**
     * 1. Assert: input is an ASCII string.
     * 2. Return the isomorphic encoding of input.
     */ console.assert(isASCIIString(str), "asciiEncode requires an ASCII string.");
    return isomorphicEncode(str);
}
exports.asciiEncode = asciiEncode;
/**
 * ASCII decodes a byte sequence.
 *
 * @param bytes - a byte sequence
 */ function asciiDecode(bytes) {
    var e_4, _a;
    try {
        /**
         * 1. Assert: All bytes in input are ASCII bytes.
         * 2. Return the isomorphic decoding of input.
         */ for(var bytes_1 = __values(bytes), bytes_1_1 = bytes_1.next(); !bytes_1_1.done; bytes_1_1 = bytes_1.next()){
            var byte = bytes_1_1.value;
            console.assert(Byte_1.isASCIIByte(byte), "asciiDecode requires an ASCII byte sequence.");
        }
    } catch (e_4_1) {
        e_4 = {
            error: e_4_1
        };
    } finally{
        try {
            if (bytes_1_1 && !bytes_1_1.done && (_a = bytes_1.return)) _a.call(bytes_1);
        } finally{
            if (e_4) throw e_4.error;
        }
    }
    return ByteSequence_1.isomorphicDecode(bytes);
}
exports.asciiDecode = asciiDecode;
/**
 * Strips newline characters from a string.
 *
 * @param str - a string
 */ function stripNewlines(str) {
    /**
     * To strip newlines from a string, remove any U+000A LF and U+000D CR code
     * points from the string.
     */ return str.replace(/[\n\r]/g, "");
}
exports.stripNewlines = stripNewlines;
/**
 * Normalizes newline characters in a string by converting consecutive
 * carriage-return newline characters and also single carriage return characters
 * into a single newline.
 *
 * @param str - a string
 */ function normalizeNewlines(str) {
    /**
     * To normalize newlines in a string, replace every U+000D CR U+000A LF code
     * point pair with a single U+000A LF code point, and then replace every
     * remaining U+000D CR code point with a U+000A LF code point.
     */ return str.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
}
exports.normalizeNewlines = normalizeNewlines;
/**
 * Removes leading and trailing whitespace characters from a string.
 *
 * @param str - a string
 */ function stripLeadingAndTrailingASCIIWhitespace(str) {
    /**
     * To strip leading and trailing ASCII whitespace from a string, remove all
     * ASCII whitespace that are at the start or the end of the string.
     */ return str.replace(/^[\t\n\f\r ]+/, "").replace(/[\t\n\f\r ]+$/, "");
}
exports.stripLeadingAndTrailingASCIIWhitespace = stripLeadingAndTrailingASCIIWhitespace;
/**
 * Removes consecutive newline characters from a string.
 *
 * @param str - a string
 */ function stripAndCollapseASCIIWhitespace(str) {
    /**
     * To strip and collapse ASCII whitespace in a string, replace any sequence of
     * one or more consecutive code points that are ASCII whitespace in the string
     * with a single U+0020 SPACE code point, and then remove any leading and
     * trailing ASCII whitespace from that string.
     */ return stripLeadingAndTrailingASCIIWhitespace(str.replace(/[\t\n\f\r ]{2,}/g, " "));
}
exports.stripAndCollapseASCIIWhitespace = stripAndCollapseASCIIWhitespace;
/**
 * Collects a sequence of code points matching a given condition from the input
 * string.
 *
 * @param condition - a condition to match
 * @param input - a string
 * @param options - starting position
 */ function collectASequenceOfCodePoints(condition, input, options) {
    /**
     * 1. Let result be the empty string.
     * 2. While position doesn’t point past the end of input and the code point at
     * position within input meets the condition condition:
     * 2.1. Append that code point to the end of result.
     * 2.2. Advance position by 1.
     * 3. Return result.
     */ if (!util_1.isArray(input)) return collectASequenceOfCodePoints(condition, Array.from(input), options);
    var result = "";
    while(options.position < input.length && !!condition.call(null, input[options.position])){
        result += input[options.position];
        options.position++;
    }
    return result;
}
exports.collectASequenceOfCodePoints = collectASequenceOfCodePoints;
/**
 * Skips over ASCII whitespace.
 *
 * @param input - input string
 * @param options - starting position
 */ function skipASCIIWhitespace(input, options) {
    /**
     * To skip ASCII whitespace within a string input given a position variable
     * position, collect a sequence of code points that are ASCII whitespace from
     * input given position. The collected code points are not used, but position
     * is still updated.
     */ collectASequenceOfCodePoints(function(str) {
        return CodePoints_1.ASCIIWhiteSpace.test(str);
    }, input, options);
}
exports.skipASCIIWhitespace = skipASCIIWhitespace;
/**
 * Solits a string at the given delimiter.
 *
 * @param input - input string
 * @param delimiter - a delimiter string
 */ function strictlySplit(input, delimiter) {
    /**
     * 1. Let position be a position variable for input, initially pointing at the
     * start of input.
     * 2. Let tokens be a list of strings, initially empty.
     * 3. Let token be the result of collecting a sequence of code points that are
     * not equal to delimiter from input, given position.
     * 4. Append token to tokens.
     * 5. While position is not past the end of input:
     * 5.1. Assert: the code point at position within input is delimiter.
     * 5.2. Advance position by 1.
     * 5.3. Let token be the result of collecting a sequence of code points that
     * are not equal to delimiter from input, given position.
     * 5.4. Append token to tokens.
     * 6. Return tokens.
     */ if (!util_1.isArray(input)) return strictlySplit(Array.from(input), delimiter);
    var options = {
        position: 0
    };
    var tokens = [];
    var token = collectASequenceOfCodePoints(function(str) {
        return delimiter !== str;
    }, input, options);
    tokens.push(token);
    while(options.position < input.length){
        console.assert(input[options.position] === delimiter, "strictlySplit found no delimiter in input string.");
        options.position++;
        token = collectASequenceOfCodePoints(function(str) {
            return delimiter !== str;
        }, input, options);
        tokens.push(token);
    }
    return tokens;
}
exports.strictlySplit = strictlySplit;
/**
 * Splits a string on ASCII whitespace.
 *
 * @param input - a string
 */ function splitAStringOnASCIIWhitespace(input) {
    /**
     * 1. Let position be a position variable for input, initially pointing at the
     * start of input.
     * 2. Let tokens be a list of strings, initially empty.
     * 3. Skip ASCII whitespace within input given position.
     * 4. While position is not past the end of input:
     * 4.1. Let token be the result of collecting a sequence of code points that
     * are not ASCII whitespace from input, given position.
     * 4.2. Append token to tokens.
     * 4.3. Skip ASCII whitespace within input given position.
     * 5. Return tokens.
     */ if (!util_1.isArray(input)) return splitAStringOnASCIIWhitespace(Array.from(input));
    var options = {
        position: 0
    };
    var tokens = [];
    skipASCIIWhitespace(input, options);
    while(options.position < input.length){
        var token = collectASequenceOfCodePoints(function(str) {
            return !CodePoints_1.ASCIIWhiteSpace.test(str);
        }, input, options);
        tokens.push(token);
        skipASCIIWhitespace(input, options);
    }
    return tokens;
}
exports.splitAStringOnASCIIWhitespace = splitAStringOnASCIIWhitespace;
/**
 * Splits a string on commas.
 *
 * @param input - a string
 */ function splitAStringOnCommas(input) {
    /**
     * 1. Let position be a position variable for input, initially pointing at the
     * start of input.
     * 2. Let tokens be a list of strings, initially empty.
     * 3. While position is not past the end of input:
     * 3.1. Let token be the result of collecting a sequence of code points that
     * are not U+002C (,) from input, given position.
     * 3.2. Strip leading and trailing ASCII whitespace from token.
     * 3.3. Append token to tokens.
     * 3.4. If position is not past the end of input, then:
     * 3.4.1. Assert: the code point at position within input is U+002C (,).
     * 3.4.2. Advance position by 1.
     * 4. Return tokens.
     */ if (!util_1.isArray(input)) return splitAStringOnCommas(Array.from(input));
    var options = {
        position: 0
    };
    var tokens = [];
    while(options.position < input.length){
        var token = collectASequenceOfCodePoints(function(str) {
            return str !== ",";
        }, input, options);
        tokens.push(stripLeadingAndTrailingASCIIWhitespace(token));
        if (options.position < input.length) {
            console.assert(input[options.position] === ",", "splitAStringOnCommas found no delimiter in input string.");
            options.position++;
        }
    }
    return tokens;
}
exports.splitAStringOnCommas = splitAStringOnCommas;
/**
 * Concatenates a list of strings with the given separator.
 *
 * @param list - a list of strings
 * @param separator - a separator string
 */ function concatenate(list, separator) {
    if (separator === void 0) {
        separator = "";
    }
    /**
     * 1. If list is empty, then return the empty string.
     * 2. If separator is not given, then set separator to the empty string.
     * 3. Return a string whose contents are list’s items, in order, separated
     * from each other by separator.
     */ if (list.length === 0) return "";
    return list.join(separator);
}
exports.concatenate = concatenate; //# sourceMappingURL=String.js.map


/***/ }),

/***/ 94317:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __importStar = (void 0) && (void 0).__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var base64 = __importStar(__webpack_require__(1606));
exports.base64 = base64;
var byte = __importStar(__webpack_require__(47192));
exports.byte = byte;
var byteSequence = __importStar(__webpack_require__(96768));
exports.byteSequence = byteSequence;
var codePoint = __importStar(__webpack_require__(96030));
exports.codePoint = codePoint;
var json = __importStar(__webpack_require__(19002));
exports.json = json;
var list = __importStar(__webpack_require__(42299));
exports.list = list;
var map = __importStar(__webpack_require__(55307));
exports.map = map;
var namespace = __importStar(__webpack_require__(21417));
exports.namespace = namespace;
var queue = __importStar(__webpack_require__(95961));
exports.queue = queue;
var set = __importStar(__webpack_require__(14440));
exports.set = set;
var stack = __importStar(__webpack_require__(28957));
exports.stack = stack;
var string = __importStar(__webpack_require__(44911));
exports.string = string; //# sourceMappingURL=index.js.map


/***/ }),

/***/ 89233:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(96883);
var interfaces_1 = __webpack_require__(74143);
var infra_1 = __webpack_require__(94317);
var url_1 = __webpack_require__(57310);
var _validationErrorCallback;
/**
 * Default ports for a special URL scheme.
 */ var _defaultPorts = {
    "ftp": 21,
    "file": null,
    "http": 80,
    "https": 443,
    "ws": 80,
    "wss": 443
};
/**
 * The C0 control percent-encode set are the C0 controls and all code points
 * greater than U+007E (~).
 */ var _c0ControlPercentEncodeSet = /[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
/**
 * The fragment percent-encode set is the C0 control percent-encode set and
 * U+0020 SPACE, U+0022 ("), U+003C (<), U+003E (>), and U+0060 (`).
 */ var _fragmentPercentEncodeSet = /[ "<>`]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
/**
 * The path percent-encode set is the fragment percent-encode set and
 * U+0023 (#), U+003F (?), U+007B ({), and U+007D (}).
 */ var _pathPercentEncodeSet = /[ "<>`#?{}]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
/**
 * The userinfo percent-encode set is the path percent-encode set and
 * U+002F (/), U+003A (:), U+003B (;), U+003D (=), U+0040 (@), U+005B ([),
 * U+005C (\), U+005D (]), U+005E (^), and U+007C (|).
 */ var _userInfoPercentEncodeSet = /[ "<>`#?{}/:;=@\[\]\\\^\|]|[\0-\x1F\x7F-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
/**
 * The URL code points are ASCII alphanumeric, U+0021 (!), U+0024 ($),
 * U+0026 (&), U+0027 ('), U+0028 LEFT PARENTHESIS, U+0029 RIGHT PARENTHESIS,
 * U+002A (*), U+002B (+), U+002C (,), U+002D (-), U+002E (.), U+002F (/),
 * U+003A (:), U+003B (;), U+003D (=), U+003F (?), U+0040 (@), U+005F (_),
 * U+007E (~), and code points in the range U+00A0 to U+10FFFD, inclusive,
 * excluding surrogates and noncharacters.
 */ var _urlCodePoints = /[0-9A-Za-z!\$&-\/:;=\?@_~\xA0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uD83E\uD840-\uD87E\uD880-\uD8BE\uD8C0-\uD8FE\uD900-\uD93E\uD940-\uD97E\uD980-\uD9BE\uD9C0-\uD9FE\uDA00-\uDA3E\uDA40-\uDA7E\uDA80-\uDABE\uDAC0-\uDAFE\uDB00-\uDB3E\uDB40-\uDB7E\uDB80-\uDBBE\uDBC0-\uDBFE][\uDC00-\uDFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDC00-\uDFFD]/;
/**
 * A forbidden host code point is U+0000 NULL, U+0009 TAB, U+000A LF,
 * U+000D CR, U+0020 SPACE, U+0023 (#), U+0025 (%), U+002F (/), U+003A (:),
 * U+003F (?), U+0040 (@), U+005B ([), U+005C (\), or U+005D (]).
 */ var _forbiddenHostCodePoint = /[\0\t\f\r #%/:?@\[\\\]]/;
/**
 * Sets the callback function for validation errors.
 *
 * @param validationErrorCallback - a callback function to be called when a
 * validation error occurs
 */ function setValidationErrorCallback(validationErrorCallback) {
    _validationErrorCallback = validationErrorCallback;
}
exports.setValidationErrorCallback = setValidationErrorCallback;
/**
 * Generates a validation error.
 *
 * @param message - error message
 */ function validationError(message) {
    if (_validationErrorCallback !== undefined) {
        _validationErrorCallback.call(null, "Validation Error: " + message);
    }
}
/**
 * Creates a new URL.
 */ function newURL() {
    return {
        scheme: "",
        username: "",
        password: "",
        host: null,
        port: null,
        path: [],
        query: null,
        fragment: null,
        _cannotBeABaseURLFlag: false,
        _blobURLEntry: null
    };
}
exports.newURL = newURL;
/**
 * Determines if the scheme is a special scheme.
 *
 * @param scheme - a scheme
 */ function isSpecialScheme(scheme) {
    return scheme in _defaultPorts;
}
exports.isSpecialScheme = isSpecialScheme;
/**
 * Determines if the URL has a special scheme.
 *
 * @param url - an URL
 */ function isSpecial(url) {
    return isSpecialScheme(url.scheme);
}
exports.isSpecial = isSpecial;
/**
 * Returns the default port for a special scheme.
 *
 * @param scheme - a scheme
 */ function defaultPort(scheme) {
    return _defaultPorts[scheme] || null;
}
exports.defaultPort = defaultPort;
/**
 * Determines if the URL has credentials.
 *
 * @param url - an URL
 */ function includesCredentials(url) {
    return url.username !== "" || url.password !== "";
}
exports.includesCredentials = includesCredentials;
/**
 * Determines if an URL cannot have credentials.
 *
 * @param url - an URL
 */ function cannotHaveAUsernamePasswordPort(url) {
    /**
     * A URL cannot have a username/password/port if its host is null or the
     * empty string, its cannot-be-a-base-URL flag is set, or its scheme is
     * "file".
     */ return url.host === null || url.host === "" || url._cannotBeABaseURLFlag || url.scheme === "file";
}
exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
/**
 * Serializes an URL into a string.
 *
 * @param url - an URL
 */ function urlSerializer(url, excludeFragmentFlag) {
    var e_1, _a;
    if (excludeFragmentFlag === void 0) {
        excludeFragmentFlag = false;
    }
    /**
     * 1. Let output be url’s scheme and U+003A (:) concatenated.
     */ var output = url.scheme + ":";
    /**
     * 2. If url’s host is non-null:
     */ if (url.host !== null) {
        /**
         * 2.1. Append "//" to output.
         */ output += "//";
        /**
         * 2.2. If url includes credentials, then:
         */ if (includesCredentials(url)) {
            /**
             * 2.2.1. Append url’s username to output.
             * 2.2.2. If url’s password is not the empty string, then append U+003A (:),
             * followed by url’s password, to output.
             * 2.2.3. Append U+0040 (@) to output.
             */ output += url.username;
            if (url.password !== "") {
                output += ":" + url.password;
            }
            output += "@";
        }
        /**
         * 2.3. Append url’s host, serialized, to output.
         * 2.4. If url’s port is non-null, append U+003A (:) followed by url’s port,
         * serialized, to output.
         */ output += hostSerializer(url.host);
        if (url.port !== null) {
            output += ":" + url.port;
        }
    } else if (url.host === null && url.scheme === "file") {
        /**
         * 3. Otherwise, if url’s host is null and url’s scheme is "file", append "//" to output.
         */ output += "//";
    }
    /**
     * 4. If url’s cannot-be-a-base-URL flag is set, append url’s path[0] to
     * output.
     * 5. Otherwise, then for each string in url’s path, append U+002F (/)
     * followed by the string to output.
     */ if (url._cannotBeABaseURLFlag) {
        output += url.path[0];
    } else {
        try {
            for(var _b = __values(url.path), _c = _b.next(); !_c.done; _c = _b.next()){
                var str = _c.value;
                output += "/" + str;
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
    }
    /**
     * 6. If url’s query is non-null, append U+003F (?), followed by url’s
     * query, to output.
     * 7. If the exclude fragment flag is unset and url’s fragment is non-null,
     * append U+0023 (#), followed by url’s fragment, to output.
     * 8. Return output.
     */ if (url.query !== null) {
        output += "?" + url.query;
    }
    if (!excludeFragmentFlag && url.fragment !== null) {
        output += "#" + url.fragment;
    }
    return output;
}
exports.urlSerializer = urlSerializer;
/**
 * Serializes a host into a string.
 *
 * @param host - a host
 */ function hostSerializer(host) {
    /**
     * 1. If host is an IPv4 address, return the result of running the IPv4
     * serializer on host.
     * 2. Otherwise, if host is an IPv6 address, return U+005B ([), followed
     * by the result of running the IPv6 serializer on host, followed by
     * U+005D (]).
     * 3. Otherwise, host is a domain, opaque host, or empty host, return host.
     */ if (util_1.isNumber(host)) {
        return iPv4Serializer(host);
    } else if (util_1.isArray(host)) {
        return "[" + iPv6Serializer(host) + "]";
    } else {
        return host;
    }
}
exports.hostSerializer = hostSerializer;
/**
 * Serializes an IPv4 address into a string.
 *
 * @param address  - an IPv4 address
 */ function iPv4Serializer(address) {
    /**
     * 1. Let output be the empty string.
     * 2. Let n be the value of address.
     * 3. For each i in the range 1 to 4, inclusive:
     * 3.1. Prepend n % 256, serialized, to output.
     * 3.2. If i is not 4, then prepend U+002E (.) to output.
     * 3.3. Set n to floor(n / 256).
     * 4. Return output.
     */ var output = "";
    var n = address;
    for(var i = 1; i <= 4; i++){
        output = (n % 256).toString() + output;
        if (i !== 4) {
            output = "." + output;
        }
        n = Math.floor(n / 256);
    }
    return output;
}
exports.iPv4Serializer = iPv4Serializer;
/**
 * Serializes an IPv6 address into a string.
 *
 * @param address  - an IPv6 address represented as a list of eight numbers
 */ function iPv6Serializer(address) {
    /**
     * 1. Let output be the empty string.
     * 2. Let compress be an index to the first IPv6 piece in the first longest
     * sequences of address’s IPv6 pieces that are 0.
     * In 0:f:0:0:f:f:0:0 it would point to the second 0.
     * 3. If there is no sequence of address’s IPv6 pieces that are 0 that is
     * longer than 1, then set compress to null.
     */ var output = "";
    var compress = null;
    var lastIndex = -1;
    var count = 0;
    var lastCount = 0;
    for(var i = 0; i < 8; i++){
        if (address[i] !== 0) continue;
        count = 1;
        for(var j = i + 1; j < 8; j++){
            if (address[j] !== 0) break;
            count++;
            continue;
        }
        if (count > lastCount) {
            lastCount = count;
            lastIndex = i;
        }
    }
    if (lastCount > 1) compress = lastIndex;
    /**
     * 4. Let ignore0 be false.
     * 5. For each pieceIndex in the range 0 to 7, inclusive:
     */ var ignore0 = false;
    for(var pieceIndex = 0; pieceIndex < 8; pieceIndex++){
        /**
         * 5.1. If ignore0 is true and address[pieceIndex] is 0, then continue.
         * 5.2. Otherwise, if ignore0 is true, set ignore0 to false.
         * 5.3. If compress is pieceIndex, then:
         */ if (ignore0 && address[pieceIndex] === 0) continue;
        if (ignore0) ignore0 = false;
        if (compress === pieceIndex) {
            /**
             * 5.3.1. Let separator be "::" if pieceIndex is 0, and U+003A (:) otherwise.
             * 5.3.2. Append separator to output.
             * 5.3.3. Set ignore0 to true and continue.
             */ output += pieceIndex === 0 ? "::" : ":";
            ignore0 = true;
            continue;
        }
        /**
         * 5.4. Append address[pieceIndex], represented as the shortest possible
         * lowercase hexadecimal number, to output.
         * 5.5. If pieceIndex is not 7, then append U+003A (:) to output.
         */ output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) output += ":";
    }
    /**
     * 6. Return output.
     */ return output;
}
exports.iPv6Serializer = iPv6Serializer;
/**
 * Parses an URL string.
 *
 * @param input - input string
 * @param baseURL - base URL
 * @param encodingOverride - encoding override
 */ function urlParser(input, baseURL, encodingOverride) {
    /**
     * 1. Let url be the result of running the basic URL parser on input with
     * base, and encoding override as provided.
     * 2. If url is failure, return failure.
     * 3. If url’s scheme is not "blob", return url.
     * 4. Set url’s blob URL entry to the result of resolving the blob URL url,
     * if that did not return failure, and null otherwise.
     * 5. Return url.
     */ var url = basicURLParser(input, baseURL, encodingOverride);
    if (url === null) return null;
    if (url.scheme !== "blob") return url;
    var entry = resolveABlobURL(url);
    if (entry !== null) {
        url._blobURLEntry = entry;
    } else {
        url._blobURLEntry = null;
    }
    return url;
}
exports.urlParser = urlParser;
/**
 * Parses an URL string.
 *
 * @param input - input string
 * @param baseURL - base URL
 * @param encodingOverride - encoding override
 */ function basicURLParser(input, baseURL, encodingOverride, url, stateOverride) {
    var e_2, _a, e_3, _b;
    /**
     * 1. If url is not given:
     * 1.1. Set url to a new URL.
     * 1.2. If input contains any leading or trailing C0 control or space,
     * validation error.
     * 1.3. Remove any leading and trailing C0 control or space from input.
     */ if (url === undefined) {
        url = newURL();
        // leading
        var leadingControlOrSpace = /^[\u0000-\u001F\u0020]+/;
        var trailingControlOrSpace = /[\u0000-\u001F\u0020]+$/;
        if (leadingControlOrSpace.test(input) || trailingControlOrSpace.test(input)) {
            validationError("Input string contains leading or trailing control characters or space.");
        }
        input = input.replace(leadingControlOrSpace, "");
        input = input.replace(trailingControlOrSpace, "");
    }
    /**
     * 2. If input contains any ASCII tab or newline, validation error.
     * 3. Remove all ASCII tab or newline from input.
     */ var tabOrNewline = /[\u0009\u000A\u000D]/g;
    if (tabOrNewline.test(input)) {
        validationError("Input string contains tab or newline characters.");
    }
    input = input.replace(tabOrNewline, "");
    /**
     * 4. Let state be state override if given, or scheme start state otherwise.
     * 5. If base is not given, set it to null.
     * 6. Let encoding be UTF-8.
     * 7. If encoding override is given, set encoding to the result of getting
     * an output encoding from encoding override.
     */ var state = stateOverride === undefined ? interfaces_1.ParserState.SchemeStart : stateOverride;
    if (baseURL === undefined) baseURL = null;
    var encoding = encodingOverride === undefined || encodingOverride === "replacement" || encodingOverride === "UTF-16BE" || encodingOverride === "UTF-16LE" ? "UTF-8" : encodingOverride;
    /**
     * 8. Let buffer be the empty string.
     * 9. Let the @ flag, [] flag, and passwordTokenSeenFlag be unset.
     * 10. Let pointer be a pointer to first code point in input.
     */ var buffer = "";
    var atFlag = false;
    var arrayFlag = false;
    var passwordTokenSeenFlag = false;
    var EOF = "";
    var walker = new util_1.StringWalker(input);
    /**
     * 11. Keep running the following state machine by switching on state. If
     * after a run pointer points to the EOF code point, go to the next step.
     * Otherwise, increase pointer by one and continue with the state machine.
     */ while(true){
        switch(state){
            case interfaces_1.ParserState.SchemeStart:
                /**
                 * 1. If c is an ASCII alpha, append c, lowercased, to buffer, and set
                 * state to scheme state.
                 * 2. Otherwise, if state override is not given, set state to no scheme
                 * state, and decrease pointer by one.
                 * 3. Otherwise, validation error, return failure.
                 */ if (infra_1.codePoint.ASCIIAlpha.test(walker.c())) {
                    buffer += walker.c().toLowerCase();
                    state = interfaces_1.ParserState.Scheme;
                } else if (stateOverride === undefined) {
                    state = interfaces_1.ParserState.NoScheme;
                    walker.pointer--;
                } else {
                    validationError("Invalid scheme start character.");
                    return null;
                }
                break;
            case interfaces_1.ParserState.Scheme:
                /**
                 * 1. If c is an ASCII alphanumeric, U+002B (+), U+002D (-), or U+002E
                 * (.), append c, lowercased, to buffer.
                 */ if (infra_1.codePoint.ASCIIAlphanumeric.test(walker.c()) || walker.c() === "+" || walker.c() === "-" || walker.c() === ".") {
                    buffer += walker.c().toLowerCase();
                } else if (walker.c() === ":") {
                    /**
                     * 2. Otherwise, if c is U+003A (:), then:
                     * 2.1. If state override is given, then:
                     * 2.1.1. If url’s scheme is a special scheme and buffer is not a
                     * special scheme, then return.
                     * 2.1.2. If url’s scheme is not a special scheme and buffer is a
                     * special scheme, then return.
                     * 2.1.3. If url includes credentials or has a non-null port, and
                     * buffer is "file", then return.
                     * 2.1.4. If url’s scheme is "file" and its host is an empty host or
                     * null, then return.
                     */ if (stateOverride !== undefined) {
                        if (isSpecialScheme(url.scheme) && !isSpecialScheme(buffer)) return url;
                        if (!isSpecialScheme(url.scheme) && isSpecialScheme(buffer)) return url;
                        if ((includesCredentials(url) || url.port !== null) && buffer === "file") return url;
                        if (url.scheme === "file" && (url.host === "" || url.host === null)) return url;
                    }
                    /**
                     * 2.2. Set url’s scheme to buffer.
                     */ url.scheme = buffer;
                    /**
                     * 2.3. If state override is given, then:
                     * 2.3.1. If url’s port is url’s scheme’s default port, then set
                     * url’s port to null.
                     * 2.3.2. Return.
                     */ if (stateOverride !== undefined) {
                        if (url.port === defaultPort(url.scheme)) {
                            url.port = null;
                        }
                        return url;
                    }
                    /**
                     * 2.4. Set buffer to the empty string.
                     */ buffer = "";
                    if (url.scheme === "file") {
                        /**
                         * 2.5. If url’s scheme is "file", then:
                         * 2.5.1. If remaining does not start with "//", validation error.
                         * 2.5.2. Set state to file state.
                         */ if (!walker.remaining().startsWith("//")) {
                            validationError("Invalid file URL scheme, '//' expected.");
                        }
                        state = interfaces_1.ParserState.File;
                    } else if (isSpecial(url) && baseURL !== null && baseURL.scheme === url.scheme) {
                        /**
                         * 2.6. Otherwise, if url is special, base is non-null, and base’s
                         * scheme is equal to url’s scheme, set state to special relative
                         * or authority state.
                         */ state = interfaces_1.ParserState.SpecialRelativeOrAuthority;
                    } else if (isSpecial(url)) {
                        /**
                         * 2.7. Otherwise, if url is special, set state to special
                         * authority slashes state.
                         */ state = interfaces_1.ParserState.SpecialAuthoritySlashes;
                    } else if (walker.remaining().startsWith("/")) {
                        /**
                         * 2.8. Otherwise, if remaining starts with an U+002F (/), set state
                         * to path or authority state and increase pointer by one.
                         */ state = interfaces_1.ParserState.PathOrAuthority;
                        walker.pointer++;
                    } else {
                        /**
                         * 2.9. Otherwise, set url’s cannot-be-a-base-URL flag, append an
                         * empty string to url’s path, and set state to
                         * cannot-be-a-base-URL path state.
                         */ url._cannotBeABaseURLFlag = true;
                        url.path.push("");
                        state = interfaces_1.ParserState.CannotBeABaseURLPath;
                    }
                } else if (stateOverride === undefined) {
                    /**
                     * 3. Otherwise, if state override is not given, set buffer to the
                     * empty string, state to no scheme state, and start over (from the
                     * first code point in input).
                     */ buffer = "";
                    state = interfaces_1.ParserState.NoScheme;
                    walker.pointer = 0;
                    continue;
                } else {
                    /**
                     * 4. Otherwise, validation error, return failure.
                     */ validationError("Invalid input string.");
                    return null;
                }
                break;
            case interfaces_1.ParserState.NoScheme:
                /**
                 * 1. If base is null, or base’s cannot-be-a-base-URL flag is set
                 * and c is not U+0023 (#), validation error, return failure.
                 * 2. Otherwise, if base’s cannot-be-a-base-URL flag is set and
                 * c is U+0023 (#), set url’s scheme to base’s scheme, url’s path to
                 * a copy of base’s path, url’s query to base’s query, url’s
                 * fragment to the empty string, set url’s cannot-be-a-base-URL
                 * flag, and set state to fragment state.
                 * 3. Otherwise, if base’s scheme is not "file", set state to
                 * relative state and decrease pointer by one.
                 * 4. Otherwise, set state to file state and decrease pointer by one.
                 */ if (baseURL === null || baseURL._cannotBeABaseURLFlag && walker.c() !== "#") {
                    validationError("Invalid input string.");
                    return null;
                } else if (baseURL._cannotBeABaseURLFlag && walker.c() === "#") {
                    url.scheme = baseURL.scheme;
                    url.path = infra_1.list.clone(baseURL.path);
                    url.query = baseURL.query;
                    url.fragment = "";
                    url._cannotBeABaseURLFlag = true;
                    state = interfaces_1.ParserState.Fragment;
                } else if (baseURL.scheme !== "file") {
                    state = interfaces_1.ParserState.Relative;
                    walker.pointer--;
                } else {
                    state = interfaces_1.ParserState.File;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.SpecialRelativeOrAuthority:
                /**
                 * If c is U+002F (/) and remaining starts with U+002F (/), then set
                 * state to special authority ignore slashes state and increase
                 * pointer by one.
                 * Otherwise, validation error, set state to relative state and
                 * decrease pointer by one.
                 */ if (walker.c() === "/" && walker.remaining().startsWith("/")) {
                    state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
                    walker.pointer++;
                } else {
                    validationError("Invalid input string.");
                    state = interfaces_1.ParserState.Relative;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.PathOrAuthority:
                /**
                 * If c is U+002F (/), then set state to authority state.
                 * Otherwise, set state to path state, and decrease pointer by one.
                 */ if (walker.c() === "/") {
                    state = interfaces_1.ParserState.Authority;
                } else {
                    state = interfaces_1.ParserState.Path;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.Relative:
                /**
                 * Set url’s scheme to base’s scheme, and then, switching on c:
                 */ if (baseURL === null) {
                    throw new Error("Invalid parser state. Base URL is null.");
                }
                url.scheme = baseURL.scheme;
                switch(walker.c()){
                    case EOF:
                        /**
                         * Set url’s username to base’s username, url’s password to base’s
                         * password, url’s host to base’s host, url’s port to base’s port,
                         * url’s path to a copy of base’s path, and url’s query to base’s
                         * query.
                         */ url.username = baseURL.username;
                        url.password = baseURL.password;
                        url.host = baseURL.host;
                        url.port = baseURL.port;
                        url.path = infra_1.list.clone(baseURL.path);
                        url.query = baseURL.query;
                        break;
                    case "/":
                        /**
                         * Set state to relative slash state.
                         */ state = interfaces_1.ParserState.RelativeSlash;
                        break;
                    case "?":
                        /**
                         * Set url’s username to base’s username, url’s password to base’s
                         * password, url’s host to base’s host, url’s port to base’s port,
                         * url’s path to a copy of base’s path, url’s query to the empty
                         * string, and state to query state.
                         */ url.username = baseURL.username;
                        url.password = baseURL.password;
                        url.host = baseURL.host;
                        url.port = baseURL.port;
                        url.path = infra_1.list.clone(baseURL.path);
                        url.query = "";
                        state = interfaces_1.ParserState.Query;
                        break;
                    case "#":
                        /**
                         * Set url’s username to base’s username, url’s password to base’s
                         * password, url’s host to base’s host, url’s port to base’s port,
                         * url’s path to a copy of base’s path, url’s query to base’s
                         * query, url’s fragment to the empty string, and state to
                         * fragment state.
                         */ url.username = baseURL.username;
                        url.password = baseURL.password;
                        url.host = baseURL.host;
                        url.port = baseURL.port;
                        url.path = infra_1.list.clone(baseURL.path);
                        url.query = baseURL.query;
                        url.fragment = "";
                        state = interfaces_1.ParserState.Fragment;
                        break;
                    default:
                        /**
                         * If url is special and c is U+005C (\), validation error,
                         * set state to relative slash state.
                         * Otherwise, run these steps:
                         * 1. Set url’s username to base’s username, url’s password to
                         * base’s password, url’s host to base’s host, url’s port to
                         * base’s port, url’s path to a copy of base’s path, and then
                         * remove url’s path’s last item, if any.
                         * 2. Set state to path state, and decrease pointer by one.
                         */ if (isSpecial(url) && walker.c() === "\\") {
                            validationError("Invalid input string.");
                            state = interfaces_1.ParserState.RelativeSlash;
                        } else {
                            url.username = baseURL.username;
                            url.password = baseURL.password;
                            url.host = baseURL.host;
                            url.port = baseURL.port;
                            url.path = infra_1.list.clone(baseURL.path);
                            if (url.path.length !== 0) url.path.splice(url.path.length - 1, 1);
                            state = interfaces_1.ParserState.Path;
                            walker.pointer--;
                        }
                        break;
                }
                break;
            case interfaces_1.ParserState.RelativeSlash:
                /**
                 * 1. If url is special and c is U+002F (/) or U+005C (\), then:
                 * 1.1. If c is U+005C (\), validation error.
                 * 1.2. Set state to special authority ignore slashes state.
                 * 2. Otherwise, if c is U+002F (/), then set state to authority state.
                 * 3. Otherwise, set url’s username to base’s username, url’s password
                 * to base’s password, url’s host to base’s host, url’s port to base’s
                 * port, state to path state, and then, decrease pointer by one.
                 */ if (isSpecial(url) && (walker.c() === "/" || walker.c() === "\\")) {
                    if (walker.c() === "\\") {
                        validationError("Invalid input string.");
                    }
                    state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
                } else if (walker.c() === "/") {
                    state = interfaces_1.ParserState.Authority;
                } else {
                    if (baseURL === null) {
                        throw new Error("Invalid parser state. Base URL is null.");
                    }
                    url.username = baseURL.username;
                    url.password = baseURL.password;
                    url.host = baseURL.host;
                    url.port = baseURL.port;
                    state = interfaces_1.ParserState.Path;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.SpecialAuthoritySlashes:
                /**
                 * If c is U+002F (/) and remaining starts with U+002F (/), then set
                 * state to special authority ignore slashes state and increase
                 * pointer by one.
                 * Otherwise, validation error, set state to special authority ignore
                 * slashes state, and decrease pointer by one.
                 */ if (walker.c() === "/" && walker.remaining().startsWith("/")) {
                    state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
                    walker.pointer++;
                } else {
                    validationError("Expected '//'.");
                    state = interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.SpecialAuthorityIgnoreSlashes:
                /**
                 * If c is neither U+002F (/) nor U+005C (\), then set state to
                 * authority state and decrease pointer by one.
                 * Otherwise, validation error.
                 */ if (walker.c() !== "/" && walker.c() !== "\\") {
                    state = interfaces_1.ParserState.Authority;
                    walker.pointer--;
                } else {
                    validationError("Unexpected '/' or '\\'.");
                }
                break;
            case interfaces_1.ParserState.Authority:
                /**
                 * 1. If c is U+0040 (@), then:
                 */ if (walker.c() === "@") {
                    /**
                     * 1.1. Validation error.
                     * 1.2. If the @ flag is set, prepend "%40" to buffer.
                     * 1.3. Set the @ flag.
                     * 1.4. For each codePoint in buffer:
                     */ validationError("Unexpected '@'.");
                    if (atFlag) buffer = "%40" + buffer;
                    atFlag = true;
                    try {
                        for(var buffer_1 = (e_2 = void 0, __values(buffer)), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()){
                            var codePoint = buffer_1_1.value;
                            /**
                             * 1.4.1. If codePoint is U+003A (:) and passwordTokenSeenFlag is
                             * unset, then set passwordTokenSeenFlag and continue.
                             * 1.4.2. Let encodedCodePoints be the result of running UTF-8
                             * percent encode codePoint using the userinfo percent-encode set.
                             * 1.4.3. If passwordTokenSeenFlag is set, then append
                             * encodedCodePoints to url’s password.
                             * 1.4.4. Otherwise, append encodedCodePoints to url’s username.
                             */ if (codePoint === ":" && !passwordTokenSeenFlag) {
                                passwordTokenSeenFlag = true;
                                continue;
                            }
                            var encodedCodePoints = utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
                            if (passwordTokenSeenFlag) {
                                url.password += encodedCodePoints;
                            } else {
                                url.username += encodedCodePoints;
                            }
                        }
                    } catch (e_2_1) {
                        e_2 = {
                            error: e_2_1
                        };
                    } finally{
                        try {
                            if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);
                        } finally{
                            if (e_2) throw e_2.error;
                        }
                    }
                    /**
                     * 1.5. Set buffer to the empty string.
                     */ buffer = "";
                } else if (walker.c() === EOF || walker.c() === "/" || walker.c() === "?" || walker.c() === "#" || isSpecial(url) && walker.c() === "\\") {
                    /**
                     * 2. Otherwise, if one of the following is true
                     * - c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
                     * - url is special and c is U+005C (\)
                     * then:
                     * 2.1. If @ flag is set and buffer is the empty string, validation
                     * error, return failure.
                     * 2.2. Decrease pointer by the number of code points in buffer plus
                     * one, set buffer to the empty string, and set state to host state.
                     */ if (atFlag && buffer === "") {
                        validationError("Invalid input string.");
                        return null;
                    }
                    walker.pointer -= buffer.length + 1;
                    buffer = "";
                    state = interfaces_1.ParserState.Host;
                } else {
                    /**
                     * 3. Otherwise, append c to buffer.
                     */ buffer += walker.c();
                }
                break;
            case interfaces_1.ParserState.Host:
            case interfaces_1.ParserState.Hostname:
                if (stateOverride !== undefined && url.scheme === "file") {
                    /**
                     * 1. If state override is given and url’s scheme is "file", then
                     * decrease pointer by one and set state to file host state.
                     */ walker.pointer--;
                    state = interfaces_1.ParserState.FileHost;
                } else if (walker.c() === ":" && !arrayFlag) {
                    /**
                     * 2. Otherwise, if c is U+003A (:) and the [] flag is unset, then:
                     * 2.1. If buffer is the empty string, validation error, return
                     * failure.
                     * 2.2. Let host be the result of host parsing buffer with url is
                     * not special.
                     * 2.3. If host is failure, then return failure.
                     * 2.4. Set url’s host to host, buffer to the empty string, and
                     * state to port state.
                     * 2.5. If state override is given and state override is hostname
                     * state, then return.
                     */ if (buffer === "") {
                        validationError("Invalid input string.");
                        return null;
                    }
                    var host = hostParser(buffer, !isSpecial(url));
                    if (host === null) return null;
                    url.host = host;
                    buffer = "";
                    state = interfaces_1.ParserState.Port;
                    if (stateOverride === interfaces_1.ParserState.Hostname) return url;
                } else if (walker.c() === EOF || walker.c() === "/" || walker.c() === "?" || walker.c() === "#" || isSpecial(url) && walker.c() === "\\") {
                    /**
                     * 3. Otherwise, if one of the following is true
                     * - c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
                     * - url is special and c is U+005C (\)
                     * then decrease pointer by one, and then:
                     * 3.1. If url is special and buffer is the empty string, validation
                     * error, return failure.
                     * 3.2. Otherwise, if state override is given, buffer is the empty
                     * string, and either url includes credentials or url’s port is
                     * non-null, validation error, return.
                     * 3.3. Let host be the result of host parsing buffer with url is
                     * not special.
                     * 3.4. If host is failure, then return failure.
                     * 3.5. Set url’s host to host, buffer to the empty string, and
                     * state to path start state.
                     * 3.6. If state override is given, then return.
                     */ walker.pointer--;
                    if (isSpecial(url) && buffer === "") {
                        validationError("Invalid input string.");
                        return null;
                    } else if (stateOverride !== undefined && buffer === "" && (includesCredentials(url) || url.port !== null)) {
                        validationError("Invalid input string.");
                        return url;
                    }
                    var host = hostParser(buffer, !isSpecial(url));
                    if (host === null) return null;
                    url.host = host;
                    buffer = "";
                    state = interfaces_1.ParserState.PathStart;
                    if (stateOverride !== undefined) return url;
                } else {
                    /**
                     * 4. Otherwise:
                     * 4.1. If c is U+005B ([), then set the [] flag.
                     * 4.2. If c is U+005D (]), then unset the [] flag.
                     * 4.3. Append c to buffer.
                     */ if (walker.c() === "[") arrayFlag = true;
                    if (walker.c() === "]") arrayFlag = false;
                    buffer += walker.c();
                }
                break;
            case interfaces_1.ParserState.Port:
                if (infra_1.codePoint.ASCIIDigit.test(walker.c())) {
                    /**
                     * 1. If c is an ASCII digit, append c to buffer.
                     */ buffer += walker.c();
                } else if (walker.c() === EOF || walker.c() === "/" || walker.c() === "?" || walker.c() === "#" || isSpecial(url) && walker.c() === "\\" || stateOverride) {
                    /**
                     * 2. Otherwise, if one of the following is true
                     * - c is the EOF code point, U+002F (/), U+003F (?), or U+0023 (#)
                     * - url is special and c is U+005C (\)
                     * - state override is given
                     * then:
                     */ if (buffer !== "") {
                        /**
                         * 2.1. If buffer is not the empty string, then:
                         * 2.1.1. Let port be the mathematical integer value that is
                         * represented by buffer in radix-10 using ASCII digits for digits
                         * with values 0 through 9.
                         * 2.1.2. If port is greater than 2**16 − 1, validation error,
                         * return failure.
                         * 2.1.3. Set url’s port to null, if port is url’s scheme’s default
                         * port, and to port otherwise.
                         * 2.1.4. Set buffer to the empty string.
                         */ if (buffer !== "") {
                            var port = parseInt(buffer, 10);
                            if (port > Math.pow(2, 16) - 1) {
                                validationError("Invalid port number.");
                                return null;
                            }
                            url.port = port === defaultPort(url.scheme) ? null : port;
                            buffer = "";
                        }
                    }
                    /**
                     * 2.2. If state override is given, then return.
                     * 2.3. Set state to path start state, and decrease pointer by one.
                     */ if (stateOverride !== undefined) {
                        return url;
                    }
                    state = interfaces_1.ParserState.PathStart;
                    walker.pointer--;
                } else {
                    /**
                     * 3. Otherwise, validation error, return failure.
                     */ validationError("Invalid input string.");
                    return null;
                }
                break;
            case interfaces_1.ParserState.File:
                /**
                 * 1. Set url’s scheme to "file".
                 */ url.scheme = "file";
                if (walker.c() === "/" || walker.c() === "\\") {
                    /**
                     * 2. If c is U+002F (/) or U+005C (\), then:
                     * 2.1. If c is U+005C (\), validation error.
                     * 2.2. Set state to file slash state.
                     */ if (walker.c() === "\\") {
                        validationError("Invalid input string.");
                    }
                    state = interfaces_1.ParserState.FileSlash;
                } else if (baseURL !== null && baseURL.scheme === "file") {
                    /**
                     * 3. Otherwise, if base is non-null and base’s scheme is "file",
                     * switch on c:
                     */ switch(walker.c()){
                        case EOF:
                            /**
                             * Set url’s host to base’s host, url’s path to a copy of base’s
                             * path, and url’s query to base’s query.
                             */ url.host = baseURL.host;
                            url.path = infra_1.list.clone(baseURL.path);
                            url.query = baseURL.query;
                            break;
                        case "?":
                            /**
                             * Set url’s host to base’s host, url’s path to a copy of base’s
                             * path, url’s query to the empty string, and state to query
                             * state.
                             */ url.host = baseURL.host;
                            url.path = infra_1.list.clone(baseURL.path);
                            url.query = "";
                            state = interfaces_1.ParserState.Query;
                            break;
                        case "#":
                            /**
                             * Set url’s host to base’s host, url’s path to a copy of base’s
                             * path, url’s query to base’s query, url’s fragment to the
                             * empty string, and state to fragment state.
                             */ url.host = baseURL.host;
                            url.path = infra_1.list.clone(baseURL.path);
                            url.query = baseURL.query;
                            url.fragment = "";
                            state = interfaces_1.ParserState.Fragment;
                            break;
                        default:
                            /**
                             * 1. If the substring from pointer in input does not start
                             * with a Windows drive letter, then set url’s host to base’s
                             * host, url’s path to a copy of base’s path, and then shorten
                             * url’s path.
                             * _Note:_ is a (platform-independent) Windows drive letter
                             * quirk.
                             * 2. Otherwise, validation error.
                             * 3. Set state to path state, and decrease pointer by one.
                             */ if (!startsWithAWindowsDriveLetter(walker.substring())) {
                                url.host = baseURL.host;
                                url.path = infra_1.list.clone(baseURL.path);
                                shorten(url);
                            } else {
                                validationError("Unexpected windows drive letter in input string.");
                            }
                            state = interfaces_1.ParserState.Path;
                            walker.pointer--;
                            break;
                    }
                } else {
                    /**
                     * 4. Otherwise, set state to path state, and decrease pointer by
                     * one.
                     */ state = interfaces_1.ParserState.Path;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.FileSlash:
                if (walker.c() === "/" || walker.c() === "\\") {
                    /**
                     * 1. If c is U+002F (/) or U+005C (\), then:
                     * 1.1. If c is U+005C (\), validation error.
                     * 1.2. Set state to file host state.
                     */ if (walker.c() === "\\") {
                        validationError("Invalid input string.");
                    }
                    state = interfaces_1.ParserState.FileHost;
                } else {
                    /**
                     * 2. Otherwise:
                     * 2.1. If base is non-null, base’s scheme is "file", and the
                     * substring from pointer in input does not start with a Windows
                     * drive letter, then:
                     * 2.1.1. If base’s path[0] is a normalized Windows drive letter,
                     * then append base’s path[0] to url’s path.
                     * _Note:_ is a (platform-independent) Windows drive letter
                     * quirk. Both url’s and base’s host are null under these conditions
                     * and therefore not copied.
                     * 2.1.2. Otherwise, set url’s host to base’s host.
                     * 2.2. Set state to path state, and decrease pointer by one.
                     */ if (baseURL !== null && baseURL.scheme === "file" && !startsWithAWindowsDriveLetter(walker.substring())) {
                        if (isNormalizedWindowsDriveLetter(baseURL.path[0])) {
                            url.path.push(baseURL.path[0]);
                        } else {
                            url.host = baseURL.host;
                        }
                    }
                    state = interfaces_1.ParserState.Path;
                    walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.FileHost:
                if (walker.c() === EOF || walker.c() === "/" || walker.c() === "\\" || walker.c() === "?" || walker.c() === "#") {
                    /**
                     * 1. If c is the EOF code point, U+002F (/), U+005C (\), U+003F (?),
                     * or U+0023 (#), then decrease pointer by one and then:
                     */ walker.pointer--;
                    if (stateOverride === undefined && isWindowsDriveLetter(buffer)) {
                        /**
                         * 1.1. If state override is not given and buffer is a Windows drive
                         * letter, validation error, set state to path state.
                         * _Note:_ is a (platform-independent) Windows drive letter
                         * quirk. buffer is not reset here and instead used in the path state.
                         */ validationError("Unexpected windows drive letter in input string.");
                        state = interfaces_1.ParserState.Path;
                    } else if (buffer === "") {
                        /**
                         * 1.2. Otherwise, if buffer is the empty string, then:
                         * 1.2.1. Set url’s host to the empty string.
                         * 1.2.2. If state override is given, then return.
                         * 1.2.3. Set state to path start state.
                         */ url.host = "";
                        if (stateOverride !== undefined) return url;
                        state = interfaces_1.ParserState.PathStart;
                    } else {
                        /**
                         * 1.3. Otherwise, run these steps:
                         * 1.3.1. Let host be the result of host parsing buffer with url
                         * is not special.
                         * 1.3.2. If host is failure, then return failure.
                         * 1.3.3. If host is "localhost", then set host to the empty
                         * string.
                         * 1.3.4. Set url’s host to host.
                         * 1.3.5. If state override is given, then return.
                         * 1.3.6. Set buffer to the empty string and state to path start
                         * state.
                         */ var host = hostParser(buffer, !isSpecial(url));
                        if (host === null) return null;
                        if (host === "localhost") host = "";
                        url.host = host;
                        if (stateOverride !== undefined) return url;
                        buffer = "";
                        state = interfaces_1.ParserState.PathStart;
                    }
                } else {
                    /**
                     * 2. Otherwise, append c to buffer.
                     */ buffer += walker.c();
                }
                break;
            case interfaces_1.ParserState.PathStart:
                if (isSpecial(url)) {
                    /**
                     * 1. If url is special, then:
                     * 1.1. If c is U+005C (\), validation error.
                     * 1.2. Set state to path state.
                     * 1.3. If c is neither U+002F (/) nor U+005C (\), then decrease
                     * pointer by one.
                     */ if (walker.c() === "\\") {
                        validationError("Invalid input string.");
                    }
                    state = interfaces_1.ParserState.Path;
                    if (walker.c() !== "/" && walker.c() !== "\\") walker.pointer--;
                } else if (stateOverride === undefined && walker.c() === "?") {
                    /**
                     * 2. Otherwise, if state override is not given and c is U+003F (?),
                     * set url’s query to the empty string and state to query state.
                     */ url.query = "";
                    state = interfaces_1.ParserState.Query;
                } else if (stateOverride === undefined && walker.c() === "#") {
                    /**
                     * 3. Otherwise, if state override is not given and c is U+0023 (#),
                     * set url’s fragment to the empty string and state to fragment
                     * state.
                     */ url.fragment = "";
                    state = interfaces_1.ParserState.Fragment;
                } else if (walker.c() !== EOF) {
                    /**
                     * 4. Otherwise, if c is not the EOF code point:
                     * 4.1. Set state to path state.
                     * 4.2. If c is not U+002F (/), then decrease pointer by one.
                     */ state = interfaces_1.ParserState.Path;
                    if (walker.c() !== "/") walker.pointer--;
                }
                break;
            case interfaces_1.ParserState.Path:
                if (walker.c() === EOF || walker.c() === "/" || isSpecial(url) && walker.c() === "\\" || stateOverride === undefined && (walker.c() === "?" || walker.c() === "#")) {
                    /**
                     * 1. If one of the following is true
                     * - c is the EOF code point or U+002F (/)
                     * - url is special and c is U+005C (\)
                     * - state override is not given and c is U+003F (?) or U+0023 (#)
                     * then:
                     */ if (isSpecial(url) && walker.c() === "\\") {
                        /**
                         * 1.1 If url is special and c is U+005C (\), validation error.
                         */ validationError("Invalid input string.");
                    }
                    if (isDoubleDotPathSegment(buffer)) {
                        /**
                         * 1.2. If buffer is a double-dot path segment, shorten url’s path,
                         * and then if neither c is U+002F (/), nor url is special and c is
                         * U+005C (\), append the empty string to url’s path.
                         */ shorten(url);
                        if (walker.c() !== "/" && !(isSpecial(url) && walker.c() === "\\")) {
                            url.path.push("");
                        }
                    } else if (isSingleDotPathSegment(buffer) && walker.c() !== "/" && !(isSpecial(url) && walker.c() === "\\")) {
                        /**
                         * 1.3. Otherwise, if buffer is a single-dot path segment and if
                         * neither c is U+002F (/), nor url is special and c is U+005C (\),
                         * append the empty string to url’s path.
                         */ url.path.push("");
                    } else if (!isSingleDotPathSegment(buffer)) {
                        /**
                         * 1.4. Otherwise, if buffer is not a single-dot path segment, then:
                         */ if (url.scheme === "file" && url.path.length === 0 && isWindowsDriveLetter(buffer)) {
                            /**
                             * 1.4.1. If url’s scheme is "file", url’s path is empty, and
                             * buffer is a Windows drive letter, then:
                             * 1.4.1.1. If url’s host is neither the empty string nor null,
                             * validation error, set url’s host to the empty string.
                             * 1.4.1.2. Replace the second code point in buffer with U+003A (:).
                             * _Note:_ is a (platform-independent) Windows drive letter quirk.
                             */ if (url.host !== null && url.host !== "") {
                                validationError("Invalid input string.");
                                url.host = "";
                            }
                            var bufferCodePoints = Array.from(buffer);
                            buffer = bufferCodePoints.slice(0, 1) + ":" + bufferCodePoints.slice(2);
                        }
                        /**
                         * 1.4.2. Append buffer to url’s path.
                         */ url.path.push(buffer);
                    }
                    /**
                     * 1.5. Set buffer to the empty string.
                     */ buffer = "";
                    /**
                     * 1.6. If url’s scheme is "file" and c is the EOF code point,
                     * U+003F (?), or U+0023 (#), then while url’s path’s size is
                     * greater than 1 and url’s path[0] is the empty string, validation
                     * error, remove the first item from url’s path.
                     */ if (url.scheme === "file" && (walker.c() === EOF || walker.c() === "?" || walker.c() === "#")) {
                        while(url.path.length > 1 && url.path[0] === ""){
                            validationError("Invalid input string.");
                            url.path.splice(0, 1);
                        }
                    }
                    /**
                     * 1.7. If c is U+003F (?), then set url’s query to the empty string
                     * and state to query state.
                     * 1.8. If c is U+0023 (#), then set url’s fragment to the empty
                     * string and state to fragment state.
                     */ if (walker.c() === "?") {
                        url.query = "";
                        state = interfaces_1.ParserState.Query;
                    }
                    if (walker.c() === "#") {
                        url.fragment = "";
                        state = interfaces_1.ParserState.Fragment;
                    }
                } else {
                    /**
                     * 2. Otherwise, run these steps:
                     * 2.1. If c is not a URL code point and not U+0025 (%), validation
                     * error.
                     * 2.2. If c is U+0025 (%) and remaining does not start with two
                     * ASCII hex digits, validation error.
                     * 2.3. UTF-8 percent encode c using the path percent-encode set,
                     * and append the result to buffer.
                     */ if (!_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
                        validationError("Character is not a URL code point or a percent encoded character.");
                    }
                    if (walker.c() === "%" && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
                        validationError("Percent encoded character must be followed by two hex digits.");
                    }
                    buffer += utf8PercentEncode(walker.c(), _pathPercentEncodeSet);
                }
                break;
            case interfaces_1.ParserState.CannotBeABaseURLPath:
                /**
                 * 1. If c is U+003F (?), then set url’s query to the empty string and
                 * state to query state.
                 * 2. Otherwise, if c is U+0023 (#), then set url’s fragment to the
                 * empty string and state to fragment state.
                 * 3. Otherwise:
                 * 3.1. If c is not the EOF code point, not a URL code point, and not
                 * U+0025 (%), validation error.
                 * 3.2. If c is U+0025 (%) and remaining does not start with two ASCII
                 * hex digits, validation error.
                 * 3.3. If c is not the EOF code point, UTF-8 percent encode c using
                 * the C0 control percent-encode set, and append the result to url’s
                 * path[0].
                 */ if (walker.c() === "?") {
                    url.query = "";
                    state = interfaces_1.ParserState.Query;
                } else if (walker.c() === "#") {
                    url.fragment = "";
                    state = interfaces_1.ParserState.Fragment;
                } else {
                    if (walker.c() !== EOF && !_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
                        validationError("Character is not a URL code point or a percent encoded character.");
                    }
                    if (walker.c() === "%" && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
                        validationError("Percent encoded character must be followed by two hex digits.");
                    }
                    if (walker.c() !== EOF) {
                        url.path[0] += utf8PercentEncode(walker.c(), _c0ControlPercentEncodeSet);
                    }
                }
                break;
            case interfaces_1.ParserState.Query:
                /**
                 * 1. If encoding is not UTF-8 and one of the following is true
                 * - url is not special
                 * - url’s scheme is "ws" or "wss"
                 * then set encoding to UTF-8.
                 */ if (encoding !== "UTF-8" && (!isSpecial(url) || url.scheme === "ws" || url.scheme === "wss")) {
                    encoding = "UTF-8";
                }
                if (stateOverride === undefined && walker.c() === "#") {
                    /**
                     * 2. If state override is not given and c is U+0023 (#), then set
                     * url’s fragment to the empty string and state to fragment state.
                     */ url.fragment = "";
                    state = interfaces_1.ParserState.Fragment;
                } else if (walker.c() !== EOF) {
                    /**
                     * 3. Otherwise, if c is not the EOF code point:
                     * 3.1. If c is not a URL code point and not U+0025 (%), validation
                     * error.
                     */ if (!_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
                        validationError("Character is not a URL code point or a percent encoded character.");
                    }
                    /**
                     * 3.2. If c is U+0025 (%) and remaining does not start with two
                     * ASCII hex digits, validation error.
                     */ if (walker.c() === "%" && !/^[0-9a-fA-F][0-9a-fA-F]/.test(walker.remaining())) {
                        validationError("Percent encoded character must be followed by two hex digits.");
                    }
                    /**
                     * 3.3. Let bytes be the result of encoding c using encoding.
                     */ if (encoding.toUpperCase() !== "UTF-8") {
                        throw new Error("Only UTF-8 encoding is supported.");
                    }
                    var bytes = util_1.utf8Encode(walker.c());
                    /**
                     * 3.4. If bytes starts with `&#` and ends with 0x3B (;), then:
                     */ if (bytes.length >= 3 && bytes[0] === 38 && bytes[1] === 35 && bytes[bytes.length - 1] === 59) {
                        /**
                         * 3.4.1. Replace `&#` at the start of bytes with `%26%23`.
                         * 3.4.2. Replace 0x3B (;) at the end of bytes with `%3B`.
                         * 3.4.4. Append bytes, isomorphic decoded, to url’s query.
                         * _Note:_ can happen when encoding code points using a
                         * non-UTF-8 encoding.
                         */ bytes = bytes.subarray(2, bytes.length - 1);
                        url.query += "%26%23" + infra_1.byteSequence.isomorphicDecode(bytes) + "%3B";
                    } else {
                        try {
                            /**
                             * 3.5. Otherwise, for each byte in bytes:
                             * 3.5.1. If one of the following is true
                             * - byte is less than 0x21 (!)
                             * - byte is greater than 0x7E (~)
                             * - byte is 0x22 ("), 0x23 (#), 0x3C (<), or 0x3E (>)
                             * - byte is 0x27 (') and url is special
                             * then append byte, percent encoded, to url’s query.
                             * 3.5.2. Otherwise, append a code point whose value is byte to
                             * url’s query.
                             */ for(var bytes_1 = (e_3 = void 0, __values(bytes)), bytes_1_1 = bytes_1.next(); !bytes_1_1.done; bytes_1_1 = bytes_1.next()){
                                var byte = bytes_1_1.value;
                                if (byte < 0x21 || byte > 0x7E || byte === 0x22 || byte === 0x23 || byte === 0x3C || byte === 0x3E || byte === 0x27 && isSpecial(url)) {
                                    url.query += percentEncode(byte);
                                } else {
                                    url.query += String.fromCharCode(byte);
                                }
                            }
                        } catch (e_3_1) {
                            e_3 = {
                                error: e_3_1
                            };
                        } finally{
                            try {
                                if (bytes_1_1 && !bytes_1_1.done && (_b = bytes_1.return)) _b.call(bytes_1);
                            } finally{
                                if (e_3) throw e_3.error;
                            }
                        }
                    }
                }
                break;
            case interfaces_1.ParserState.Fragment:
                /**
                 * Switching on c:
                 * - The EOF code point
                 * Do nothing.
                 * - U+0000 NULL
                 * Validation error.
                 * - Otherwise
                 * 1. If c is not a URL code point and not U+0025 (%), validation
                 * error.
                 * 2. If c is U+0025 (%) and remaining does not start with two ASCII
                 * hex digits, validation error.
                 * 3. UTF-8 percent encode c using the fragment percent-encode set and
                 * append the result to url’s fragment.
                 */ if (walker.c() === EOF) {
                //
                } else if (walker.c() === "\x00") {
                    validationError("NULL character in input string.");
                } else {
                    if (!_urlCodePoints.test(walker.c()) && walker.c() !== "%") {
                        validationError("Unexpected character in fragment string.");
                    }
                    if (walker.c() === "%" && !/^[A-Za-z0-9][A-Za-z0-9]/.test(walker.remaining())) {
                        validationError("Unexpected character in fragment string.");
                    }
                    url.fragment += utf8PercentEncode(walker.c(), _fragmentPercentEncodeSet);
                }
                break;
        }
        if (walker.eof) break;
        else walker.pointer++;
    }
    /**
     * 12. Return url.
     */ return url;
}
exports.basicURLParser = basicURLParser;
/**
 * Sets a URL's username.
 *
 * @param url - a URL
 * @param username - username string
 */ function setTheUsername(url, username) {
    var e_4, _a;
    /**
     * 1. Set url’s username to the empty string.
     * 2. For each code point in username, UTF-8 percent encode it using the
     * userinfo percent-encode set, and append the result to url’s username.
     */ var result = "";
    try {
        for(var username_1 = __values(username), username_1_1 = username_1.next(); !username_1_1.done; username_1_1 = username_1.next()){
            var codePoint = username_1_1.value;
            result += utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
        }
    } catch (e_4_1) {
        e_4 = {
            error: e_4_1
        };
    } finally{
        try {
            if (username_1_1 && !username_1_1.done && (_a = username_1.return)) _a.call(username_1);
        } finally{
            if (e_4) throw e_4.error;
        }
    }
    url.username = result;
}
exports.setTheUsername = setTheUsername;
/**
 * Sets a URL's password.
 *
 * @param url - a URL
 * @param username - password string
 */ function setThePassword(url, password) {
    var e_5, _a;
    /**
     * 1. Set url’s password to the empty string.
     * 2. For each code point in password, UTF-8 percent encode it using the
     * userinfo percent-encode set, and append the result to url’s password.
     */ var result = "";
    try {
        for(var password_1 = __values(password), password_1_1 = password_1.next(); !password_1_1.done; password_1_1 = password_1.next()){
            var codePoint = password_1_1.value;
            result += utf8PercentEncode(codePoint, _userInfoPercentEncodeSet);
        }
    } catch (e_5_1) {
        e_5 = {
            error: e_5_1
        };
    } finally{
        try {
            if (password_1_1 && !password_1_1.done && (_a = password_1.return)) _a.call(password_1);
        } finally{
            if (e_5) throw e_5.error;
        }
    }
    url.password = result;
}
exports.setThePassword = setThePassword;
/**
 * Determines if the string represents a single dot path.
 *
 * @param str - a string
 */ function isSingleDotPathSegment(str) {
    return str === "." || str.toLowerCase() === "%2e";
}
exports.isSingleDotPathSegment = isSingleDotPathSegment;
/**
 * Determines if the string represents a double dot path.
 *
 * @param str - a string
 */ function isDoubleDotPathSegment(str) {
    var lowerStr = str.toLowerCase();
    return lowerStr === ".." || lowerStr === ".%2e" || lowerStr === "%2e." || lowerStr === "%2e%2e";
}
exports.isDoubleDotPathSegment = isDoubleDotPathSegment;
/**
 * Shorten's URL's path.
 *
 * @param url - an URL
 */ function shorten(url) {
    /**
     * 1. Let path be url’s path.
     * 2. If path is empty, then return.
     * 3. If url’s scheme is "file", path’s size is 1, and path[0] is a
     * normalized Windows drive letter, then return.
     * 4. Remove path’s last item.
     */ var path = url.path;
    if (path.length === 0) return;
    if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) return;
    url.path.splice(url.path.length - 1, 1);
}
exports.shorten = shorten;
/**
 * Determines if a string is a normalized Windows drive letter.
 *
 * @param str - a string
 */ function isNormalizedWindowsDriveLetter(str) {
    /**
     * A normalized Windows drive letter is a Windows drive letter of which the
     * second code point is U+003A (:).
     */ return str.length >= 2 && infra_1.codePoint.ASCIIAlpha.test(str[0]) && str[1] === ":";
}
exports.isNormalizedWindowsDriveLetter = isNormalizedWindowsDriveLetter;
/**
 * Determines if a string is a Windows drive letter.
 *
 * @param str - a string
 */ function isWindowsDriveLetter(str) {
    /**
     * A Windows drive letter is two code points, of which the first is an ASCII
     * alpha and the second is either U+003A (:) or U+007C (|).
     */ return str.length >= 2 && infra_1.codePoint.ASCIIAlpha.test(str[0]) && (str[1] === ":" || str[1] === "|");
}
exports.isWindowsDriveLetter = isWindowsDriveLetter;
/**
 * Determines if a string starts with a Windows drive letter.
 *
 * @param str - a string
 */ function startsWithAWindowsDriveLetter(str) {
    /**
     * A string starts with a Windows drive letter if all of the following are
     * true:
     * - its length is greater than or equal to 2
     * - its first two code points are a Windows drive letter
     * - its length is 2 or its third code point is U+002F (/), U+005C (\),
     * U+003F (?), or U+0023 (#).
     */ return str.length >= 2 && isWindowsDriveLetter(str) && (str.length === 2 || str[2] === "/" || str[2] === "\\" || str[2] === "?" || str[2] === "#");
}
exports.startsWithAWindowsDriveLetter = startsWithAWindowsDriveLetter;
/**
 * Parses a host string.
 *
 * @param input - input string
 * @param isNotSpecial - `true` if the source URL is not special; otherwise
 * `false`.
 */ function hostParser(input, isNotSpecial) {
    if (isNotSpecial === void 0) {
        isNotSpecial = false;
    }
    /**
     * 1. If isNotSpecial is not given, then set isNotSpecial to false.
     * 2. If input starts with U+005B ([), then:
     * 2.1. If input does not end with U+005D (]), validation error, return
     * failure.
     * 2.2. Return the result of IPv6 parsing input with its leading U+005B ([)
     * and trailing U+005D (]) removed.
     */ if (input.startsWith("[")) {
        if (!input.endsWith("]")) {
            validationError("Expected ']' after '['.");
            return null;
        }
        return iPv6Parser(input.substring(1, input.length - 1));
    }
    /**
     * 3. If isNotSpecial is true, then return the result of opaque-host parsing
     * input.
     */ if (isNotSpecial) {
        return opaqueHostParser(input);
    }
    /**
     * 4. Let domain be the result of running UTF-8 decode without BOM on the
     * string percent decoding of input.
     * _Note:_ Alternatively UTF-8 decode without BOM or fail can be used,
     * coupled with an early return for failure, as domain to ASCII fails
     * on U+FFFD REPLACEMENT CHARACTER.
     */ var domain = util_1.utf8Decode(stringPercentDecode(input));
    /**
     * 5. Let asciiDomain be the result of running domain to ASCII on domain.
     * 6. If asciiDomain is failure, validation error, return failure.
     * 7. If asciiDomain contains a forbidden host code point, validation error,
     * return failure.
     */ var asciiDomain = domainToASCII(domain);
    if (asciiDomain === null) {
        validationError("Invalid domain.");
        return null;
    }
    if (_forbiddenHostCodePoint.test(asciiDomain)) {
        validationError("Invalid domain.");
        return null;
    }
    /**
     * 8. Let ipv4Host be the result of IPv4 parsing asciiDomain.
     * 9. If ipv4Host is an IPv4 address or failure, return ipv4Host.
     * 10. Return asciiDomain.
     */ var ipv4Host = iPv4Parser(asciiDomain);
    if (ipv4Host === null || util_1.isNumber(ipv4Host)) return ipv4Host;
    return asciiDomain;
}
exports.hostParser = hostParser;
/**
 * Parses a string containing an IP v4 address.
 *
 * @param input - input string
 * @param isNotSpecial - `true` if the source URL is not special; otherwise
 * `false`.
 */ function iPv4NumberParser(input, validationErrorFlag) {
    if (validationErrorFlag === void 0) {
        validationErrorFlag = {
            value: false
        };
    }
    /**
     * 1. Let R be 10.
     */ var R = 10;
    if (input.startsWith("0x") || input.startsWith("0X")) {
        /**
         * 2. If input contains at least two code points and the first two code
         * points are either "0x" or "0X", then:
         * 2.1. Set validationErrorFlag.
         * 2.2. Remove the first two code points from input.
         * 2.3. Set R to 16.
         */ validationErrorFlag.value = true;
        input = input.substr(2);
        R = 16;
    } else if (input.length >= 2 && input[0] === "0") {
        /**
         * 3. Otherwise, if input contains at least two code points and the first
         * code point is U+0030 (0), then:
         * 3.1. Set validationErrorFlag.
         * 3.2. Remove the first code point from input.
         * 3.3. Set R to 8.
         */ validationErrorFlag.value = true;
        input = input.substr(1);
        R = 8;
    }
    /**
     * 4. If input is the empty string, then return zero.
     * 5. If input contains a code point that is not a radix-R digit, then
     * return failure.
     */ if (input === "") return 0;
    var radixRDigits = R === 10 ? /^[0-9]+$/ : R === 16 ? /^[0-9A-Fa-f]+$/ : /^[0-7]+$/;
    if (!radixRDigits.test(input)) return null;
    /**
     * 6. Return the mathematical integer value that is represented by input in
     * radix-R notation, using ASCII hex digits for digits with values
     * 0 through 15.
     */ return parseInt(input, R);
}
exports.iPv4NumberParser = iPv4NumberParser;
/**
 * Parses a string containing an IP v4 address.
 *
 * @param input - input string
 */ function iPv4Parser(input) {
    var e_6, _a, e_7, _b;
    /**
     * 1. Let validationErrorFlag be unset.
     * 2. Let parts be input split on U+002E (.).
     */ var validationErrorFlag = {
        value: false
    };
    var parts = input.split(".");
    /**
     * 3. If the last item in parts is the empty string, then:
     * 3.1. Set validationErrorFlag.
     * 3.2. If parts has more than one item, then remove the last item from
     * parts.
     */ if (parts[parts.length - 1] === "") {
        validationErrorFlag.value = true;
        if (parts.length > 1) parts.pop();
    }
    /**
     * 4. If parts has more than four items, return input.
     */ if (parts.length > 4) return input;
    /**
     * 5. Let numbers be the empty list.
     * 6. For each part in parts:
     * 6.1. If part is the empty string, return input.
     * 6.2. Let n be the result of parsing part using validationErrorFlag.
     * 6.3. If n is failure, return input.
     * 6.4. Append n to numbers.
     */ var numbers = [];
    try {
        for(var parts_1 = __values(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()){
            var part = parts_1_1.value;
            if (part === "") return input;
            var n = iPv4NumberParser(part, validationErrorFlag);
            if (n === null) return input;
            numbers.push(n);
        }
    } catch (e_6_1) {
        e_6 = {
            error: e_6_1
        };
    } finally{
        try {
            if (parts_1_1 && !parts_1_1.done && (_a = parts_1.return)) _a.call(parts_1);
        } finally{
            if (e_6) throw e_6.error;
        }
    }
    /**
     * 7. If validationErrorFlag is set, validation error.
     * 8. If any item in numbers is greater than 255, validation error.
     * 9. If any but the last item in numbers is greater than 255, return
     * failure.
     * 10. If the last item in numbers is greater than or equal to
     * 256**(5 − the number of items in numbers), validation error, return failure.
     */ if (validationErrorFlag.value) validationError("Invalid IP v4 address.");
    for(var i = 0; i < numbers.length; i++){
        var item = numbers[i];
        if (item > 255) {
            validationError("Invalid IP v4 address.");
            if (i < numbers.length - 1) return null;
        }
    }
    if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        validationError("Invalid IP v4 address.");
        return null;
    }
    /**
     * 11. Let ipv4 be the last item in numbers.
     * 12. Remove the last item from numbers.
     */ var ipv4 = numbers[numbers.length - 1];
    numbers.pop();
    /**
     * 13. Let counter be zero.
     * 14. For each n in numbers:
     * 14.2. Increment ipv4 by n × 256**(3 − counter).
     * 14.2. Increment counter by 1.
     */ var counter = 0;
    try {
        for(var numbers_1 = __values(numbers), numbers_1_1 = numbers_1.next(); !numbers_1_1.done; numbers_1_1 = numbers_1.next()){
            var n = numbers_1_1.value;
            ipv4 += n * Math.pow(256, 3 - counter);
            counter++;
        }
    } catch (e_7_1) {
        e_7 = {
            error: e_7_1
        };
    } finally{
        try {
            if (numbers_1_1 && !numbers_1_1.done && (_b = numbers_1.return)) _b.call(numbers_1);
        } finally{
            if (e_7) throw e_7.error;
        }
    }
    /**
     * 15. Return ipv4.
     */ return ipv4;
}
exports.iPv4Parser = iPv4Parser;
/**
 * Parses a string containing an IP v6 address.
 *
 * @param input - input string
 */ function iPv6Parser(input) {
    var _a;
    /**
     * 1. Let address be a new IPv6 address whose IPv6 pieces are all 0.
     * 2. Let pieceIndex be 0.
     * 3. Let compress be null.
     * 4. Let pointer be a pointer into input, initially 0 (pointing to the
     * first code point).
     */ var EOF = "";
    var address = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
    ];
    var pieceIndex = 0;
    var compress = null;
    var walker = new util_1.StringWalker(input);
    /**
     * 5. If c is U+003A (:), then:
     * 5.1. If remaining does not start with U+003A (:), validation error,
     * return failure.
     * 5.2. Increase pointer by 2.
     * 5.3. Increase pieceIndex by 1 and then set compress to pieceIndex.
     */ if (walker.c() === ":") {
        if (!walker.remaining().startsWith(":")) {
            validationError("Invalid IP v6 address.");
            return null;
        }
        walker.pointer += 2;
        pieceIndex += 1;
        compress = pieceIndex;
    }
    /**
     * 6. While c is not the EOF code point:
     */ while(walker.c() !== EOF){
        /**
         * 6.1. If pieceIndex is 8, validation error, return failure.
         */ if (pieceIndex === 8) {
            validationError("Invalid IP v6 address.");
            return null;
        }
        /**
         * 6.2. If c is U+003A (:), then:
         * 6.2.1. If compress is non-null, validation error, return failure.
         * 6.2.2. Increase pointer and pieceIndex by 1, set compress to pieceIndex,
         * and then continue.
         */ if (walker.c() === ":") {
            if (compress !== null) {
                validationError("Invalid IP v6 address.");
                return null;
            }
            walker.pointer++;
            pieceIndex++;
            compress = pieceIndex;
            continue;
        }
        /**
         * 6.3. Let value and length be 0.
         * 6.4. While length is less than 4 and c is an ASCII hex digit, set value
         * to value × 0x10 + c interpreted as hexadecimal number, and increase
         * pointer and length by 1.
         */ var value = 0;
        var length = 0;
        while(length < 4 && infra_1.codePoint.ASCIIHexDigit.test(walker.c())){
            value = value * 0x10 + parseInt(walker.c(), 16);
            walker.pointer++;
            length++;
        }
        /**
         * 6.5. If c is U+002E (.), then:
         */ if (walker.c() === ".") {
            /**
             * 6.5.1. If length is 0, validation error, return failure.
             * 6.5.2. Decrease pointer by length.
             * 6.5.3. If pieceIndex is greater than 6, validation error, return
             * failure.
             * 6.5.4. Let numbersSeen be 0.
             */ if (length === 0) {
                validationError("Invalid IP v6 address.");
                return null;
            }
            walker.pointer -= length;
            if (pieceIndex > 6) {
                validationError("Invalid IP v6 address.");
                return null;
            }
            var numbersSeen = 0;
            /**
             * 6.5.5. While c is not the EOF code point:
             */ while(walker.c() !== EOF){
                /**
                 * 6.5.5.1. Let ipv4Piece be null.
                 */ var ipv4Piece = null;
                /**
                 * 6.5.5.2. If numbersSeen is greater than 0, then:
                 * 6.5.5.2.1. If c is a U+002E (.) and numbersSeen is less than 4, then
                 * increase pointer by 1.
                 * 6.5.5.2.1. Otherwise, validation error, return failure.
                 */ if (numbersSeen > 0) {
                    if (walker.c() === "." && numbersSeen < 4) {
                        walker.pointer++;
                    } else {
                        validationError("Invalid IP v6 address.");
                        return null;
                    }
                }
                /**
                 * 6.5.5.3. If c is not an ASCII digit, validation error, return
                 * failure.
                 */ if (!infra_1.codePoint.ASCIIDigit.test(walker.c())) {
                    validationError("Invalid IP v6 address.");
                    return null;
                }
                /**
                 * 6.5.5.4. While c is an ASCII digit:
                 */ while(infra_1.codePoint.ASCIIDigit.test(walker.c())){
                    /**
                     * 6.5.5.4.1. Let number be c interpreted as decimal number.
                     */ var number = parseInt(walker.c(), 10);
                    /**
                     * 6.5.5.4.2. If ipv4Piece is null, then set ipv4Piece to number.
                     * Otherwise, if ipv4Piece is 0, validation error, return failure.
                     * Otherwise, set ipv4Piece to ipv4Piece × 10 + number.
                     */ if (ipv4Piece === null) {
                        ipv4Piece = number;
                    } else if (ipv4Piece === 0) {
                        validationError("Invalid IP v6 address.");
                        return null;
                    } else {
                        ipv4Piece = ipv4Piece * 10 + number;
                    }
                    /**
                     * 6.5.5.4.3. If ipv4Piece is greater than 255, validation error, return failure.
                     * 6.5.5.4.4. Increase pointer by 1.
                     */ if (ipv4Piece > 255) {
                        validationError("Invalid IP v6 address.");
                        return null;
                    }
                    walker.pointer++;
                }
                /**
                 * 6.5.5.5. Set address[pieceIndex] to address[pieceIndex] × 0x100 + ipv4Piece.
                 * 6.5.5.6. Increase numbersSeen by 1.
                 * 6.5.5.7. If numbersSeen is 2 or 4, then increase pieceIndex by 1.
                 */ if (ipv4Piece === null) {
                    validationError("Invalid IP v6 address.");
                    return null;
                }
                address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;
                numbersSeen++;
                if (numbersSeen === 2 || numbersSeen === 4) pieceIndex++;
            }
            /**
             * 6.5.6. If numbersSeen is not 4, validation error, return failure.
             */ if (numbersSeen !== 4) {
                validationError("Invalid IP v6 address.");
                return null;
            }
            break;
        } else if (walker.c() === ":") {
            /**
             * 6.6. Otherwise, if c is U+003A (:):
             * 6.6.1. Increase pointer by 1.
             * 6.6.2. If c is the EOF code point, validation error, return failure.
             */ walker.pointer++;
            if (walker.c() === EOF) {
                validationError("Invalid IP v6 address.");
                return null;
            }
        } else if (walker.c() !== EOF) {
            /**
             * 6.7. Otherwise, if c is not the EOF code point, validation error,
             * return failure.
             */ validationError("Invalid IP v6 address.");
            return null;
        }
        /**
         * 6.8. Set address[pieceIndex] to value.
         * 6.9. Increase pieceIndex by 1.
         */ address[pieceIndex] = value;
        pieceIndex++;
    }
    /**
     * 7. If compress is non-null, then:
     * 7.1. Let swaps be pieceIndex − compress.
     * 7.2. Set pieceIndex to 7.
     * 7.3. While pieceIndex is not 0 and swaps is greater than 0, swap
     * address[pieceIndex] with address[compress + swaps − 1], and then decrease
     * both pieceIndex and swaps by 1.
     */ if (compress !== null) {
        var swaps = pieceIndex - compress;
        pieceIndex = 7;
        while(pieceIndex !== 0 && swaps > 0){
            _a = __read([
                address[compress + swaps - 1],
                address[pieceIndex]
            ], 2), address[pieceIndex] = _a[0], address[compress + swaps - 1] = _a[1];
            pieceIndex--;
            swaps--;
        }
    } else if (compress === null && pieceIndex !== 8) {
        /**
         * 8. Otherwise, if compress is null and pieceIndex is not 8,
         * validation error, return failure.
         */ validationError("Invalid IP v6 address.");
        return null;
    }
    /**
     * 9. Return address.
     */ return address;
}
exports.iPv6Parser = iPv6Parser;
/**
 * Parses an opaque host string.
 *
 * @param input - a string
 */ function opaqueHostParser(input) {
    var e_8, _a;
    /**
     * 1. If input contains a forbidden host code point excluding U+0025 (%),
     * validation error, return failure.
     * 2. Let output be the empty string.
     * 3. For each code point in input, UTF-8 percent encode it using the C0
     * control percent-encode set, and append the result to output.
     * 4. Return output.
     */ var forbiddenChars = /[\x00\t\f\r #/:?@\[\\\]]/;
    if (forbiddenChars.test(input)) {
        validationError("Invalid host string.");
        return null;
    }
    var output = "";
    try {
        for(var input_1 = __values(input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()){
            var codePoint = input_1_1.value;
            output += utf8PercentEncode(codePoint, _c0ControlPercentEncodeSet);
        }
    } catch (e_8_1) {
        e_8 = {
            error: e_8_1
        };
    } finally{
        try {
            if (input_1_1 && !input_1_1.done && (_a = input_1.return)) _a.call(input_1);
        } finally{
            if (e_8) throw e_8.error;
        }
    }
    return output;
}
exports.opaqueHostParser = opaqueHostParser;
/**
 * Resolves a Blob URL from the user agent's Blob URL store.
 * function is not implemented.
 * See: https://w3c.github.io/FileAPI/#blob-url-resolve
 *
 * @param url - an url
 */ function resolveABlobURL(url) {
    return null;
}
exports.resolveABlobURL = resolveABlobURL;
/**
 * Percent encodes a byte.
 *
 * @param value - a byte
 */ function percentEncode(value) {
    /**
     * To percent encode a byte into a percent-encoded byte, return a string
     * consisting of U+0025 (%), followed by two ASCII upper hex digits
     * representing byte.
     */ return "%" + ("00" + value.toString(16).toUpperCase()).slice(-2);
}
exports.percentEncode = percentEncode;
/**
 * Percent decodes a byte sequence input.
 *
 * @param input - a byte sequence
 */ function percentDecode(input) {
    var isHexDigit = function(byte) {
        return byte >= 0x30 && byte <= 0x39 || byte >= 0x41 && byte <= 0x46 || byte >= 0x61 && byte <= 0x66;
    };
    /**
     * 1. Let output be an empty byte sequence.
     * 2. For each byte byte in input:
     */ var output = new Uint8Array(input.length);
    var n = 0;
    for(var i = 0; i < input.length; i++){
        var byte = input[i];
        /**
         * 2.1. If byte is not 0x25 (%), then append byte to output.
         * 2.2. Otherwise, if byte is 0x25 (%) and the next two bytes after byte
         * in input are not in the ranges 0x30 (0) to 0x39 (9), 0x41 (A)
         * to 0x46 (F), and 0x61 (a) to 0x66 (f), all inclusive, append byte
         * to output.
         * 2.3. Otherwise:
         * 2.3.1. Let bytePoint be the two bytes after byte in input, decoded,
         * and then interpreted as hexadecimal number.
         * 2.3.2. Append a byte whose value is bytePoint to output.
         * 2.3.3. Skip the next two bytes in input.
         */ if (byte !== 0x25) {
            output[n] = byte;
            n++;
        } else if (byte === 0x25 && i >= input.length - 2) {
            output[n] = byte;
            n++;
        } else if (byte === 0x25 && (!isHexDigit(input[i + 1]) || !isHexDigit(input[i + 2]))) {
            output[n] = byte;
            n++;
        } else {
            var bytePoint = parseInt(util_1.utf8Decode(Uint8Array.of(input[i + 1], input[i + 2])), 16);
            output[n] = bytePoint;
            n++;
            i += 2;
        }
    }
    return output.subarray(0, n);
}
exports.percentDecode = percentDecode;
/**
 * String percent decodes a string.
 *
 * @param input - a string
 */ function stringPercentDecode(input) {
    /**
     * 1. Let bytes be the UTF-8 encoding of input.
     * 2. Return the percent decoding of bytes.
     */ return percentDecode(util_1.utf8Encode(input));
}
exports.stringPercentDecode = stringPercentDecode;
/**
 * UTF-8 percent encodes a code point, using a percent encode set.
 *
 * @param codePoint - a code point
 * @param percentEncodeSet - a percent encode set
 */ function utf8PercentEncode(codePoint, percentEncodeSet) {
    var e_9, _a;
    /**
     * 1. If codePoint is not in percentEncodeSet, then return codePoint.
     * 2. Let bytes be the result of running UTF-8 encode on codePoint.
     * 3. Percent encode each byte in bytes, and then return the results
     * concatenated, in the same order.
     */ if (!percentEncodeSet.test(codePoint)) return codePoint;
    var bytes = util_1.utf8Encode(codePoint);
    var result = "";
    try {
        for(var bytes_2 = __values(bytes), bytes_2_1 = bytes_2.next(); !bytes_2_1.done; bytes_2_1 = bytes_2.next()){
            var byte = bytes_2_1.value;
            result += percentEncode(byte);
        }
    } catch (e_9_1) {
        e_9 = {
            error: e_9_1
        };
    } finally{
        try {
            if (bytes_2_1 && !bytes_2_1.done && (_a = bytes_2.return)) _a.call(bytes_2);
        } finally{
            if (e_9) throw e_9.error;
        }
    }
    return result;
}
exports.utf8PercentEncode = utf8PercentEncode;
/**
 * Determines if two hosts are considered equal.
 *
 * @param hostA - a host
 * @param hostB - a host
 */ function hostEquals(hostA, hostB) {
    return hostA === hostB;
}
exports.hostEquals = hostEquals;
/**
 * Determines if two URLs are considered equal.
 *
 * @param urlA - a URL
 * @param urlB - a URL
 * @param excludeFragmentsFlag - whether to ignore fragments while comparing
 */ function urlEquals(urlA, urlB, excludeFragmentsFlag) {
    if (excludeFragmentsFlag === void 0) {
        excludeFragmentsFlag = false;
    }
    /**
     * 1. Let serializedA be the result of serializing A, with the exclude
     * fragment flag set if the exclude fragments flag is set.
     * 2. Let serializedB be the result of serializing B, with the exclude
     * fragment flag set if the exclude fragments flag is set.
     * 3. Return true if serializedA is serializedB, and false otherwise.
     */ return urlSerializer(urlA, excludeFragmentsFlag) === urlSerializer(urlB, excludeFragmentsFlag);
}
exports.urlEquals = urlEquals;
/**
 * Parses an `application/x-www-form-urlencoded` string.
 *
 * @param input - a string
 */ function urlEncodedStringParser(input) {
    /**
     * The application/x-www-form-urlencoded string parser takes a string input,
     * UTF-8 encodes it, and then returns the result of
     * application/x-www-form-urlencoded parsing it.
     */ return urlEncodedParser(util_1.utf8Encode(input));
}
exports.urlEncodedStringParser = urlEncodedStringParser;
/**
 * Parses `application/x-www-form-urlencoded` bytes.
 *
 * @param input - a byte sequence
 */ function urlEncodedParser(input) {
    var e_10, _a, e_11, _b;
    /**
     * 1. Let sequences be the result of splitting input on 0x26 (&).
     */ var sequences = [];
    var currentSequence = [];
    try {
        for(var input_2 = __values(input), input_2_1 = input_2.next(); !input_2_1.done; input_2_1 = input_2.next()){
            var byte = input_2_1.value;
            if (byte === 0x26) {
                sequences.push(Uint8Array.from(currentSequence));
                currentSequence = [];
            } else {
                currentSequence.push(byte);
            }
        }
    } catch (e_10_1) {
        e_10 = {
            error: e_10_1
        };
    } finally{
        try {
            if (input_2_1 && !input_2_1.done && (_a = input_2.return)) _a.call(input_2);
        } finally{
            if (e_10) throw e_10.error;
        }
    }
    if (currentSequence.length !== 0) {
        sequences.push(Uint8Array.from(currentSequence));
    }
    /**
     * 2. Let output be an initially empty list of name-value tuples where both name and value hold a string.
     */ var output = [];
    try {
        /**
         * 3. For each byte sequence bytes in sequences:
         */ for(var sequences_1 = __values(sequences), sequences_1_1 = sequences_1.next(); !sequences_1_1.done; sequences_1_1 = sequences_1.next()){
            var bytes = sequences_1_1.value;
            /**
             * 3.1. If bytes is the empty byte sequence, then continue.
             */ if (bytes.length === 0) continue;
            /**
             * 3.2. If bytes contains a 0x3D (=), then let name be the bytes from the
             * start of bytes up to but excluding its first 0x3D (=), and let value be
             * the bytes, if any, after the first 0x3D (=) up to the end of bytes.
             * If 0x3D (=) is the first byte, then name will be the empty byte
             * sequence. If it is the last, then value will be the empty byte sequence.
             * 3.3. Otherwise, let name have the value of bytes and let value be the
             * empty byte sequence.
             */ var index = bytes.indexOf(0x3D);
            var name = index !== -1 ? bytes.slice(0, index) : bytes;
            var value = index !== -1 ? bytes.slice(index + 1) : new Uint8Array();
            /**
             * 3.4. Replace any 0x2B (+) in name and value with 0x20 (SP).
             */ for(var i = 0; i < name.length; i++)if (name[i] === 0x2B) name[i] = 0x20;
            for(var i = 0; i < value.length; i++)if (value[i] === 0x2B) value[i] = 0x20;
            /**
             * 3.5. Let nameString and valueString be the result of running UTF-8
             * decode without BOM on the percent decoding of name and value,
             * respectively.
             */ var nameString = util_1.utf8Decode(name);
            var valueString = util_1.utf8Decode(value);
            /**
             * 3.6. Append (nameString, valueString) to output.
             */ output.push([
                nameString,
                valueString
            ]);
        }
    } catch (e_11_1) {
        e_11 = {
            error: e_11_1
        };
    } finally{
        try {
            if (sequences_1_1 && !sequences_1_1.done && (_b = sequences_1.return)) _b.call(sequences_1);
        } finally{
            if (e_11) throw e_11.error;
        }
    }
    /**
     * 4. Return output.
     */ return output;
}
exports.urlEncodedParser = urlEncodedParser;
/**
 * Serializes `application/x-www-form-urlencoded` bytes.
 *
 * @param input - a byte sequence
 */ function urlEncodedByteSerializer(input) {
    var e_12, _a;
    /**
     * 1. Let output be the empty string.
     * 2. For each byte in input, depending on byte:
     * 0x20 (SP)
     * Append U+002B (+) to output.
     *
     * 0x2A (*)
     * 0x2D (-)
     * 0x2E (.)
     * 0x30 (0) to 0x39 (9)
     * 0x41 (A) to 0x5A (Z)
     * 0x5F (_)
     * 0x61 (a) to 0x7A (z)
     * Append a code point whose value is byte to output.
     *
     * Otherwise
     * Append byte, percent encoded, to output.
     * 3. Return output.
     */ var output = "";
    try {
        for(var input_3 = __values(input), input_3_1 = input_3.next(); !input_3_1.done; input_3_1 = input_3.next()){
            var byte = input_3_1.value;
            if (byte === 0x20) {
                output += "+";
            } else if (byte === 0x2A || byte === 0x2D || byte === 0x2E || byte >= 0x30 && byte <= 0x39 || byte >= 0x41 && byte <= 0x5A || byte === 0x5F || byte >= 0x61 && byte <= 0x7A) {
                output += String.fromCodePoint(byte);
            } else {
                output += percentEncode(byte);
            }
        }
    } catch (e_12_1) {
        e_12 = {
            error: e_12_1
        };
    } finally{
        try {
            if (input_3_1 && !input_3_1.done && (_a = input_3.return)) _a.call(input_3);
        } finally{
            if (e_12) throw e_12.error;
        }
    }
    return output;
}
exports.urlEncodedByteSerializer = urlEncodedByteSerializer;
/**
 * Serializes `application/x-www-form-urlencoded` tuples.
 *
 * @param input - input tuple of name/value pairs
 * @param encodingOverride: encoding override
 */ function urlEncodedSerializer(tuples, encodingOverride) {
    var e_13, _a;
    /**
     * 1. Let encoding be UTF-8.
     * 2. If encoding override is given, set encoding to the result of getting
     * an output encoding from encoding override.
     */ var encoding = encodingOverride === undefined || encodingOverride === "replacement" || encodingOverride === "UTF-16BE" || encodingOverride === "UTF-16LE" ? "UTF-8" : encodingOverride;
    if (encoding.toUpperCase() !== "UTF-8") {
        throw new Error("Only UTF-8 encoding is supported.");
    }
    /**
     * 3. Let output be the empty string.
     */ var output = "";
    try {
        /**
         * 4. For each tuple in tuples:
         */ for(var tuples_1 = __values(tuples), tuples_1_1 = tuples_1.next(); !tuples_1_1.done; tuples_1_1 = tuples_1.next()){
            var tuple = tuples_1_1.value;
            /**
             * 4.1. Let name be the result of serializing the result of encoding
             * tuple’s name, using encoding.
             */ var name = urlEncodedByteSerializer(util_1.utf8Encode(tuple[0]));
            /**
             * 4.2. Let value be tuple’s value.
             */ var value = tuple[1];
            /**
             * TODO:
             * 4.3. If value is a file, then set value to value’s filename.
             */ /**
             * 4.4. Set value to the result of serializing the result of encoding
             * value, using encoding.
             */ value = urlEncodedByteSerializer(util_1.utf8Encode(value));
            /**
             * 4.5. If tuple is not the first pair in tuples, then append U+0026 (&)
             * to output.
             */ if (output !== "") output += "&";
            /**
             * 4.6. Append name, followed by U+003D (=), followed by value, to output.
             */ output += name + "=" + value;
        }
    } catch (e_13_1) {
        e_13 = {
            error: e_13_1
        };
    } finally{
        try {
            if (tuples_1_1 && !tuples_1_1.done && (_a = tuples_1.return)) _a.call(tuples_1);
        } finally{
            if (e_13) throw e_13.error;
        }
    }
    /**
     * 5. Return output.
     */ return output;
}
exports.urlEncodedSerializer = urlEncodedSerializer;
/**
 * Returns a URL's origin.
 *
 * @param url - a URL
 */ function origin(url) {
    /**
     * A URL’s origin is the origin returned by running these steps, switching
     * on URL’s scheme:
     * "blob"
     * 1. If URL’s blob URL entry is non-null, then return URL’s blob URL
     * entry’s environment’s origin.
     * 2. Let url be the result of parsing URL’s path[0].
     * 3. Return a new opaque origin, if url is failure, and url’s origin
     * otherwise.
     * "ftp"
     * "http"
     * "https"
     * "ws"
     * "wss"
     * Return a tuple consisting of URL’s scheme, URL’s host, URL’s port, and
     * null.
     * "file"
     * Unfortunate as it is, is left as an exercise to the reader. When in
     * doubt, return a new opaque origin.
     * Otherwise
     * Return a new opaque origin.
     */ switch(url.scheme){
        case "blob":
            if (url._blobURLEntry !== null) {
            // TODO: return URL’s blob URL entry’s environment’s origin.
            }
            var parsedURL = basicURLParser(url.path[0]);
            if (parsedURL === null) return interfaces_1.OpaqueOrigin;
            else return origin(parsedURL);
        case "ftp":
        case "http":
        case "https":
        case "ws":
        case "wss":
            return [
                url.scheme,
                url.host === null ? "" : url.host,
                url.port,
                null
            ];
        case "file":
            return interfaces_1.OpaqueOrigin;
        default:
            return interfaces_1.OpaqueOrigin;
    }
}
exports.origin = origin;
/**
 * Converts a domain string to ASCII.
 *
 * @param domain - a domain string
 */ function domainToASCII(domain, beStrict) {
    if (beStrict === void 0) {
        beStrict = false;
    }
    /**
     * 1. If beStrict is not given, set it to false.
     * 2. Let result be the result of running Unicode ToASCII with domain_name
     * set to domain, UseSTD3ASCIIRules set to beStrict, CheckHyphens set to
     * false, CheckBidi set to true, CheckJoiners set to true,
     * Transitional_Processing set to false, and VerifyDnsLength set to beStrict.
     * 3. If result is a failure value, validation error, return failure.
     * 4. Return result.
     */ // Use node.js function
    var result = url_1.domainToASCII(domain);
    if (result === "") {
        validationError("Invalid domain name.");
        return null;
    }
    return result;
}
exports.domainToASCII = domainToASCII;
/**
 * Converts a domain string to Unicode.
 *
 * @param domain - a domain string
 */ function domainToUnicode(domain, beStrict) {
    if (beStrict === void 0) {
        beStrict = false;
    }
    /**
     * 1. Let result be the result of running Unicode ToUnicode with domain_name
     * set to domain, CheckHyphens set to false, CheckBidi set to true,
     * CheckJoiners set to true, UseSTD3ASCIIRules set to false, and
     * Transitional_Processing set to false.
     * 2. Signify validation errors for any returned errors, and then,
     * return result.
     */ // Use node.js function
    var result = url_1.domainToUnicode(domain);
    if (result === "") {
        validationError("Invalid domain name.");
    }
    return result;
}
exports.domainToUnicode = domainToUnicode;
/**
 * Serializes an origin.
 * function is from the HTML spec:
 * https://html.spec.whatwg.org/#ascii-serialisation-of-an-origin
 *
 * @param origin - an origin
 */ function asciiSerializationOfAnOrigin(origin) {
    /**
     * 1. If origin is an opaque origin, then return "null".
     * 2. Otherwise, let result be origin's scheme.
     * 3. Append "://" to result.
     * 4. Append origin's host, serialized, to result.
     * 5. If origin's port is non-null, append a U+003A COLON character (:),
     * and origin's port, serialized, to result.
     * 6. Return result.
     */ if (origin[0] === "" && origin[1] === "" && origin[2] === null && origin[3] === null) {
        return "null";
    }
    var result = origin[0] + "://" + hostSerializer(origin[1]);
    if (origin[2] !== null) result += ":" + origin[2].toString();
    return result;
}
exports.asciiSerializationOfAnOrigin = asciiSerializationOfAnOrigin; //# sourceMappingURL=URLAlgorithm.js.map


/***/ }),

/***/ 74143:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Represents the state of the URL parser.
 */ var ParserState;
(function(ParserState) {
    ParserState[ParserState["SchemeStart"] = 0] = "SchemeStart";
    ParserState[ParserState["Scheme"] = 1] = "Scheme";
    ParserState[ParserState["NoScheme"] = 2] = "NoScheme";
    ParserState[ParserState["SpecialRelativeOrAuthority"] = 3] = "SpecialRelativeOrAuthority";
    ParserState[ParserState["PathOrAuthority"] = 4] = "PathOrAuthority";
    ParserState[ParserState["Relative"] = 5] = "Relative";
    ParserState[ParserState["RelativeSlash"] = 6] = "RelativeSlash";
    ParserState[ParserState["SpecialAuthoritySlashes"] = 7] = "SpecialAuthoritySlashes";
    ParserState[ParserState["SpecialAuthorityIgnoreSlashes"] = 8] = "SpecialAuthorityIgnoreSlashes";
    ParserState[ParserState["Authority"] = 9] = "Authority";
    ParserState[ParserState["Host"] = 10] = "Host";
    ParserState[ParserState["Hostname"] = 11] = "Hostname";
    ParserState[ParserState["Port"] = 12] = "Port";
    ParserState[ParserState["File"] = 13] = "File";
    ParserState[ParserState["FileSlash"] = 14] = "FileSlash";
    ParserState[ParserState["FileHost"] = 15] = "FileHost";
    ParserState[ParserState["PathStart"] = 16] = "PathStart";
    ParserState[ParserState["Path"] = 17] = "Path";
    ParserState[ParserState["CannotBeABaseURLPath"] = 18] = "CannotBeABaseURLPath";
    ParserState[ParserState["Query"] = 19] = "Query";
    ParserState[ParserState["Fragment"] = 20] = "Fragment";
})(ParserState = exports.ParserState || (exports.ParserState = {}));
exports.OpaqueOrigin = [
    "",
    "",
    null,
    null
]; //# sourceMappingURL=interfaces.js.map


/***/ }),

/***/ 55539:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Represents a cache for storing order between equal objects.
 *
 * This cache is used when an algorithm compares two objects and finds them to
 * be equal but still needs to establish an order between those two objects.
 * When two such objects `a` and `b` are passed to the `check` method, a random
 * number is generated with `Math.random()`. If the random number is less than
 * `0.5` it is assumed that `a < b` otherwise `a > b`. The random number along
 * with `a` and `b` is stored in the cache, so that subsequent checks result
 * in the same consistent result.
 *
 * The cache has a size limit which is defined on initialization.
 */ var CompareCache = /** @class */ function() {
    /**
     * Initializes a new instance of `CompareCache`.
     *
     * @param limit - maximum number of items to keep in the cache. When the limit
     * is exceeded the first item is removed from the cache.
     */ function CompareCache(limit) {
        if (limit === void 0) {
            limit = 1000;
        }
        this._items = new Map();
        this._limit = limit;
    }
    /**
     * Compares and caches the given objects. Returns `true` if `objA < objB` and
     * `false` otherwise.
     *
     * @param objA - an item to compare
     * @param objB - an item to compare
     */ CompareCache.prototype.check = function(objA, objB) {
        if (this._items.get(objA) === objB) return true;
        else if (this._items.get(objB) === objA) return false;
        var result = Math.random() < 0.5;
        if (result) {
            this._items.set(objA, objB);
        } else {
            this._items.set(objB, objA);
        }
        if (this._items.size > this._limit) {
            var it_1 = this._items.keys().next();
            /* istanbul ignore else */ if (!it_1.done) {
                this._items.delete(it_1.value);
            }
        }
        return result;
    };
    return CompareCache;
}();
exports.CompareCache = CompareCache; //# sourceMappingURL=CompareCache.js.map


/***/ }),

/***/ 86349:
/***/ ((__unused_webpack_module, exports) => {


var __generator = (void 0) && (void 0).__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Represents a set of objects with a size limit.
 */ var FixedSizeSet = /** @class */ function() {
    /**
     * Initializes a new instance of `FixedSizeSet`.
     *
     * @param limit - maximum number of items to keep in the set. When the limit
     * is exceeded the first item is removed from the set.
     */ function FixedSizeSet(limit) {
        if (limit === void 0) {
            limit = 1000;
        }
        this._items = new Set();
        this._limit = limit;
    }
    /**
     * Adds a new item to the set.
     *
     * @param item - an item
     */ FixedSizeSet.prototype.add = function(item) {
        this._items.add(item);
        if (this._items.size > this._limit) {
            var it_1 = this._items.values().next();
            /* istanbul ignore else */ if (!it_1.done) {
                this._items.delete(it_1.value);
            }
        }
        return this;
    };
    /**
     * Removes an item from the set.
     *
     * @param item - an item
     */ FixedSizeSet.prototype.delete = function(item) {
        return this._items.delete(item);
    };
    /**
     * Determines if an item is in the set.
     *
     * @param item - an item
     */ FixedSizeSet.prototype.has = function(item) {
        return this._items.has(item);
    };
    /**
     * Removes all items from the set.
     */ FixedSizeSet.prototype.clear = function() {
        this._items.clear();
    };
    Object.defineProperty(FixedSizeSet.prototype, "size", {
        /**
         * Gets the number of items in the set.
         */ get: function() {
            return this._items.size;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Applies the given callback function to all elements of the set.
     */ FixedSizeSet.prototype.forEach = function(callback, thisArg) {
        var _this = this;
        this._items.forEach(function(e) {
            return callback.call(thisArg, e, e, _this);
        });
    };
    /**
     * Iterates through the items in the set.
     */ FixedSizeSet.prototype.keys = function() {
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    return [
                        5 /*yield**/ ,
                        __values(this._items.keys())
                    ];
                case 1:
                    _a.sent();
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */ FixedSizeSet.prototype.values = function() {
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    return [
                        5 /*yield**/ ,
                        __values(this._items.values())
                    ];
                case 1:
                    _a.sent();
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */ FixedSizeSet.prototype.entries = function() {
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    return [
                        5 /*yield**/ ,
                        __values(this._items.entries())
                    ];
                case 1:
                    _a.sent();
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */ FixedSizeSet.prototype[Symbol.iterator] = function() {
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    return [
                        5 /*yield**/ ,
                        __values(this._items)
                    ];
                case 1:
                    _a.sent();
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    };
    Object.defineProperty(FixedSizeSet.prototype, Symbol.toStringTag, {
        /**
         * Returns the string tag of the set.
         */ get: function() {
            return "FixedSizeSet";
        },
        enumerable: true,
        configurable: true
    });
    return FixedSizeSet;
}();
exports.FixedSizeSet = FixedSizeSet; //# sourceMappingURL=FixedSizeSet.js.map


/***/ }),

/***/ 20477:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Represents an object with lazy initialization.
 */ var Lazy = /** @class */ function() {
    /**
     * Initializes a new instance of `Lazy`.
     *
     * @param initFunc - initializer function
     */ function Lazy(initFunc) {
        this._initialized = false;
        this._value = undefined;
        this._initFunc = initFunc;
    }
    Object.defineProperty(Lazy.prototype, "value", {
        /**
         * Gets the value of the object.
         */ get: function() {
            if (!this._initialized) {
                this._value = this._initFunc();
                this._initialized = true;
            }
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    return Lazy;
}();
exports.Lazy = Lazy; //# sourceMappingURL=Lazy.js.map


/***/ }),

/***/ 55117:
/***/ ((__unused_webpack_module, exports) => {


var __generator = (void 0) && (void 0).__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Represents a cache of objects with a size limit.
 */ var ObjectCache = /** @class */ function() {
    /**
     * Initializes a new instance of `ObjectCache`.
     *
     * @param limit - maximum number of items to keep in the cache. When the limit
     * is exceeded the first item is removed from the cache.
     */ function ObjectCache(limit) {
        if (limit === void 0) {
            limit = 1000;
        }
        this._items = new Map();
        this._limit = limit;
    }
    /**
     * Gets an item from the cache.
     *
     * @param key - object key
     */ ObjectCache.prototype.get = function(key) {
        return this._items.get(key);
    };
    /**
     * Adds a new item to the cache.
     *
     * @param key - object key
     * @param value - object value
     */ ObjectCache.prototype.set = function(key, value) {
        this._items.set(key, value);
        if (this._items.size > this._limit) {
            var it_1 = this._items.keys().next();
            /* istanbul ignore else */ if (!it_1.done) {
                this._items.delete(it_1.value);
            }
        }
    };
    /**
     * Removes an item from the cache.
     *
     * @param item - an item
     */ ObjectCache.prototype.delete = function(key) {
        return this._items.delete(key);
    };
    /**
     * Determines if an item is in the cache.
     *
     * @param item - an item
     */ ObjectCache.prototype.has = function(key) {
        return this._items.has(key);
    };
    /**
     * Removes all items from the cache.
     */ ObjectCache.prototype.clear = function() {
        this._items.clear();
    };
    Object.defineProperty(ObjectCache.prototype, "size", {
        /**
         * Gets the number of items in the cache.
         */ get: function() {
            return this._items.size;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Applies the given callback function to all elements of the cache.
     */ ObjectCache.prototype.forEach = function(callback, thisArg) {
        this._items.forEach(function(v, k) {
            return callback.call(thisArg, k, v);
        });
    };
    /**
     * Iterates through the items in the set.
     */ ObjectCache.prototype.keys = function() {
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    return [
                        5 /*yield**/ ,
                        __values(this._items.keys())
                    ];
                case 1:
                    _a.sent();
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */ ObjectCache.prototype.values = function() {
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    return [
                        5 /*yield**/ ,
                        __values(this._items.values())
                    ];
                case 1:
                    _a.sent();
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */ ObjectCache.prototype.entries = function() {
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    return [
                        5 /*yield**/ ,
                        __values(this._items.entries())
                    ];
                case 1:
                    _a.sent();
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    };
    /**
     * Iterates through the items in the set.
     */ ObjectCache.prototype[Symbol.iterator] = function() {
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    return [
                        5 /*yield**/ ,
                        __values(this._items)
                    ];
                case 1:
                    _a.sent();
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    };
    Object.defineProperty(ObjectCache.prototype, Symbol.toStringTag, {
        /**
         * Returns the string tag of the cache.
         */ get: function() {
            return "ObjectCache";
        },
        enumerable: true,
        configurable: true
    });
    return ObjectCache;
}();
exports.ObjectCache = ObjectCache; //# sourceMappingURL=ObjectCache.js.map


/***/ }),

/***/ 66466:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Walks through the code points of a string.
 */ var StringWalker = /** @class */ function() {
    /**
     * Initializes a new `StringWalker`.
     *
     * @param input - input string
     */ function StringWalker(input) {
        this._pointer = 0;
        this._chars = Array.from(input);
        this._length = this._chars.length;
    }
    Object.defineProperty(StringWalker.prototype, "eof", {
        /**
         * Determines if the current position is beyond the end of string.
         */ get: function() {
            return this._pointer >= this._length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StringWalker.prototype, "length", {
        /**
         * Returns the number of code points in the input string.
         */ get: function() {
            return this._length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the current code point. Returns `-1` if the position is beyond
     * the end of string.
     */ StringWalker.prototype.codePoint = function() {
        if (this._codePoint === undefined) {
            if (this.eof) {
                this._codePoint = -1;
            } else {
                var cp = this._chars[this._pointer].codePointAt(0);
                /* istanbul ignore else */ if (cp !== undefined) {
                    this._codePoint = cp;
                } else {
                    this._codePoint = -1;
                }
            }
        }
        return this._codePoint;
    };
    /**
     * Returns the current character. Returns an empty string if the position is
     * beyond the end of string.
     */ StringWalker.prototype.c = function() {
        if (this._c === undefined) {
            this._c = this.eof ? "" : this._chars[this._pointer];
        }
        return this._c;
    };
    /**
     * Returns the remaining string.
     */ StringWalker.prototype.remaining = function() {
        if (this._remaining === undefined) {
            this._remaining = this.eof ? "" : this._chars.slice(this._pointer + 1).join("");
        }
        return this._remaining;
    };
    /**
     * Returns the substring from the current character to the end of string.
     */ StringWalker.prototype.substring = function() {
        if (this._substring === undefined) {
            this._substring = this.eof ? "" : this._chars.slice(this._pointer).join("");
        }
        return this._substring;
    };
    Object.defineProperty(StringWalker.prototype, "pointer", {
        /**
         * Gets or sets the current position.
         */ get: function() {
            return this._pointer;
        },
        set: function(val) {
            if (val === this._pointer) return;
            this._pointer = val;
            this._codePoint = undefined;
            this._c = undefined;
            this._remaining = undefined;
            this._substring = undefined;
        },
        enumerable: true,
        configurable: true
    });
    return StringWalker;
}();
exports.StringWalker = StringWalker; //# sourceMappingURL=StringWalker.js.map


/***/ }),

/***/ 96883:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var FixedSizeSet_1 = __webpack_require__(86349);
exports.FixedSizeSet = FixedSizeSet_1.FixedSizeSet;
var ObjectCache_1 = __webpack_require__(55117);
exports.ObjectCache = ObjectCache_1.ObjectCache;
var CompareCache_1 = __webpack_require__(55539);
exports.CompareCache = CompareCache_1.CompareCache;
var Lazy_1 = __webpack_require__(20477);
exports.Lazy = Lazy_1.Lazy;
var StringWalker_1 = __webpack_require__(66466);
exports.StringWalker = StringWalker_1.StringWalker;
/**
 * Applies the mixin to a given class.
 *
 * @param baseClass - class to receive the mixin
 * @param mixinClass - mixin class
 * @param overrides - an array with names of function overrides. Base class
 * functions whose names are in this array will be kept by prepending an
 * underscore to their names.
 */ function applyMixin(baseClass, mixinClass) {
    var overrides = [];
    for(var _i = 2; _i < arguments.length; _i++){
        overrides[_i - 2] = arguments[_i];
    }
    Object.getOwnPropertyNames(mixinClass.prototype).forEach(function(name) {
        if (name !== "constructor") {
            if (overrides.indexOf(name) !== -1) {
                var orgPropDesc = Object.getOwnPropertyDescriptor(baseClass.prototype, name);
                /* istanbul ignore else */ if (orgPropDesc) {
                    Object.defineProperty(baseClass.prototype, "_" + name, orgPropDesc);
                }
            }
            var propDesc = Object.getOwnPropertyDescriptor(mixinClass.prototype, name);
            /* istanbul ignore else */ if (propDesc) {
                Object.defineProperty(baseClass.prototype, name, propDesc);
            }
        }
    });
}
exports.applyMixin = applyMixin;
/**
 * Applies default values to the given object.
 *
 * @param obj - an object
 * @param defaults - an object with default values
 * @param overwrite - if set to `true` defaults object always overwrites object
 * values, whether they are `undefined` or not.
 */ function applyDefaults(obj, defaults, overwrite) {
    if (overwrite === void 0) {
        overwrite = false;
    }
    var result = clone(obj || {});
    forEachObject(defaults, function(key, val) {
        if (isPlainObject(val)) {
            result[key] = applyDefaults(result[key], val, overwrite);
        } else if (overwrite || result[key] === undefined) {
            result[key] = val;
        }
    });
    return result;
}
exports.applyDefaults = applyDefaults;
/**
 * Iterates over items of an array or set.
 *
 * @param arr - array or set to iterate
 * @param callback - a callback function which receives each array item as its
 * single argument
 * @param thisArg - the value of this inside callback
 */ function forEachArray(arr, callback, thisArg) {
    arr.forEach(callback, thisArg);
}
exports.forEachArray = forEachArray;
/**
 * Iterates over key/value pairs of a map or object.
 *
 * @param obj - map or object to iterate
 * @param callback - a callback function which receives object key as its first
 * argument and object value as its second argument
 * @param thisArg - the value of this inside callback
 */ function forEachObject(obj, callback, thisArg) {
    if (isMap(obj)) {
        obj.forEach(function(value, key) {
            return callback.call(thisArg, key, value);
        });
    } else {
        for(var key in obj){
            /* istanbul ignore else */ if (obj.hasOwnProperty(key)) {
                callback.call(thisArg, key, obj[key]);
            }
        }
    }
}
exports.forEachObject = forEachObject;
/**
 * Returns the number of entries in an array or set.
 *
 * @param arr - array or set
 */ function arrayLength(obj) {
    if (isSet(obj)) {
        return obj.size;
    } else {
        return obj.length;
    }
}
exports.arrayLength = arrayLength;
/**
 * Returns the number of entries in a map or object.
 *
 * @param obj - map or object
 */ function objectLength(obj) {
    if (isMap(obj)) {
        return obj.size;
    } else {
        return Object.keys(obj).length;
    }
}
exports.objectLength = objectLength;
/**
 * Gets the value of a key from a map or object.
 *
 * @param obj - map or object
 * @param key - the key to retrieve
 */ function getObjectValue(obj, key) {
    if (isMap(obj)) {
        return obj.get(key);
    } else {
        return obj[key];
    }
}
exports.getObjectValue = getObjectValue;
/**
 * Removes a property from a map or object.
 *
 * @param obj - map or object
 * @param key - the key to remove
 */ function removeObjectValue(obj, key) {
    if (isMap(obj)) {
        obj.delete(key);
    } else {
        delete obj[key];
    }
}
exports.removeObjectValue = removeObjectValue;
/**
 * Deep clones the given object.
 *
 * @param obj - an object
 */ function clone(obj) {
    var e_1, _a;
    if (isFunction(obj)) {
        return obj;
    } else if (isArray(obj)) {
        var result = [];
        try {
            for(var obj_1 = __values(obj), obj_1_1 = obj_1.next(); !obj_1_1.done; obj_1_1 = obj_1.next()){
                var item = obj_1_1.value;
                result.push(clone(item));
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (obj_1_1 && !obj_1_1.done && (_a = obj_1.return)) _a.call(obj_1);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        return result;
    } else if (isObject(obj)) {
        var result = {};
        for(var key in obj){
            /* istanbul ignore next */ if (obj.hasOwnProperty(key)) {
                var val = obj[key];
                result[key] = clone(val);
            }
        }
        return result;
    } else {
        return obj;
    }
}
exports.clone = clone;
/**
 * Type guard for boolean types
 *
 * @param x - a variable to type check
 */ function isBoolean(x) {
    return typeof x === "boolean";
}
exports.isBoolean = isBoolean;
/**
 * Type guard for numeric types
 *
 * @param x - a variable to type check
 */ function isNumber(x) {
    return typeof x === "number";
}
exports.isNumber = isNumber;
/**
 * Type guard for strings
 *
 * @param x - a variable to type check
 */ function isString(x) {
    return typeof x === "string";
}
exports.isString = isString;
/**
 * Type guard for function objects
 *
 * @param x - a variable to type check
 */ function isFunction(x) {
    return !!x && Object.prototype.toString.call(x) === "[object Function]";
}
exports.isFunction = isFunction;
/**
 * Type guard for JS objects
 *
 * _Note:_ Functions are objects too
 *
 * @param x - a variable to type check
 */ function isObject(x) {
    var type = typeof x;
    return !!x && (type === "function" || type === "object");
}
exports.isObject = isObject;
/**
 * Type guard for arrays
 *
 * @param x - a variable to type check
 */ function isArray(x) {
    return Array.isArray(x);
}
exports.isArray = isArray;
/**
 * Type guard for sets.
 *
 * @param x - a variable to check
 */ function isSet(x) {
    return x instanceof Set;
}
exports.isSet = isSet;
/**
 * Type guard for maps.
 *
 * @param x - a variable to check
 */ function isMap(x) {
    return x instanceof Map;
}
exports.isMap = isMap;
/**
 * Determines if `x` is an empty Array or an Object with no own properties.
 *
 * @param x - a variable to check
 */ function isEmpty(x) {
    if (isArray(x)) {
        return !x.length;
    } else if (isSet(x)) {
        return !x.size;
    } else if (isMap(x)) {
        return !x.size;
    } else if (isObject(x)) {
        for(var key in x){
            if (x.hasOwnProperty(key)) {
                return false;
            }
        }
        return true;
    }
    return false;
}
exports.isEmpty = isEmpty;
/**
 * Determines if `x` is a plain Object.
 *
 * @param x - a variable to check
 */ function isPlainObject(x) {
    if (isObject(x)) {
        var proto = Object.getPrototypeOf(x);
        var ctor = proto.constructor;
        return proto && ctor && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
    }
    return false;
}
exports.isPlainObject = isPlainObject;
/**
 * Determines if `x` is an iterable Object.
 *
 * @param x - a variable to check
 */ function isIterable(x) {
    return x && typeof x[Symbol.iterator] === "function";
}
exports.isIterable = isIterable;
/**
 * Gets the primitive value of an object.
 */ function getValue(obj) {
    if (isFunction(obj.valueOf)) {
        return obj.valueOf();
    } else {
        return obj;
    }
}
exports.getValue = getValue;
/**
 * UTF-8 encodes the given string.
 *
 * @param input - a string
 */ function utf8Encode(input) {
    var bytes = new Uint8Array(input.length * 4);
    var byteIndex = 0;
    for(var i = 0; i < input.length; i++){
        var char = input.charCodeAt(i);
        if (char < 128) {
            bytes[byteIndex++] = char;
            continue;
        } else if (char < 2048) {
            bytes[byteIndex++] = char >> 6 | 192;
        } else {
            if (char > 0xd7ff && char < 0xdc00) {
                if (++i >= input.length) {
                    throw new Error("Incomplete surrogate pair.");
                }
                var c2 = input.charCodeAt(i);
                if (c2 < 0xdc00 || c2 > 0xdfff) {
                    throw new Error("Invalid surrogate character.");
                }
                char = 0x10000 + ((char & 0x03ff) << 10) + (c2 & 0x03ff);
                bytes[byteIndex++] = char >> 18 | 240;
                bytes[byteIndex++] = char >> 12 & 63 | 128;
            } else {
                bytes[byteIndex++] = char >> 12 | 224;
            }
            bytes[byteIndex++] = char >> 6 & 63 | 128;
        }
        bytes[byteIndex++] = char & 63 | 128;
    }
    return bytes.subarray(0, byteIndex);
}
exports.utf8Encode = utf8Encode;
/**
 * UTF-8 decodes the given byte sequence into a string.
 *
 * @param bytes - a byte sequence
 */ function utf8Decode(bytes) {
    var result = "";
    var i = 0;
    while(i < bytes.length){
        var c = bytes[i++];
        if (c > 127) {
            if (c > 191 && c < 224) {
                if (i >= bytes.length) {
                    throw new Error("Incomplete 2-byte sequence.");
                }
                c = (c & 31) << 6 | bytes[i++] & 63;
            } else if (c > 223 && c < 240) {
                if (i + 1 >= bytes.length) {
                    throw new Error("Incomplete 3-byte sequence.");
                }
                c = (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
            } else if (c > 239 && c < 248) {
                if (i + 2 >= bytes.length) {
                    throw new Error("Incomplete 4-byte sequence.");
                }
                c = (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
            } else {
                throw new Error("Unknown multi-byte start.");
            }
        }
        if (c <= 0xffff) {
            result += String.fromCharCode(c);
        } else if (c <= 0x10ffff) {
            c -= 0x10000;
            result += String.fromCharCode(c >> 10 | 0xd800);
            result += String.fromCharCode(c & 0x3FF | 0xdc00);
        } else {
            throw new Error("Code point exceeds UTF-16 limit.");
        }
    }
    return result;
}
exports.utf8Decode = utf8Decode; //# sourceMappingURL=index.js.map


/***/ }),

/***/ 35914:
/***/ ((module) => {


(function webpackUniversalModuleDefinition(root, factory) {
    /* istanbul ignore next */ if (true) module.exports = factory();
    else {}
})(void 0, function() {
    return /******/ function(modules) {
        /******/ // The module cache
        /******/ var installedModules = {};
        /******/ // The require function
        /******/ function __nested_webpack_require_589__(moduleId) {
            /******/ // Check if module is in cache
            /* istanbul ignore if */ /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports;
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = installedModules[moduleId] = {
                /******/ exports: {},
                /******/ id: moduleId,
                /******/ loaded: false
            };
            /******/ // Execute the module function
            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_589__);
            /******/ // Flag the module as loaded
            /******/ module1.loaded = true;
            /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ // expose the modules object (__webpack_modules__)
        /******/ __nested_webpack_require_589__.m = modules;
        /******/ // expose the module cache
        /******/ __nested_webpack_require_589__.c = installedModules;
        /******/ // __webpack_public_path__
        /******/ __nested_webpack_require_589__.p = "";
        /******/ // Load entry module and return exports
        /******/ return __nested_webpack_require_589__(0);
    /******/ }([
        /* 0 */ /***/ function(module1, exports1, __nested_webpack_require_1939__) {
            "use strict";
            /*
	  Copyright JS Foundation and other contributors, https://js.foundation/

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/ Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var comment_handler_1 = __nested_webpack_require_1939__(1);
            var jsx_parser_1 = __nested_webpack_require_1939__(3);
            var parser_1 = __nested_webpack_require_1939__(8);
            var tokenizer_1 = __nested_webpack_require_1939__(15);
            function parse(code, options, delegate) {
                var commentHandler = null;
                var proxyDelegate = function(node, metadata) {
                    if (delegate) {
                        delegate(node, metadata);
                    }
                    if (commentHandler) {
                        commentHandler.visit(node, metadata);
                    }
                };
                var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
                var collectComment = false;
                if (options) {
                    collectComment = typeof options.comment === "boolean" && options.comment;
                    var attachComment = typeof options.attachComment === "boolean" && options.attachComment;
                    if (collectComment || attachComment) {
                        commentHandler = new comment_handler_1.CommentHandler();
                        commentHandler.attach = attachComment;
                        options.comment = true;
                        parserDelegate = proxyDelegate;
                    }
                }
                var isModule = false;
                if (options && typeof options.sourceType === "string") {
                    isModule = options.sourceType === "module";
                }
                var parser;
                if (options && typeof options.jsx === "boolean" && options.jsx) {
                    parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
                } else {
                    parser = new parser_1.Parser(code, options, parserDelegate);
                }
                var program = isModule ? parser.parseModule() : parser.parseScript();
                var ast = program;
                if (collectComment && commentHandler) {
                    ast.comments = commentHandler.comments;
                }
                if (parser.config.tokens) {
                    ast.tokens = parser.tokens;
                }
                if (parser.config.tolerant) {
                    ast.errors = parser.errorHandler.errors;
                }
                return ast;
            }
            exports1.parse = parse;
            function parseModule(code, options, delegate) {
                var parsingOptions = options || {};
                parsingOptions.sourceType = "module";
                return parse(code, parsingOptions, delegate);
            }
            exports1.parseModule = parseModule;
            function parseScript(code, options, delegate) {
                var parsingOptions = options || {};
                parsingOptions.sourceType = "script";
                return parse(code, parsingOptions, delegate);
            }
            exports1.parseScript = parseScript;
            function tokenize(code, options, delegate) {
                var tokenizer = new tokenizer_1.Tokenizer(code, options);
                var tokens;
                tokens = [];
                try {
                    while(true){
                        var token = tokenizer.getNextToken();
                        if (!token) {
                            break;
                        }
                        if (delegate) {
                            token = delegate(token);
                        }
                        tokens.push(token);
                    }
                } catch (e) {
                    tokenizer.errorHandler.tolerate(e);
                }
                if (tokenizer.errorHandler.tolerant) {
                    tokens.errors = tokenizer.errors();
                }
                return tokens;
            }
            exports1.tokenize = tokenize;
            var syntax_1 = __nested_webpack_require_1939__(2);
            exports1.Syntax = syntax_1.Syntax;
            // Sync with *.json manifests.
            exports1.version = "4.0.1";
        /***/ },
        /* 1 */ /***/ function(module1, exports1, __nested_webpack_require_7627__) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var syntax_1 = __nested_webpack_require_7627__(2);
            var CommentHandler = function() {
                function CommentHandler() {
                    this.attach = false;
                    this.comments = [];
                    this.stack = [];
                    this.leading = [];
                    this.trailing = [];
                }
                CommentHandler.prototype.insertInnerComments = function(node, metadata) {
                    //  innnerComments for properties empty block
                    //  `function a() {/** comments **\/}`
                    if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
                        var innerComments = [];
                        for(var i = this.leading.length - 1; i >= 0; --i){
                            var entry = this.leading[i];
                            if (metadata.end.offset >= entry.start) {
                                innerComments.unshift(entry.comment);
                                this.leading.splice(i, 1);
                                this.trailing.splice(i, 1);
                            }
                        }
                        if (innerComments.length) {
                            node.innerComments = innerComments;
                        }
                    }
                };
                CommentHandler.prototype.findTrailingComments = function(metadata) {
                    var trailingComments = [];
                    if (this.trailing.length > 0) {
                        for(var i = this.trailing.length - 1; i >= 0; --i){
                            var entry_1 = this.trailing[i];
                            if (entry_1.start >= metadata.end.offset) {
                                trailingComments.unshift(entry_1.comment);
                            }
                        }
                        this.trailing.length = 0;
                        return trailingComments;
                    }
                    var entry = this.stack[this.stack.length - 1];
                    if (entry && entry.node.trailingComments) {
                        var firstComment = entry.node.trailingComments[0];
                        if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                            trailingComments = entry.node.trailingComments;
                            delete entry.node.trailingComments;
                        }
                    }
                    return trailingComments;
                };
                CommentHandler.prototype.findLeadingComments = function(metadata) {
                    var leadingComments = [];
                    var target;
                    while(this.stack.length > 0){
                        var entry = this.stack[this.stack.length - 1];
                        if (entry && entry.start >= metadata.start.offset) {
                            target = entry.node;
                            this.stack.pop();
                        } else {
                            break;
                        }
                    }
                    if (target) {
                        var count = target.leadingComments ? target.leadingComments.length : 0;
                        for(var i = count - 1; i >= 0; --i){
                            var comment = target.leadingComments[i];
                            if (comment.range[1] <= metadata.start.offset) {
                                leadingComments.unshift(comment);
                                target.leadingComments.splice(i, 1);
                            }
                        }
                        if (target.leadingComments && target.leadingComments.length === 0) {
                            delete target.leadingComments;
                        }
                        return leadingComments;
                    }
                    for(var i = this.leading.length - 1; i >= 0; --i){
                        var entry = this.leading[i];
                        if (entry.start <= metadata.start.offset) {
                            leadingComments.unshift(entry.comment);
                            this.leading.splice(i, 1);
                        }
                    }
                    return leadingComments;
                };
                CommentHandler.prototype.visitNode = function(node, metadata) {
                    if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
                        return;
                    }
                    this.insertInnerComments(node, metadata);
                    var trailingComments = this.findTrailingComments(metadata);
                    var leadingComments = this.findLeadingComments(metadata);
                    if (leadingComments.length > 0) {
                        node.leadingComments = leadingComments;
                    }
                    if (trailingComments.length > 0) {
                        node.trailingComments = trailingComments;
                    }
                    this.stack.push({
                        node: node,
                        start: metadata.start.offset
                    });
                };
                CommentHandler.prototype.visitComment = function(node, metadata) {
                    var type = node.type[0] === "L" ? "Line" : "Block";
                    var comment = {
                        type: type,
                        value: node.value
                    };
                    if (node.range) {
                        comment.range = node.range;
                    }
                    if (node.loc) {
                        comment.loc = node.loc;
                    }
                    this.comments.push(comment);
                    if (this.attach) {
                        var entry = {
                            comment: {
                                type: type,
                                value: node.value,
                                range: [
                                    metadata.start.offset,
                                    metadata.end.offset
                                ]
                            },
                            start: metadata.start.offset
                        };
                        if (node.loc) {
                            entry.comment.loc = node.loc;
                        }
                        node.type = type;
                        this.leading.push(entry);
                        this.trailing.push(entry);
                    }
                };
                CommentHandler.prototype.visit = function(node, metadata) {
                    if (node.type === "LineComment") {
                        this.visitComment(node, metadata);
                    } else if (node.type === "BlockComment") {
                        this.visitComment(node, metadata);
                    } else if (this.attach) {
                        this.visitNode(node, metadata);
                    }
                };
                return CommentHandler;
            }();
            exports1.CommentHandler = CommentHandler;
        /***/ },
        /* 2 */ /***/ function(module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            exports1.Syntax = {
                AssignmentExpression: "AssignmentExpression",
                AssignmentPattern: "AssignmentPattern",
                ArrayExpression: "ArrayExpression",
                ArrayPattern: "ArrayPattern",
                ArrowFunctionExpression: "ArrowFunctionExpression",
                AwaitExpression: "AwaitExpression",
                BlockStatement: "BlockStatement",
                BinaryExpression: "BinaryExpression",
                BreakStatement: "BreakStatement",
                CallExpression: "CallExpression",
                CatchClause: "CatchClause",
                ClassBody: "ClassBody",
                ClassDeclaration: "ClassDeclaration",
                ClassExpression: "ClassExpression",
                ConditionalExpression: "ConditionalExpression",
                ContinueStatement: "ContinueStatement",
                DoWhileStatement: "DoWhileStatement",
                DebuggerStatement: "DebuggerStatement",
                EmptyStatement: "EmptyStatement",
                ExportAllDeclaration: "ExportAllDeclaration",
                ExportDefaultDeclaration: "ExportDefaultDeclaration",
                ExportNamedDeclaration: "ExportNamedDeclaration",
                ExportSpecifier: "ExportSpecifier",
                ExpressionStatement: "ExpressionStatement",
                ForStatement: "ForStatement",
                ForOfStatement: "ForOfStatement",
                ForInStatement: "ForInStatement",
                FunctionDeclaration: "FunctionDeclaration",
                FunctionExpression: "FunctionExpression",
                Identifier: "Identifier",
                IfStatement: "IfStatement",
                ImportDeclaration: "ImportDeclaration",
                ImportDefaultSpecifier: "ImportDefaultSpecifier",
                ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
                ImportSpecifier: "ImportSpecifier",
                Literal: "Literal",
                LabeledStatement: "LabeledStatement",
                LogicalExpression: "LogicalExpression",
                MemberExpression: "MemberExpression",
                MetaProperty: "MetaProperty",
                MethodDefinition: "MethodDefinition",
                NewExpression: "NewExpression",
                ObjectExpression: "ObjectExpression",
                ObjectPattern: "ObjectPattern",
                Program: "Program",
                Property: "Property",
                RestElement: "RestElement",
                ReturnStatement: "ReturnStatement",
                SequenceExpression: "SequenceExpression",
                SpreadElement: "SpreadElement",
                Super: "Super",
                SwitchCase: "SwitchCase",
                SwitchStatement: "SwitchStatement",
                TaggedTemplateExpression: "TaggedTemplateExpression",
                TemplateElement: "TemplateElement",
                TemplateLiteral: "TemplateLiteral",
                ThisExpression: "ThisExpression",
                ThrowStatement: "ThrowStatement",
                TryStatement: "TryStatement",
                UnaryExpression: "UnaryExpression",
                UpdateExpression: "UpdateExpression",
                VariableDeclaration: "VariableDeclaration",
                VariableDeclarator: "VariableDeclarator",
                WhileStatement: "WhileStatement",
                WithStatement: "WithStatement",
                YieldExpression: "YieldExpression"
            };
        /***/ },
        /* 3 */ /***/ function(module1, exports1, __nested_webpack_require_18710__) {
            "use strict";
            /* istanbul ignore next */ var __extends = this && this.__extends || function() {
                var extendStatics = Object.setPrototypeOf || ({
                    __proto__: []
                }) instanceof Array && function(d, b) {
                    d.__proto__ = b;
                } || function(d, b) {
                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
                };
                return function(d, b) {
                    extendStatics(d, b);
                    function __() {
                        this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            }();
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var character_1 = __nested_webpack_require_18710__(4);
            var JSXNode = __nested_webpack_require_18710__(5);
            var jsx_syntax_1 = __nested_webpack_require_18710__(6);
            var Node = __nested_webpack_require_18710__(7);
            var parser_1 = __nested_webpack_require_18710__(8);
            var token_1 = __nested_webpack_require_18710__(13);
            var xhtml_entities_1 = __nested_webpack_require_18710__(14);
            token_1.TokenName[100 /* Identifier */ ] = "JSXIdentifier";
            token_1.TokenName[101 /* Text */ ] = "JSXText";
            // Fully qualified element name, e.g. <svg:path> returns "svg:path"
            function getQualifiedElementName(elementName) {
                var qualifiedName;
                switch(elementName.type){
                    case jsx_syntax_1.JSXSyntax.JSXIdentifier:
                        var id = elementName;
                        qualifiedName = id.name;
                        break;
                    case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
                        var ns = elementName;
                        qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
                        break;
                    case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
                        var expr = elementName;
                        qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
                        break;
                    /* istanbul ignore next */ default:
                        break;
                }
                return qualifiedName;
            }
            var JSXParser = function(_super) {
                __extends(JSXParser, _super);
                function JSXParser(code, options, delegate) {
                    return _super.call(this, code, options, delegate) || this;
                }
                JSXParser.prototype.parsePrimaryExpression = function() {
                    return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
                };
                JSXParser.prototype.startJSX = function() {
                    // Unwind the scanner before the lookahead token.
                    this.scanner.index = this.startMarker.index;
                    this.scanner.lineNumber = this.startMarker.line;
                    this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
                };
                JSXParser.prototype.finishJSX = function() {
                    // Prime the next lookahead.
                    this.nextToken();
                };
                JSXParser.prototype.reenterJSX = function() {
                    this.startJSX();
                    this.expectJSX("}");
                    // Pop the closing '}' added from the lookahead.
                    if (this.config.tokens) {
                        this.tokens.pop();
                    }
                };
                JSXParser.prototype.createJSXNode = function() {
                    this.collectComments();
                    return {
                        index: this.scanner.index,
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                    };
                };
                JSXParser.prototype.createJSXChildNode = function() {
                    return {
                        index: this.scanner.index,
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                    };
                };
                JSXParser.prototype.scanXHTMLEntity = function(quote) {
                    var result = "&";
                    var valid = true;
                    var terminated = false;
                    var numeric = false;
                    var hex = false;
                    while(!this.scanner.eof() && valid && !terminated){
                        var ch = this.scanner.source[this.scanner.index];
                        if (ch === quote) {
                            break;
                        }
                        terminated = ch === ";";
                        result += ch;
                        ++this.scanner.index;
                        if (!terminated) {
                            switch(result.length){
                                case 2:
                                    // e.g. '&#123;'
                                    numeric = ch === "#";
                                    break;
                                case 3:
                                    if (numeric) {
                                        // e.g. '&#x41;'
                                        hex = ch === "x";
                                        valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                                        numeric = numeric && !hex;
                                    }
                                    break;
                                default:
                                    valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                                    valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                                    break;
                            }
                        }
                    }
                    if (valid && terminated && result.length > 2) {
                        // e.g. '&#x41;' becomes just '#x41'
                        var str = result.substr(1, result.length - 2);
                        if (numeric && str.length > 1) {
                            result = String.fromCharCode(parseInt(str.substr(1), 10));
                        } else if (hex && str.length > 2) {
                            result = String.fromCharCode(parseInt("0" + str.substr(1), 16));
                        } else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
                            result = xhtml_entities_1.XHTMLEntities[str];
                        }
                    }
                    return result;
                };
                // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
                JSXParser.prototype.lexJSX = function() {
                    var cp = this.scanner.source.charCodeAt(this.scanner.index);
                    // < > / : = { }
                    if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
                        var value = this.scanner.source[this.scanner.index++];
                        return {
                            type: 7 /* Punctuator */ ,
                            value: value,
                            lineNumber: this.scanner.lineNumber,
                            lineStart: this.scanner.lineStart,
                            start: this.scanner.index - 1,
                            end: this.scanner.index
                        };
                    }
                    // " '
                    if (cp === 34 || cp === 39) {
                        var start = this.scanner.index;
                        var quote = this.scanner.source[this.scanner.index++];
                        var str = "";
                        while(!this.scanner.eof()){
                            var ch = this.scanner.source[this.scanner.index++];
                            if (ch === quote) {
                                break;
                            } else if (ch === "&") {
                                str += this.scanXHTMLEntity(quote);
                            } else {
                                str += ch;
                            }
                        }
                        return {
                            type: 8 /* StringLiteral */ ,
                            value: str,
                            lineNumber: this.scanner.lineNumber,
                            lineStart: this.scanner.lineStart,
                            start: start,
                            end: this.scanner.index
                        };
                    }
                    // ... or .
                    if (cp === 46) {
                        var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
                        var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
                        var value = n1 === 46 && n2 === 46 ? "..." : ".";
                        var start = this.scanner.index;
                        this.scanner.index += value.length;
                        return {
                            type: 7 /* Punctuator */ ,
                            value: value,
                            lineNumber: this.scanner.lineNumber,
                            lineStart: this.scanner.lineStart,
                            start: start,
                            end: this.scanner.index
                        };
                    }
                    // `
                    if (cp === 96) {
                        // Only placeholder, since it will be rescanned as a real assignment expression.
                        return {
                            type: 10 /* Template */ ,
                            value: "",
                            lineNumber: this.scanner.lineNumber,
                            lineStart: this.scanner.lineStart,
                            start: this.scanner.index,
                            end: this.scanner.index
                        };
                    }
                    // Identifer can not contain backslash (char code 92).
                    if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
                        var start = this.scanner.index;
                        ++this.scanner.index;
                        while(!this.scanner.eof()){
                            var ch = this.scanner.source.charCodeAt(this.scanner.index);
                            if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
                                ++this.scanner.index;
                            } else if (ch === 45) {
                                // Hyphen (char code 45) can be part of an identifier.
                                ++this.scanner.index;
                            } else {
                                break;
                            }
                        }
                        var id = this.scanner.source.slice(start, this.scanner.index);
                        return {
                            type: 100 /* Identifier */ ,
                            value: id,
                            lineNumber: this.scanner.lineNumber,
                            lineStart: this.scanner.lineStart,
                            start: start,
                            end: this.scanner.index
                        };
                    }
                    return this.scanner.lex();
                };
                JSXParser.prototype.nextJSXToken = function() {
                    this.collectComments();
                    this.startMarker.index = this.scanner.index;
                    this.startMarker.line = this.scanner.lineNumber;
                    this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                    var token = this.lexJSX();
                    this.lastMarker.index = this.scanner.index;
                    this.lastMarker.line = this.scanner.lineNumber;
                    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                    if (this.config.tokens) {
                        this.tokens.push(this.convertToken(token));
                    }
                    return token;
                };
                JSXParser.prototype.nextJSXText = function() {
                    this.startMarker.index = this.scanner.index;
                    this.startMarker.line = this.scanner.lineNumber;
                    this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                    var start = this.scanner.index;
                    var text = "";
                    while(!this.scanner.eof()){
                        var ch = this.scanner.source[this.scanner.index];
                        if (ch === "{" || ch === "<") {
                            break;
                        }
                        ++this.scanner.index;
                        text += ch;
                        if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                            ++this.scanner.lineNumber;
                            if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") {
                                ++this.scanner.index;
                            }
                            this.scanner.lineStart = this.scanner.index;
                        }
                    }
                    this.lastMarker.index = this.scanner.index;
                    this.lastMarker.line = this.scanner.lineNumber;
                    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                    var token = {
                        type: 101 /* Text */ ,
                        value: text,
                        lineNumber: this.scanner.lineNumber,
                        lineStart: this.scanner.lineStart,
                        start: start,
                        end: this.scanner.index
                    };
                    if (text.length > 0 && this.config.tokens) {
                        this.tokens.push(this.convertToken(token));
                    }
                    return token;
                };
                JSXParser.prototype.peekJSXToken = function() {
                    var state = this.scanner.saveState();
                    this.scanner.scanComments();
                    var next = this.lexJSX();
                    this.scanner.restoreState(state);
                    return next;
                };
                // Expect the next JSX token to match the specified punctuator.
                // If not, an exception will be thrown.
                JSXParser.prototype.expectJSX = function(value) {
                    var token = this.nextJSXToken();
                    if (token.type !== 7 /* Punctuator */  || token.value !== value) {
                        this.throwUnexpectedToken(token);
                    }
                };
                // Return true if the next JSX token matches the specified punctuator.
                JSXParser.prototype.matchJSX = function(value) {
                    var next = this.peekJSXToken();
                    return next.type === 7 /* Punctuator */  && next.value === value;
                };
                JSXParser.prototype.parseJSXIdentifier = function() {
                    var node = this.createJSXNode();
                    var token = this.nextJSXToken();
                    if (token.type !== 100 /* Identifier */ ) {
                        this.throwUnexpectedToken(token);
                    }
                    return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
                };
                JSXParser.prototype.parseJSXElementName = function() {
                    var node = this.createJSXNode();
                    var elementName = this.parseJSXIdentifier();
                    if (this.matchJSX(":")) {
                        var namespace = elementName;
                        this.expectJSX(":");
                        var name_1 = this.parseJSXIdentifier();
                        elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
                    } else if (this.matchJSX(".")) {
                        while(this.matchJSX(".")){
                            var object = elementName;
                            this.expectJSX(".");
                            var property = this.parseJSXIdentifier();
                            elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
                        }
                    }
                    return elementName;
                };
                JSXParser.prototype.parseJSXAttributeName = function() {
                    var node = this.createJSXNode();
                    var attributeName;
                    var identifier = this.parseJSXIdentifier();
                    if (this.matchJSX(":")) {
                        var namespace = identifier;
                        this.expectJSX(":");
                        var name_2 = this.parseJSXIdentifier();
                        attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
                    } else {
                        attributeName = identifier;
                    }
                    return attributeName;
                };
                JSXParser.prototype.parseJSXStringLiteralAttribute = function() {
                    var node = this.createJSXNode();
                    var token = this.nextJSXToken();
                    if (token.type !== 8 /* StringLiteral */ ) {
                        this.throwUnexpectedToken(token);
                    }
                    var raw = this.getTokenRaw(token);
                    return this.finalize(node, new Node.Literal(token.value, raw));
                };
                JSXParser.prototype.parseJSXExpressionAttribute = function() {
                    var node = this.createJSXNode();
                    this.expectJSX("{");
                    this.finishJSX();
                    if (this.match("}")) {
                        this.tolerateError("JSX attributes must only be assigned a non-empty expression");
                    }
                    var expression = this.parseAssignmentExpression();
                    this.reenterJSX();
                    return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
                };
                JSXParser.prototype.parseJSXAttributeValue = function() {
                    return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
                };
                JSXParser.prototype.parseJSXNameValueAttribute = function() {
                    var node = this.createJSXNode();
                    var name = this.parseJSXAttributeName();
                    var value = null;
                    if (this.matchJSX("=")) {
                        this.expectJSX("=");
                        value = this.parseJSXAttributeValue();
                    }
                    return this.finalize(node, new JSXNode.JSXAttribute(name, value));
                };
                JSXParser.prototype.parseJSXSpreadAttribute = function() {
                    var node = this.createJSXNode();
                    this.expectJSX("{");
                    this.expectJSX("...");
                    this.finishJSX();
                    var argument = this.parseAssignmentExpression();
                    this.reenterJSX();
                    return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
                };
                JSXParser.prototype.parseJSXAttributes = function() {
                    var attributes = [];
                    while(!this.matchJSX("/") && !this.matchJSX(">")){
                        var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                        attributes.push(attribute);
                    }
                    return attributes;
                };
                JSXParser.prototype.parseJSXOpeningElement = function() {
                    var node = this.createJSXNode();
                    this.expectJSX("<");
                    var name = this.parseJSXElementName();
                    var attributes = this.parseJSXAttributes();
                    var selfClosing = this.matchJSX("/");
                    if (selfClosing) {
                        this.expectJSX("/");
                    }
                    this.expectJSX(">");
                    return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
                };
                JSXParser.prototype.parseJSXBoundaryElement = function() {
                    var node = this.createJSXNode();
                    this.expectJSX("<");
                    if (this.matchJSX("/")) {
                        this.expectJSX("/");
                        var name_3 = this.parseJSXElementName();
                        this.expectJSX(">");
                        return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
                    }
                    var name = this.parseJSXElementName();
                    var attributes = this.parseJSXAttributes();
                    var selfClosing = this.matchJSX("/");
                    if (selfClosing) {
                        this.expectJSX("/");
                    }
                    this.expectJSX(">");
                    return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
                };
                JSXParser.prototype.parseJSXEmptyExpression = function() {
                    var node = this.createJSXChildNode();
                    this.collectComments();
                    this.lastMarker.index = this.scanner.index;
                    this.lastMarker.line = this.scanner.lineNumber;
                    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                    return this.finalize(node, new JSXNode.JSXEmptyExpression());
                };
                JSXParser.prototype.parseJSXExpressionContainer = function() {
                    var node = this.createJSXNode();
                    this.expectJSX("{");
                    var expression;
                    if (this.matchJSX("}")) {
                        expression = this.parseJSXEmptyExpression();
                        this.expectJSX("}");
                    } else {
                        this.finishJSX();
                        expression = this.parseAssignmentExpression();
                        this.reenterJSX();
                    }
                    return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
                };
                JSXParser.prototype.parseJSXChildren = function() {
                    var children = [];
                    while(!this.scanner.eof()){
                        var node = this.createJSXChildNode();
                        var token = this.nextJSXText();
                        if (token.start < token.end) {
                            var raw = this.getTokenRaw(token);
                            var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
                            children.push(child);
                        }
                        if (this.scanner.source[this.scanner.index] === "{") {
                            var container = this.parseJSXExpressionContainer();
                            children.push(container);
                        } else {
                            break;
                        }
                    }
                    return children;
                };
                JSXParser.prototype.parseComplexJSXElement = function(el) {
                    var stack = [];
                    while(!this.scanner.eof()){
                        el.children = el.children.concat(this.parseJSXChildren());
                        var node = this.createJSXChildNode();
                        var element = this.parseJSXBoundaryElement();
                        if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                            var opening = element;
                            if (opening.selfClosing) {
                                var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
                                el.children.push(child);
                            } else {
                                stack.push(el);
                                el = {
                                    node: node,
                                    opening: opening,
                                    closing: null,
                                    children: []
                                };
                            }
                        }
                        if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                            el.closing = element;
                            var open_1 = getQualifiedElementName(el.opening.name);
                            var close_1 = getQualifiedElementName(el.closing.name);
                            if (open_1 !== close_1) {
                                this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
                            }
                            if (stack.length > 0) {
                                var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                                el = stack[stack.length - 1];
                                el.children.push(child);
                                stack.pop();
                            } else {
                                break;
                            }
                        }
                    }
                    return el;
                };
                JSXParser.prototype.parseJSXElement = function() {
                    var node = this.createJSXNode();
                    var opening = this.parseJSXOpeningElement();
                    var children = [];
                    var closing = null;
                    if (!opening.selfClosing) {
                        var el = this.parseComplexJSXElement({
                            node: node,
                            opening: opening,
                            closing: closing,
                            children: children
                        });
                        children = el.children;
                        closing = el.closing;
                    }
                    return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
                };
                JSXParser.prototype.parseJSXRoot = function() {
                    // Pop the opening '<' added from the lookahead.
                    if (this.config.tokens) {
                        this.tokens.pop();
                    }
                    this.startJSX();
                    var element = this.parseJSXElement();
                    this.finishJSX();
                    return element;
                };
                JSXParser.prototype.isStartOfExpression = function() {
                    return _super.prototype.isStartOfExpression.call(this) || this.match("<");
                };
                return JSXParser;
            }(parser_1.Parser);
            exports1.JSXParser = JSXParser;
        /***/ },
        /* 4 */ /***/ function(module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            // See also tools/generate-unicode-regex.js.
            var Regex = {
                // Unicode v8.0.0 NonAsciiIdentifierStart:
                NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
                // Unicode v8.0.0 NonAsciiIdentifierPart:
                NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
            };
            exports1.Character = {
                /* tslint:disable:no-bitwise */ fromCodePoint: function(cp) {
                    return cp < 0x10000 ? String.fromCharCode(cp) : String.fromCharCode(0xD800 + (cp - 0x10000 >> 10)) + String.fromCharCode(0xDC00 + (cp - 0x10000 & 1023));
                },
                // https://tc39.github.io/ecma262/#sec-white-space
                isWhiteSpace: function(cp) {
                    return cp === 0x20 || cp === 0x09 || cp === 0x0B || cp === 0x0C || cp === 0xA0 || cp >= 0x1680 && [
                        0x1680,
                        0x2000,
                        0x2001,
                        0x2002,
                        0x2003,
                        0x2004,
                        0x2005,
                        0x2006,
                        0x2007,
                        0x2008,
                        0x2009,
                        0x200A,
                        0x202F,
                        0x205F,
                        0x3000,
                        0xFEFF
                    ].indexOf(cp) >= 0;
                },
                // https://tc39.github.io/ecma262/#sec-line-terminators
                isLineTerminator: function(cp) {
                    return cp === 0x0A || cp === 0x0D || cp === 0x2028 || cp === 0x2029;
                },
                // https://tc39.github.io/ecma262/#sec-names-and-keywords
                isIdentifierStart: function(cp) {
                    return cp === 0x24 || cp === 0x5F || cp >= 0x41 && cp <= 0x5A || cp >= 0x61 && cp <= 0x7A || cp === 0x5C || cp >= 0x80 && Regex.NonAsciiIdentifierStart.test(exports1.Character.fromCodePoint(cp));
                },
                isIdentifierPart: function(cp) {
                    return cp === 0x24 || cp === 0x5F || cp >= 0x41 && cp <= 0x5A || cp >= 0x61 && cp <= 0x7A || cp >= 0x30 && cp <= 0x39 || cp === 0x5C || cp >= 0x80 && Regex.NonAsciiIdentifierPart.test(exports1.Character.fromCodePoint(cp));
                },
                // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
                isDecimalDigit: function(cp) {
                    return cp >= 0x30 && cp <= 0x39; // 0..9
                },
                isHexDigit: function(cp) {
                    return cp >= 0x30 && cp <= 0x39 || cp >= 0x41 && cp <= 0x46 || cp >= 0x61 && cp <= 0x66; // a..f
                },
                isOctalDigit: function(cp) {
                    return cp >= 0x30 && cp <= 0x37; // 0..7
                }
            };
        /***/ },
        /* 5 */ /***/ function(module1, exports1, __nested_webpack_require_64544__) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var jsx_syntax_1 = __nested_webpack_require_64544__(6);
            /* tslint:disable:max-classes-per-file */ var JSXClosingElement = function() {
                function JSXClosingElement(name) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
                    this.name = name;
                }
                return JSXClosingElement;
            }();
            exports1.JSXClosingElement = JSXClosingElement;
            var JSXElement = function() {
                function JSXElement(openingElement, children, closingElement) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXElement;
                    this.openingElement = openingElement;
                    this.children = children;
                    this.closingElement = closingElement;
                }
                return JSXElement;
            }();
            exports1.JSXElement = JSXElement;
            var JSXEmptyExpression = function() {
                function JSXEmptyExpression() {
                    this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
                }
                return JSXEmptyExpression;
            }();
            exports1.JSXEmptyExpression = JSXEmptyExpression;
            var JSXExpressionContainer = function() {
                function JSXExpressionContainer(expression) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
                    this.expression = expression;
                }
                return JSXExpressionContainer;
            }();
            exports1.JSXExpressionContainer = JSXExpressionContainer;
            var JSXIdentifier = function() {
                function JSXIdentifier(name) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
                    this.name = name;
                }
                return JSXIdentifier;
            }();
            exports1.JSXIdentifier = JSXIdentifier;
            var JSXMemberExpression = function() {
                function JSXMemberExpression(object, property) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
                    this.object = object;
                    this.property = property;
                }
                return JSXMemberExpression;
            }();
            exports1.JSXMemberExpression = JSXMemberExpression;
            var JSXAttribute = function() {
                function JSXAttribute(name, value) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
                    this.name = name;
                    this.value = value;
                }
                return JSXAttribute;
            }();
            exports1.JSXAttribute = JSXAttribute;
            var JSXNamespacedName = function() {
                function JSXNamespacedName(namespace, name) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
                    this.namespace = namespace;
                    this.name = name;
                }
                return JSXNamespacedName;
            }();
            exports1.JSXNamespacedName = JSXNamespacedName;
            var JSXOpeningElement = function() {
                function JSXOpeningElement(name, selfClosing, attributes) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
                    this.name = name;
                    this.selfClosing = selfClosing;
                    this.attributes = attributes;
                }
                return JSXOpeningElement;
            }();
            exports1.JSXOpeningElement = JSXOpeningElement;
            var JSXSpreadAttribute = function() {
                function JSXSpreadAttribute(argument) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
                    this.argument = argument;
                }
                return JSXSpreadAttribute;
            }();
            exports1.JSXSpreadAttribute = JSXSpreadAttribute;
            var JSXText = function() {
                function JSXText(value, raw) {
                    this.type = jsx_syntax_1.JSXSyntax.JSXText;
                    this.value = value;
                    this.raw = raw;
                }
                return JSXText;
            }();
            exports1.JSXText = JSXText;
        /***/ },
        /* 6 */ /***/ function(module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            exports1.JSXSyntax = {
                JSXAttribute: "JSXAttribute",
                JSXClosingElement: "JSXClosingElement",
                JSXElement: "JSXElement",
                JSXEmptyExpression: "JSXEmptyExpression",
                JSXExpressionContainer: "JSXExpressionContainer",
                JSXIdentifier: "JSXIdentifier",
                JSXMemberExpression: "JSXMemberExpression",
                JSXNamespacedName: "JSXNamespacedName",
                JSXOpeningElement: "JSXOpeningElement",
                JSXSpreadAttribute: "JSXSpreadAttribute",
                JSXText: "JSXText"
            };
        /***/ },
        /* 7 */ /***/ function(module1, exports1, __nested_webpack_require_69915__) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var syntax_1 = __nested_webpack_require_69915__(2);
            /* tslint:disable:max-classes-per-file */ var ArrayExpression = function() {
                function ArrayExpression(elements) {
                    this.type = syntax_1.Syntax.ArrayExpression;
                    this.elements = elements;
                }
                return ArrayExpression;
            }();
            exports1.ArrayExpression = ArrayExpression;
            var ArrayPattern = function() {
                function ArrayPattern(elements) {
                    this.type = syntax_1.Syntax.ArrayPattern;
                    this.elements = elements;
                }
                return ArrayPattern;
            }();
            exports1.ArrayPattern = ArrayPattern;
            var ArrowFunctionExpression = function() {
                function ArrowFunctionExpression(params, body, expression) {
                    this.type = syntax_1.Syntax.ArrowFunctionExpression;
                    this.id = null;
                    this.params = params;
                    this.body = body;
                    this.generator = false;
                    this.expression = expression;
                    this.async = false;
                }
                return ArrowFunctionExpression;
            }();
            exports1.ArrowFunctionExpression = ArrowFunctionExpression;
            var AssignmentExpression = function() {
                function AssignmentExpression(operator, left, right) {
                    this.type = syntax_1.Syntax.AssignmentExpression;
                    this.operator = operator;
                    this.left = left;
                    this.right = right;
                }
                return AssignmentExpression;
            }();
            exports1.AssignmentExpression = AssignmentExpression;
            var AssignmentPattern = function() {
                function AssignmentPattern(left, right) {
                    this.type = syntax_1.Syntax.AssignmentPattern;
                    this.left = left;
                    this.right = right;
                }
                return AssignmentPattern;
            }();
            exports1.AssignmentPattern = AssignmentPattern;
            var AsyncArrowFunctionExpression = function() {
                function AsyncArrowFunctionExpression(params, body, expression) {
                    this.type = syntax_1.Syntax.ArrowFunctionExpression;
                    this.id = null;
                    this.params = params;
                    this.body = body;
                    this.generator = false;
                    this.expression = expression;
                    this.async = true;
                }
                return AsyncArrowFunctionExpression;
            }();
            exports1.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
            var AsyncFunctionDeclaration = function() {
                function AsyncFunctionDeclaration(id, params, body) {
                    this.type = syntax_1.Syntax.FunctionDeclaration;
                    this.id = id;
                    this.params = params;
                    this.body = body;
                    this.generator = false;
                    this.expression = false;
                    this.async = true;
                }
                return AsyncFunctionDeclaration;
            }();
            exports1.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
            var AsyncFunctionExpression = function() {
                function AsyncFunctionExpression(id, params, body) {
                    this.type = syntax_1.Syntax.FunctionExpression;
                    this.id = id;
                    this.params = params;
                    this.body = body;
                    this.generator = false;
                    this.expression = false;
                    this.async = true;
                }
                return AsyncFunctionExpression;
            }();
            exports1.AsyncFunctionExpression = AsyncFunctionExpression;
            var AwaitExpression = function() {
                function AwaitExpression(argument) {
                    this.type = syntax_1.Syntax.AwaitExpression;
                    this.argument = argument;
                }
                return AwaitExpression;
            }();
            exports1.AwaitExpression = AwaitExpression;
            var BinaryExpression = function() {
                function BinaryExpression(operator, left, right) {
                    var logical = operator === "||" || operator === "&&";
                    this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
                    this.operator = operator;
                    this.left = left;
                    this.right = right;
                }
                return BinaryExpression;
            }();
            exports1.BinaryExpression = BinaryExpression;
            var BlockStatement = function() {
                function BlockStatement(body) {
                    this.type = syntax_1.Syntax.BlockStatement;
                    this.body = body;
                }
                return BlockStatement;
            }();
            exports1.BlockStatement = BlockStatement;
            var BreakStatement = function() {
                function BreakStatement(label) {
                    this.type = syntax_1.Syntax.BreakStatement;
                    this.label = label;
                }
                return BreakStatement;
            }();
            exports1.BreakStatement = BreakStatement;
            var CallExpression = function() {
                function CallExpression(callee, args) {
                    this.type = syntax_1.Syntax.CallExpression;
                    this.callee = callee;
                    this.arguments = args;
                }
                return CallExpression;
            }();
            exports1.CallExpression = CallExpression;
            var CatchClause = function() {
                function CatchClause(param, body) {
                    this.type = syntax_1.Syntax.CatchClause;
                    this.param = param;
                    this.body = body;
                }
                return CatchClause;
            }();
            exports1.CatchClause = CatchClause;
            var ClassBody = function() {
                function ClassBody(body) {
                    this.type = syntax_1.Syntax.ClassBody;
                    this.body = body;
                }
                return ClassBody;
            }();
            exports1.ClassBody = ClassBody;
            var ClassDeclaration = function() {
                function ClassDeclaration(id, superClass, body) {
                    this.type = syntax_1.Syntax.ClassDeclaration;
                    this.id = id;
                    this.superClass = superClass;
                    this.body = body;
                }
                return ClassDeclaration;
            }();
            exports1.ClassDeclaration = ClassDeclaration;
            var ClassExpression = function() {
                function ClassExpression(id, superClass, body) {
                    this.type = syntax_1.Syntax.ClassExpression;
                    this.id = id;
                    this.superClass = superClass;
                    this.body = body;
                }
                return ClassExpression;
            }();
            exports1.ClassExpression = ClassExpression;
            var ComputedMemberExpression = function() {
                function ComputedMemberExpression(object, property) {
                    this.type = syntax_1.Syntax.MemberExpression;
                    this.computed = true;
                    this.object = object;
                    this.property = property;
                }
                return ComputedMemberExpression;
            }();
            exports1.ComputedMemberExpression = ComputedMemberExpression;
            var ConditionalExpression = function() {
                function ConditionalExpression(test, consequent, alternate) {
                    this.type = syntax_1.Syntax.ConditionalExpression;
                    this.test = test;
                    this.consequent = consequent;
                    this.alternate = alternate;
                }
                return ConditionalExpression;
            }();
            exports1.ConditionalExpression = ConditionalExpression;
            var ContinueStatement = function() {
                function ContinueStatement(label) {
                    this.type = syntax_1.Syntax.ContinueStatement;
                    this.label = label;
                }
                return ContinueStatement;
            }();
            exports1.ContinueStatement = ContinueStatement;
            var DebuggerStatement = function() {
                function DebuggerStatement() {
                    this.type = syntax_1.Syntax.DebuggerStatement;
                }
                return DebuggerStatement;
            }();
            exports1.DebuggerStatement = DebuggerStatement;
            var Directive = function() {
                function Directive(expression, directive) {
                    this.type = syntax_1.Syntax.ExpressionStatement;
                    this.expression = expression;
                    this.directive = directive;
                }
                return Directive;
            }();
            exports1.Directive = Directive;
            var DoWhileStatement = function() {
                function DoWhileStatement(body, test) {
                    this.type = syntax_1.Syntax.DoWhileStatement;
                    this.body = body;
                    this.test = test;
                }
                return DoWhileStatement;
            }();
            exports1.DoWhileStatement = DoWhileStatement;
            var EmptyStatement = function() {
                function EmptyStatement() {
                    this.type = syntax_1.Syntax.EmptyStatement;
                }
                return EmptyStatement;
            }();
            exports1.EmptyStatement = EmptyStatement;
            var ExportAllDeclaration = function() {
                function ExportAllDeclaration(source) {
                    this.type = syntax_1.Syntax.ExportAllDeclaration;
                    this.source = source;
                }
                return ExportAllDeclaration;
            }();
            exports1.ExportAllDeclaration = ExportAllDeclaration;
            var ExportDefaultDeclaration = function() {
                function ExportDefaultDeclaration(declaration) {
                    this.type = syntax_1.Syntax.ExportDefaultDeclaration;
                    this.declaration = declaration;
                }
                return ExportDefaultDeclaration;
            }();
            exports1.ExportDefaultDeclaration = ExportDefaultDeclaration;
            var ExportNamedDeclaration = function() {
                function ExportNamedDeclaration(declaration, specifiers, source) {
                    this.type = syntax_1.Syntax.ExportNamedDeclaration;
                    this.declaration = declaration;
                    this.specifiers = specifiers;
                    this.source = source;
                }
                return ExportNamedDeclaration;
            }();
            exports1.ExportNamedDeclaration = ExportNamedDeclaration;
            var ExportSpecifier = function() {
                function ExportSpecifier(local, exported) {
                    this.type = syntax_1.Syntax.ExportSpecifier;
                    this.exported = exported;
                    this.local = local;
                }
                return ExportSpecifier;
            }();
            exports1.ExportSpecifier = ExportSpecifier;
            var ExpressionStatement = function() {
                function ExpressionStatement(expression) {
                    this.type = syntax_1.Syntax.ExpressionStatement;
                    this.expression = expression;
                }
                return ExpressionStatement;
            }();
            exports1.ExpressionStatement = ExpressionStatement;
            var ForInStatement = function() {
                function ForInStatement(left, right, body) {
                    this.type = syntax_1.Syntax.ForInStatement;
                    this.left = left;
                    this.right = right;
                    this.body = body;
                    this.each = false;
                }
                return ForInStatement;
            }();
            exports1.ForInStatement = ForInStatement;
            var ForOfStatement = function() {
                function ForOfStatement(left, right, body) {
                    this.type = syntax_1.Syntax.ForOfStatement;
                    this.left = left;
                    this.right = right;
                    this.body = body;
                }
                return ForOfStatement;
            }();
            exports1.ForOfStatement = ForOfStatement;
            var ForStatement = function() {
                function ForStatement(init, test, update, body) {
                    this.type = syntax_1.Syntax.ForStatement;
                    this.init = init;
                    this.test = test;
                    this.update = update;
                    this.body = body;
                }
                return ForStatement;
            }();
            exports1.ForStatement = ForStatement;
            var FunctionDeclaration = function() {
                function FunctionDeclaration(id, params, body, generator) {
                    this.type = syntax_1.Syntax.FunctionDeclaration;
                    this.id = id;
                    this.params = params;
                    this.body = body;
                    this.generator = generator;
                    this.expression = false;
                    this.async = false;
                }
                return FunctionDeclaration;
            }();
            exports1.FunctionDeclaration = FunctionDeclaration;
            var FunctionExpression = function() {
                function FunctionExpression(id, params, body, generator) {
                    this.type = syntax_1.Syntax.FunctionExpression;
                    this.id = id;
                    this.params = params;
                    this.body = body;
                    this.generator = generator;
                    this.expression = false;
                    this.async = false;
                }
                return FunctionExpression;
            }();
            exports1.FunctionExpression = FunctionExpression;
            var Identifier = function() {
                function Identifier(name) {
                    this.type = syntax_1.Syntax.Identifier;
                    this.name = name;
                }
                return Identifier;
            }();
            exports1.Identifier = Identifier;
            var IfStatement = function() {
                function IfStatement(test, consequent, alternate) {
                    this.type = syntax_1.Syntax.IfStatement;
                    this.test = test;
                    this.consequent = consequent;
                    this.alternate = alternate;
                }
                return IfStatement;
            }();
            exports1.IfStatement = IfStatement;
            var ImportDeclaration = function() {
                function ImportDeclaration(specifiers, source) {
                    this.type = syntax_1.Syntax.ImportDeclaration;
                    this.specifiers = specifiers;
                    this.source = source;
                }
                return ImportDeclaration;
            }();
            exports1.ImportDeclaration = ImportDeclaration;
            var ImportDefaultSpecifier = function() {
                function ImportDefaultSpecifier(local) {
                    this.type = syntax_1.Syntax.ImportDefaultSpecifier;
                    this.local = local;
                }
                return ImportDefaultSpecifier;
            }();
            exports1.ImportDefaultSpecifier = ImportDefaultSpecifier;
            var ImportNamespaceSpecifier = function() {
                function ImportNamespaceSpecifier(local) {
                    this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
                    this.local = local;
                }
                return ImportNamespaceSpecifier;
            }();
            exports1.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
            var ImportSpecifier = function() {
                function ImportSpecifier(local, imported) {
                    this.type = syntax_1.Syntax.ImportSpecifier;
                    this.local = local;
                    this.imported = imported;
                }
                return ImportSpecifier;
            }();
            exports1.ImportSpecifier = ImportSpecifier;
            var LabeledStatement = function() {
                function LabeledStatement(label, body) {
                    this.type = syntax_1.Syntax.LabeledStatement;
                    this.label = label;
                    this.body = body;
                }
                return LabeledStatement;
            }();
            exports1.LabeledStatement = LabeledStatement;
            var Literal = function() {
                function Literal(value, raw) {
                    this.type = syntax_1.Syntax.Literal;
                    this.value = value;
                    this.raw = raw;
                }
                return Literal;
            }();
            exports1.Literal = Literal;
            var MetaProperty = function() {
                function MetaProperty(meta, property) {
                    this.type = syntax_1.Syntax.MetaProperty;
                    this.meta = meta;
                    this.property = property;
                }
                return MetaProperty;
            }();
            exports1.MetaProperty = MetaProperty;
            var MethodDefinition = function() {
                function MethodDefinition(key, computed, value, kind, isStatic) {
                    this.type = syntax_1.Syntax.MethodDefinition;
                    this.key = key;
                    this.computed = computed;
                    this.value = value;
                    this.kind = kind;
                    this.static = isStatic;
                }
                return MethodDefinition;
            }();
            exports1.MethodDefinition = MethodDefinition;
            var Module = function() {
                function Module(body) {
                    this.type = syntax_1.Syntax.Program;
                    this.body = body;
                    this.sourceType = "module";
                }
                return Module;
            }();
            exports1.Module = Module;
            var NewExpression = function() {
                function NewExpression(callee, args) {
                    this.type = syntax_1.Syntax.NewExpression;
                    this.callee = callee;
                    this.arguments = args;
                }
                return NewExpression;
            }();
            exports1.NewExpression = NewExpression;
            var ObjectExpression = function() {
                function ObjectExpression(properties) {
                    this.type = syntax_1.Syntax.ObjectExpression;
                    this.properties = properties;
                }
                return ObjectExpression;
            }();
            exports1.ObjectExpression = ObjectExpression;
            var ObjectPattern = function() {
                function ObjectPattern(properties) {
                    this.type = syntax_1.Syntax.ObjectPattern;
                    this.properties = properties;
                }
                return ObjectPattern;
            }();
            exports1.ObjectPattern = ObjectPattern;
            var Property = function() {
                function Property(kind, key, computed, value, method, shorthand) {
                    this.type = syntax_1.Syntax.Property;
                    this.key = key;
                    this.computed = computed;
                    this.value = value;
                    this.kind = kind;
                    this.method = method;
                    this.shorthand = shorthand;
                }
                return Property;
            }();
            exports1.Property = Property;
            var RegexLiteral = function() {
                function RegexLiteral(value, raw, pattern, flags) {
                    this.type = syntax_1.Syntax.Literal;
                    this.value = value;
                    this.raw = raw;
                    this.regex = {
                        pattern: pattern,
                        flags: flags
                    };
                }
                return RegexLiteral;
            }();
            exports1.RegexLiteral = RegexLiteral;
            var RestElement = function() {
                function RestElement(argument) {
                    this.type = syntax_1.Syntax.RestElement;
                    this.argument = argument;
                }
                return RestElement;
            }();
            exports1.RestElement = RestElement;
            var ReturnStatement = function() {
                function ReturnStatement(argument) {
                    this.type = syntax_1.Syntax.ReturnStatement;
                    this.argument = argument;
                }
                return ReturnStatement;
            }();
            exports1.ReturnStatement = ReturnStatement;
            var Script = function() {
                function Script(body) {
                    this.type = syntax_1.Syntax.Program;
                    this.body = body;
                    this.sourceType = "script";
                }
                return Script;
            }();
            exports1.Script = Script;
            var SequenceExpression = function() {
                function SequenceExpression(expressions) {
                    this.type = syntax_1.Syntax.SequenceExpression;
                    this.expressions = expressions;
                }
                return SequenceExpression;
            }();
            exports1.SequenceExpression = SequenceExpression;
            var SpreadElement = function() {
                function SpreadElement(argument) {
                    this.type = syntax_1.Syntax.SpreadElement;
                    this.argument = argument;
                }
                return SpreadElement;
            }();
            exports1.SpreadElement = SpreadElement;
            var StaticMemberExpression = function() {
                function StaticMemberExpression(object, property) {
                    this.type = syntax_1.Syntax.MemberExpression;
                    this.computed = false;
                    this.object = object;
                    this.property = property;
                }
                return StaticMemberExpression;
            }();
            exports1.StaticMemberExpression = StaticMemberExpression;
            var Super = function() {
                function Super() {
                    this.type = syntax_1.Syntax.Super;
                }
                return Super;
            }();
            exports1.Super = Super;
            var SwitchCase = function() {
                function SwitchCase(test, consequent) {
                    this.type = syntax_1.Syntax.SwitchCase;
                    this.test = test;
                    this.consequent = consequent;
                }
                return SwitchCase;
            }();
            exports1.SwitchCase = SwitchCase;
            var SwitchStatement = function() {
                function SwitchStatement(discriminant, cases) {
                    this.type = syntax_1.Syntax.SwitchStatement;
                    this.discriminant = discriminant;
                    this.cases = cases;
                }
                return SwitchStatement;
            }();
            exports1.SwitchStatement = SwitchStatement;
            var TaggedTemplateExpression = function() {
                function TaggedTemplateExpression(tag, quasi) {
                    this.type = syntax_1.Syntax.TaggedTemplateExpression;
                    this.tag = tag;
                    this.quasi = quasi;
                }
                return TaggedTemplateExpression;
            }();
            exports1.TaggedTemplateExpression = TaggedTemplateExpression;
            var TemplateElement = function() {
                function TemplateElement(value, tail) {
                    this.type = syntax_1.Syntax.TemplateElement;
                    this.value = value;
                    this.tail = tail;
                }
                return TemplateElement;
            }();
            exports1.TemplateElement = TemplateElement;
            var TemplateLiteral = function() {
                function TemplateLiteral(quasis, expressions) {
                    this.type = syntax_1.Syntax.TemplateLiteral;
                    this.quasis = quasis;
                    this.expressions = expressions;
                }
                return TemplateLiteral;
            }();
            exports1.TemplateLiteral = TemplateLiteral;
            var ThisExpression = function() {
                function ThisExpression() {
                    this.type = syntax_1.Syntax.ThisExpression;
                }
                return ThisExpression;
            }();
            exports1.ThisExpression = ThisExpression;
            var ThrowStatement = function() {
                function ThrowStatement(argument) {
                    this.type = syntax_1.Syntax.ThrowStatement;
                    this.argument = argument;
                }
                return ThrowStatement;
            }();
            exports1.ThrowStatement = ThrowStatement;
            var TryStatement = function() {
                function TryStatement(block, handler, finalizer) {
                    this.type = syntax_1.Syntax.TryStatement;
                    this.block = block;
                    this.handler = handler;
                    this.finalizer = finalizer;
                }
                return TryStatement;
            }();
            exports1.TryStatement = TryStatement;
            var UnaryExpression = function() {
                function UnaryExpression(operator, argument) {
                    this.type = syntax_1.Syntax.UnaryExpression;
                    this.operator = operator;
                    this.argument = argument;
                    this.prefix = true;
                }
                return UnaryExpression;
            }();
            exports1.UnaryExpression = UnaryExpression;
            var UpdateExpression = function() {
                function UpdateExpression(operator, argument, prefix) {
                    this.type = syntax_1.Syntax.UpdateExpression;
                    this.operator = operator;
                    this.argument = argument;
                    this.prefix = prefix;
                }
                return UpdateExpression;
            }();
            exports1.UpdateExpression = UpdateExpression;
            var VariableDeclaration = function() {
                function VariableDeclaration(declarations, kind) {
                    this.type = syntax_1.Syntax.VariableDeclaration;
                    this.declarations = declarations;
                    this.kind = kind;
                }
                return VariableDeclaration;
            }();
            exports1.VariableDeclaration = VariableDeclaration;
            var VariableDeclarator = function() {
                function VariableDeclarator(id, init) {
                    this.type = syntax_1.Syntax.VariableDeclarator;
                    this.id = id;
                    this.init = init;
                }
                return VariableDeclarator;
            }();
            exports1.VariableDeclarator = VariableDeclarator;
            var WhileStatement = function() {
                function WhileStatement(test, body) {
                    this.type = syntax_1.Syntax.WhileStatement;
                    this.test = test;
                    this.body = body;
                }
                return WhileStatement;
            }();
            exports1.WhileStatement = WhileStatement;
            var WithStatement = function() {
                function WithStatement(object, body) {
                    this.type = syntax_1.Syntax.WithStatement;
                    this.object = object;
                    this.body = body;
                }
                return WithStatement;
            }();
            exports1.WithStatement = WithStatement;
            var YieldExpression = function() {
                function YieldExpression(argument, delegate) {
                    this.type = syntax_1.Syntax.YieldExpression;
                    this.argument = argument;
                    this.delegate = delegate;
                }
                return YieldExpression;
            }();
            exports1.YieldExpression = YieldExpression;
        /***/ },
        /* 8 */ /***/ function(module1, exports1, __nested_webpack_require_99358__) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var assert_1 = __nested_webpack_require_99358__(9);
            var error_handler_1 = __nested_webpack_require_99358__(10);
            var messages_1 = __nested_webpack_require_99358__(11);
            var Node = __nested_webpack_require_99358__(7);
            var scanner_1 = __nested_webpack_require_99358__(12);
            var syntax_1 = __nested_webpack_require_99358__(2);
            var token_1 = __nested_webpack_require_99358__(13);
            var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
            var Parser = function() {
                function Parser(code, options, delegate) {
                    if (options === void 0) {
                        options = {};
                    }
                    this.config = {
                        range: typeof options.range === "boolean" && options.range,
                        loc: typeof options.loc === "boolean" && options.loc,
                        source: null,
                        tokens: typeof options.tokens === "boolean" && options.tokens,
                        comment: typeof options.comment === "boolean" && options.comment,
                        tolerant: typeof options.tolerant === "boolean" && options.tolerant
                    };
                    if (this.config.loc && options.source && options.source !== null) {
                        this.config.source = String(options.source);
                    }
                    this.delegate = delegate;
                    this.errorHandler = new error_handler_1.ErrorHandler();
                    this.errorHandler.tolerant = this.config.tolerant;
                    this.scanner = new scanner_1.Scanner(code, this.errorHandler);
                    this.scanner.trackComment = this.config.comment;
                    this.operatorPrecedence = {
                        ")": 0,
                        ";": 0,
                        ",": 0,
                        "=": 0,
                        "]": 0,
                        "||": 1,
                        "&&": 2,
                        "|": 3,
                        "^": 4,
                        "&": 5,
                        "==": 6,
                        "!=": 6,
                        "===": 6,
                        "!==": 6,
                        "<": 7,
                        ">": 7,
                        "<=": 7,
                        ">=": 7,
                        "<<": 8,
                        ">>": 8,
                        ">>>": 8,
                        "+": 9,
                        "-": 9,
                        "*": 11,
                        "/": 11,
                        "%": 11
                    };
                    this.lookahead = {
                        type: 2 /* EOF */ ,
                        value: "",
                        lineNumber: this.scanner.lineNumber,
                        lineStart: 0,
                        start: 0,
                        end: 0
                    };
                    this.hasLineTerminator = false;
                    this.context = {
                        isModule: false,
                        await: false,
                        allowIn: true,
                        allowStrictDirective: true,
                        allowYield: true,
                        firstCoverInitializedNameError: null,
                        isAssignmentTarget: false,
                        isBindingElement: false,
                        inFunctionBody: false,
                        inIteration: false,
                        inSwitch: false,
                        labelSet: {},
                        strict: false
                    };
                    this.tokens = [];
                    this.startMarker = {
                        index: 0,
                        line: this.scanner.lineNumber,
                        column: 0
                    };
                    this.lastMarker = {
                        index: 0,
                        line: this.scanner.lineNumber,
                        column: 0
                    };
                    this.nextToken();
                    this.lastMarker = {
                        index: this.scanner.index,
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                    };
                }
                Parser.prototype.throwError = function(messageFormat) {
                    var values = [];
                    for(var _i = 1; _i < arguments.length; _i++){
                        values[_i - 1] = arguments[_i];
                    }
                    var args = Array.prototype.slice.call(arguments, 1);
                    var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                        assert_1.assert(idx < args.length, "Message reference must be in range");
                        return args[idx];
                    });
                    var index = this.lastMarker.index;
                    var line = this.lastMarker.line;
                    var column = this.lastMarker.column + 1;
                    throw this.errorHandler.createError(index, line, column, msg);
                };
                Parser.prototype.tolerateError = function(messageFormat) {
                    var values = [];
                    for(var _i = 1; _i < arguments.length; _i++){
                        values[_i - 1] = arguments[_i];
                    }
                    var args = Array.prototype.slice.call(arguments, 1);
                    var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                        assert_1.assert(idx < args.length, "Message reference must be in range");
                        return args[idx];
                    });
                    var index = this.lastMarker.index;
                    var line = this.scanner.lineNumber;
                    var column = this.lastMarker.column + 1;
                    this.errorHandler.tolerateError(index, line, column, msg);
                };
                // Throw an exception because of the token.
                Parser.prototype.unexpectedTokenError = function(token, message) {
                    var msg = message || messages_1.Messages.UnexpectedToken;
                    var value;
                    if (token) {
                        if (!message) {
                            msg = token.type === 2 /* EOF */  ? messages_1.Messages.UnexpectedEOS : token.type === 3 /* Identifier */  ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 /* NumericLiteral */  ? messages_1.Messages.UnexpectedNumber : token.type === 8 /* StringLiteral */  ? messages_1.Messages.UnexpectedString : token.type === 10 /* Template */  ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
                            if (token.type === 4 /* Keyword */ ) {
                                if (this.scanner.isFutureReservedWord(token.value)) {
                                    msg = messages_1.Messages.UnexpectedReserved;
                                } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                                    msg = messages_1.Messages.StrictReservedWord;
                                }
                            }
                        }
                        value = token.value;
                    } else {
                        value = "ILLEGAL";
                    }
                    msg = msg.replace("%0", value);
                    if (token && typeof token.lineNumber === "number") {
                        var index = token.start;
                        var line = token.lineNumber;
                        var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
                        var column = token.start - lastMarkerLineStart + 1;
                        return this.errorHandler.createError(index, line, column, msg);
                    } else {
                        var index = this.lastMarker.index;
                        var line = this.lastMarker.line;
                        var column = this.lastMarker.column + 1;
                        return this.errorHandler.createError(index, line, column, msg);
                    }
                };
                Parser.prototype.throwUnexpectedToken = function(token, message) {
                    throw this.unexpectedTokenError(token, message);
                };
                Parser.prototype.tolerateUnexpectedToken = function(token, message) {
                    this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
                };
                Parser.prototype.collectComments = function() {
                    if (!this.config.comment) {
                        this.scanner.scanComments();
                    } else {
                        var comments = this.scanner.scanComments();
                        if (comments.length > 0 && this.delegate) {
                            for(var i = 0; i < comments.length; ++i){
                                var e = comments[i];
                                var node = void 0;
                                node = {
                                    type: e.multiLine ? "BlockComment" : "LineComment",
                                    value: this.scanner.source.slice(e.slice[0], e.slice[1])
                                };
                                if (this.config.range) {
                                    node.range = e.range;
                                }
                                if (this.config.loc) {
                                    node.loc = e.loc;
                                }
                                var metadata = {
                                    start: {
                                        line: e.loc.start.line,
                                        column: e.loc.start.column,
                                        offset: e.range[0]
                                    },
                                    end: {
                                        line: e.loc.end.line,
                                        column: e.loc.end.column,
                                        offset: e.range[1]
                                    }
                                };
                                this.delegate(node, metadata);
                            }
                        }
                    }
                };
                // From internal representation to an external structure
                Parser.prototype.getTokenRaw = function(token) {
                    return this.scanner.source.slice(token.start, token.end);
                };
                Parser.prototype.convertToken = function(token) {
                    var t = {
                        type: token_1.TokenName[token.type],
                        value: this.getTokenRaw(token)
                    };
                    if (this.config.range) {
                        t.range = [
                            token.start,
                            token.end
                        ];
                    }
                    if (this.config.loc) {
                        t.loc = {
                            start: {
                                line: this.startMarker.line,
                                column: this.startMarker.column
                            },
                            end: {
                                line: this.scanner.lineNumber,
                                column: this.scanner.index - this.scanner.lineStart
                            }
                        };
                    }
                    if (token.type === 9 /* RegularExpression */ ) {
                        var pattern = token.pattern;
                        var flags = token.flags;
                        t.regex = {
                            pattern: pattern,
                            flags: flags
                        };
                    }
                    return t;
                };
                Parser.prototype.nextToken = function() {
                    var token = this.lookahead;
                    this.lastMarker.index = this.scanner.index;
                    this.lastMarker.line = this.scanner.lineNumber;
                    this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
                    this.collectComments();
                    if (this.scanner.index !== this.startMarker.index) {
                        this.startMarker.index = this.scanner.index;
                        this.startMarker.line = this.scanner.lineNumber;
                        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
                    }
                    var next = this.scanner.lex();
                    this.hasLineTerminator = token.lineNumber !== next.lineNumber;
                    if (next && this.context.strict && next.type === 3 /* Identifier */ ) {
                        if (this.scanner.isStrictModeReservedWord(next.value)) {
                            next.type = 4 /* Keyword */ ;
                        }
                    }
                    this.lookahead = next;
                    if (this.config.tokens && next.type !== 2 /* EOF */ ) {
                        this.tokens.push(this.convertToken(next));
                    }
                    return token;
                };
                Parser.prototype.nextRegexToken = function() {
                    this.collectComments();
                    var token = this.scanner.scanRegExp();
                    if (this.config.tokens) {
                        // Pop the previous token, '/' or '/='
                        // This is added from the lookahead token.
                        this.tokens.pop();
                        this.tokens.push(this.convertToken(token));
                    }
                    // Prime the next lookahead.
                    this.lookahead = token;
                    this.nextToken();
                    return token;
                };
                Parser.prototype.createNode = function() {
                    return {
                        index: this.startMarker.index,
                        line: this.startMarker.line,
                        column: this.startMarker.column
                    };
                };
                Parser.prototype.startNode = function(token, lastLineStart) {
                    if (lastLineStart === void 0) {
                        lastLineStart = 0;
                    }
                    var column = token.start - token.lineStart;
                    var line = token.lineNumber;
                    if (column < 0) {
                        column += lastLineStart;
                        line--;
                    }
                    return {
                        index: token.start,
                        line: line,
                        column: column
                    };
                };
                Parser.prototype.finalize = function(marker, node) {
                    if (this.config.range) {
                        node.range = [
                            marker.index,
                            this.lastMarker.index
                        ];
                    }
                    if (this.config.loc) {
                        node.loc = {
                            start: {
                                line: marker.line,
                                column: marker.column
                            },
                            end: {
                                line: this.lastMarker.line,
                                column: this.lastMarker.column
                            }
                        };
                        if (this.config.source) {
                            node.loc.source = this.config.source;
                        }
                    }
                    if (this.delegate) {
                        var metadata = {
                            start: {
                                line: marker.line,
                                column: marker.column,
                                offset: marker.index
                            },
                            end: {
                                line: this.lastMarker.line,
                                column: this.lastMarker.column,
                                offset: this.lastMarker.index
                            }
                        };
                        this.delegate(node, metadata);
                    }
                    return node;
                };
                // Expect the next token to match the specified punctuator.
                // If not, an exception will be thrown.
                Parser.prototype.expect = function(value) {
                    var token = this.nextToken();
                    if (token.type !== 7 /* Punctuator */  || token.value !== value) {
                        this.throwUnexpectedToken(token);
                    }
                };
                // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
                Parser.prototype.expectCommaSeparator = function() {
                    if (this.config.tolerant) {
                        var token = this.lookahead;
                        if (token.type === 7 /* Punctuator */  && token.value === ",") {
                            this.nextToken();
                        } else if (token.type === 7 /* Punctuator */  && token.value === ";") {
                            this.nextToken();
                            this.tolerateUnexpectedToken(token);
                        } else {
                            this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
                        }
                    } else {
                        this.expect(",");
                    }
                };
                // Expect the next token to match the specified keyword.
                // If not, an exception will be thrown.
                Parser.prototype.expectKeyword = function(keyword) {
                    var token = this.nextToken();
                    if (token.type !== 4 /* Keyword */  || token.value !== keyword) {
                        this.throwUnexpectedToken(token);
                    }
                };
                // Return true if the next token matches the specified punctuator.
                Parser.prototype.match = function(value) {
                    return this.lookahead.type === 7 /* Punctuator */  && this.lookahead.value === value;
                };
                // Return true if the next token matches the specified keyword
                Parser.prototype.matchKeyword = function(keyword) {
                    return this.lookahead.type === 4 /* Keyword */  && this.lookahead.value === keyword;
                };
                // Return true if the next token matches the specified contextual keyword
                // (where an identifier is sometimes a keyword depending on the context)
                Parser.prototype.matchContextualKeyword = function(keyword) {
                    return this.lookahead.type === 3 /* Identifier */  && this.lookahead.value === keyword;
                };
                // Return true if the next token is an assignment operator
                Parser.prototype.matchAssign = function() {
                    if (this.lookahead.type !== 7 /* Punctuator */ ) {
                        return false;
                    }
                    var op = this.lookahead.value;
                    return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
                };
                // Cover grammar support.
                //
                // When an assignment expression position starts with an left parenthesis, the determination of the type
                // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
                // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
                //
                // There are three productions that can be parsed in a parentheses pair that needs to be determined
                // after the outermost pair is closed. They are:
                //
                //   1. AssignmentExpression
                //   2. BindingElements
                //   3. AssignmentTargets
                //
                // In order to avoid exponential backtracking, we use two flags to denote if the production can be
                // binding element or assignment target.
                //
                // The three productions have the relationship:
                //
                //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
                //
                // with a single exception that CoverInitializedName when used directly in an Expression, generates
                // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
                // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
                //
                // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
                // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
                // the CoverInitializedName check is conducted.
                //
                // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
                // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
                // pattern. The CoverInitializedName check is deferred.
                Parser.prototype.isolateCoverGrammar = function(parseFunction) {
                    var previousIsBindingElement = this.context.isBindingElement;
                    var previousIsAssignmentTarget = this.context.isAssignmentTarget;
                    var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                    this.context.isBindingElement = true;
                    this.context.isAssignmentTarget = true;
                    this.context.firstCoverInitializedNameError = null;
                    var result = parseFunction.call(this);
                    if (this.context.firstCoverInitializedNameError !== null) {
                        this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
                    }
                    this.context.isBindingElement = previousIsBindingElement;
                    this.context.isAssignmentTarget = previousIsAssignmentTarget;
                    this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
                    return result;
                };
                Parser.prototype.inheritCoverGrammar = function(parseFunction) {
                    var previousIsBindingElement = this.context.isBindingElement;
                    var previousIsAssignmentTarget = this.context.isAssignmentTarget;
                    var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
                    this.context.isBindingElement = true;
                    this.context.isAssignmentTarget = true;
                    this.context.firstCoverInitializedNameError = null;
                    var result = parseFunction.call(this);
                    this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
                    this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
                    this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
                    return result;
                };
                Parser.prototype.consumeSemicolon = function() {
                    if (this.match(";")) {
                        this.nextToken();
                    } else if (!this.hasLineTerminator) {
                        if (this.lookahead.type !== 2 /* EOF */  && !this.match("}")) {
                            this.throwUnexpectedToken(this.lookahead);
                        }
                        this.lastMarker.index = this.startMarker.index;
                        this.lastMarker.line = this.startMarker.line;
                        this.lastMarker.column = this.startMarker.column;
                    }
                };
                // https://tc39.github.io/ecma262/#sec-primary-expression
                Parser.prototype.parsePrimaryExpression = function() {
                    var node = this.createNode();
                    var expr;
                    var token, raw;
                    switch(this.lookahead.type){
                        case 3 /* Identifier */ :
                            if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                                this.tolerateUnexpectedToken(this.lookahead);
                            }
                            expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
                            break;
                        case 6 /* NumericLiteral */ :
                        case 8 /* StringLiteral */ :
                            if (this.context.strict && this.lookahead.octal) {
                                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                            }
                            this.context.isAssignmentTarget = false;
                            this.context.isBindingElement = false;
                            token = this.nextToken();
                            raw = this.getTokenRaw(token);
                            expr = this.finalize(node, new Node.Literal(token.value, raw));
                            break;
                        case 1 /* BooleanLiteral */ :
                            this.context.isAssignmentTarget = false;
                            this.context.isBindingElement = false;
                            token = this.nextToken();
                            raw = this.getTokenRaw(token);
                            expr = this.finalize(node, new Node.Literal(token.value === "true", raw));
                            break;
                        case 5 /* NullLiteral */ :
                            this.context.isAssignmentTarget = false;
                            this.context.isBindingElement = false;
                            token = this.nextToken();
                            raw = this.getTokenRaw(token);
                            expr = this.finalize(node, new Node.Literal(null, raw));
                            break;
                        case 10 /* Template */ :
                            expr = this.parseTemplateLiteral();
                            break;
                        case 7 /* Punctuator */ :
                            switch(this.lookahead.value){
                                case "(":
                                    this.context.isBindingElement = false;
                                    expr = this.inheritCoverGrammar(this.parseGroupExpression);
                                    break;
                                case "[":
                                    expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                                    break;
                                case "{":
                                    expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                                    break;
                                case "/":
                                case "/=":
                                    this.context.isAssignmentTarget = false;
                                    this.context.isBindingElement = false;
                                    this.scanner.index = this.startMarker.index;
                                    token = this.nextRegexToken();
                                    raw = this.getTokenRaw(token);
                                    expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
                                    break;
                                default:
                                    expr = this.throwUnexpectedToken(this.nextToken());
                            }
                            break;
                        case 4 /* Keyword */ :
                            if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                                expr = this.parseIdentifierName();
                            } else if (!this.context.strict && this.matchKeyword("let")) {
                                expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
                            } else {
                                this.context.isAssignmentTarget = false;
                                this.context.isBindingElement = false;
                                if (this.matchKeyword("function")) {
                                    expr = this.parseFunctionExpression();
                                } else if (this.matchKeyword("this")) {
                                    this.nextToken();
                                    expr = this.finalize(node, new Node.ThisExpression());
                                } else if (this.matchKeyword("class")) {
                                    expr = this.parseClassExpression();
                                } else {
                                    expr = this.throwUnexpectedToken(this.nextToken());
                                }
                            }
                            break;
                        default:
                            expr = this.throwUnexpectedToken(this.nextToken());
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-array-initializer
                Parser.prototype.parseSpreadElement = function() {
                    var node = this.createNode();
                    this.expect("...");
                    var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
                    return this.finalize(node, new Node.SpreadElement(arg));
                };
                Parser.prototype.parseArrayInitializer = function() {
                    var node = this.createNode();
                    var elements = [];
                    this.expect("[");
                    while(!this.match("]")){
                        if (this.match(",")) {
                            this.nextToken();
                            elements.push(null);
                        } else if (this.match("...")) {
                            var element = this.parseSpreadElement();
                            if (!this.match("]")) {
                                this.context.isAssignmentTarget = false;
                                this.context.isBindingElement = false;
                                this.expect(",");
                            }
                            elements.push(element);
                        } else {
                            elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                            if (!this.match("]")) {
                                this.expect(",");
                            }
                        }
                    }
                    this.expect("]");
                    return this.finalize(node, new Node.ArrayExpression(elements));
                };
                // https://tc39.github.io/ecma262/#sec-object-initializer
                Parser.prototype.parsePropertyMethod = function(params) {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = params.simple;
                    var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
                    if (this.context.strict && params.firstRestricted) {
                        this.tolerateUnexpectedToken(params.firstRestricted, params.message);
                    }
                    if (this.context.strict && params.stricted) {
                        this.tolerateUnexpectedToken(params.stricted, params.message);
                    }
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    return body;
                };
                Parser.prototype.parsePropertyMethodFunction = function() {
                    var isGenerator = false;
                    var node = this.createNode();
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = true;
                    var params = this.parseFormalParameters();
                    var method = this.parsePropertyMethod(params);
                    this.context.allowYield = previousAllowYield;
                    return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
                };
                Parser.prototype.parsePropertyMethodAsyncFunction = function() {
                    var node = this.createNode();
                    var previousAllowYield = this.context.allowYield;
                    var previousAwait = this.context.await;
                    this.context.allowYield = false;
                    this.context.await = true;
                    var params = this.parseFormalParameters();
                    var method = this.parsePropertyMethod(params);
                    this.context.allowYield = previousAllowYield;
                    this.context.await = previousAwait;
                    return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
                };
                Parser.prototype.parseObjectPropertyKey = function() {
                    var node = this.createNode();
                    var token = this.nextToken();
                    var key;
                    switch(token.type){
                        case 8 /* StringLiteral */ :
                        case 6 /* NumericLiteral */ :
                            if (this.context.strict && token.octal) {
                                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
                            }
                            var raw = this.getTokenRaw(token);
                            key = this.finalize(node, new Node.Literal(token.value, raw));
                            break;
                        case 3 /* Identifier */ :
                        case 1 /* BooleanLiteral */ :
                        case 5 /* NullLiteral */ :
                        case 4 /* Keyword */ :
                            key = this.finalize(node, new Node.Identifier(token.value));
                            break;
                        case 7 /* Punctuator */ :
                            if (token.value === "[") {
                                key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                                this.expect("]");
                            } else {
                                key = this.throwUnexpectedToken(token);
                            }
                            break;
                        default:
                            key = this.throwUnexpectedToken(token);
                    }
                    return key;
                };
                Parser.prototype.isPropertyKey = function(key, value) {
                    return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
                };
                Parser.prototype.parseObjectProperty = function(hasProto) {
                    var node = this.createNode();
                    var token = this.lookahead;
                    var kind;
                    var key = null;
                    var value = null;
                    var computed = false;
                    var method = false;
                    var shorthand = false;
                    var isAsync = false;
                    if (token.type === 3 /* Identifier */ ) {
                        var id = token.value;
                        this.nextToken();
                        computed = this.match("[");
                        isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
                        key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
                    } else if (this.match("*")) {
                        this.nextToken();
                    } else {
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                    }
                    var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                    if (token.type === 3 /* Identifier */  && !isAsync && token.value === "get" && lookaheadPropertyKey) {
                        kind = "get";
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                        this.context.allowYield = false;
                        value = this.parseGetterMethod();
                    } else if (token.type === 3 /* Identifier */  && !isAsync && token.value === "set" && lookaheadPropertyKey) {
                        kind = "set";
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                        value = this.parseSetterMethod();
                    } else if (token.type === 7 /* Punctuator */  && token.value === "*" && lookaheadPropertyKey) {
                        kind = "init";
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                        value = this.parseGeneratorMethod();
                        method = true;
                    } else {
                        if (!key) {
                            this.throwUnexpectedToken(this.lookahead);
                        }
                        kind = "init";
                        if (this.match(":") && !isAsync) {
                            if (!computed && this.isPropertyKey(key, "__proto__")) {
                                if (hasProto.value) {
                                    this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                                }
                                hasProto.value = true;
                            }
                            this.nextToken();
                            value = this.inheritCoverGrammar(this.parseAssignmentExpression);
                        } else if (this.match("(")) {
                            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                            method = true;
                        } else if (token.type === 3 /* Identifier */ ) {
                            var id = this.finalize(node, new Node.Identifier(token.value));
                            if (this.match("=")) {
                                this.context.firstCoverInitializedNameError = this.lookahead;
                                this.nextToken();
                                shorthand = true;
                                var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                                value = this.finalize(node, new Node.AssignmentPattern(id, init));
                            } else {
                                shorthand = true;
                                value = id;
                            }
                        } else {
                            this.throwUnexpectedToken(this.nextToken());
                        }
                    }
                    return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
                };
                Parser.prototype.parseObjectInitializer = function() {
                    var node = this.createNode();
                    this.expect("{");
                    var properties = [];
                    var hasProto = {
                        value: false
                    };
                    while(!this.match("}")){
                        properties.push(this.parseObjectProperty(hasProto));
                        if (!this.match("}")) {
                            this.expectCommaSeparator();
                        }
                    }
                    this.expect("}");
                    return this.finalize(node, new Node.ObjectExpression(properties));
                };
                // https://tc39.github.io/ecma262/#sec-template-literals
                Parser.prototype.parseTemplateHead = function() {
                    assert_1.assert(this.lookahead.head, "Template literal must start with a template head");
                    var node = this.createNode();
                    var token = this.nextToken();
                    var raw = token.value;
                    var cooked = token.cooked;
                    return this.finalize(node, new Node.TemplateElement({
                        raw: raw,
                        cooked: cooked
                    }, token.tail));
                };
                Parser.prototype.parseTemplateElement = function() {
                    if (this.lookahead.type !== 10 /* Template */ ) {
                        this.throwUnexpectedToken();
                    }
                    var node = this.createNode();
                    var token = this.nextToken();
                    var raw = token.value;
                    var cooked = token.cooked;
                    return this.finalize(node, new Node.TemplateElement({
                        raw: raw,
                        cooked: cooked
                    }, token.tail));
                };
                Parser.prototype.parseTemplateLiteral = function() {
                    var node = this.createNode();
                    var expressions = [];
                    var quasis = [];
                    var quasi = this.parseTemplateHead();
                    quasis.push(quasi);
                    while(!quasi.tail){
                        expressions.push(this.parseExpression());
                        quasi = this.parseTemplateElement();
                        quasis.push(quasi);
                    }
                    return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
                };
                // https://tc39.github.io/ecma262/#sec-grouping-operator
                Parser.prototype.reinterpretExpressionAsPattern = function(expr) {
                    switch(expr.type){
                        case syntax_1.Syntax.Identifier:
                        case syntax_1.Syntax.MemberExpression:
                        case syntax_1.Syntax.RestElement:
                        case syntax_1.Syntax.AssignmentPattern:
                            break;
                        case syntax_1.Syntax.SpreadElement:
                            expr.type = syntax_1.Syntax.RestElement;
                            this.reinterpretExpressionAsPattern(expr.argument);
                            break;
                        case syntax_1.Syntax.ArrayExpression:
                            expr.type = syntax_1.Syntax.ArrayPattern;
                            for(var i = 0; i < expr.elements.length; i++){
                                if (expr.elements[i] !== null) {
                                    this.reinterpretExpressionAsPattern(expr.elements[i]);
                                }
                            }
                            break;
                        case syntax_1.Syntax.ObjectExpression:
                            expr.type = syntax_1.Syntax.ObjectPattern;
                            for(var i = 0; i < expr.properties.length; i++){
                                this.reinterpretExpressionAsPattern(expr.properties[i].value);
                            }
                            break;
                        case syntax_1.Syntax.AssignmentExpression:
                            expr.type = syntax_1.Syntax.AssignmentPattern;
                            delete expr.operator;
                            this.reinterpretExpressionAsPattern(expr.left);
                            break;
                        default:
                            break;
                    }
                };
                Parser.prototype.parseGroupExpression = function() {
                    var expr;
                    this.expect("(");
                    if (this.match(")")) {
                        this.nextToken();
                        if (!this.match("=>")) {
                            this.expect("=>");
                        }
                        expr = {
                            type: ArrowParameterPlaceHolder,
                            params: [],
                            async: false
                        };
                    } else {
                        var startToken = this.lookahead;
                        var params = [];
                        if (this.match("...")) {
                            expr = this.parseRestElement(params);
                            this.expect(")");
                            if (!this.match("=>")) {
                                this.expect("=>");
                            }
                            expr = {
                                type: ArrowParameterPlaceHolder,
                                params: [
                                    expr
                                ],
                                async: false
                            };
                        } else {
                            var arrow = false;
                            this.context.isBindingElement = true;
                            expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
                            if (this.match(",")) {
                                var expressions = [];
                                this.context.isAssignmentTarget = false;
                                expressions.push(expr);
                                while(this.lookahead.type !== 2 /* EOF */ ){
                                    if (!this.match(",")) {
                                        break;
                                    }
                                    this.nextToken();
                                    if (this.match(")")) {
                                        this.nextToken();
                                        for(var i = 0; i < expressions.length; i++){
                                            this.reinterpretExpressionAsPattern(expressions[i]);
                                        }
                                        arrow = true;
                                        expr = {
                                            type: ArrowParameterPlaceHolder,
                                            params: expressions,
                                            async: false
                                        };
                                    } else if (this.match("...")) {
                                        if (!this.context.isBindingElement) {
                                            this.throwUnexpectedToken(this.lookahead);
                                        }
                                        expressions.push(this.parseRestElement(params));
                                        this.expect(")");
                                        if (!this.match("=>")) {
                                            this.expect("=>");
                                        }
                                        this.context.isBindingElement = false;
                                        for(var i = 0; i < expressions.length; i++){
                                            this.reinterpretExpressionAsPattern(expressions[i]);
                                        }
                                        arrow = true;
                                        expr = {
                                            type: ArrowParameterPlaceHolder,
                                            params: expressions,
                                            async: false
                                        };
                                    } else {
                                        expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                                    }
                                    if (arrow) {
                                        break;
                                    }
                                }
                                if (!arrow) {
                                    expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                                }
                            }
                            if (!arrow) {
                                this.expect(")");
                                if (this.match("=>")) {
                                    if (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield") {
                                        arrow = true;
                                        expr = {
                                            type: ArrowParameterPlaceHolder,
                                            params: [
                                                expr
                                            ],
                                            async: false
                                        };
                                    }
                                    if (!arrow) {
                                        if (!this.context.isBindingElement) {
                                            this.throwUnexpectedToken(this.lookahead);
                                        }
                                        if (expr.type === syntax_1.Syntax.SequenceExpression) {
                                            for(var i = 0; i < expr.expressions.length; i++){
                                                this.reinterpretExpressionAsPattern(expr.expressions[i]);
                                            }
                                        } else {
                                            this.reinterpretExpressionAsPattern(expr);
                                        }
                                        var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [
                                            expr
                                        ];
                                        expr = {
                                            type: ArrowParameterPlaceHolder,
                                            params: parameters,
                                            async: false
                                        };
                                    }
                                }
                                this.context.isBindingElement = false;
                            }
                        }
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
                Parser.prototype.parseArguments = function() {
                    this.expect("(");
                    var args = [];
                    if (!this.match(")")) {
                        while(true){
                            var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                            args.push(expr);
                            if (this.match(")")) {
                                break;
                            }
                            this.expectCommaSeparator();
                            if (this.match(")")) {
                                break;
                            }
                        }
                    }
                    this.expect(")");
                    return args;
                };
                Parser.prototype.isIdentifierName = function(token) {
                    return token.type === 3 /* Identifier */  || token.type === 4 /* Keyword */  || token.type === 1 /* BooleanLiteral */  || token.type === 5 /* NullLiteral */ ;
                };
                Parser.prototype.parseIdentifierName = function() {
                    var node = this.createNode();
                    var token = this.nextToken();
                    if (!this.isIdentifierName(token)) {
                        this.throwUnexpectedToken(token);
                    }
                    return this.finalize(node, new Node.Identifier(token.value));
                };
                Parser.prototype.parseNewExpression = function() {
                    var node = this.createNode();
                    var id = this.parseIdentifierName();
                    assert_1.assert(id.name === "new", "New expression must start with `new`");
                    var expr;
                    if (this.match(".")) {
                        this.nextToken();
                        if (this.lookahead.type === 3 /* Identifier */  && this.context.inFunctionBody && this.lookahead.value === "target") {
                            var property = this.parseIdentifierName();
                            expr = new Node.MetaProperty(id, property);
                        } else {
                            this.throwUnexpectedToken(this.lookahead);
                        }
                    } else {
                        var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
                        var args = this.match("(") ? this.parseArguments() : [];
                        expr = new Node.NewExpression(callee, args);
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                    }
                    return this.finalize(node, expr);
                };
                Parser.prototype.parseAsyncArgument = function() {
                    var arg = this.parseAssignmentExpression();
                    this.context.firstCoverInitializedNameError = null;
                    return arg;
                };
                Parser.prototype.parseAsyncArguments = function() {
                    this.expect("(");
                    var args = [];
                    if (!this.match(")")) {
                        while(true){
                            var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                            args.push(expr);
                            if (this.match(")")) {
                                break;
                            }
                            this.expectCommaSeparator();
                            if (this.match(")")) {
                                break;
                            }
                        }
                    }
                    this.expect(")");
                    return args;
                };
                Parser.prototype.parseLeftHandSideExpressionAllowCall = function() {
                    var startToken = this.lookahead;
                    var maybeAsync = this.matchContextualKeyword("async");
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = true;
                    var expr;
                    if (this.matchKeyword("super") && this.context.inFunctionBody) {
                        expr = this.createNode();
                        this.nextToken();
                        expr = this.finalize(expr, new Node.Super());
                        if (!this.match("(") && !this.match(".") && !this.match("[")) {
                            this.throwUnexpectedToken(this.lookahead);
                        }
                    } else {
                        expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                    }
                    while(true){
                        if (this.match(".")) {
                            this.context.isBindingElement = false;
                            this.context.isAssignmentTarget = true;
                            this.expect(".");
                            var property = this.parseIdentifierName();
                            expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
                        } else if (this.match("(")) {
                            var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
                            this.context.isBindingElement = false;
                            this.context.isAssignmentTarget = false;
                            var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                            expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
                            if (asyncArrow && this.match("=>")) {
                                for(var i = 0; i < args.length; ++i){
                                    this.reinterpretExpressionAsPattern(args[i]);
                                }
                                expr = {
                                    type: ArrowParameterPlaceHolder,
                                    params: args,
                                    async: true
                                };
                            }
                        } else if (this.match("[")) {
                            this.context.isBindingElement = false;
                            this.context.isAssignmentTarget = true;
                            this.expect("[");
                            var property = this.isolateCoverGrammar(this.parseExpression);
                            this.expect("]");
                            expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
                        } else if (this.lookahead.type === 10 /* Template */  && this.lookahead.head) {
                            var quasi = this.parseTemplateLiteral();
                            expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
                        } else {
                            break;
                        }
                    }
                    this.context.allowIn = previousAllowIn;
                    return expr;
                };
                Parser.prototype.parseSuper = function() {
                    var node = this.createNode();
                    this.expectKeyword("super");
                    if (!this.match("[") && !this.match(".")) {
                        this.throwUnexpectedToken(this.lookahead);
                    }
                    return this.finalize(node, new Node.Super());
                };
                Parser.prototype.parseLeftHandSideExpression = function() {
                    assert_1.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
                    var node = this.startNode(this.lookahead);
                    var expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
                    while(true){
                        if (this.match("[")) {
                            this.context.isBindingElement = false;
                            this.context.isAssignmentTarget = true;
                            this.expect("[");
                            var property = this.isolateCoverGrammar(this.parseExpression);
                            this.expect("]");
                            expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
                        } else if (this.match(".")) {
                            this.context.isBindingElement = false;
                            this.context.isAssignmentTarget = true;
                            this.expect(".");
                            var property = this.parseIdentifierName();
                            expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
                        } else if (this.lookahead.type === 10 /* Template */  && this.lookahead.head) {
                            var quasi = this.parseTemplateLiteral();
                            expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
                        } else {
                            break;
                        }
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-update-expressions
                Parser.prototype.parseUpdateExpression = function() {
                    var expr;
                    var startToken = this.lookahead;
                    if (this.match("++") || this.match("--")) {
                        var node = this.startNode(startToken);
                        var token = this.nextToken();
                        expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                        if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                            this.tolerateError(messages_1.Messages.StrictLHSPrefix);
                        }
                        if (!this.context.isAssignmentTarget) {
                            this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                        }
                        var prefix = true;
                        expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                    } else {
                        expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                        if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */ ) {
                            if (this.match("++") || this.match("--")) {
                                if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                                    this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                                }
                                if (!this.context.isAssignmentTarget) {
                                    this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                                }
                                this.context.isAssignmentTarget = false;
                                this.context.isBindingElement = false;
                                var operator = this.nextToken().value;
                                var prefix = false;
                                expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
                            }
                        }
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-unary-operators
                Parser.prototype.parseAwaitExpression = function() {
                    var node = this.createNode();
                    this.nextToken();
                    var argument = this.parseUnaryExpression();
                    return this.finalize(node, new Node.AwaitExpression(argument));
                };
                Parser.prototype.parseUnaryExpression = function() {
                    var expr;
                    if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                        var node = this.startNode(this.lookahead);
                        var token = this.nextToken();
                        expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                        expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
                        if (this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier) {
                            this.tolerateError(messages_1.Messages.StrictDelete);
                        }
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                    } else if (this.context.await && this.matchContextualKeyword("await")) {
                        expr = this.parseAwaitExpression();
                    } else {
                        expr = this.parseUpdateExpression();
                    }
                    return expr;
                };
                Parser.prototype.parseExponentiationExpression = function() {
                    var startToken = this.lookahead;
                    var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                    if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
                        this.nextToken();
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        var left = expr;
                        var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                        expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression("**", left, right));
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-exp-operator
                // https://tc39.github.io/ecma262/#sec-multiplicative-operators
                // https://tc39.github.io/ecma262/#sec-additive-operators
                // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
                // https://tc39.github.io/ecma262/#sec-relational-operators
                // https://tc39.github.io/ecma262/#sec-equality-operators
                // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
                // https://tc39.github.io/ecma262/#sec-binary-logical-operators
                Parser.prototype.binaryPrecedence = function(token) {
                    var op = token.value;
                    var precedence;
                    if (token.type === 7 /* Punctuator */ ) {
                        precedence = this.operatorPrecedence[op] || 0;
                    } else if (token.type === 4 /* Keyword */ ) {
                        precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
                    } else {
                        precedence = 0;
                    }
                    return precedence;
                };
                Parser.prototype.parseBinaryExpression = function() {
                    var startToken = this.lookahead;
                    var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
                    var token = this.lookahead;
                    var prec = this.binaryPrecedence(token);
                    if (prec > 0) {
                        this.nextToken();
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                        var markers = [
                            startToken,
                            this.lookahead
                        ];
                        var left = expr;
                        var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                        var stack = [
                            left,
                            token.value,
                            right
                        ];
                        var precedences = [
                            prec
                        ];
                        while(true){
                            prec = this.binaryPrecedence(this.lookahead);
                            if (prec <= 0) {
                                break;
                            }
                            // Reduce: make a binary expression from the three topmost entries.
                            while(stack.length > 2 && prec <= precedences[precedences.length - 1]){
                                right = stack.pop();
                                var operator = stack.pop();
                                precedences.pop();
                                left = stack.pop();
                                markers.pop();
                                var node = this.startNode(markers[markers.length - 1]);
                                stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
                            }
                            // Shift.
                            stack.push(this.nextToken().value);
                            precedences.push(prec);
                            markers.push(this.lookahead);
                            stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                        }
                        // Final reduce to clean-up the stack.
                        var i = stack.length - 1;
                        expr = stack[i];
                        var lastMarker = markers.pop();
                        while(i > 1){
                            var marker = markers.pop();
                            var lastLineStart = lastMarker && lastMarker.lineStart;
                            var node = this.startNode(marker, lastLineStart);
                            var operator = stack[i - 1];
                            expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
                            i -= 2;
                            lastMarker = marker;
                        }
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-conditional-operator
                Parser.prototype.parseConditionalExpression = function() {
                    var startToken = this.lookahead;
                    var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
                    if (this.match("?")) {
                        this.nextToken();
                        var previousAllowIn = this.context.allowIn;
                        this.context.allowIn = true;
                        var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
                        this.context.allowIn = previousAllowIn;
                        this.expect(":");
                        var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
                        expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
                        this.context.isAssignmentTarget = false;
                        this.context.isBindingElement = false;
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-assignment-operators
                Parser.prototype.checkPatternParam = function(options, param) {
                    switch(param.type){
                        case syntax_1.Syntax.Identifier:
                            this.validateParam(options, param, param.name);
                            break;
                        case syntax_1.Syntax.RestElement:
                            this.checkPatternParam(options, param.argument);
                            break;
                        case syntax_1.Syntax.AssignmentPattern:
                            this.checkPatternParam(options, param.left);
                            break;
                        case syntax_1.Syntax.ArrayPattern:
                            for(var i = 0; i < param.elements.length; i++){
                                if (param.elements[i] !== null) {
                                    this.checkPatternParam(options, param.elements[i]);
                                }
                            }
                            break;
                        case syntax_1.Syntax.ObjectPattern:
                            for(var i = 0; i < param.properties.length; i++){
                                this.checkPatternParam(options, param.properties[i].value);
                            }
                            break;
                        default:
                            break;
                    }
                    options.simple = options.simple && param instanceof Node.Identifier;
                };
                Parser.prototype.reinterpretAsCoverFormalsList = function(expr) {
                    var params = [
                        expr
                    ];
                    var options;
                    var asyncArrow = false;
                    switch(expr.type){
                        case syntax_1.Syntax.Identifier:
                            break;
                        case ArrowParameterPlaceHolder:
                            params = expr.params;
                            asyncArrow = expr.async;
                            break;
                        default:
                            return null;
                    }
                    options = {
                        simple: true,
                        paramSet: {}
                    };
                    for(var i = 0; i < params.length; ++i){
                        var param = params[i];
                        if (param.type === syntax_1.Syntax.AssignmentPattern) {
                            if (param.right.type === syntax_1.Syntax.YieldExpression) {
                                if (param.right.argument) {
                                    this.throwUnexpectedToken(this.lookahead);
                                }
                                param.right.type = syntax_1.Syntax.Identifier;
                                param.right.name = "yield";
                                delete param.right.argument;
                                delete param.right.delegate;
                            }
                        } else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await") {
                            this.throwUnexpectedToken(this.lookahead);
                        }
                        this.checkPatternParam(options, param);
                        params[i] = param;
                    }
                    if (this.context.strict || !this.context.allowYield) {
                        for(var i = 0; i < params.length; ++i){
                            var param = params[i];
                            if (param.type === syntax_1.Syntax.YieldExpression) {
                                this.throwUnexpectedToken(this.lookahead);
                            }
                        }
                    }
                    if (options.message === messages_1.Messages.StrictParamDupe) {
                        var token = this.context.strict ? options.stricted : options.firstRestricted;
                        this.throwUnexpectedToken(token, options.message);
                    }
                    return {
                        simple: options.simple,
                        params: params,
                        stricted: options.stricted,
                        firstRestricted: options.firstRestricted,
                        message: options.message
                    };
                };
                Parser.prototype.parseAssignmentExpression = function() {
                    var expr;
                    if (!this.context.allowYield && this.matchKeyword("yield")) {
                        expr = this.parseYieldExpression();
                    } else {
                        var startToken = this.lookahead;
                        var token = startToken;
                        expr = this.parseConditionalExpression();
                        if (token.type === 3 /* Identifier */  && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
                            if (this.lookahead.type === 3 /* Identifier */  || this.matchKeyword("yield")) {
                                var arg = this.parsePrimaryExpression();
                                this.reinterpretExpressionAsPattern(arg);
                                expr = {
                                    type: ArrowParameterPlaceHolder,
                                    params: [
                                        arg
                                    ],
                                    async: true
                                };
                            }
                        }
                        if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
                            // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
                            this.context.isAssignmentTarget = false;
                            this.context.isBindingElement = false;
                            var isAsync = expr.async;
                            var list = this.reinterpretAsCoverFormalsList(expr);
                            if (list) {
                                if (this.hasLineTerminator) {
                                    this.tolerateUnexpectedToken(this.lookahead);
                                }
                                this.context.firstCoverInitializedNameError = null;
                                var previousStrict = this.context.strict;
                                var previousAllowStrictDirective = this.context.allowStrictDirective;
                                this.context.allowStrictDirective = list.simple;
                                var previousAllowYield = this.context.allowYield;
                                var previousAwait = this.context.await;
                                this.context.allowYield = true;
                                this.context.await = isAsync;
                                var node = this.startNode(startToken);
                                this.expect("=>");
                                var body = void 0;
                                if (this.match("{")) {
                                    var previousAllowIn = this.context.allowIn;
                                    this.context.allowIn = true;
                                    body = this.parseFunctionSourceElements();
                                    this.context.allowIn = previousAllowIn;
                                } else {
                                    body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                                }
                                var expression = body.type !== syntax_1.Syntax.BlockStatement;
                                if (this.context.strict && list.firstRestricted) {
                                    this.throwUnexpectedToken(list.firstRestricted, list.message);
                                }
                                if (this.context.strict && list.stricted) {
                                    this.tolerateUnexpectedToken(list.stricted, list.message);
                                }
                                expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
                                this.context.strict = previousStrict;
                                this.context.allowStrictDirective = previousAllowStrictDirective;
                                this.context.allowYield = previousAllowYield;
                                this.context.await = previousAwait;
                            }
                        } else {
                            if (this.matchAssign()) {
                                if (!this.context.isAssignmentTarget) {
                                    this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                                }
                                if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                                    var id = expr;
                                    if (this.scanner.isRestrictedWord(id.name)) {
                                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                                    }
                                    if (this.scanner.isStrictModeReservedWord(id.name)) {
                                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                                    }
                                }
                                if (!this.match("=")) {
                                    this.context.isAssignmentTarget = false;
                                    this.context.isBindingElement = false;
                                } else {
                                    this.reinterpretExpressionAsPattern(expr);
                                }
                                token = this.nextToken();
                                var operator = token.value;
                                var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                                expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
                                this.context.firstCoverInitializedNameError = null;
                            }
                        }
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-comma-operator
                Parser.prototype.parseExpression = function() {
                    var startToken = this.lookahead;
                    var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    if (this.match(",")) {
                        var expressions = [];
                        expressions.push(expr);
                        while(this.lookahead.type !== 2 /* EOF */ ){
                            if (!this.match(",")) {
                                break;
                            }
                            this.nextToken();
                            expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                        }
                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                    }
                    return expr;
                };
                // https://tc39.github.io/ecma262/#sec-block
                Parser.prototype.parseStatementListItem = function() {
                    var statement;
                    this.context.isAssignmentTarget = true;
                    this.context.isBindingElement = true;
                    if (this.lookahead.type === 4 /* Keyword */ ) {
                        switch(this.lookahead.value){
                            case "export":
                                if (!this.context.isModule) {
                                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                                }
                                statement = this.parseExportDeclaration();
                                break;
                            case "import":
                                if (!this.context.isModule) {
                                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                                }
                                statement = this.parseImportDeclaration();
                                break;
                            case "const":
                                statement = this.parseLexicalDeclaration({
                                    inFor: false
                                });
                                break;
                            case "function":
                                statement = this.parseFunctionDeclaration();
                                break;
                            case "class":
                                statement = this.parseClassDeclaration();
                                break;
                            case "let":
                                statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({
                                    inFor: false
                                }) : this.parseStatement();
                                break;
                            default:
                                statement = this.parseStatement();
                                break;
                        }
                    } else {
                        statement = this.parseStatement();
                    }
                    return statement;
                };
                Parser.prototype.parseBlock = function() {
                    var node = this.createNode();
                    this.expect("{");
                    var block = [];
                    while(true){
                        if (this.match("}")) {
                            break;
                        }
                        block.push(this.parseStatementListItem());
                    }
                    this.expect("}");
                    return this.finalize(node, new Node.BlockStatement(block));
                };
                // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
                Parser.prototype.parseLexicalBinding = function(kind, options) {
                    var node = this.createNode();
                    var params = [];
                    var id = this.parsePattern(params, kind);
                    if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                        if (this.scanner.isRestrictedWord(id.name)) {
                            this.tolerateError(messages_1.Messages.StrictVarName);
                        }
                    }
                    var init = null;
                    if (kind === "const") {
                        if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                            if (this.match("=")) {
                                this.nextToken();
                                init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                            } else {
                                this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
                            }
                        }
                    } else if (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) {
                        this.expect("=");
                        init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    }
                    return this.finalize(node, new Node.VariableDeclarator(id, init));
                };
                Parser.prototype.parseBindingList = function(kind, options) {
                    var list = [
                        this.parseLexicalBinding(kind, options)
                    ];
                    while(this.match(",")){
                        this.nextToken();
                        list.push(this.parseLexicalBinding(kind, options));
                    }
                    return list;
                };
                Parser.prototype.isLexicalDeclaration = function() {
                    var state = this.scanner.saveState();
                    this.scanner.scanComments();
                    var next = this.scanner.lex();
                    this.scanner.restoreState(state);
                    return next.type === 3 /* Identifier */  || next.type === 7 /* Punctuator */  && next.value === "[" || next.type === 7 /* Punctuator */  && next.value === "{" || next.type === 4 /* Keyword */  && next.value === "let" || next.type === 4 /* Keyword */  && next.value === "yield";
                };
                Parser.prototype.parseLexicalDeclaration = function(options) {
                    var node = this.createNode();
                    var kind = this.nextToken().value;
                    assert_1.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
                    var declarations = this.parseBindingList(kind, options);
                    this.consumeSemicolon();
                    return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
                };
                // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
                Parser.prototype.parseBindingRestElement = function(params, kind) {
                    var node = this.createNode();
                    this.expect("...");
                    var arg = this.parsePattern(params, kind);
                    return this.finalize(node, new Node.RestElement(arg));
                };
                Parser.prototype.parseArrayPattern = function(params, kind) {
                    var node = this.createNode();
                    this.expect("[");
                    var elements = [];
                    while(!this.match("]")){
                        if (this.match(",")) {
                            this.nextToken();
                            elements.push(null);
                        } else {
                            if (this.match("...")) {
                                elements.push(this.parseBindingRestElement(params, kind));
                                break;
                            } else {
                                elements.push(this.parsePatternWithDefault(params, kind));
                            }
                            if (!this.match("]")) {
                                this.expect(",");
                            }
                        }
                    }
                    this.expect("]");
                    return this.finalize(node, new Node.ArrayPattern(elements));
                };
                Parser.prototype.parsePropertyPattern = function(params, kind) {
                    var node = this.createNode();
                    var computed = false;
                    var shorthand = false;
                    var method = false;
                    var key;
                    var value;
                    if (this.lookahead.type === 3 /* Identifier */ ) {
                        var keyToken = this.lookahead;
                        key = this.parseVariableIdentifier();
                        var init = this.finalize(node, new Node.Identifier(keyToken.value));
                        if (this.match("=")) {
                            params.push(keyToken);
                            shorthand = true;
                            this.nextToken();
                            var expr = this.parseAssignmentExpression();
                            value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
                        } else if (!this.match(":")) {
                            params.push(keyToken);
                            shorthand = true;
                            value = init;
                        } else {
                            this.expect(":");
                            value = this.parsePatternWithDefault(params, kind);
                        }
                    } else {
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                        this.expect(":");
                        value = this.parsePatternWithDefault(params, kind);
                    }
                    return this.finalize(node, new Node.Property("init", key, computed, value, method, shorthand));
                };
                Parser.prototype.parseObjectPattern = function(params, kind) {
                    var node = this.createNode();
                    var properties = [];
                    this.expect("{");
                    while(!this.match("}")){
                        properties.push(this.parsePropertyPattern(params, kind));
                        if (!this.match("}")) {
                            this.expect(",");
                        }
                    }
                    this.expect("}");
                    return this.finalize(node, new Node.ObjectPattern(properties));
                };
                Parser.prototype.parsePattern = function(params, kind) {
                    var pattern;
                    if (this.match("[")) {
                        pattern = this.parseArrayPattern(params, kind);
                    } else if (this.match("{")) {
                        pattern = this.parseObjectPattern(params, kind);
                    } else {
                        if (this.matchKeyword("let") && (kind === "const" || kind === "let")) {
                            this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
                        }
                        params.push(this.lookahead);
                        pattern = this.parseVariableIdentifier(kind);
                    }
                    return pattern;
                };
                Parser.prototype.parsePatternWithDefault = function(params, kind) {
                    var startToken = this.lookahead;
                    var pattern = this.parsePattern(params, kind);
                    if (this.match("=")) {
                        this.nextToken();
                        var previousAllowYield = this.context.allowYield;
                        this.context.allowYield = true;
                        var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                        this.context.allowYield = previousAllowYield;
                        pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
                    }
                    return pattern;
                };
                // https://tc39.github.io/ecma262/#sec-variable-statement
                Parser.prototype.parseVariableIdentifier = function(kind) {
                    var node = this.createNode();
                    var token = this.nextToken();
                    if (token.type === 4 /* Keyword */  && token.value === "yield") {
                        if (this.context.strict) {
                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                        } else if (!this.context.allowYield) {
                            this.throwUnexpectedToken(token);
                        }
                    } else if (token.type !== 3 /* Identifier */ ) {
                        if (this.context.strict && token.type === 4 /* Keyword */  && this.scanner.isStrictModeReservedWord(token.value)) {
                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                        } else {
                            if (this.context.strict || token.value !== "let" || kind !== "var") {
                                this.throwUnexpectedToken(token);
                            }
                        }
                    } else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */  && token.value === "await") {
                        this.tolerateUnexpectedToken(token);
                    }
                    return this.finalize(node, new Node.Identifier(token.value));
                };
                Parser.prototype.parseVariableDeclaration = function(options) {
                    var node = this.createNode();
                    var params = [];
                    var id = this.parsePattern(params, "var");
                    if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                        if (this.scanner.isRestrictedWord(id.name)) {
                            this.tolerateError(messages_1.Messages.StrictVarName);
                        }
                    }
                    var init = null;
                    if (this.match("=")) {
                        this.nextToken();
                        init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    } else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
                        this.expect("=");
                    }
                    return this.finalize(node, new Node.VariableDeclarator(id, init));
                };
                Parser.prototype.parseVariableDeclarationList = function(options) {
                    var opt = {
                        inFor: options.inFor
                    };
                    var list = [];
                    list.push(this.parseVariableDeclaration(opt));
                    while(this.match(",")){
                        this.nextToken();
                        list.push(this.parseVariableDeclaration(opt));
                    }
                    return list;
                };
                Parser.prototype.parseVariableStatement = function() {
                    var node = this.createNode();
                    this.expectKeyword("var");
                    var declarations = this.parseVariableDeclarationList({
                        inFor: false
                    });
                    this.consumeSemicolon();
                    return this.finalize(node, new Node.VariableDeclaration(declarations, "var"));
                };
                // https://tc39.github.io/ecma262/#sec-empty-statement
                Parser.prototype.parseEmptyStatement = function() {
                    var node = this.createNode();
                    this.expect(";");
                    return this.finalize(node, new Node.EmptyStatement());
                };
                // https://tc39.github.io/ecma262/#sec-expression-statement
                Parser.prototype.parseExpressionStatement = function() {
                    var node = this.createNode();
                    var expr = this.parseExpression();
                    this.consumeSemicolon();
                    return this.finalize(node, new Node.ExpressionStatement(expr));
                };
                // https://tc39.github.io/ecma262/#sec-if-statement
                Parser.prototype.parseIfClause = function() {
                    if (this.context.strict && this.matchKeyword("function")) {
                        this.tolerateError(messages_1.Messages.StrictFunction);
                    }
                    return this.parseStatement();
                };
                Parser.prototype.parseIfStatement = function() {
                    var node = this.createNode();
                    var consequent;
                    var alternate = null;
                    this.expectKeyword("if");
                    this.expect("(");
                    var test = this.parseExpression();
                    if (!this.match(")") && this.config.tolerant) {
                        this.tolerateUnexpectedToken(this.nextToken());
                        consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
                    } else {
                        this.expect(")");
                        consequent = this.parseIfClause();
                        if (this.matchKeyword("else")) {
                            this.nextToken();
                            alternate = this.parseIfClause();
                        }
                    }
                    return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
                };
                // https://tc39.github.io/ecma262/#sec-do-while-statement
                Parser.prototype.parseDoWhileStatement = function() {
                    var node = this.createNode();
                    this.expectKeyword("do");
                    var previousInIteration = this.context.inIteration;
                    this.context.inIteration = true;
                    var body = this.parseStatement();
                    this.context.inIteration = previousInIteration;
                    this.expectKeyword("while");
                    this.expect("(");
                    var test = this.parseExpression();
                    if (!this.match(")") && this.config.tolerant) {
                        this.tolerateUnexpectedToken(this.nextToken());
                    } else {
                        this.expect(")");
                        if (this.match(";")) {
                            this.nextToken();
                        }
                    }
                    return this.finalize(node, new Node.DoWhileStatement(body, test));
                };
                // https://tc39.github.io/ecma262/#sec-while-statement
                Parser.prototype.parseWhileStatement = function() {
                    var node = this.createNode();
                    var body;
                    this.expectKeyword("while");
                    this.expect("(");
                    var test = this.parseExpression();
                    if (!this.match(")") && this.config.tolerant) {
                        this.tolerateUnexpectedToken(this.nextToken());
                        body = this.finalize(this.createNode(), new Node.EmptyStatement());
                    } else {
                        this.expect(")");
                        var previousInIteration = this.context.inIteration;
                        this.context.inIteration = true;
                        body = this.parseStatement();
                        this.context.inIteration = previousInIteration;
                    }
                    return this.finalize(node, new Node.WhileStatement(test, body));
                };
                // https://tc39.github.io/ecma262/#sec-for-statement
                // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
                Parser.prototype.parseForStatement = function() {
                    var init = null;
                    var test = null;
                    var update = null;
                    var forIn = true;
                    var left, right;
                    var node = this.createNode();
                    this.expectKeyword("for");
                    this.expect("(");
                    if (this.match(";")) {
                        this.nextToken();
                    } else {
                        if (this.matchKeyword("var")) {
                            init = this.createNode();
                            this.nextToken();
                            var previousAllowIn = this.context.allowIn;
                            this.context.allowIn = false;
                            var declarations = this.parseVariableDeclarationList({
                                inFor: true
                            });
                            this.context.allowIn = previousAllowIn;
                            if (declarations.length === 1 && this.matchKeyword("in")) {
                                var decl = declarations[0];
                                if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                                    this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
                                }
                                init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                                this.nextToken();
                                left = init;
                                right = this.parseExpression();
                                init = null;
                            } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                                init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                                this.nextToken();
                                left = init;
                                right = this.parseAssignmentExpression();
                                init = null;
                                forIn = false;
                            } else {
                                init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                                this.expect(";");
                            }
                        } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                            init = this.createNode();
                            var kind = this.nextToken().value;
                            if (!this.context.strict && this.lookahead.value === "in") {
                                init = this.finalize(init, new Node.Identifier(kind));
                                this.nextToken();
                                left = init;
                                right = this.parseExpression();
                                init = null;
                            } else {
                                var previousAllowIn = this.context.allowIn;
                                this.context.allowIn = false;
                                var declarations = this.parseBindingList(kind, {
                                    inFor: true
                                });
                                this.context.allowIn = previousAllowIn;
                                if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
                                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                                    this.nextToken();
                                    left = init;
                                    right = this.parseExpression();
                                    init = null;
                                } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                                    this.nextToken();
                                    left = init;
                                    right = this.parseAssignmentExpression();
                                    init = null;
                                    forIn = false;
                                } else {
                                    this.consumeSemicolon();
                                    init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                                }
                            }
                        } else {
                            var initStartToken = this.lookahead;
                            var previousAllowIn = this.context.allowIn;
                            this.context.allowIn = false;
                            init = this.inheritCoverGrammar(this.parseAssignmentExpression);
                            this.context.allowIn = previousAllowIn;
                            if (this.matchKeyword("in")) {
                                if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                                    this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                                }
                                this.nextToken();
                                this.reinterpretExpressionAsPattern(init);
                                left = init;
                                right = this.parseExpression();
                                init = null;
                            } else if (this.matchContextualKeyword("of")) {
                                if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                                    this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                                }
                                this.nextToken();
                                this.reinterpretExpressionAsPattern(init);
                                left = init;
                                right = this.parseAssignmentExpression();
                                init = null;
                                forIn = false;
                            } else {
                                if (this.match(",")) {
                                    var initSeq = [
                                        init
                                    ];
                                    while(this.match(",")){
                                        this.nextToken();
                                        initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                                    }
                                    init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
                                }
                                this.expect(";");
                            }
                        }
                    }
                    if (typeof left === "undefined") {
                        if (!this.match(";")) {
                            test = this.parseExpression();
                        }
                        this.expect(";");
                        if (!this.match(")")) {
                            update = this.parseExpression();
                        }
                    }
                    var body;
                    if (!this.match(")") && this.config.tolerant) {
                        this.tolerateUnexpectedToken(this.nextToken());
                        body = this.finalize(this.createNode(), new Node.EmptyStatement());
                    } else {
                        this.expect(")");
                        var previousInIteration = this.context.inIteration;
                        this.context.inIteration = true;
                        body = this.isolateCoverGrammar(this.parseStatement);
                        this.context.inIteration = previousInIteration;
                    }
                    return typeof left === "undefined" ? this.finalize(node, new Node.ForStatement(init, test, update, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
                };
                // https://tc39.github.io/ecma262/#sec-continue-statement
                Parser.prototype.parseContinueStatement = function() {
                    var node = this.createNode();
                    this.expectKeyword("continue");
                    var label = null;
                    if (this.lookahead.type === 3 /* Identifier */  && !this.hasLineTerminator) {
                        var id = this.parseVariableIdentifier();
                        label = id;
                        var key = "$" + id.name;
                        if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                            this.throwError(messages_1.Messages.UnknownLabel, id.name);
                        }
                    }
                    this.consumeSemicolon();
                    if (label === null && !this.context.inIteration) {
                        this.throwError(messages_1.Messages.IllegalContinue);
                    }
                    return this.finalize(node, new Node.ContinueStatement(label));
                };
                // https://tc39.github.io/ecma262/#sec-break-statement
                Parser.prototype.parseBreakStatement = function() {
                    var node = this.createNode();
                    this.expectKeyword("break");
                    var label = null;
                    if (this.lookahead.type === 3 /* Identifier */  && !this.hasLineTerminator) {
                        var id = this.parseVariableIdentifier();
                        var key = "$" + id.name;
                        if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                            this.throwError(messages_1.Messages.UnknownLabel, id.name);
                        }
                        label = id;
                    }
                    this.consumeSemicolon();
                    if (label === null && !this.context.inIteration && !this.context.inSwitch) {
                        this.throwError(messages_1.Messages.IllegalBreak);
                    }
                    return this.finalize(node, new Node.BreakStatement(label));
                };
                // https://tc39.github.io/ecma262/#sec-return-statement
                Parser.prototype.parseReturnStatement = function() {
                    if (!this.context.inFunctionBody) {
                        this.tolerateError(messages_1.Messages.IllegalReturn);
                    }
                    var node = this.createNode();
                    this.expectKeyword("return");
                    var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */  || this.lookahead.type === 8 /* StringLiteral */  || this.lookahead.type === 10 /* Template */ ;
                    var argument = hasArgument ? this.parseExpression() : null;
                    this.consumeSemicolon();
                    return this.finalize(node, new Node.ReturnStatement(argument));
                };
                // https://tc39.github.io/ecma262/#sec-with-statement
                Parser.prototype.parseWithStatement = function() {
                    if (this.context.strict) {
                        this.tolerateError(messages_1.Messages.StrictModeWith);
                    }
                    var node = this.createNode();
                    var body;
                    this.expectKeyword("with");
                    this.expect("(");
                    var object = this.parseExpression();
                    if (!this.match(")") && this.config.tolerant) {
                        this.tolerateUnexpectedToken(this.nextToken());
                        body = this.finalize(this.createNode(), new Node.EmptyStatement());
                    } else {
                        this.expect(")");
                        body = this.parseStatement();
                    }
                    return this.finalize(node, new Node.WithStatement(object, body));
                };
                // https://tc39.github.io/ecma262/#sec-switch-statement
                Parser.prototype.parseSwitchCase = function() {
                    var node = this.createNode();
                    var test;
                    if (this.matchKeyword("default")) {
                        this.nextToken();
                        test = null;
                    } else {
                        this.expectKeyword("case");
                        test = this.parseExpression();
                    }
                    this.expect(":");
                    var consequent = [];
                    while(true){
                        if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                            break;
                        }
                        consequent.push(this.parseStatementListItem());
                    }
                    return this.finalize(node, new Node.SwitchCase(test, consequent));
                };
                Parser.prototype.parseSwitchStatement = function() {
                    var node = this.createNode();
                    this.expectKeyword("switch");
                    this.expect("(");
                    var discriminant = this.parseExpression();
                    this.expect(")");
                    var previousInSwitch = this.context.inSwitch;
                    this.context.inSwitch = true;
                    var cases = [];
                    var defaultFound = false;
                    this.expect("{");
                    while(true){
                        if (this.match("}")) {
                            break;
                        }
                        var clause = this.parseSwitchCase();
                        if (clause.test === null) {
                            if (defaultFound) {
                                this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                            }
                            defaultFound = true;
                        }
                        cases.push(clause);
                    }
                    this.expect("}");
                    this.context.inSwitch = previousInSwitch;
                    return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
                };
                // https://tc39.github.io/ecma262/#sec-labelled-statements
                Parser.prototype.parseLabelledStatement = function() {
                    var node = this.createNode();
                    var expr = this.parseExpression();
                    var statement;
                    if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
                        this.nextToken();
                        var id = expr;
                        var key = "$" + id.name;
                        if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                            this.throwError(messages_1.Messages.Redeclaration, "Label", id.name);
                        }
                        this.context.labelSet[key] = true;
                        var body = void 0;
                        if (this.matchKeyword("class")) {
                            this.tolerateUnexpectedToken(this.lookahead);
                            body = this.parseClassDeclaration();
                        } else if (this.matchKeyword("function")) {
                            var token = this.lookahead;
                            var declaration = this.parseFunctionDeclaration();
                            if (this.context.strict) {
                                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
                            } else if (declaration.generator) {
                                this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
                            }
                            body = declaration;
                        } else {
                            body = this.parseStatement();
                        }
                        delete this.context.labelSet[key];
                        statement = new Node.LabeledStatement(id, body);
                    } else {
                        this.consumeSemicolon();
                        statement = new Node.ExpressionStatement(expr);
                    }
                    return this.finalize(node, statement);
                };
                // https://tc39.github.io/ecma262/#sec-throw-statement
                Parser.prototype.parseThrowStatement = function() {
                    var node = this.createNode();
                    this.expectKeyword("throw");
                    if (this.hasLineTerminator) {
                        this.throwError(messages_1.Messages.NewlineAfterThrow);
                    }
                    var argument = this.parseExpression();
                    this.consumeSemicolon();
                    return this.finalize(node, new Node.ThrowStatement(argument));
                };
                // https://tc39.github.io/ecma262/#sec-try-statement
                Parser.prototype.parseCatchClause = function() {
                    var node = this.createNode();
                    this.expectKeyword("catch");
                    this.expect("(");
                    if (this.match(")")) {
                        this.throwUnexpectedToken(this.lookahead);
                    }
                    var params = [];
                    var param = this.parsePattern(params);
                    var paramMap = {};
                    for(var i = 0; i < params.length; i++){
                        var key = "$" + params[i].value;
                        if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                            this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
                        }
                        paramMap[key] = true;
                    }
                    if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
                        if (this.scanner.isRestrictedWord(param.name)) {
                            this.tolerateError(messages_1.Messages.StrictCatchVariable);
                        }
                    }
                    this.expect(")");
                    var body = this.parseBlock();
                    return this.finalize(node, new Node.CatchClause(param, body));
                };
                Parser.prototype.parseFinallyClause = function() {
                    this.expectKeyword("finally");
                    return this.parseBlock();
                };
                Parser.prototype.parseTryStatement = function() {
                    var node = this.createNode();
                    this.expectKeyword("try");
                    var block = this.parseBlock();
                    var handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
                    var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
                    if (!handler && !finalizer) {
                        this.throwError(messages_1.Messages.NoCatchOrFinally);
                    }
                    return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
                };
                // https://tc39.github.io/ecma262/#sec-debugger-statement
                Parser.prototype.parseDebuggerStatement = function() {
                    var node = this.createNode();
                    this.expectKeyword("debugger");
                    this.consumeSemicolon();
                    return this.finalize(node, new Node.DebuggerStatement());
                };
                // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
                Parser.prototype.parseStatement = function() {
                    var statement;
                    switch(this.lookahead.type){
                        case 1 /* BooleanLiteral */ :
                        case 5 /* NullLiteral */ :
                        case 6 /* NumericLiteral */ :
                        case 8 /* StringLiteral */ :
                        case 10 /* Template */ :
                        case 9 /* RegularExpression */ :
                            statement = this.parseExpressionStatement();
                            break;
                        case 7 /* Punctuator */ :
                            var value = this.lookahead.value;
                            if (value === "{") {
                                statement = this.parseBlock();
                            } else if (value === "(") {
                                statement = this.parseExpressionStatement();
                            } else if (value === ";") {
                                statement = this.parseEmptyStatement();
                            } else {
                                statement = this.parseExpressionStatement();
                            }
                            break;
                        case 3 /* Identifier */ :
                            statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                            break;
                        case 4 /* Keyword */ :
                            switch(this.lookahead.value){
                                case "break":
                                    statement = this.parseBreakStatement();
                                    break;
                                case "continue":
                                    statement = this.parseContinueStatement();
                                    break;
                                case "debugger":
                                    statement = this.parseDebuggerStatement();
                                    break;
                                case "do":
                                    statement = this.parseDoWhileStatement();
                                    break;
                                case "for":
                                    statement = this.parseForStatement();
                                    break;
                                case "function":
                                    statement = this.parseFunctionDeclaration();
                                    break;
                                case "if":
                                    statement = this.parseIfStatement();
                                    break;
                                case "return":
                                    statement = this.parseReturnStatement();
                                    break;
                                case "switch":
                                    statement = this.parseSwitchStatement();
                                    break;
                                case "throw":
                                    statement = this.parseThrowStatement();
                                    break;
                                case "try":
                                    statement = this.parseTryStatement();
                                    break;
                                case "var":
                                    statement = this.parseVariableStatement();
                                    break;
                                case "while":
                                    statement = this.parseWhileStatement();
                                    break;
                                case "with":
                                    statement = this.parseWithStatement();
                                    break;
                                default:
                                    statement = this.parseExpressionStatement();
                                    break;
                            }
                            break;
                        default:
                            statement = this.throwUnexpectedToken(this.lookahead);
                    }
                    return statement;
                };
                // https://tc39.github.io/ecma262/#sec-function-definitions
                Parser.prototype.parseFunctionSourceElements = function() {
                    var node = this.createNode();
                    this.expect("{");
                    var body = this.parseDirectivePrologues();
                    var previousLabelSet = this.context.labelSet;
                    var previousInIteration = this.context.inIteration;
                    var previousInSwitch = this.context.inSwitch;
                    var previousInFunctionBody = this.context.inFunctionBody;
                    this.context.labelSet = {};
                    this.context.inIteration = false;
                    this.context.inSwitch = false;
                    this.context.inFunctionBody = true;
                    while(this.lookahead.type !== 2 /* EOF */ ){
                        if (this.match("}")) {
                            break;
                        }
                        body.push(this.parseStatementListItem());
                    }
                    this.expect("}");
                    this.context.labelSet = previousLabelSet;
                    this.context.inIteration = previousInIteration;
                    this.context.inSwitch = previousInSwitch;
                    this.context.inFunctionBody = previousInFunctionBody;
                    return this.finalize(node, new Node.BlockStatement(body));
                };
                Parser.prototype.validateParam = function(options, param, name) {
                    var key = "$" + name;
                    if (this.context.strict) {
                        if (this.scanner.isRestrictedWord(name)) {
                            options.stricted = param;
                            options.message = messages_1.Messages.StrictParamName;
                        }
                        if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                            options.stricted = param;
                            options.message = messages_1.Messages.StrictParamDupe;
                        }
                    } else if (!options.firstRestricted) {
                        if (this.scanner.isRestrictedWord(name)) {
                            options.firstRestricted = param;
                            options.message = messages_1.Messages.StrictParamName;
                        } else if (this.scanner.isStrictModeReservedWord(name)) {
                            options.firstRestricted = param;
                            options.message = messages_1.Messages.StrictReservedWord;
                        } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                            options.stricted = param;
                            options.message = messages_1.Messages.StrictParamDupe;
                        }
                    }
                    /* istanbul ignore next */ if (typeof Object.defineProperty === "function") {
                        Object.defineProperty(options.paramSet, key, {
                            value: true,
                            enumerable: true,
                            writable: true,
                            configurable: true
                        });
                    } else {
                        options.paramSet[key] = true;
                    }
                };
                Parser.prototype.parseRestElement = function(params) {
                    var node = this.createNode();
                    this.expect("...");
                    var arg = this.parsePattern(params);
                    if (this.match("=")) {
                        this.throwError(messages_1.Messages.DefaultRestParameter);
                    }
                    if (!this.match(")")) {
                        this.throwError(messages_1.Messages.ParameterAfterRestParameter);
                    }
                    return this.finalize(node, new Node.RestElement(arg));
                };
                Parser.prototype.parseFormalParameter = function(options) {
                    var params = [];
                    var param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
                    for(var i = 0; i < params.length; i++){
                        this.validateParam(options, params[i], params[i].value);
                    }
                    options.simple = options.simple && param instanceof Node.Identifier;
                    options.params.push(param);
                };
                Parser.prototype.parseFormalParameters = function(firstRestricted) {
                    var options;
                    options = {
                        simple: true,
                        params: [],
                        firstRestricted: firstRestricted
                    };
                    this.expect("(");
                    if (!this.match(")")) {
                        options.paramSet = {};
                        while(this.lookahead.type !== 2 /* EOF */ ){
                            this.parseFormalParameter(options);
                            if (this.match(")")) {
                                break;
                            }
                            this.expect(",");
                            if (this.match(")")) {
                                break;
                            }
                        }
                    }
                    this.expect(")");
                    return {
                        simple: options.simple,
                        params: options.params,
                        stricted: options.stricted,
                        firstRestricted: options.firstRestricted,
                        message: options.message
                    };
                };
                Parser.prototype.matchAsyncFunction = function() {
                    var match = this.matchContextualKeyword("async");
                    if (match) {
                        var state = this.scanner.saveState();
                        this.scanner.scanComments();
                        var next = this.scanner.lex();
                        this.scanner.restoreState(state);
                        match = state.lineNumber === next.lineNumber && next.type === 4 /* Keyword */  && next.value === "function";
                    }
                    return match;
                };
                Parser.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
                    var node = this.createNode();
                    var isAsync = this.matchContextualKeyword("async");
                    if (isAsync) {
                        this.nextToken();
                    }
                    this.expectKeyword("function");
                    var isGenerator = isAsync ? false : this.match("*");
                    if (isGenerator) {
                        this.nextToken();
                    }
                    var message;
                    var id = null;
                    var firstRestricted = null;
                    if (!identifierIsOptional || !this.match("(")) {
                        var token = this.lookahead;
                        id = this.parseVariableIdentifier();
                        if (this.context.strict) {
                            if (this.scanner.isRestrictedWord(token.value)) {
                                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                            }
                        } else {
                            if (this.scanner.isRestrictedWord(token.value)) {
                                firstRestricted = token;
                                message = messages_1.Messages.StrictFunctionName;
                            } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                                firstRestricted = token;
                                message = messages_1.Messages.StrictReservedWord;
                            }
                        }
                    }
                    var previousAllowAwait = this.context.await;
                    var previousAllowYield = this.context.allowYield;
                    this.context.await = isAsync;
                    this.context.allowYield = !isGenerator;
                    var formalParameters = this.parseFormalParameters(firstRestricted);
                    var params = formalParameters.params;
                    var stricted = formalParameters.stricted;
                    firstRestricted = formalParameters.firstRestricted;
                    if (formalParameters.message) {
                        message = formalParameters.message;
                    }
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = formalParameters.simple;
                    var body = this.parseFunctionSourceElements();
                    if (this.context.strict && firstRestricted) {
                        this.throwUnexpectedToken(firstRestricted, message);
                    }
                    if (this.context.strict && stricted) {
                        this.tolerateUnexpectedToken(stricted, message);
                    }
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    this.context.await = previousAllowAwait;
                    this.context.allowYield = previousAllowYield;
                    return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
                };
                Parser.prototype.parseFunctionExpression = function() {
                    var node = this.createNode();
                    var isAsync = this.matchContextualKeyword("async");
                    if (isAsync) {
                        this.nextToken();
                    }
                    this.expectKeyword("function");
                    var isGenerator = isAsync ? false : this.match("*");
                    if (isGenerator) {
                        this.nextToken();
                    }
                    var message;
                    var id = null;
                    var firstRestricted;
                    var previousAllowAwait = this.context.await;
                    var previousAllowYield = this.context.allowYield;
                    this.context.await = isAsync;
                    this.context.allowYield = !isGenerator;
                    if (!this.match("(")) {
                        var token = this.lookahead;
                        id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
                        if (this.context.strict) {
                            if (this.scanner.isRestrictedWord(token.value)) {
                                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                            }
                        } else {
                            if (this.scanner.isRestrictedWord(token.value)) {
                                firstRestricted = token;
                                message = messages_1.Messages.StrictFunctionName;
                            } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                                firstRestricted = token;
                                message = messages_1.Messages.StrictReservedWord;
                            }
                        }
                    }
                    var formalParameters = this.parseFormalParameters(firstRestricted);
                    var params = formalParameters.params;
                    var stricted = formalParameters.stricted;
                    firstRestricted = formalParameters.firstRestricted;
                    if (formalParameters.message) {
                        message = formalParameters.message;
                    }
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = formalParameters.simple;
                    var body = this.parseFunctionSourceElements();
                    if (this.context.strict && firstRestricted) {
                        this.throwUnexpectedToken(firstRestricted, message);
                    }
                    if (this.context.strict && stricted) {
                        this.tolerateUnexpectedToken(stricted, message);
                    }
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    this.context.await = previousAllowAwait;
                    this.context.allowYield = previousAllowYield;
                    return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
                };
                // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
                Parser.prototype.parseDirective = function() {
                    var token = this.lookahead;
                    var node = this.createNode();
                    var expr = this.parseExpression();
                    var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
                    this.consumeSemicolon();
                    return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
                };
                Parser.prototype.parseDirectivePrologues = function() {
                    var firstRestricted = null;
                    var body = [];
                    while(true){
                        var token = this.lookahead;
                        if (token.type !== 8 /* StringLiteral */ ) {
                            break;
                        }
                        var statement = this.parseDirective();
                        body.push(statement);
                        var directive = statement.directive;
                        if (typeof directive !== "string") {
                            break;
                        }
                        if (directive === "use strict") {
                            this.context.strict = true;
                            if (firstRestricted) {
                                this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                            }
                            if (!this.context.allowStrictDirective) {
                                this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
                            }
                        } else {
                            if (!firstRestricted && token.octal) {
                                firstRestricted = token;
                            }
                        }
                    }
                    return body;
                };
                // https://tc39.github.io/ecma262/#sec-method-definitions
                Parser.prototype.qualifiedPropertyName = function(token) {
                    switch(token.type){
                        case 3 /* Identifier */ :
                        case 8 /* StringLiteral */ :
                        case 1 /* BooleanLiteral */ :
                        case 5 /* NullLiteral */ :
                        case 6 /* NumericLiteral */ :
                        case 4 /* Keyword */ :
                            return true;
                        case 7 /* Punctuator */ :
                            return token.value === "[";
                        default:
                            break;
                    }
                    return false;
                };
                Parser.prototype.parseGetterMethod = function() {
                    var node = this.createNode();
                    var isGenerator = false;
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = !isGenerator;
                    var formalParameters = this.parseFormalParameters();
                    if (formalParameters.params.length > 0) {
                        this.tolerateError(messages_1.Messages.BadGetterArity);
                    }
                    var method = this.parsePropertyMethod(formalParameters);
                    this.context.allowYield = previousAllowYield;
                    return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
                };
                Parser.prototype.parseSetterMethod = function() {
                    var node = this.createNode();
                    var isGenerator = false;
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = !isGenerator;
                    var formalParameters = this.parseFormalParameters();
                    if (formalParameters.params.length !== 1) {
                        this.tolerateError(messages_1.Messages.BadSetterArity);
                    } else if (formalParameters.params[0] instanceof Node.RestElement) {
                        this.tolerateError(messages_1.Messages.BadSetterRestParameter);
                    }
                    var method = this.parsePropertyMethod(formalParameters);
                    this.context.allowYield = previousAllowYield;
                    return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
                };
                Parser.prototype.parseGeneratorMethod = function() {
                    var node = this.createNode();
                    var isGenerator = true;
                    var previousAllowYield = this.context.allowYield;
                    this.context.allowYield = true;
                    var params = this.parseFormalParameters();
                    this.context.allowYield = false;
                    var method = this.parsePropertyMethod(params);
                    this.context.allowYield = previousAllowYield;
                    return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
                };
                // https://tc39.github.io/ecma262/#sec-generator-function-definitions
                Parser.prototype.isStartOfExpression = function() {
                    var start = true;
                    var value = this.lookahead.value;
                    switch(this.lookahead.type){
                        case 7 /* Punctuator */ :
                            start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/="; // regular expression literal
                            break;
                        case 4 /* Keyword */ :
                            start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
                            break;
                        default:
                            break;
                    }
                    return start;
                };
                Parser.prototype.parseYieldExpression = function() {
                    var node = this.createNode();
                    this.expectKeyword("yield");
                    var argument = null;
                    var delegate = false;
                    if (!this.hasLineTerminator) {
                        var previousAllowYield = this.context.allowYield;
                        this.context.allowYield = false;
                        delegate = this.match("*");
                        if (delegate) {
                            this.nextToken();
                            argument = this.parseAssignmentExpression();
                        } else if (this.isStartOfExpression()) {
                            argument = this.parseAssignmentExpression();
                        }
                        this.context.allowYield = previousAllowYield;
                    }
                    return this.finalize(node, new Node.YieldExpression(argument, delegate));
                };
                // https://tc39.github.io/ecma262/#sec-class-definitions
                Parser.prototype.parseClassElement = function(hasConstructor) {
                    var token = this.lookahead;
                    var node = this.createNode();
                    var kind = "";
                    var key = null;
                    var value = null;
                    var computed = false;
                    var method = false;
                    var isStatic = false;
                    var isAsync = false;
                    if (this.match("*")) {
                        this.nextToken();
                    } else {
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                        var id = key;
                        if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                            token = this.lookahead;
                            isStatic = true;
                            computed = this.match("[");
                            if (this.match("*")) {
                                this.nextToken();
                            } else {
                                key = this.parseObjectPropertyKey();
                            }
                        }
                        if (token.type === 3 /* Identifier */  && !this.hasLineTerminator && token.value === "async") {
                            var punctuator = this.lookahead.value;
                            if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
                                isAsync = true;
                                token = this.lookahead;
                                key = this.parseObjectPropertyKey();
                                if (token.type === 3 /* Identifier */  && token.value === "constructor") {
                                    this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
                                }
                            }
                        }
                    }
                    var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
                    if (token.type === 3 /* Identifier */ ) {
                        if (token.value === "get" && lookaheadPropertyKey) {
                            kind = "get";
                            computed = this.match("[");
                            key = this.parseObjectPropertyKey();
                            this.context.allowYield = false;
                            value = this.parseGetterMethod();
                        } else if (token.value === "set" && lookaheadPropertyKey) {
                            kind = "set";
                            computed = this.match("[");
                            key = this.parseObjectPropertyKey();
                            value = this.parseSetterMethod();
                        }
                    } else if (token.type === 7 /* Punctuator */  && token.value === "*" && lookaheadPropertyKey) {
                        kind = "init";
                        computed = this.match("[");
                        key = this.parseObjectPropertyKey();
                        value = this.parseGeneratorMethod();
                        method = true;
                    }
                    if (!kind && key && this.match("(")) {
                        kind = "init";
                        value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                        method = true;
                    }
                    if (!kind) {
                        this.throwUnexpectedToken(this.lookahead);
                    }
                    if (kind === "init") {
                        kind = "method";
                    }
                    if (!computed) {
                        if (isStatic && this.isPropertyKey(key, "prototype")) {
                            this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
                        }
                        if (!isStatic && this.isPropertyKey(key, "constructor")) {
                            if (kind !== "method" || !method || value && value.generator) {
                                this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
                            }
                            if (hasConstructor.value) {
                                this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
                            } else {
                                hasConstructor.value = true;
                            }
                            kind = "constructor";
                        }
                    }
                    return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
                };
                Parser.prototype.parseClassElementList = function() {
                    var body = [];
                    var hasConstructor = {
                        value: false
                    };
                    this.expect("{");
                    while(!this.match("}")){
                        if (this.match(";")) {
                            this.nextToken();
                        } else {
                            body.push(this.parseClassElement(hasConstructor));
                        }
                    }
                    this.expect("}");
                    return body;
                };
                Parser.prototype.parseClassBody = function() {
                    var node = this.createNode();
                    var elementList = this.parseClassElementList();
                    return this.finalize(node, new Node.ClassBody(elementList));
                };
                Parser.prototype.parseClassDeclaration = function(identifierIsOptional) {
                    var node = this.createNode();
                    var previousStrict = this.context.strict;
                    this.context.strict = true;
                    this.expectKeyword("class");
                    var id = identifierIsOptional && this.lookahead.type !== 3 /* Identifier */  ? null : this.parseVariableIdentifier();
                    var superClass = null;
                    if (this.matchKeyword("extends")) {
                        this.nextToken();
                        superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                    }
                    var classBody = this.parseClassBody();
                    this.context.strict = previousStrict;
                    return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
                };
                Parser.prototype.parseClassExpression = function() {
                    var node = this.createNode();
                    var previousStrict = this.context.strict;
                    this.context.strict = true;
                    this.expectKeyword("class");
                    var id = this.lookahead.type === 3 /* Identifier */  ? this.parseVariableIdentifier() : null;
                    var superClass = null;
                    if (this.matchKeyword("extends")) {
                        this.nextToken();
                        superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                    }
                    var classBody = this.parseClassBody();
                    this.context.strict = previousStrict;
                    return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
                };
                // https://tc39.github.io/ecma262/#sec-scripts
                // https://tc39.github.io/ecma262/#sec-modules
                Parser.prototype.parseModule = function() {
                    this.context.strict = true;
                    this.context.isModule = true;
                    this.scanner.isModule = true;
                    var node = this.createNode();
                    var body = this.parseDirectivePrologues();
                    while(this.lookahead.type !== 2 /* EOF */ ){
                        body.push(this.parseStatementListItem());
                    }
                    return this.finalize(node, new Node.Module(body));
                };
                Parser.prototype.parseScript = function() {
                    var node = this.createNode();
                    var body = this.parseDirectivePrologues();
                    while(this.lookahead.type !== 2 /* EOF */ ){
                        body.push(this.parseStatementListItem());
                    }
                    return this.finalize(node, new Node.Script(body));
                };
                // https://tc39.github.io/ecma262/#sec-imports
                Parser.prototype.parseModuleSpecifier = function() {
                    var node = this.createNode();
                    if (this.lookahead.type !== 8 /* StringLiteral */ ) {
                        this.throwError(messages_1.Messages.InvalidModuleSpecifier);
                    }
                    var token = this.nextToken();
                    var raw = this.getTokenRaw(token);
                    return this.finalize(node, new Node.Literal(token.value, raw));
                };
                // import {<foo as bar>} ...;
                Parser.prototype.parseImportSpecifier = function() {
                    var node = this.createNode();
                    var imported;
                    var local;
                    if (this.lookahead.type === 3 /* Identifier */ ) {
                        imported = this.parseVariableIdentifier();
                        local = imported;
                        if (this.matchContextualKeyword("as")) {
                            this.nextToken();
                            local = this.parseVariableIdentifier();
                        }
                    } else {
                        imported = this.parseIdentifierName();
                        local = imported;
                        if (this.matchContextualKeyword("as")) {
                            this.nextToken();
                            local = this.parseVariableIdentifier();
                        } else {
                            this.throwUnexpectedToken(this.nextToken());
                        }
                    }
                    return this.finalize(node, new Node.ImportSpecifier(local, imported));
                };
                // {foo, bar as bas}
                Parser.prototype.parseNamedImports = function() {
                    this.expect("{");
                    var specifiers = [];
                    while(!this.match("}")){
                        specifiers.push(this.parseImportSpecifier());
                        if (!this.match("}")) {
                            this.expect(",");
                        }
                    }
                    this.expect("}");
                    return specifiers;
                };
                // import <foo> ...;
                Parser.prototype.parseImportDefaultSpecifier = function() {
                    var node = this.createNode();
                    var local = this.parseIdentifierName();
                    return this.finalize(node, new Node.ImportDefaultSpecifier(local));
                };
                // import <* as foo> ...;
                Parser.prototype.parseImportNamespaceSpecifier = function() {
                    var node = this.createNode();
                    this.expect("*");
                    if (!this.matchContextualKeyword("as")) {
                        this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
                    }
                    this.nextToken();
                    var local = this.parseIdentifierName();
                    return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
                };
                Parser.prototype.parseImportDeclaration = function() {
                    if (this.context.inFunctionBody) {
                        this.throwError(messages_1.Messages.IllegalImportDeclaration);
                    }
                    var node = this.createNode();
                    this.expectKeyword("import");
                    var src;
                    var specifiers = [];
                    if (this.lookahead.type === 8 /* StringLiteral */ ) {
                        // import 'foo';
                        src = this.parseModuleSpecifier();
                    } else {
                        if (this.match("{")) {
                            // import {bar}
                            specifiers = specifiers.concat(this.parseNamedImports());
                        } else if (this.match("*")) {
                            // import * as foo
                            specifiers.push(this.parseImportNamespaceSpecifier());
                        } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                            // import foo
                            specifiers.push(this.parseImportDefaultSpecifier());
                            if (this.match(",")) {
                                this.nextToken();
                                if (this.match("*")) {
                                    // import foo, * as foo
                                    specifiers.push(this.parseImportNamespaceSpecifier());
                                } else if (this.match("{")) {
                                    // import foo, {bar}
                                    specifiers = specifiers.concat(this.parseNamedImports());
                                } else {
                                    this.throwUnexpectedToken(this.lookahead);
                                }
                            }
                        } else {
                            this.throwUnexpectedToken(this.nextToken());
                        }
                        if (!this.matchContextualKeyword("from")) {
                            var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                            this.throwError(message, this.lookahead.value);
                        }
                        this.nextToken();
                        src = this.parseModuleSpecifier();
                    }
                    this.consumeSemicolon();
                    return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
                };
                // https://tc39.github.io/ecma262/#sec-exports
                Parser.prototype.parseExportSpecifier = function() {
                    var node = this.createNode();
                    var local = this.parseIdentifierName();
                    var exported = local;
                    if (this.matchContextualKeyword("as")) {
                        this.nextToken();
                        exported = this.parseIdentifierName();
                    }
                    return this.finalize(node, new Node.ExportSpecifier(local, exported));
                };
                Parser.prototype.parseExportDeclaration = function() {
                    if (this.context.inFunctionBody) {
                        this.throwError(messages_1.Messages.IllegalExportDeclaration);
                    }
                    var node = this.createNode();
                    this.expectKeyword("export");
                    var exportDeclaration;
                    if (this.matchKeyword("default")) {
                        // export default ...
                        this.nextToken();
                        if (this.matchKeyword("function")) {
                            // export default function foo () {}
                            // export default function () {}
                            var declaration = this.parseFunctionDeclaration(true);
                            exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                        } else if (this.matchKeyword("class")) {
                            // export default class foo {}
                            var declaration = this.parseClassDeclaration(true);
                            exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                        } else if (this.matchContextualKeyword("async")) {
                            // export default async function f () {}
                            // export default async function () {}
                            // export default async x => x
                            var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                            exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                        } else {
                            if (this.matchContextualKeyword("from")) {
                                this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                            }
                            // export default {};
                            // export default [];
                            // export default (1 + 2);
                            var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                            this.consumeSemicolon();
                            exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                        }
                    } else if (this.match("*")) {
                        // export * from 'foo';
                        this.nextToken();
                        if (!this.matchContextualKeyword("from")) {
                            var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                            this.throwError(message, this.lookahead.value);
                        }
                        this.nextToken();
                        var src = this.parseModuleSpecifier();
                        this.consumeSemicolon();
                        exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
                    } else if (this.lookahead.type === 4 /* Keyword */ ) {
                        // export var f = 1;
                        var declaration = void 0;
                        switch(this.lookahead.value){
                            case "let":
                            case "const":
                                declaration = this.parseLexicalDeclaration({
                                    inFor: false
                                });
                                break;
                            case "var":
                            case "class":
                            case "function":
                                declaration = this.parseStatementListItem();
                                break;
                            default:
                                this.throwUnexpectedToken(this.lookahead);
                        }
                        exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
                    } else if (this.matchAsyncFunction()) {
                        var declaration = this.parseFunctionDeclaration();
                        exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
                    } else {
                        var specifiers = [];
                        var source = null;
                        var isExportFromIdentifier = false;
                        this.expect("{");
                        while(!this.match("}")){
                            isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
                            specifiers.push(this.parseExportSpecifier());
                            if (!this.match("}")) {
                                this.expect(",");
                            }
                        }
                        this.expect("}");
                        if (this.matchContextualKeyword("from")) {
                            // export {default} from 'foo';
                            // export {foo} from 'foo';
                            this.nextToken();
                            source = this.parseModuleSpecifier();
                            this.consumeSemicolon();
                        } else if (isExportFromIdentifier) {
                            // export {default}; // missing fromClause
                            var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                            this.throwError(message, this.lookahead.value);
                        } else {
                            // export {foo};
                            this.consumeSemicolon();
                        }
                        exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
                    }
                    return exportDeclaration;
                };
                return Parser;
            }();
            exports1.Parser = Parser;
        /***/ },
        /* 9 */ /***/ function(module1, exports1) {
            "use strict";
            // Ensure the condition is true, otherwise throw an error.
            // This is only to have a better contract semantic, i.e. another safety net
            // to catch a logic error. The condition shall be fulfilled in normal case.
            // Do NOT use this to enforce a certain condition on any user input.
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            function assert(condition, message) {
                /* istanbul ignore if */ if (!condition) {
                    throw new Error("ASSERT: " + message);
                }
            }
            exports1.assert = assert;
        /***/ },
        /* 10 */ /***/ function(module1, exports1) {
            "use strict";
            /* tslint:disable:max-classes-per-file */ Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var ErrorHandler = function() {
                function ErrorHandler() {
                    this.errors = [];
                    this.tolerant = false;
                }
                ErrorHandler.prototype.recordError = function(error) {
                    this.errors.push(error);
                };
                ErrorHandler.prototype.tolerate = function(error) {
                    if (this.tolerant) {
                        this.recordError(error);
                    } else {
                        throw error;
                    }
                };
                ErrorHandler.prototype.constructError = function(msg, column) {
                    var error = new Error(msg);
                    try {
                        throw error;
                    } catch (base) {
                        /* istanbul ignore else */ if (Object.create && Object.defineProperty) {
                            error = Object.create(base);
                            Object.defineProperty(error, "column", {
                                value: column
                            });
                        }
                    }
                    /* istanbul ignore next */ return error;
                };
                ErrorHandler.prototype.createError = function(index, line, col, description) {
                    var msg = "Line " + line + ": " + description;
                    var error = this.constructError(msg, col);
                    error.index = index;
                    error.lineNumber = line;
                    error.description = description;
                    return error;
                };
                ErrorHandler.prototype.throwError = function(index, line, col, description) {
                    throw this.createError(index, line, col, description);
                };
                ErrorHandler.prototype.tolerateError = function(index, line, col, description) {
                    var error = this.createError(index, line, col, description);
                    if (this.tolerant) {
                        this.recordError(error);
                    } else {
                        throw error;
                    }
                };
                return ErrorHandler;
            }();
            exports1.ErrorHandler = ErrorHandler;
        /***/ },
        /* 11 */ /***/ function(module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            // Error messages should be identical to V8.
            exports1.Messages = {
                BadGetterArity: "Getter must not have any formal parameters",
                BadSetterArity: "Setter must have exactly one formal parameter",
                BadSetterRestParameter: "Setter function argument must not be a rest parameter",
                ConstructorIsAsync: "Class constructor may not be an async method",
                ConstructorSpecialMethod: "Class constructor may not be an accessor",
                DeclarationMissingInitializer: "Missing initializer in %0 declaration",
                DefaultRestParameter: "Unexpected token =",
                DuplicateBinding: "Duplicate binding %0",
                DuplicateConstructor: "A class may only have one constructor",
                DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
                ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
                GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
                IllegalBreak: "Illegal break statement",
                IllegalContinue: "Illegal continue statement",
                IllegalExportDeclaration: "Unexpected token",
                IllegalImportDeclaration: "Unexpected token",
                IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
                IllegalReturn: "Illegal return statement",
                InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
                InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
                InvalidLHSInAssignment: "Invalid left-hand side in assignment",
                InvalidLHSInForIn: "Invalid left-hand side in for-in",
                InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
                InvalidModuleSpecifier: "Unexpected token",
                InvalidRegExp: "Invalid regular expression",
                LetInLexicalBinding: "let is disallowed as a lexically bound name",
                MissingFromClause: "Unexpected token",
                MultipleDefaultsInSwitch: "More than one default clause in switch statement",
                NewlineAfterThrow: "Illegal newline after throw",
                NoAsAfterImportNamespace: "Unexpected token",
                NoCatchOrFinally: "Missing catch or finally after try",
                ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
                Redeclaration: "%0 '%1' has already been declared",
                StaticPrototype: "Classes may not have static property named prototype",
                StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
                StrictDelete: "Delete of an unqualified identifier in strict mode.",
                StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
                StrictFunctionName: "Function name may not be eval or arguments in strict mode",
                StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
                StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
                StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
                StrictModeWith: "Strict mode code may not include a with statement",
                StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
                StrictParamDupe: "Strict mode function may not have duplicate parameter names",
                StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
                StrictReservedWord: "Use of future reserved word in strict mode",
                StrictVarName: "Variable name may not be eval or arguments in strict mode",
                TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
                UnexpectedEOS: "Unexpected end of input",
                UnexpectedIdentifier: "Unexpected identifier",
                UnexpectedNumber: "Unexpected number",
                UnexpectedReserved: "Unexpected reserved word",
                UnexpectedString: "Unexpected string",
                UnexpectedTemplate: "Unexpected quasi %0",
                UnexpectedToken: "Unexpected token %0",
                UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
                UnknownLabel: "Undefined label '%0'",
                UnterminatedRegExp: "Invalid regular expression: missing /"
            };
        /***/ },
        /* 12 */ /***/ function(module1, exports1, __nested_webpack_require_278838__) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var assert_1 = __nested_webpack_require_278838__(9);
            var character_1 = __nested_webpack_require_278838__(4);
            var messages_1 = __nested_webpack_require_278838__(11);
            function hexValue(ch) {
                return "0123456789abcdef".indexOf(ch.toLowerCase());
            }
            function octalValue(ch) {
                return "01234567".indexOf(ch);
            }
            var Scanner = function() {
                function Scanner(code, handler) {
                    this.source = code;
                    this.errorHandler = handler;
                    this.trackComment = false;
                    this.isModule = false;
                    this.length = code.length;
                    this.index = 0;
                    this.lineNumber = code.length > 0 ? 1 : 0;
                    this.lineStart = 0;
                    this.curlyStack = [];
                }
                Scanner.prototype.saveState = function() {
                    return {
                        index: this.index,
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart
                    };
                };
                Scanner.prototype.restoreState = function(state) {
                    this.index = state.index;
                    this.lineNumber = state.lineNumber;
                    this.lineStart = state.lineStart;
                };
                Scanner.prototype.eof = function() {
                    return this.index >= this.length;
                };
                Scanner.prototype.throwUnexpectedToken = function(message) {
                    if (message === void 0) {
                        message = messages_1.Messages.UnexpectedTokenIllegal;
                    }
                    return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
                };
                Scanner.prototype.tolerateUnexpectedToken = function(message) {
                    if (message === void 0) {
                        message = messages_1.Messages.UnexpectedTokenIllegal;
                    }
                    this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
                };
                // https://tc39.github.io/ecma262/#sec-comments
                Scanner.prototype.skipSingleLineComment = function(offset) {
                    var comments = [];
                    var start, loc;
                    if (this.trackComment) {
                        comments = [];
                        start = this.index - offset;
                        loc = {
                            start: {
                                line: this.lineNumber,
                                column: this.index - this.lineStart - offset
                            },
                            end: {}
                        };
                    }
                    while(!this.eof()){
                        var ch = this.source.charCodeAt(this.index);
                        ++this.index;
                        if (character_1.Character.isLineTerminator(ch)) {
                            if (this.trackComment) {
                                loc.end = {
                                    line: this.lineNumber,
                                    column: this.index - this.lineStart - 1
                                };
                                var entry = {
                                    multiLine: false,
                                    slice: [
                                        start + offset,
                                        this.index - 1
                                    ],
                                    range: [
                                        start,
                                        this.index - 1
                                    ],
                                    loc: loc
                                };
                                comments.push(entry);
                            }
                            if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                                ++this.index;
                            }
                            ++this.lineNumber;
                            this.lineStart = this.index;
                            return comments;
                        }
                    }
                    if (this.trackComment) {
                        loc.end = {
                            line: this.lineNumber,
                            column: this.index - this.lineStart
                        };
                        var entry = {
                            multiLine: false,
                            slice: [
                                start + offset,
                                this.index
                            ],
                            range: [
                                start,
                                this.index
                            ],
                            loc: loc
                        };
                        comments.push(entry);
                    }
                    return comments;
                };
                Scanner.prototype.skipMultiLineComment = function() {
                    var comments = [];
                    var start, loc;
                    if (this.trackComment) {
                        comments = [];
                        start = this.index - 2;
                        loc = {
                            start: {
                                line: this.lineNumber,
                                column: this.index - this.lineStart - 2
                            },
                            end: {}
                        };
                    }
                    while(!this.eof()){
                        var ch = this.source.charCodeAt(this.index);
                        if (character_1.Character.isLineTerminator(ch)) {
                            if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
                                ++this.index;
                            }
                            ++this.lineNumber;
                            ++this.index;
                            this.lineStart = this.index;
                        } else if (ch === 0x2A) {
                            // Block comment ends with '*/'.
                            if (this.source.charCodeAt(this.index + 1) === 0x2F) {
                                this.index += 2;
                                if (this.trackComment) {
                                    loc.end = {
                                        line: this.lineNumber,
                                        column: this.index - this.lineStart
                                    };
                                    var entry = {
                                        multiLine: true,
                                        slice: [
                                            start + 2,
                                            this.index - 2
                                        ],
                                        range: [
                                            start,
                                            this.index
                                        ],
                                        loc: loc
                                    };
                                    comments.push(entry);
                                }
                                return comments;
                            }
                            ++this.index;
                        } else {
                            ++this.index;
                        }
                    }
                    // Ran off the end of the file - the whole thing is a comment
                    if (this.trackComment) {
                        loc.end = {
                            line: this.lineNumber,
                            column: this.index - this.lineStart
                        };
                        var entry = {
                            multiLine: true,
                            slice: [
                                start + 2,
                                this.index
                            ],
                            range: [
                                start,
                                this.index
                            ],
                            loc: loc
                        };
                        comments.push(entry);
                    }
                    this.tolerateUnexpectedToken();
                    return comments;
                };
                Scanner.prototype.scanComments = function() {
                    var comments;
                    if (this.trackComment) {
                        comments = [];
                    }
                    var start = this.index === 0;
                    while(!this.eof()){
                        var ch = this.source.charCodeAt(this.index);
                        if (character_1.Character.isWhiteSpace(ch)) {
                            ++this.index;
                        } else if (character_1.Character.isLineTerminator(ch)) {
                            ++this.index;
                            if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
                                ++this.index;
                            }
                            ++this.lineNumber;
                            this.lineStart = this.index;
                            start = true;
                        } else if (ch === 0x2F) {
                            ch = this.source.charCodeAt(this.index + 1);
                            if (ch === 0x2F) {
                                this.index += 2;
                                var comment = this.skipSingleLineComment(2);
                                if (this.trackComment) {
                                    comments = comments.concat(comment);
                                }
                                start = true;
                            } else if (ch === 0x2A) {
                                this.index += 2;
                                var comment = this.skipMultiLineComment();
                                if (this.trackComment) {
                                    comments = comments.concat(comment);
                                }
                            } else {
                                break;
                            }
                        } else if (start && ch === 0x2D) {
                            // U+003E is '>'
                            if (this.source.charCodeAt(this.index + 1) === 0x2D && this.source.charCodeAt(this.index + 2) === 0x3E) {
                                // '-->' is a single-line comment
                                this.index += 3;
                                var comment = this.skipSingleLineComment(3);
                                if (this.trackComment) {
                                    comments = comments.concat(comment);
                                }
                            } else {
                                break;
                            }
                        } else if (ch === 0x3C && !this.isModule) {
                            if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                                this.index += 4; // `<!--`
                                var comment = this.skipSingleLineComment(4);
                                if (this.trackComment) {
                                    comments = comments.concat(comment);
                                }
                            } else {
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                    return comments;
                };
                // https://tc39.github.io/ecma262/#sec-future-reserved-words
                Scanner.prototype.isFutureReservedWord = function(id) {
                    switch(id){
                        case "enum":
                        case "export":
                        case "import":
                        case "super":
                            return true;
                        default:
                            return false;
                    }
                };
                Scanner.prototype.isStrictModeReservedWord = function(id) {
                    switch(id){
                        case "implements":
                        case "interface":
                        case "package":
                        case "private":
                        case "protected":
                        case "public":
                        case "static":
                        case "yield":
                        case "let":
                            return true;
                        default:
                            return false;
                    }
                };
                Scanner.prototype.isRestrictedWord = function(id) {
                    return id === "eval" || id === "arguments";
                };
                // https://tc39.github.io/ecma262/#sec-keywords
                Scanner.prototype.isKeyword = function(id) {
                    switch(id.length){
                        case 2:
                            return id === "if" || id === "in" || id === "do";
                        case 3:
                            return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
                        case 4:
                            return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
                        case 5:
                            return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
                        case 6:
                            return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
                        case 7:
                            return id === "default" || id === "finally" || id === "extends";
                        case 8:
                            return id === "function" || id === "continue" || id === "debugger";
                        case 10:
                            return id === "instanceof";
                        default:
                            return false;
                    }
                };
                Scanner.prototype.codePointAt = function(i) {
                    var cp = this.source.charCodeAt(i);
                    if (cp >= 0xD800 && cp <= 0xDBFF) {
                        var second = this.source.charCodeAt(i + 1);
                        if (second >= 0xDC00 && second <= 0xDFFF) {
                            var first = cp;
                            cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
                        }
                    }
                    return cp;
                };
                Scanner.prototype.scanHexEscape = function(prefix) {
                    var len = prefix === "u" ? 4 : 2;
                    var code = 0;
                    for(var i = 0; i < len; ++i){
                        if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                            code = code * 16 + hexValue(this.source[this.index++]);
                        } else {
                            return null;
                        }
                    }
                    return String.fromCharCode(code);
                };
                Scanner.prototype.scanUnicodeCodePointEscape = function() {
                    var ch = this.source[this.index];
                    var code = 0;
                    // At least, one hex digit is required.
                    if (ch === "}") {
                        this.throwUnexpectedToken();
                    }
                    while(!this.eof()){
                        ch = this.source[this.index++];
                        if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                            break;
                        }
                        code = code * 16 + hexValue(ch);
                    }
                    if (code > 0x10FFFF || ch !== "}") {
                        this.throwUnexpectedToken();
                    }
                    return character_1.Character.fromCodePoint(code);
                };
                Scanner.prototype.getIdentifier = function() {
                    var start = this.index++;
                    while(!this.eof()){
                        var ch = this.source.charCodeAt(this.index);
                        if (ch === 0x5C) {
                            // Blackslash (U+005C) marks Unicode escape sequence.
                            this.index = start;
                            return this.getComplexIdentifier();
                        } else if (ch >= 0xD800 && ch < 0xDFFF) {
                            // Need to handle surrogate pairs.
                            this.index = start;
                            return this.getComplexIdentifier();
                        }
                        if (character_1.Character.isIdentifierPart(ch)) {
                            ++this.index;
                        } else {
                            break;
                        }
                    }
                    return this.source.slice(start, this.index);
                };
                Scanner.prototype.getComplexIdentifier = function() {
                    var cp = this.codePointAt(this.index);
                    var id = character_1.Character.fromCodePoint(cp);
                    this.index += id.length;
                    // '\u' (U+005C, U+0075) denotes an escaped character.
                    var ch;
                    if (cp === 0x5C) {
                        if (this.source.charCodeAt(this.index) !== 0x75) {
                            this.throwUnexpectedToken();
                        }
                        ++this.index;
                        if (this.source[this.index] === "{") {
                            ++this.index;
                            ch = this.scanUnicodeCodePointEscape();
                        } else {
                            ch = this.scanHexEscape("u");
                            if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                                this.throwUnexpectedToken();
                            }
                        }
                        id = ch;
                    }
                    while(!this.eof()){
                        cp = this.codePointAt(this.index);
                        if (!character_1.Character.isIdentifierPart(cp)) {
                            break;
                        }
                        ch = character_1.Character.fromCodePoint(cp);
                        id += ch;
                        this.index += ch.length;
                        // '\u' (U+005C, U+0075) denotes an escaped character.
                        if (cp === 0x5C) {
                            id = id.substr(0, id.length - 1);
                            if (this.source.charCodeAt(this.index) !== 0x75) {
                                this.throwUnexpectedToken();
                            }
                            ++this.index;
                            if (this.source[this.index] === "{") {
                                ++this.index;
                                ch = this.scanUnicodeCodePointEscape();
                            } else {
                                ch = this.scanHexEscape("u");
                                if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                                    this.throwUnexpectedToken();
                                }
                            }
                            id += ch;
                        }
                    }
                    return id;
                };
                Scanner.prototype.octalToDecimal = function(ch) {
                    // \0 is not octal escape sequence
                    var octal = ch !== "0";
                    var code = octalValue(ch);
                    if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                        octal = true;
                        code = code * 8 + octalValue(this.source[this.index++]);
                        // 3 digits are only allowed when string starts
                        // with 0, 1, 2, 3
                        if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                            code = code * 8 + octalValue(this.source[this.index++]);
                        }
                    }
                    return {
                        code: code,
                        octal: octal
                    };
                };
                // https://tc39.github.io/ecma262/#sec-names-and-keywords
                Scanner.prototype.scanIdentifier = function() {
                    var type;
                    var start = this.index;
                    // Backslash (U+005C) starts an escaped character.
                    var id = this.source.charCodeAt(start) === 0x5C ? this.getComplexIdentifier() : this.getIdentifier();
                    // There is no keyword or literal with only one character.
                    // Thus, it must be an identifier.
                    if (id.length === 1) {
                        type = 3 /* Identifier */ ;
                    } else if (this.isKeyword(id)) {
                        type = 4 /* Keyword */ ;
                    } else if (id === "null") {
                        type = 5 /* NullLiteral */ ;
                    } else if (id === "true" || id === "false") {
                        type = 1 /* BooleanLiteral */ ;
                    } else {
                        type = 3 /* Identifier */ ;
                    }
                    if (type !== 3 /* Identifier */  && start + id.length !== this.index) {
                        var restore = this.index;
                        this.index = start;
                        this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
                        this.index = restore;
                    }
                    return {
                        type: type,
                        value: id,
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                // https://tc39.github.io/ecma262/#sec-punctuators
                Scanner.prototype.scanPunctuator = function() {
                    var start = this.index;
                    // Check for most common single-character punctuators.
                    var str = this.source[this.index];
                    switch(str){
                        case "(":
                        case "{":
                            if (str === "{") {
                                this.curlyStack.push("{");
                            }
                            ++this.index;
                            break;
                        case ".":
                            ++this.index;
                            if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                                // Spread operator: ...
                                this.index += 2;
                                str = "...";
                            }
                            break;
                        case "}":
                            ++this.index;
                            this.curlyStack.pop();
                            break;
                        case ")":
                        case ";":
                        case ",":
                        case "[":
                        case "]":
                        case ":":
                        case "?":
                        case "~":
                            ++this.index;
                            break;
                        default:
                            // 4-character punctuator.
                            str = this.source.substr(this.index, 4);
                            if (str === ">>>=") {
                                this.index += 4;
                            } else {
                                // 3-character punctuators.
                                str = str.substr(0, 3);
                                if (str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=" || str === "**=") {
                                    this.index += 3;
                                } else {
                                    // 2-character punctuators.
                                    str = str.substr(0, 2);
                                    if (str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" || str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>" || str === "**") {
                                        this.index += 2;
                                    } else {
                                        // 1-character punctuators.
                                        str = this.source[this.index];
                                        if ("<>=!+-*%&|^/".indexOf(str) >= 0) {
                                            ++this.index;
                                        }
                                    }
                                }
                            }
                    }
                    if (this.index === start) {
                        this.throwUnexpectedToken();
                    }
                    return {
                        type: 7 /* Punctuator */ ,
                        value: str,
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
                Scanner.prototype.scanHexLiteral = function(start) {
                    var num = "";
                    while(!this.eof()){
                        if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                            break;
                        }
                        num += this.source[this.index++];
                    }
                    if (num.length === 0) {
                        this.throwUnexpectedToken();
                    }
                    if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                        this.throwUnexpectedToken();
                    }
                    return {
                        type: 6 /* NumericLiteral */ ,
                        value: parseInt("0x" + num, 16),
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                Scanner.prototype.scanBinaryLiteral = function(start) {
                    var num = "";
                    var ch;
                    while(!this.eof()){
                        ch = this.source[this.index];
                        if (ch !== "0" && ch !== "1") {
                            break;
                        }
                        num += this.source[this.index++];
                    }
                    if (num.length === 0) {
                        // only 0b or 0B
                        this.throwUnexpectedToken();
                    }
                    if (!this.eof()) {
                        ch = this.source.charCodeAt(this.index);
                        /* istanbul ignore else */ if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                            this.throwUnexpectedToken();
                        }
                    }
                    return {
                        type: 6 /* NumericLiteral */ ,
                        value: parseInt(num, 2),
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                Scanner.prototype.scanOctalLiteral = function(prefix, start) {
                    var num = "";
                    var octal = false;
                    if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
                        octal = true;
                        num = "0" + this.source[this.index++];
                    } else {
                        ++this.index;
                    }
                    while(!this.eof()){
                        if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                            break;
                        }
                        num += this.source[this.index++];
                    }
                    if (!octal && num.length === 0) {
                        // only 0o or 0O
                        this.throwUnexpectedToken();
                    }
                    if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                        this.throwUnexpectedToken();
                    }
                    return {
                        type: 6 /* NumericLiteral */ ,
                        value: parseInt(num, 8),
                        octal: octal,
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                Scanner.prototype.isImplicitOctalLiteral = function() {
                    // Implicit octal, unless there is a non-octal digit.
                    // (Annex B.1.1 on Numeric Literals)
                    for(var i = this.index + 1; i < this.length; ++i){
                        var ch = this.source[i];
                        if (ch === "8" || ch === "9") {
                            return false;
                        }
                        if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                            return true;
                        }
                    }
                    return true;
                };
                Scanner.prototype.scanNumericLiteral = function() {
                    var start = this.index;
                    var ch = this.source[start];
                    assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
                    var num = "";
                    if (ch !== ".") {
                        num = this.source[this.index++];
                        ch = this.source[this.index];
                        // Hex number starts with '0x'.
                        // Octal number starts with '0'.
                        // Octal number in ES6 starts with '0o'.
                        // Binary number in ES6 starts with '0b'.
                        if (num === "0") {
                            if (ch === "x" || ch === "X") {
                                ++this.index;
                                return this.scanHexLiteral(start);
                            }
                            if (ch === "b" || ch === "B") {
                                ++this.index;
                                return this.scanBinaryLiteral(start);
                            }
                            if (ch === "o" || ch === "O") {
                                return this.scanOctalLiteral(ch, start);
                            }
                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                                if (this.isImplicitOctalLiteral()) {
                                    return this.scanOctalLiteral(ch, start);
                                }
                            }
                        }
                        while(character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))){
                            num += this.source[this.index++];
                        }
                        ch = this.source[this.index];
                    }
                    if (ch === ".") {
                        num += this.source[this.index++];
                        while(character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))){
                            num += this.source[this.index++];
                        }
                        ch = this.source[this.index];
                    }
                    if (ch === "e" || ch === "E") {
                        num += this.source[this.index++];
                        ch = this.source[this.index];
                        if (ch === "+" || ch === "-") {
                            num += this.source[this.index++];
                        }
                        if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                            while(character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))){
                                num += this.source[this.index++];
                            }
                        } else {
                            this.throwUnexpectedToken();
                        }
                    }
                    if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                        this.throwUnexpectedToken();
                    }
                    return {
                        type: 6 /* NumericLiteral */ ,
                        value: parseFloat(num),
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                // https://tc39.github.io/ecma262/#sec-literals-string-literals
                Scanner.prototype.scanStringLiteral = function() {
                    var start = this.index;
                    var quote = this.source[start];
                    assert_1.assert(quote === "'" || quote === '"', "String literal must starts with a quote");
                    ++this.index;
                    var octal = false;
                    var str = "";
                    while(!this.eof()){
                        var ch = this.source[this.index++];
                        if (ch === quote) {
                            quote = "";
                            break;
                        } else if (ch === "\\") {
                            ch = this.source[this.index++];
                            if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                                switch(ch){
                                    case "u":
                                        if (this.source[this.index] === "{") {
                                            ++this.index;
                                            str += this.scanUnicodeCodePointEscape();
                                        } else {
                                            var unescaped_1 = this.scanHexEscape(ch);
                                            if (unescaped_1 === null) {
                                                this.throwUnexpectedToken();
                                            }
                                            str += unescaped_1;
                                        }
                                        break;
                                    case "x":
                                        var unescaped = this.scanHexEscape(ch);
                                        if (unescaped === null) {
                                            this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                                        }
                                        str += unescaped;
                                        break;
                                    case "n":
                                        str += "\n";
                                        break;
                                    case "r":
                                        str += "\r";
                                        break;
                                    case "t":
                                        str += "	";
                                        break;
                                    case "b":
                                        str += "\b";
                                        break;
                                    case "f":
                                        str += "\f";
                                        break;
                                    case "v":
                                        str += "\v";
                                        break;
                                    case "8":
                                    case "9":
                                        str += ch;
                                        this.tolerateUnexpectedToken();
                                        break;
                                    default:
                                        if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                                            var octToDec = this.octalToDecimal(ch);
                                            octal = octToDec.octal || octal;
                                            str += String.fromCharCode(octToDec.code);
                                        } else {
                                            str += ch;
                                        }
                                        break;
                                }
                            } else {
                                ++this.lineNumber;
                                if (ch === "\r" && this.source[this.index] === "\n") {
                                    ++this.index;
                                }
                                this.lineStart = this.index;
                            }
                        } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                            break;
                        } else {
                            str += ch;
                        }
                    }
                    if (quote !== "") {
                        this.index = start;
                        this.throwUnexpectedToken();
                    }
                    return {
                        type: 8 /* StringLiteral */ ,
                        value: str,
                        octal: octal,
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
                Scanner.prototype.scanTemplate = function() {
                    var cooked = "";
                    var terminated = false;
                    var start = this.index;
                    var head = this.source[start] === "`";
                    var tail = false;
                    var rawOffset = 2;
                    ++this.index;
                    while(!this.eof()){
                        var ch = this.source[this.index++];
                        if (ch === "`") {
                            rawOffset = 1;
                            tail = true;
                            terminated = true;
                            break;
                        } else if (ch === "$") {
                            if (this.source[this.index] === "{") {
                                this.curlyStack.push("${");
                                ++this.index;
                                terminated = true;
                                break;
                            }
                            cooked += ch;
                        } else if (ch === "\\") {
                            ch = this.source[this.index++];
                            if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                                switch(ch){
                                    case "n":
                                        cooked += "\n";
                                        break;
                                    case "r":
                                        cooked += "\r";
                                        break;
                                    case "t":
                                        cooked += "	";
                                        break;
                                    case "u":
                                        if (this.source[this.index] === "{") {
                                            ++this.index;
                                            cooked += this.scanUnicodeCodePointEscape();
                                        } else {
                                            var restore = this.index;
                                            var unescaped_2 = this.scanHexEscape(ch);
                                            if (unescaped_2 !== null) {
                                                cooked += unescaped_2;
                                            } else {
                                                this.index = restore;
                                                cooked += ch;
                                            }
                                        }
                                        break;
                                    case "x":
                                        var unescaped = this.scanHexEscape(ch);
                                        if (unescaped === null) {
                                            this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                                        }
                                        cooked += unescaped;
                                        break;
                                    case "b":
                                        cooked += "\b";
                                        break;
                                    case "f":
                                        cooked += "\f";
                                        break;
                                    case "v":
                                        cooked += "\v";
                                        break;
                                    default:
                                        if (ch === "0") {
                                            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                                                // Illegal: \01 \02 and so on
                                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                                            }
                                            cooked += "\x00";
                                        } else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                                            // Illegal: \1 \2
                                            this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                                        } else {
                                            cooked += ch;
                                        }
                                        break;
                                }
                            } else {
                                ++this.lineNumber;
                                if (ch === "\r" && this.source[this.index] === "\n") {
                                    ++this.index;
                                }
                                this.lineStart = this.index;
                            }
                        } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                            ++this.lineNumber;
                            if (ch === "\r" && this.source[this.index] === "\n") {
                                ++this.index;
                            }
                            this.lineStart = this.index;
                            cooked += "\n";
                        } else {
                            cooked += ch;
                        }
                    }
                    if (!terminated) {
                        this.throwUnexpectedToken();
                    }
                    if (!head) {
                        this.curlyStack.pop();
                    }
                    return {
                        type: 10 /* Template */ ,
                        value: this.source.slice(start + 1, this.index - rawOffset),
                        cooked: cooked,
                        head: head,
                        tail: tail,
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
                Scanner.prototype.testRegExp = function(pattern, flags) {
                    // The BMP character to use as a replacement for astral symbols when
                    // translating an ES6 "u"-flagged pattern to an ES5-compatible
                    // approximation.
                    // Note: replacing with '\uFFFF' enables false positives in unlikely
                    // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
                    // pattern that would not be detected by this substitution.
                    var astralSubstitute = "￿";
                    var tmp = pattern;
                    var self = this;
                    if (flags.indexOf("u") >= 0) {
                        tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
                            var codePoint = parseInt($1 || $2, 16);
                            if (codePoint > 0x10FFFF) {
                                self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                            }
                            if (codePoint <= 0xFFFF) {
                                return String.fromCharCode(codePoint);
                            }
                            return astralSubstitute;
                        }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
                    }
                    // First, detect invalid regular expressions.
                    try {
                        RegExp(tmp);
                    } catch (e) {
                        this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                    }
                    // Return a regular expression object for this pattern-flag pair, or
                    // `null` in case the current environment doesn't support the flags it
                    // uses.
                    try {
                        return new RegExp(pattern, flags);
                    } catch (exception) {
                        /* istanbul ignore next */ return null;
                    }
                };
                Scanner.prototype.scanRegExpBody = function() {
                    var ch = this.source[this.index];
                    assert_1.assert(ch === "/", "Regular expression literal must start with a slash");
                    var str = this.source[this.index++];
                    var classMarker = false;
                    var terminated = false;
                    while(!this.eof()){
                        ch = this.source[this.index++];
                        str += ch;
                        if (ch === "\\") {
                            ch = this.source[this.index++];
                            // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
                            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                            }
                            str += ch;
                        } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                        } else if (classMarker) {
                            if (ch === "]") {
                                classMarker = false;
                            }
                        } else {
                            if (ch === "/") {
                                terminated = true;
                                break;
                            } else if (ch === "[") {
                                classMarker = true;
                            }
                        }
                    }
                    if (!terminated) {
                        this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                    }
                    // Exclude leading and trailing slash.
                    return str.substr(1, str.length - 2);
                };
                Scanner.prototype.scanRegExpFlags = function() {
                    var str = "";
                    var flags = "";
                    while(!this.eof()){
                        var ch = this.source[this.index];
                        if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                            break;
                        }
                        ++this.index;
                        if (ch === "\\" && !this.eof()) {
                            ch = this.source[this.index];
                            if (ch === "u") {
                                ++this.index;
                                var restore = this.index;
                                var char = this.scanHexEscape("u");
                                if (char !== null) {
                                    flags += char;
                                    for(str += "\\u"; restore < this.index; ++restore){
                                        str += this.source[restore];
                                    }
                                } else {
                                    this.index = restore;
                                    flags += "u";
                                    str += "\\u";
                                }
                                this.tolerateUnexpectedToken();
                            } else {
                                str += "\\";
                                this.tolerateUnexpectedToken();
                            }
                        } else {
                            flags += ch;
                            str += ch;
                        }
                    }
                    return flags;
                };
                Scanner.prototype.scanRegExp = function() {
                    var start = this.index;
                    var pattern = this.scanRegExpBody();
                    var flags = this.scanRegExpFlags();
                    var value = this.testRegExp(pattern, flags);
                    return {
                        type: 9 /* RegularExpression */ ,
                        value: "",
                        pattern: pattern,
                        flags: flags,
                        regex: value,
                        lineNumber: this.lineNumber,
                        lineStart: this.lineStart,
                        start: start,
                        end: this.index
                    };
                };
                Scanner.prototype.lex = function() {
                    if (this.eof()) {
                        return {
                            type: 2 /* EOF */ ,
                            value: "",
                            lineNumber: this.lineNumber,
                            lineStart: this.lineStart,
                            start: this.index,
                            end: this.index
                        };
                    }
                    var cp = this.source.charCodeAt(this.index);
                    if (character_1.Character.isIdentifierStart(cp)) {
                        return this.scanIdentifier();
                    }
                    // Very common: ( and ) and ;
                    if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
                        return this.scanPunctuator();
                    }
                    // String literal starts with single quote (U+0027) or double quote (U+0022).
                    if (cp === 0x27 || cp === 0x22) {
                        return this.scanStringLiteral();
                    }
                    // Dot (.) U+002E can also start a floating-point number, hence the need
                    // to check the next character.
                    if (cp === 0x2E) {
                        if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                            return this.scanNumericLiteral();
                        }
                        return this.scanPunctuator();
                    }
                    if (character_1.Character.isDecimalDigit(cp)) {
                        return this.scanNumericLiteral();
                    }
                    // Template literals start with ` (U+0060) for template head
                    // or } (U+007D) for template middle or template tail.
                    if (cp === 0x60 || cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === "${") {
                        return this.scanTemplate();
                    }
                    // Possible identifier start in a surrogate pair.
                    if (cp >= 0xD800 && cp < 0xDFFF) {
                        if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                            return this.scanIdentifier();
                        }
                    }
                    return this.scanPunctuator();
                };
                return Scanner;
            }();
            exports1.Scanner = Scanner;
        /***/ },
        /* 13 */ /***/ function(module1, exports1) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            exports1.TokenName = {};
            exports1.TokenName[1 /* BooleanLiteral */ ] = "Boolean";
            exports1.TokenName[2 /* EOF */ ] = "<end>";
            exports1.TokenName[3 /* Identifier */ ] = "Identifier";
            exports1.TokenName[4 /* Keyword */ ] = "Keyword";
            exports1.TokenName[5 /* NullLiteral */ ] = "Null";
            exports1.TokenName[6 /* NumericLiteral */ ] = "Numeric";
            exports1.TokenName[7 /* Punctuator */ ] = "Punctuator";
            exports1.TokenName[8 /* StringLiteral */ ] = "String";
            exports1.TokenName[9 /* RegularExpression */ ] = "RegularExpression";
            exports1.TokenName[10 /* Template */ ] = "Template";
        /***/ },
        /* 14 */ /***/ function(module1, exports1) {
            "use strict";
            // Generated by generate-xhtml-entities.js. DO NOT MODIFY!
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            exports1.XHTMLEntities = {
                quot: '"',
                amp: "&",
                apos: "'",
                gt: ">",
                nbsp: "\xa0",
                iexcl: "\xa1",
                cent: "\xa2",
                pound: "\xa3",
                curren: "\xa4",
                yen: "\xa5",
                brvbar: "\xa6",
                sect: "\xa7",
                uml: "\xa8",
                copy: "\xa9",
                ordf: "\xaa",
                laquo: "\xab",
                not: "\xac",
                shy: "\xad",
                reg: "\xae",
                macr: "\xaf",
                deg: "\xb0",
                plusmn: "\xb1",
                sup2: "\xb2",
                sup3: "\xb3",
                acute: "\xb4",
                micro: "\xb5",
                para: "\xb6",
                middot: "\xb7",
                cedil: "\xb8",
                sup1: "\xb9",
                ordm: "\xba",
                raquo: "\xbb",
                frac14: "\xbc",
                frac12: "\xbd",
                frac34: "\xbe",
                iquest: "\xbf",
                Agrave: "\xc0",
                Aacute: "\xc1",
                Acirc: "\xc2",
                Atilde: "\xc3",
                Auml: "\xc4",
                Aring: "\xc5",
                AElig: "\xc6",
                Ccedil: "\xc7",
                Egrave: "\xc8",
                Eacute: "\xc9",
                Ecirc: "\xca",
                Euml: "\xcb",
                Igrave: "\xcc",
                Iacute: "\xcd",
                Icirc: "\xce",
                Iuml: "\xcf",
                ETH: "\xd0",
                Ntilde: "\xd1",
                Ograve: "\xd2",
                Oacute: "\xd3",
                Ocirc: "\xd4",
                Otilde: "\xd5",
                Ouml: "\xd6",
                times: "\xd7",
                Oslash: "\xd8",
                Ugrave: "\xd9",
                Uacute: "\xda",
                Ucirc: "\xdb",
                Uuml: "\xdc",
                Yacute: "\xdd",
                THORN: "\xde",
                szlig: "\xdf",
                agrave: "\xe0",
                aacute: "\xe1",
                acirc: "\xe2",
                atilde: "\xe3",
                auml: "\xe4",
                aring: "\xe5",
                aelig: "\xe6",
                ccedil: "\xe7",
                egrave: "\xe8",
                eacute: "\xe9",
                ecirc: "\xea",
                euml: "\xeb",
                igrave: "\xec",
                iacute: "\xed",
                icirc: "\xee",
                iuml: "\xef",
                eth: "\xf0",
                ntilde: "\xf1",
                ograve: "\xf2",
                oacute: "\xf3",
                ocirc: "\xf4",
                otilde: "\xf5",
                ouml: "\xf6",
                divide: "\xf7",
                oslash: "\xf8",
                ugrave: "\xf9",
                uacute: "\xfa",
                ucirc: "\xfb",
                uuml: "\xfc",
                yacute: "\xfd",
                thorn: "\xfe",
                yuml: "\xff",
                OElig: "Œ",
                oelig: "œ",
                Scaron: "Š",
                scaron: "š",
                Yuml: "Ÿ",
                fnof: "ƒ",
                circ: "ˆ",
                tilde: "˜",
                Alpha: "Α",
                Beta: "Β",
                Gamma: "Γ",
                Delta: "Δ",
                Epsilon: "Ε",
                Zeta: "Ζ",
                Eta: "Η",
                Theta: "Θ",
                Iota: "Ι",
                Kappa: "Κ",
                Lambda: "Λ",
                Mu: "Μ",
                Nu: "Ν",
                Xi: "Ξ",
                Omicron: "Ο",
                Pi: "Π",
                Rho: "Ρ",
                Sigma: "Σ",
                Tau: "Τ",
                Upsilon: "Υ",
                Phi: "Φ",
                Chi: "Χ",
                Psi: "Ψ",
                Omega: "Ω",
                alpha: "α",
                beta: "β",
                gamma: "γ",
                delta: "δ",
                epsilon: "ε",
                zeta: "ζ",
                eta: "η",
                theta: "θ",
                iota: "ι",
                kappa: "κ",
                lambda: "λ",
                mu: "μ",
                nu: "ν",
                xi: "ξ",
                omicron: "ο",
                pi: "π",
                rho: "ρ",
                sigmaf: "ς",
                sigma: "σ",
                tau: "τ",
                upsilon: "υ",
                phi: "φ",
                chi: "χ",
                psi: "ψ",
                omega: "ω",
                thetasym: "ϑ",
                upsih: "ϒ",
                piv: "ϖ",
                ensp: " ",
                emsp: " ",
                thinsp: " ",
                zwnj: "‌",
                zwj: "‍",
                lrm: "‎",
                rlm: "‏",
                ndash: "–",
                mdash: "—",
                lsquo: "‘",
                rsquo: "’",
                sbquo: "‚",
                ldquo: "“",
                rdquo: "”",
                bdquo: "„",
                dagger: "†",
                Dagger: "‡",
                bull: "•",
                hellip: "…",
                permil: "‰",
                prime: "′",
                Prime: "″",
                lsaquo: "‹",
                rsaquo: "›",
                oline: "‾",
                frasl: "⁄",
                euro: "€",
                image: "ℑ",
                weierp: "℘",
                real: "ℜ",
                trade: "™",
                alefsym: "ℵ",
                larr: "←",
                uarr: "↑",
                rarr: "→",
                darr: "↓",
                harr: "↔",
                crarr: "↵",
                lArr: "⇐",
                uArr: "⇑",
                rArr: "⇒",
                dArr: "⇓",
                hArr: "⇔",
                forall: "∀",
                part: "∂",
                exist: "∃",
                empty: "∅",
                nabla: "∇",
                isin: "∈",
                notin: "∉",
                ni: "∋",
                prod: "∏",
                sum: "∑",
                minus: "−",
                lowast: "∗",
                radic: "√",
                prop: "∝",
                infin: "∞",
                ang: "∠",
                and: "∧",
                or: "∨",
                cap: "∩",
                cup: "∪",
                int: "∫",
                there4: "∴",
                sim: "∼",
                cong: "≅",
                asymp: "≈",
                ne: "≠",
                equiv: "≡",
                le: "≤",
                ge: "≥",
                sub: "⊂",
                sup: "⊃",
                nsub: "⊄",
                sube: "⊆",
                supe: "⊇",
                oplus: "⊕",
                otimes: "⊗",
                perp: "⊥",
                sdot: "⋅",
                lceil: "⌈",
                rceil: "⌉",
                lfloor: "⌊",
                rfloor: "⌋",
                loz: "◊",
                spades: "♠",
                clubs: "♣",
                hearts: "♥",
                diams: "♦",
                lang: "⟨",
                rang: "⟩"
            };
        /***/ },
        /* 15 */ /***/ function(module1, exports1, __nested_webpack_require_343122__) {
            "use strict";
            Object.defineProperty(exports1, "__esModule", {
                value: true
            });
            var error_handler_1 = __nested_webpack_require_343122__(10);
            var scanner_1 = __nested_webpack_require_343122__(12);
            var token_1 = __nested_webpack_require_343122__(13);
            var Reader = function() {
                function Reader() {
                    this.values = [];
                    this.curly = this.paren = -1;
                }
                // A function following one of those tokens is an expression.
                Reader.prototype.beforeFunctionExpression = function(t) {
                    return [
                        "(",
                        "{",
                        "[",
                        "in",
                        "typeof",
                        "instanceof",
                        "new",
                        "return",
                        "case",
                        "delete",
                        "throw",
                        "void",
                        // assignment operators
                        "=",
                        "+=",
                        "-=",
                        "*=",
                        "**=",
                        "/=",
                        "%=",
                        "<<=",
                        ">>=",
                        ">>>=",
                        "&=",
                        "|=",
                        "^=",
                        ",",
                        // binary/unary operators
                        "+",
                        "-",
                        "*",
                        "**",
                        "/",
                        "%",
                        "++",
                        "--",
                        "<<",
                        ">>",
                        ">>>",
                        "&",
                        "|",
                        "^",
                        "!",
                        "~",
                        "&&",
                        "||",
                        "?",
                        ":",
                        "===",
                        "==",
                        ">=",
                        "<=",
                        "<",
                        ">",
                        "!=",
                        "!=="
                    ].indexOf(t) >= 0;
                };
                // Determine if forward slash (/) is an operator or part of a regular expression
                // https://github.com/mozilla/sweet.js/wiki/design
                Reader.prototype.isRegexStart = function() {
                    var previous = this.values[this.values.length - 1];
                    var regex = previous !== null;
                    switch(previous){
                        case "this":
                        case "]":
                            regex = false;
                            break;
                        case ")":
                            var keyword = this.values[this.paren - 1];
                            regex = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
                            break;
                        case "}":
                            // Dividing a function by anything makes little sense,
                            // but we have to check for that.
                            regex = false;
                            if (this.values[this.curly - 3] === "function") {
                                // Anonymous function, e.g. function(){} /42
                                var check = this.values[this.curly - 4];
                                regex = check ? !this.beforeFunctionExpression(check) : false;
                            } else if (this.values[this.curly - 4] === "function") {
                                // Named function, e.g. function f(){} /42/
                                var check = this.values[this.curly - 5];
                                regex = check ? !this.beforeFunctionExpression(check) : true;
                            }
                            break;
                        default:
                            break;
                    }
                    return regex;
                };
                Reader.prototype.push = function(token) {
                    if (token.type === 7 /* Punctuator */  || token.type === 4 /* Keyword */ ) {
                        if (token.value === "{") {
                            this.curly = this.values.length;
                        } else if (token.value === "(") {
                            this.paren = this.values.length;
                        }
                        this.values.push(token.value);
                    } else {
                        this.values.push(null);
                    }
                };
                return Reader;
            }();
            var Tokenizer = function() {
                function Tokenizer(code, config) {
                    this.errorHandler = new error_handler_1.ErrorHandler();
                    this.errorHandler.tolerant = config ? typeof config.tolerant === "boolean" && config.tolerant : false;
                    this.scanner = new scanner_1.Scanner(code, this.errorHandler);
                    this.scanner.trackComment = config ? typeof config.comment === "boolean" && config.comment : false;
                    this.trackRange = config ? typeof config.range === "boolean" && config.range : false;
                    this.trackLoc = config ? typeof config.loc === "boolean" && config.loc : false;
                    this.buffer = [];
                    this.reader = new Reader();
                }
                Tokenizer.prototype.errors = function() {
                    return this.errorHandler.errors;
                };
                Tokenizer.prototype.getNextToken = function() {
                    if (this.buffer.length === 0) {
                        var comments = this.scanner.scanComments();
                        if (this.scanner.trackComment) {
                            for(var i = 0; i < comments.length; ++i){
                                var e = comments[i];
                                var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
                                var comment = {
                                    type: e.multiLine ? "BlockComment" : "LineComment",
                                    value: value
                                };
                                if (this.trackRange) {
                                    comment.range = e.range;
                                }
                                if (this.trackLoc) {
                                    comment.loc = e.loc;
                                }
                                this.buffer.push(comment);
                            }
                        }
                        if (!this.scanner.eof()) {
                            var loc = void 0;
                            if (this.trackLoc) {
                                loc = {
                                    start: {
                                        line: this.scanner.lineNumber,
                                        column: this.scanner.index - this.scanner.lineStart
                                    },
                                    end: {}
                                };
                            }
                            var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                            var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                            this.reader.push(token);
                            var entry = {
                                type: token_1.TokenName[token.type],
                                value: this.scanner.source.slice(token.start, token.end)
                            };
                            if (this.trackRange) {
                                entry.range = [
                                    token.start,
                                    token.end
                                ];
                            }
                            if (this.trackLoc) {
                                loc.end = {
                                    line: this.scanner.lineNumber,
                                    column: this.scanner.index - this.scanner.lineStart
                                };
                                entry.loc = loc;
                            }
                            if (token.type === 9 /* RegularExpression */ ) {
                                var pattern = token.pattern;
                                var flags = token.flags;
                                entry.regex = {
                                    pattern: pattern,
                                    flags: flags
                                };
                            }
                            this.buffer.push(entry);
                        }
                    }
                    return this.buffer.shift();
                };
                return Tokenizer;
            }();
            exports1.Tokenizer = Tokenizer;
        /***/ }
    ]);
});
;


/***/ }),

/***/ 71807:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(14859);
var util_1 = __webpack_require__(96883);
var util_2 = __webpack_require__(57294);
var _1 = __webpack_require__(94949);
var dom_1 = __webpack_require__(99178);
/** @inheritdoc */ function builder(p1, p2) {
    var options = formatBuilderOptions(isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
    var nodes = util_2.Guard.isNode(p1) || util_1.isArray(p1) ? p1 : p2;
    if (nodes === undefined) {
        throw new Error("Invalid arguments.");
    }
    if (util_1.isArray(nodes)) {
        var builders = [];
        for(var i = 0; i < nodes.length; i++){
            var builder_1 = new _1.XMLBuilderImpl(nodes[i]);
            builder_1.set(options);
            builders.push(builder_1);
        }
        return builders;
    } else {
        var builder_2 = new _1.XMLBuilderImpl(nodes);
        builder_2.set(options);
        return builder_2;
    }
}
exports.builder = builder;
/** @inheritdoc */ function create(p1, p2) {
    var options = formatBuilderOptions(p1 === undefined || isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
    var contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;
    var doc = dom_1.createDocument();
    setOptions(doc, options);
    var builder = new _1.XMLBuilderImpl(doc);
    if (contents !== undefined) {
        // parse contents
        builder.ele(contents);
    }
    return builder;
}
exports.create = create;
/** @inheritdoc */ function fragment(p1, p2) {
    var options = formatBuilderOptions(p1 === undefined || isXMLBuilderCreateOptions(p1) ? p1 : interfaces_1.DefaultBuilderOptions);
    var contents = isXMLBuilderCreateOptions(p1) ? p2 : p1;
    var doc = dom_1.createDocument();
    setOptions(doc, options, true);
    var builder = new _1.XMLBuilderImpl(doc.createDocumentFragment());
    if (contents !== undefined) {
        // parse contents
        builder.ele(contents);
    }
    return builder;
}
exports.fragment = fragment;
/** @inheritdoc */ function convert(p1, p2, p3) {
    var builderOptions;
    var contents;
    var convertOptions;
    if (isXMLBuilderCreateOptions(p1) && p2 !== undefined) {
        builderOptions = p1;
        contents = p2;
        convertOptions = p3;
    } else {
        builderOptions = interfaces_1.DefaultBuilderOptions;
        contents = p1;
        convertOptions = p2 || undefined;
    }
    return create(builderOptions, contents).end(convertOptions);
}
exports.convert = convert;
function isXMLBuilderCreateOptions(obj) {
    if (!util_1.isPlainObject(obj)) return false;
    for(var key in obj){
        /* istanbul ignore else */ if (obj.hasOwnProperty(key)) {
            if (!interfaces_1.XMLBuilderOptionKeys.has(key)) return false;
        }
    }
    return true;
}
function formatBuilderOptions(createOptions) {
    if (createOptions === void 0) {
        createOptions = {};
    }
    var options = util_1.applyDefaults(createOptions, interfaces_1.DefaultBuilderOptions);
    if (options.convert.att.length === 0 || options.convert.ins.length === 0 || options.convert.text.length === 0 || options.convert.cdata.length === 0 || options.convert.comment.length === 0) {
        throw new Error("JS object converter strings cannot be zero length.");
    }
    return options;
}
function setOptions(doc, options, isFragment) {
    var docWithSettings = doc;
    docWithSettings._xmlBuilderOptions = options;
    docWithSettings._isFragment = isFragment;
} //# sourceMappingURL=BuilderFunctions.js.map


/***/ }),

/***/ 10309:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _1 = __webpack_require__(94949);
/**
 * Creates an XML builder which serializes the document in chunks.
 *
 * @param options - callback builder options
 *
 * @returns callback builder
 */ function createCB(options) {
    return new _1.XMLBuilderCBImpl(options);
}
exports.createCB = createCB;
/**
 * Creates an XML builder which serializes the fragment in chunks.
 *
 * @param options - callback builder options
 *
 * @returns callback builder
 */ function fragmentCB(options) {
    return new _1.XMLBuilderCBImpl(options, true);
}
exports.fragmentCB = fragmentCB; //# sourceMappingURL=BuilderFunctionsCB.js.map


/***/ }),

/***/ 81855:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(14859);
var util_1 = __webpack_require__(96883);
var BuilderFunctions_1 = __webpack_require__(71807);
var algorithm_1 = __webpack_require__(75306);
var infra_1 = __webpack_require__(94317);
var NamespacePrefixMap_1 = __webpack_require__(83771);
var LocalNameSet_1 = __webpack_require__(3367);
var util_2 = __webpack_require__(57294);
var XMLCBWriter_1 = __webpack_require__(29494);
var JSONCBWriter_1 = __webpack_require__(93265);
var YAMLCBWriter_1 = __webpack_require__(51043);
var events_1 = __webpack_require__(82361);
/**
 * Represents a readable XML document stream.
 */ var XMLBuilderCBImpl = /** @class */ function(_super) {
    __extends(XMLBuilderCBImpl, _super);
    /**
     * Initializes a new instance of `XMLStream`.
     *
     * @param options - stream writer options
     * @param fragment - whether to create fragment stream or a document stream
     *
     * @returns XML stream
     */ function XMLBuilderCBImpl(options, fragment) {
        if (fragment === void 0) {
            fragment = false;
        }
        var _this = _super.call(this) || this;
        _this._hasDeclaration = false;
        _this._docTypeName = "";
        _this._hasDocumentElement = false;
        _this._currentElementSerialized = false;
        _this._openTags = [];
        _this._ended = false;
        _this._fragment = fragment;
        // provide default options
        _this._options = util_1.applyDefaults(options || {}, interfaces_1.DefaultXMLBuilderCBOptions);
        _this._builderOptions = {
            defaultNamespace: _this._options.defaultNamespace,
            namespaceAlias: _this._options.namespaceAlias
        };
        if (_this._options.format === "json") {
            _this._writer = new JSONCBWriter_1.JSONCBWriter(_this._options);
        } else if (_this._options.format === "yaml") {
            _this._writer = new YAMLCBWriter_1.YAMLCBWriter(_this._options);
        } else {
            _this._writer = new XMLCBWriter_1.XMLCBWriter(_this._options);
        }
        // automatically create listeners for callbacks passed via options
        if (_this._options.data !== undefined) {
            _this.on("data", _this._options.data);
        }
        if (_this._options.end !== undefined) {
            _this.on("end", _this._options.end);
        }
        if (_this._options.error !== undefined) {
            _this.on("error", _this._options.error);
        }
        _this._prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();
        _this._prefixMap.set("xml", infra_1.namespace.XML);
        _this._prefixIndex = {
            value: 1
        };
        _this._push(_this._writer.frontMatter());
        return _this;
    }
    /** @inheritdoc */ XMLBuilderCBImpl.prototype.ele = function(p1, p2, p3) {
        var e_1, _a;
        // parse if JS object or XML or JSON string
        if (util_1.isObject(p1) || util_1.isString(p1) && (/^\s*</.test(p1) || /^\s*[\{\[]/.test(p1) || /^(\s*|(#.*)|(%.*))*---/.test(p1))) {
            var frag = BuilderFunctions_1.fragment().set(this._options);
            try {
                frag.ele(p1);
            } catch (err) {
                this.emit("error", err);
                return this;
            }
            try {
                for(var _b = __values(frag.node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()){
                    var node = _c.value;
                    this._fromNode(node);
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            return this;
        }
        this._serializeOpenTag(true);
        if (!this._fragment && this._hasDocumentElement && this._writer.level === 0) {
            this.emit("error", new Error("Document cannot have multiple document element nodes."));
            return this;
        }
        try {
            this._currentElement = BuilderFunctions_1.fragment(this._builderOptions).ele(p1, p2, p3);
        } catch (err) {
            this.emit("error", err);
            return this;
        }
        if (!this._fragment && !this._hasDocumentElement && this._docTypeName !== "" && this._currentElement.node._qualifiedName !== this._docTypeName) {
            this.emit("error", new Error("Document element name does not match DocType declaration name."));
            return this;
        }
        this._currentElementSerialized = false;
        if (!this._fragment) {
            this._hasDocumentElement = true;
        }
        return this;
    };
    /** @inheritdoc */ XMLBuilderCBImpl.prototype.att = function(p1, p2, p3) {
        if (this._currentElement === undefined) {
            this.emit("error", new Error("Cannot insert an attribute node as child of a document node."));
            return this;
        }
        try {
            this._currentElement.att(p1, p2, p3);
        } catch (err) {
            this.emit("error", err);
            return this;
        }
        return this;
    };
    /** @inheritdoc */ XMLBuilderCBImpl.prototype.com = function(content) {
        this._serializeOpenTag(true);
        var node;
        try {
            node = BuilderFunctions_1.fragment(this._builderOptions).com(content).first().node;
        } catch (err) {
            /* istanbul ignore next */ this.emit("error", err);
            /* istanbul ignore next */ return this;
        }
        if (this._options.wellFormed && (!algorithm_1.xml_isLegalChar(node.data) || node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
            this.emit("error", new Error("Comment data contains invalid characters (well-formed required)."));
            return this;
        }
        this._push(this._writer.comment(node.data));
        return this;
    };
    /** @inheritdoc */ XMLBuilderCBImpl.prototype.txt = function(content) {
        if (!this._fragment && this._currentElement === undefined) {
            this.emit("error", new Error("Cannot insert a text node as child of a document node."));
            return this;
        }
        this._serializeOpenTag(true);
        var node;
        try {
            node = BuilderFunctions_1.fragment(this._builderOptions).txt(content).first().node;
        } catch (err) {
            /* istanbul ignore next */ this.emit("error", err);
            /* istanbul ignore next */ return this;
        }
        if (this._options.wellFormed && !algorithm_1.xml_isLegalChar(node.data)) {
            this.emit("error", new Error("Text data contains invalid characters (well-formed required)."));
            return this;
        }
        var markup = node.data.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        this._push(this._writer.text(markup));
        return this;
    };
    /** @inheritdoc */ XMLBuilderCBImpl.prototype.ins = function(target, content) {
        if (content === void 0) {
            content = "";
        }
        this._serializeOpenTag(true);
        var node;
        try {
            node = BuilderFunctions_1.fragment(this._builderOptions).ins(target, content).first().node;
        } catch (err) {
            /* istanbul ignore next */ this.emit("error", err);
            /* istanbul ignore next */ return this;
        }
        if (this._options.wellFormed && (node.target.indexOf(":") !== -1 || /^xml$/i.test(node.target))) {
            this.emit("error", new Error("Processing instruction target contains invalid characters (well-formed required)."));
            return this;
        }
        if (this._options.wellFormed && !algorithm_1.xml_isLegalChar(node.data)) {
            this.emit("error", Error("Processing instruction data contains invalid characters (well-formed required)."));
            return this;
        }
        this._push(this._writer.instruction(node.target, node.data));
        return this;
    };
    /** @inheritdoc */ XMLBuilderCBImpl.prototype.dat = function(content) {
        this._serializeOpenTag(true);
        var node;
        try {
            node = BuilderFunctions_1.fragment(this._builderOptions).dat(content).first().node;
        } catch (err) {
            this.emit("error", err);
            return this;
        }
        this._push(this._writer.cdata(node.data));
        return this;
    };
    /** @inheritdoc */ XMLBuilderCBImpl.prototype.dec = function(options) {
        if (options === void 0) {
            options = {
                version: "1.0"
            };
        }
        if (this._fragment) {
            this.emit("error", Error("Cannot insert an XML declaration into a document fragment."));
            return this;
        }
        if (this._hasDeclaration) {
            this.emit("error", Error("XML declaration is already inserted."));
            return this;
        }
        this._push(this._writer.declaration(options.version || "1.0", options.encoding, options.standalone));
        this._hasDeclaration = true;
        return this;
    };
    /** @inheritdoc */ XMLBuilderCBImpl.prototype.dtd = function(options) {
        if (this._fragment) {
            this.emit("error", Error("Cannot insert a DocType declaration into a document fragment."));
            return this;
        }
        if (this._docTypeName !== "") {
            this.emit("error", new Error("DocType declaration is already inserted."));
            return this;
        }
        if (this._hasDocumentElement) {
            this.emit("error", new Error("Cannot insert DocType declaration after document element."));
            return this;
        }
        var node;
        try {
            node = BuilderFunctions_1.create().dtd(options).first().node;
        } catch (err) {
            this.emit("error", err);
            return this;
        }
        if (this._options.wellFormed && !algorithm_1.xml_isPubidChar(node.publicId)) {
            this.emit("error", new Error("DocType public identifier does not match PubidChar construct (well-formed required)."));
            return this;
        }
        if (this._options.wellFormed && (!algorithm_1.xml_isLegalChar(node.systemId) || node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1)) {
            this.emit("error", new Error("DocType system identifier contains invalid characters (well-formed required)."));
            return this;
        }
        this._docTypeName = options.name;
        this._push(this._writer.docType(options.name, node.publicId, node.systemId));
        return this;
    };
    /** @inheritdoc */ XMLBuilderCBImpl.prototype.import = function(node) {
        var e_2, _a;
        var frag = BuilderFunctions_1.fragment().set(this._options);
        try {
            frag.import(node);
        } catch (err) {
            this.emit("error", err);
            return this;
        }
        try {
            for(var _b = __values(frag.node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()){
                var node_1 = _c.value;
                this._fromNode(node_1);
            }
        } catch (e_2_1) {
            e_2 = {
                error: e_2_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_2) throw e_2.error;
            }
        }
        return this;
    };
    /** @inheritdoc */ XMLBuilderCBImpl.prototype.up = function() {
        this._serializeOpenTag(false);
        this._serializeCloseTag();
        return this;
    };
    /** @inheritdoc */ XMLBuilderCBImpl.prototype.end = function() {
        this._serializeOpenTag(false);
        while(this._openTags.length > 0){
            this._serializeCloseTag();
        }
        this._push(null);
        return this;
    };
    /**
     * Serializes the opening tag of an element node.
     *
     * @param hasChildren - whether the element node has child nodes
     */ XMLBuilderCBImpl.prototype._serializeOpenTag = function(hasChildren) {
        if (this._currentElementSerialized) return;
        if (this._currentElement === undefined) return;
        var node = this._currentElement.node;
        if (this._options.wellFormed && (node.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(node.localName))) {
            this.emit("error", new Error("Node local name contains invalid characters (well-formed required)."));
            return;
        }
        var qualifiedName = "";
        var ignoreNamespaceDefinitionAttribute = false;
        var map = this._prefixMap.copy();
        var localPrefixesMap = {};
        var localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
        var inheritedNS = this._openTags.length === 0 ? null : this._openTags[this._openTags.length - 1][1];
        var ns = node.namespaceURI;
        if (ns === null) ns = inheritedNS;
        if (inheritedNS === ns) {
            if (localDefaultNamespace !== null) {
                ignoreNamespaceDefinitionAttribute = true;
            }
            if (ns === infra_1.namespace.XML) {
                qualifiedName = "xml:" + node.localName;
            } else {
                qualifiedName = node.localName;
            }
            this._writer.beginElement(qualifiedName);
            this._push(this._writer.openTagBegin(qualifiedName));
        } else {
            var prefix = node.prefix;
            var candidatePrefix = null;
            if (prefix !== null || ns !== localDefaultNamespace) {
                candidatePrefix = map.get(prefix, ns);
            }
            if (prefix === "xmlns") {
                if (this._options.wellFormed) {
                    this.emit("error", new Error("An element cannot have the 'xmlns' prefix (well-formed required)."));
                    return;
                }
                candidatePrefix = prefix;
            }
            if (candidatePrefix !== null) {
                qualifiedName = candidatePrefix + ":" + node.localName;
                if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
                    inheritedNS = localDefaultNamespace || null;
                }
                this._writer.beginElement(qualifiedName);
                this._push(this._writer.openTagBegin(qualifiedName));
            } else if (prefix !== null) {
                if (prefix in localPrefixesMap) {
                    prefix = this._generatePrefix(ns, map, this._prefixIndex);
                }
                map.set(prefix, ns);
                qualifiedName += prefix + ":" + node.localName;
                this._writer.beginElement(qualifiedName);
                this._push(this._writer.openTagBegin(qualifiedName));
                this._push(this._writer.attribute("xmlns:" + prefix, this._serializeAttributeValue(ns, this._options.wellFormed)));
                if (localDefaultNamespace !== null) {
                    inheritedNS = localDefaultNamespace || null;
                }
            } else if (localDefaultNamespace === null || localDefaultNamespace !== null && localDefaultNamespace !== ns) {
                ignoreNamespaceDefinitionAttribute = true;
                qualifiedName += node.localName;
                inheritedNS = ns;
                this._writer.beginElement(qualifiedName);
                this._push(this._writer.openTagBegin(qualifiedName));
                this._push(this._writer.attribute("xmlns", this._serializeAttributeValue(ns, this._options.wellFormed)));
            } else {
                qualifiedName += node.localName;
                inheritedNS = ns;
                this._writer.beginElement(qualifiedName);
                this._push(this._writer.openTagBegin(qualifiedName));
            }
        }
        this._serializeAttributes(node, map, this._prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, this._options.wellFormed);
        var isHTML = ns === infra_1.namespace.HTML;
        if (isHTML && !hasChildren && XMLBuilderCBImpl._VoidElementNames.has(node.localName)) {
            this._push(this._writer.openTagEnd(qualifiedName, true, true));
            this._writer.endElement(qualifiedName);
        } else if (!isHTML && !hasChildren) {
            this._push(this._writer.openTagEnd(qualifiedName, true, false));
            this._writer.endElement(qualifiedName);
        } else {
            this._push(this._writer.openTagEnd(qualifiedName, false, false));
        }
        this._currentElementSerialized = true;
        /**
         * Save qualified name, original inherited ns, original prefix map, and
         * hasChildren flag.
         */ this._openTags.push([
            qualifiedName,
            inheritedNS,
            this._prefixMap,
            hasChildren
        ]);
        /**
         * New values of inherited namespace and prefix map will be used while
         * serializing child nodes. They will be returned to their original values
         * when this node is closed using the _openTags array item we saved above.
         */ if (this._isPrefixMapModified(this._prefixMap, map)) {
            this._prefixMap = map;
        }
        /**
         * Calls following this will either serialize child nodes or close this tag.
         */ this._writer.level++;
    };
    /**
     * Serializes the closing tag of an element node.
     */ XMLBuilderCBImpl.prototype._serializeCloseTag = function() {
        this._writer.level--;
        var lastEle = this._openTags.pop();
        /* istanbul ignore next */ if (lastEle === undefined) {
            this.emit("error", new Error("Last element is undefined."));
            return;
        }
        var _a = __read(lastEle, 4), qualifiedName = _a[0], ns = _a[1], map = _a[2], hasChildren = _a[3];
        /**
         * Restore original values of inherited namespace and prefix map.
         */ this._prefixMap = map;
        if (!hasChildren) return;
        this._push(this._writer.closeTag(qualifiedName));
        this._writer.endElement(qualifiedName);
    };
    /**
     * Pushes data to internal buffer.
     *
     * @param data - data
     */ XMLBuilderCBImpl.prototype._push = function(data) {
        if (data === null) {
            this._ended = true;
            this.emit("end");
        } else if (this._ended) {
            this.emit("error", new Error("Cannot push to ended stream."));
        } else if (data.length !== 0) {
            this._writer.hasData = true;
            this.emit("data", data, this._writer.level);
        }
    };
    /**
     * Reads and serializes an XML tree.
     *
     * @param node - root node
     */ XMLBuilderCBImpl.prototype._fromNode = function(node) {
        var e_3, _a, e_4, _b;
        if (util_2.Guard.isElementNode(node)) {
            var name = node.prefix ? node.prefix + ":" + node.localName : node.localName;
            if (node.namespaceURI !== null) {
                this.ele(node.namespaceURI, name);
            } else {
                this.ele(name);
            }
            try {
                for(var _c = __values(node.attributes), _d = _c.next(); !_d.done; _d = _c.next()){
                    var attr = _d.value;
                    var name_1 = attr.prefix ? attr.prefix + ":" + attr.localName : attr.localName;
                    if (attr.namespaceURI !== null) {
                        this.att(attr.namespaceURI, name_1, attr.value);
                    } else {
                        this.att(name_1, attr.value);
                    }
                }
            } catch (e_3_1) {
                e_3 = {
                    error: e_3_1
                };
            } finally{
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                } finally{
                    if (e_3) throw e_3.error;
                }
            }
            try {
                for(var _e = __values(node.childNodes), _f = _e.next(); !_f.done; _f = _e.next()){
                    var child = _f.value;
                    this._fromNode(child);
                }
            } catch (e_4_1) {
                e_4 = {
                    error: e_4_1
                };
            } finally{
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                } finally{
                    if (e_4) throw e_4.error;
                }
            }
            this.up();
        } else if (util_2.Guard.isExclusiveTextNode(node) && node.data) {
            this.txt(node.data);
        } else if (util_2.Guard.isCommentNode(node)) {
            this.com(node.data);
        } else if (util_2.Guard.isCDATASectionNode(node)) {
            this.dat(node.data);
        } else if (util_2.Guard.isProcessingInstructionNode(node)) {
            this.ins(node.target, node.data);
        }
    };
    /**
     * Produces an XML serialization of the attributes of an element node.
     *
     * @param node - node to serialize
     * @param map - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param localPrefixesMap - local prefixes map
     * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace
     * attributes
     * @param requireWellFormed - whether to check conformance
     */ XMLBuilderCBImpl.prototype._serializeAttributes = function(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
        var e_5, _a;
        var localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : undefined;
        try {
            for(var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()){
                var attr = _c.value;
                // Optimize common case
                if (!requireWellFormed && !ignoreNamespaceDefinitionAttribute && attr.namespaceURI === null) {
                    this._push(this._writer.attribute(attr.localName, this._serializeAttributeValue(attr.value, this._options.wellFormed)));
                    continue;
                }
                if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
                    this.emit("error", new Error("Element contains duplicate attributes (well-formed required)."));
                    return;
                }
                if (requireWellFormed && localNameSet) localNameSet.set(attr.namespaceURI, attr.localName);
                var attributeNamespace = attr.namespaceURI;
                var candidatePrefix = null;
                if (attributeNamespace !== null) {
                    candidatePrefix = map.get(attr.prefix, attributeNamespace);
                    if (attributeNamespace === infra_1.namespace.XMLNS) {
                        if (attr.value === infra_1.namespace.XML || attr.prefix === null && ignoreNamespaceDefinitionAttribute || attr.prefix !== null && (!(attr.localName in localPrefixesMap) || localPrefixesMap[attr.localName] !== attr.value) && map.has(attr.localName, attr.value)) continue;
                        if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
                            this.emit("error", new Error("XMLNS namespace is reserved (well-formed required)."));
                            return;
                        }
                        if (requireWellFormed && attr.value === "") {
                            this.emit("error", new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required)."));
                            return;
                        }
                        if (attr.prefix === "xmlns") candidatePrefix = "xmlns";
                    /**
                         * _Note:_ The (candidatePrefix === null) check is not in the spec.
                         * We deviate from the spec here. Otherwise a prefix is generated for
                         * all attributes with namespaces.
                         */ } else if (candidatePrefix === null) {
                        if (attr.prefix !== null && (!map.hasPrefix(attr.prefix) || map.has(attr.prefix, attributeNamespace))) {
                            /**
                             * Check if we can use the attribute's own prefix.
                             * We deviate from the spec here.
                             * TODO: This is not an efficient way of searching for prefixes.
                             * Follow developments to the spec.
                             */ candidatePrefix = attr.prefix;
                        } else {
                            candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
                        }
                        this._push(this._writer.attribute("xmlns:" + candidatePrefix, this._serializeAttributeValue(attributeNamespace, this._options.wellFormed)));
                    }
                }
                if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attr.localName) || attr.localName === "xmlns" && attributeNamespace === null)) {
                    this.emit("error", new Error("Attribute local name contains invalid characters (well-formed required)."));
                    return;
                }
                this._push(this._writer.attribute((candidatePrefix !== null ? candidatePrefix + ":" : "") + attr.localName, this._serializeAttributeValue(attr.value, this._options.wellFormed)));
            }
        } catch (e_5_1) {
            e_5 = {
                error: e_5_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_5) throw e_5.error;
            }
        }
    };
    /**
     * Produces an XML serialization of an attribute value.
     *
     * @param value - attribute value
     * @param requireWellFormed - whether to check conformance
     */ XMLBuilderCBImpl.prototype._serializeAttributeValue = function(value, requireWellFormed) {
        if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {
            this.emit("error", new Error("Invalid characters in attribute value."));
            return "";
        }
        if (value === null) return "";
        return value.replace(/(?!&(lt|gt|amp|apos|quot);)&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    };
    /**
     * Records namespace information for the given element and returns the
     * default namespace attribute value.
     *
     * @param node - element node to process
     * @param map - namespace prefix map
     * @param localPrefixesMap - local prefixes map
     */ XMLBuilderCBImpl.prototype._recordNamespaceInformation = function(node, map, localPrefixesMap) {
        var e_6, _a;
        var defaultNamespaceAttrValue = null;
        try {
            for(var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()){
                var attr = _c.value;
                var attributeNamespace = attr.namespaceURI;
                var attributePrefix = attr.prefix;
                if (attributeNamespace === infra_1.namespace.XMLNS) {
                    if (attributePrefix === null) {
                        defaultNamespaceAttrValue = attr.value;
                        continue;
                    } else {
                        var prefixDefinition = attr.localName;
                        var namespaceDefinition = attr.value;
                        if (namespaceDefinition === infra_1.namespace.XML) {
                            continue;
                        }
                        if (namespaceDefinition === "") {
                            namespaceDefinition = null;
                        }
                        if (map.has(prefixDefinition, namespaceDefinition)) {
                            continue;
                        }
                        map.set(prefixDefinition, namespaceDefinition);
                        localPrefixesMap[prefixDefinition] = namespaceDefinition || "";
                    }
                }
            }
        } catch (e_6_1) {
            e_6 = {
                error: e_6_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_6) throw e_6.error;
            }
        }
        return defaultNamespaceAttrValue;
    };
    /**
     * Generates a new prefix for the given namespace.
     *
     * @param newNamespace - a namespace to generate prefix for
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     */ XMLBuilderCBImpl.prototype._generatePrefix = function(newNamespace, prefixMap, prefixIndex) {
        var generatedPrefix = "ns" + prefixIndex.value;
        prefixIndex.value++;
        prefixMap.set(generatedPrefix, newNamespace);
        return generatedPrefix;
    };
    /**
     * Determines if the namespace prefix map was modified from its original.
     *
     * @param originalMap - original namespace prefix map
     * @param newMap - new namespace prefix map
     */ XMLBuilderCBImpl.prototype._isPrefixMapModified = function(originalMap, newMap) {
        var items1 = originalMap._items;
        var items2 = newMap._items;
        var nullItems1 = originalMap._nullItems;
        var nullItems2 = newMap._nullItems;
        for(var key in items2){
            var arr1 = items1[key];
            if (arr1 === undefined) return true;
            var arr2 = items2[key];
            if (arr1.length !== arr2.length) return true;
            for(var i = 0; i < arr1.length; i++){
                if (arr1[i] !== arr2[i]) return true;
            }
        }
        if (nullItems1.length !== nullItems2.length) return true;
        for(var i = 0; i < nullItems1.length; i++){
            if (nullItems1[i] !== nullItems2[i]) return true;
        }
        return false;
    };
    XMLBuilderCBImpl._VoidElementNames = new Set([
        "area",
        "base",
        "basefont",
        "bgsound",
        "br",
        "col",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "keygen",
        "link",
        "menuitem",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
    ]);
    return XMLBuilderCBImpl;
}(events_1.EventEmitter);
exports.XMLBuilderCBImpl = XMLBuilderCBImpl; //# sourceMappingURL=XMLBuilderCBImpl.js.map


/***/ }),

/***/ 96424:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(14859);
var util_1 = __webpack_require__(96883);
var writers_1 = __webpack_require__(17020);
var interfaces_2 = __webpack_require__(52580);
var util_2 = __webpack_require__(57294);
var algorithm_1 = __webpack_require__(75306);
var dom_1 = __webpack_require__(99178);
var infra_1 = __webpack_require__(94317);
var readers_1 = __webpack_require__(46450);
/**
 * Represents a wrapper that extends XML nodes to implement easy to use and
 * chainable document builder methods.
 */ var XMLBuilderImpl = /** @class */ function() {
    /**
     * Initializes a new instance of `XMLBuilderNodeImpl`.
     *
     * @param domNode - the DOM node to wrap
     */ function XMLBuilderImpl(domNode) {
        this._domNode = domNode;
    }
    Object.defineProperty(XMLBuilderImpl.prototype, "node", {
        /** @inheritdoc */ get: function() {
            return this._domNode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XMLBuilderImpl.prototype, "options", {
        /** @inheritdoc */ get: function() {
            return this._options;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritdoc */ XMLBuilderImpl.prototype.set = function(options) {
        this._options = util_1.applyDefaults(util_1.applyDefaults(this._options, options, true), interfaces_1.DefaultBuilderOptions); // provide defaults
        return this;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.ele = function(p1, p2, p3) {
        var _a, _b, _c;
        var namespace;
        var name;
        var attributes;
        if (util_1.isObject(p1)) {
            // ele(obj: ExpandObject)
            return new readers_1.ObjectReader(this._options).parse(this, p1);
        } else if (p1 !== null && /^\s*</.test(p1)) {
            // parse XML document string
            return new readers_1.XMLReader(this._options).parse(this, p1);
        } else if (p1 !== null && /^\s*[\{\[]/.test(p1)) {
            // parse JSON string
            return new readers_1.JSONReader(this._options).parse(this, p1);
        } else if (p1 !== null && /^(\s*|(#.*)|(%.*))*---/.test(p1)) {
            // parse YAML string
            return new readers_1.YAMLReader(this._options).parse(this, p1);
        }
        if ((p1 === null || util_1.isString(p1)) && util_1.isString(p2)) {
            // ele(namespace: string, name: string, attributes?: AttributesObject)
            _a = __read([
                p1,
                p2,
                p3
            ], 3), namespace = _a[0], name = _a[1], attributes = _a[2];
        } else if (p1 !== null) {
            // ele(name: string, attributes?: AttributesObject)
            _b = __read([
                undefined,
                p1,
                util_1.isObject(p2) ? p2 : undefined
            ], 3), namespace = _b[0], name = _b[1], attributes = _b[2];
        } else {
            throw new Error("Element name cannot be null. " + this._debugInfo());
        }
        if (attributes) {
            attributes = util_1.getValue(attributes);
        }
        _c = __read(this._extractNamespace(dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement), dom_1.sanitizeInput(name, this._options.invalidCharReplacement), true), 2), namespace = _c[0], name = _c[1];
        // inherit namespace from parent
        if (namespace === undefined) {
            var _d = __read(algorithm_1.namespace_extractQName(name), 1), prefix = _d[0];
            namespace = this.node.lookupNamespaceURI(prefix);
        }
        // create a child element node
        var childNode = namespace !== undefined && namespace !== null ? this._doc.createElementNS(namespace, name) : this._doc.createElement(name);
        this.node.appendChild(childNode);
        var builder = new XMLBuilderImpl(childNode);
        // update doctype node if the new node is the document element node
        var oldDocType = this._doc.doctype;
        if (childNode === this._doc.documentElement && oldDocType !== null) {
            var docType = this._doc.implementation.createDocumentType(this._doc.documentElement.tagName, oldDocType.publicId, oldDocType.systemId);
            this._doc.replaceChild(docType, oldDocType);
        }
        // create attributes
        if (attributes && !util_1.isEmpty(attributes)) {
            builder.att(attributes);
        }
        return builder;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.remove = function() {
        var parent = this.up();
        parent.node.removeChild(this.node);
        return parent;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.att = function(p1, p2, p3) {
        var _a, _b, _c;
        var _this = this;
        if (util_1.isMap(p1) || util_1.isObject(p1)) {
            // att(obj: AttributesObject)
            // expand if object
            util_1.forEachObject(p1, function(attName, attValue) {
                return _this.att(attName, attValue);
            }, this);
            return this;
        }
        // get primitive values
        if (p1 !== undefined && p1 !== null) p1 = util_1.getValue(p1 + "");
        if (p2 !== undefined && p2 !== null) p2 = util_1.getValue(p2 + "");
        if (p3 !== undefined && p3 !== null) p3 = util_1.getValue(p3 + "");
        var namespace;
        var name;
        var value;
        if ((p1 === null || util_1.isString(p1)) && util_1.isString(p2) && (p3 === null || util_1.isString(p3))) {
            // att(namespace: string, name: string, value: string)
            _a = __read([
                p1,
                p2,
                p3
            ], 3), namespace = _a[0], name = _a[1], value = _a[2];
        } else if (util_1.isString(p1) && (p2 == null || util_1.isString(p2))) {
            // ele(name: string, value: string)
            _b = __read([
                undefined,
                p1,
                p2
            ], 3), namespace = _b[0], name = _b[1], value = _b[2];
        } else {
            throw new Error("Attribute name and value not specified. " + this._debugInfo());
        }
        if (this._options.keepNullAttributes && value == null) {
            // keep null attributes
            value = "";
        } else if (value == null) {
            // skip null|undefined attributes
            return this;
        }
        if (!util_2.Guard.isElementNode(this.node)) {
            throw new Error("An attribute can only be assigned to an element node.");
        }
        var ele = this.node;
        _c = __read(this._extractNamespace(namespace, name, false), 2), namespace = _c[0], name = _c[1];
        name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
        namespace = dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement);
        value = dom_1.sanitizeInput(value, this._options.invalidCharReplacement);
        var _d = __read(algorithm_1.namespace_extractQName(name), 2), prefix = _d[0], localName = _d[1];
        var _e = __read(algorithm_1.namespace_extractQName(ele.prefix ? ele.prefix + ":" + ele.localName : ele.localName), 1), elePrefix = _e[0];
        // check if this is a namespace declaration attribute
        // assign a new element namespace if it wasn't previously assigned
        var eleNamespace = null;
        if (prefix === "xmlns") {
            namespace = infra_1.namespace.XMLNS;
            if (ele.namespaceURI === null && elePrefix === localName) {
                eleNamespace = value;
            }
        } else if (prefix === null && localName === "xmlns" && elePrefix === null) {
            namespace = infra_1.namespace.XMLNS;
            eleNamespace = value;
        }
        // re-create the element node if its namespace changed
        // we can't simply change the namespaceURI since its read-only
        if (eleNamespace !== null) {
            this._updateNamespace(eleNamespace);
            ele = this.node;
        }
        if (namespace !== undefined) {
            ele.setAttributeNS(namespace, name, value);
        } else {
            ele.setAttribute(name, value);
        }
        return this;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.removeAtt = function(p1, p2) {
        var _this = this;
        if (!util_2.Guard.isElementNode(this.node)) {
            throw new Error("An attribute can only be removed from an element node.");
        }
        // get primitive values
        p1 = util_1.getValue(p1);
        if (p2 !== undefined) {
            p2 = util_1.getValue(p2);
        }
        var namespace;
        var name;
        if (p1 !== null && p2 === undefined) {
            name = p1;
        } else if ((p1 === null || util_1.isString(p1)) && p2 !== undefined) {
            namespace = p1;
            name = p2;
        } else {
            throw new Error("Attribute namespace must be a string. " + this._debugInfo());
        }
        if (util_1.isArray(name) || util_1.isSet(name)) {
            // removeAtt(names: string[])
            // removeAtt(namespace: string, names: string[])
            util_1.forEachArray(name, function(attName) {
                return namespace === undefined ? _this.removeAtt(attName) : _this.removeAtt(namespace, attName);
            }, this);
        } else if (namespace !== undefined) {
            // removeAtt(namespace: string, name: string)
            name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
            namespace = dom_1.sanitizeInput(namespace, this._options.invalidCharReplacement);
            this.node.removeAttributeNS(namespace, name);
        } else {
            // removeAtt(name: string)
            name = dom_1.sanitizeInput(name, this._options.invalidCharReplacement);
            this.node.removeAttribute(name);
        }
        return this;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.txt = function(content) {
        if (content === null || content === undefined) {
            if (this._options.keepNullNodes) {
                // keep null nodes
                content = "";
            } else {
                // skip null|undefined nodes
                return this;
            }
        }
        var child = this._doc.createTextNode(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
        this.node.appendChild(child);
        return this;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.com = function(content) {
        if (content === null || content === undefined) {
            if (this._options.keepNullNodes) {
                // keep null nodes
                content = "";
            } else {
                // skip null|undefined nodes
                return this;
            }
        }
        var child = this._doc.createComment(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
        this.node.appendChild(child);
        return this;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.dat = function(content) {
        if (content === null || content === undefined) {
            if (this._options.keepNullNodes) {
                // keep null nodes
                content = "";
            } else {
                // skip null|undefined nodes
                return this;
            }
        }
        var child = this._doc.createCDATASection(dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
        this.node.appendChild(child);
        return this;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.ins = function(target, content) {
        var _this = this;
        if (content === void 0) {
            content = "";
        }
        if (content === null || content === undefined) {
            if (this._options.keepNullNodes) {
                // keep null nodes
                content = "";
            } else {
                // skip null|undefined nodes
                return this;
            }
        }
        if (util_1.isArray(target) || util_1.isSet(target)) {
            util_1.forEachArray(target, function(item) {
                item += "";
                var insIndex = item.indexOf(" ");
                var insTarget = insIndex === -1 ? item : item.substr(0, insIndex);
                var insValue = insIndex === -1 ? "" : item.substr(insIndex + 1);
                _this.ins(insTarget, insValue);
            }, this);
        } else if (util_1.isMap(target) || util_1.isObject(target)) {
            util_1.forEachObject(target, function(insTarget, insValue) {
                return _this.ins(insTarget, insValue);
            }, this);
        } else {
            var child = this._doc.createProcessingInstruction(dom_1.sanitizeInput(target, this._options.invalidCharReplacement), dom_1.sanitizeInput(content, this._options.invalidCharReplacement));
            this.node.appendChild(child);
        }
        return this;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.dec = function(options) {
        this._options.version = options.version || "1.0";
        this._options.encoding = options.encoding;
        this._options.standalone = options.standalone;
        return this;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.dtd = function(options) {
        var name = dom_1.sanitizeInput(options && options.name || (this._doc.documentElement ? this._doc.documentElement.tagName : "ROOT"), this._options.invalidCharReplacement);
        var pubID = dom_1.sanitizeInput(options && options.pubID || "", this._options.invalidCharReplacement);
        var sysID = dom_1.sanitizeInput(options && options.sysID || "", this._options.invalidCharReplacement);
        // name must match document element
        if (this._doc.documentElement !== null && name !== this._doc.documentElement.tagName) {
            throw new Error("DocType name does not match document element name.");
        }
        // create doctype node
        var docType = this._doc.implementation.createDocumentType(name, pubID, sysID);
        if (this._doc.doctype !== null) {
            // replace existing doctype
            this._doc.replaceChild(docType, this._doc.doctype);
        } else {
            // insert before document element node or append to end
            this._doc.insertBefore(docType, this._doc.documentElement);
        }
        return this;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.import = function(node) {
        var e_1, _a;
        var hostNode = this._domNode;
        var hostDoc = this._doc;
        var importedNode = node.node;
        if (util_2.Guard.isDocumentNode(importedNode)) {
            // import document node
            var elementNode = importedNode.documentElement;
            if (elementNode === null) {
                throw new Error("Imported document has no document element node. " + this._debugInfo());
            }
            var clone = hostDoc.importNode(elementNode, true);
            hostNode.appendChild(clone);
            var _b = __read(algorithm_1.namespace_extractQName(clone.prefix ? clone.prefix + ":" + clone.localName : clone.localName), 1), prefix = _b[0];
            var namespace = hostNode.lookupNamespaceURI(prefix);
            new XMLBuilderImpl(clone)._updateNamespace(namespace);
        } else if (util_2.Guard.isDocumentFragmentNode(importedNode)) {
            try {
                // import child nodes
                for(var _c = __values(importedNode.childNodes), _d = _c.next(); !_d.done; _d = _c.next()){
                    var childNode = _d.value;
                    var clone = hostDoc.importNode(childNode, true);
                    hostNode.appendChild(clone);
                    if (util_2.Guard.isElementNode(clone)) {
                        var _e = __read(algorithm_1.namespace_extractQName(clone.prefix ? clone.prefix + ":" + clone.localName : clone.localName), 1), prefix = _e[0];
                        var namespace = hostNode.lookupNamespaceURI(prefix);
                        new XMLBuilderImpl(clone)._updateNamespace(namespace);
                    }
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
        } else {
            // import node
            var clone = hostDoc.importNode(importedNode, true);
            hostNode.appendChild(clone);
            if (util_2.Guard.isElementNode(clone)) {
                var _f = __read(algorithm_1.namespace_extractQName(clone.prefix ? clone.prefix + ":" + clone.localName : clone.localName), 1), prefix = _f[0];
                var namespace = hostNode.lookupNamespaceURI(prefix);
                new XMLBuilderImpl(clone)._updateNamespace(namespace);
            }
        }
        return this;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.doc = function() {
        if (this._doc._isFragment) {
            var node = this.node;
            while(node && node.nodeType !== interfaces_2.NodeType.DocumentFragment){
                node = node.parentNode;
            }
            /* istanbul ignore next */ if (node === null) {
                throw new Error("Node has no parent node while searching for document fragment ancestor. " + this._debugInfo());
            }
            return new XMLBuilderImpl(node);
        } else {
            return new XMLBuilderImpl(this._doc);
        }
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.root = function() {
        var ele = this._doc.documentElement;
        if (!ele) {
            throw new Error("Document root element is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(ele);
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.up = function() {
        var parent = this._domNode.parentNode;
        if (!parent) {
            throw new Error("Parent node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(parent);
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.prev = function() {
        var node = this._domNode.previousSibling;
        if (!node) {
            throw new Error("Previous sibling node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(node);
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.next = function() {
        var node = this._domNode.nextSibling;
        if (!node) {
            throw new Error("Next sibling node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(node);
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.first = function() {
        var node = this._domNode.firstChild;
        if (!node) {
            throw new Error("First child node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(node);
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.last = function() {
        var node = this._domNode.lastChild;
        if (!node) {
            throw new Error("Last child node is null. " + this._debugInfo());
        }
        return new XMLBuilderImpl(node);
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.each = function(callback, self, recursive, thisArg) {
        if (self === void 0) {
            self = false;
        }
        if (recursive === void 0) {
            recursive = false;
        }
        var result = this._getFirstDescendantNode(this._domNode, self, recursive);
        while(result[0]){
            var nextResult = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
            callback.call(thisArg, new XMLBuilderImpl(result[0]), result[1], result[2]);
            result = nextResult;
        }
        return this;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.map = function(callback, self, recursive, thisArg) {
        if (self === void 0) {
            self = false;
        }
        if (recursive === void 0) {
            recursive = false;
        }
        var result = [];
        this.each(function(node, index, level) {
            return result.push(callback.call(thisArg, node, index, level));
        }, self, recursive);
        return result;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.reduce = function(callback, initialValue, self, recursive, thisArg) {
        if (self === void 0) {
            self = false;
        }
        if (recursive === void 0) {
            recursive = false;
        }
        var value = initialValue;
        this.each(function(node, index, level) {
            return value = callback.call(thisArg, value, node, index, level);
        }, self, recursive);
        return value;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.find = function(predicate, self, recursive, thisArg) {
        if (self === void 0) {
            self = false;
        }
        if (recursive === void 0) {
            recursive = false;
        }
        var result = this._getFirstDescendantNode(this._domNode, self, recursive);
        while(result[0]){
            var builder = new XMLBuilderImpl(result[0]);
            if (predicate.call(thisArg, builder, result[1], result[2])) {
                return builder;
            }
            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
        }
        return undefined;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.filter = function(predicate, self, recursive, thisArg) {
        if (self === void 0) {
            self = false;
        }
        if (recursive === void 0) {
            recursive = false;
        }
        var result = [];
        this.each(function(node, index, level) {
            if (predicate.call(thisArg, node, index, level)) {
                result.push(node);
            }
        }, self, recursive);
        return result;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.every = function(predicate, self, recursive, thisArg) {
        if (self === void 0) {
            self = false;
        }
        if (recursive === void 0) {
            recursive = false;
        }
        var result = this._getFirstDescendantNode(this._domNode, self, recursive);
        while(result[0]){
            var builder = new XMLBuilderImpl(result[0]);
            if (!predicate.call(thisArg, builder, result[1], result[2])) {
                return false;
            }
            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
        }
        return true;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.some = function(predicate, self, recursive, thisArg) {
        if (self === void 0) {
            self = false;
        }
        if (recursive === void 0) {
            recursive = false;
        }
        var result = this._getFirstDescendantNode(this._domNode, self, recursive);
        while(result[0]){
            var builder = new XMLBuilderImpl(result[0]);
            if (predicate.call(thisArg, builder, result[1], result[2])) {
                return true;
            }
            result = this._getNextDescendantNode(this._domNode, result[0], recursive, result[1], result[2]);
        }
        return false;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.toArray = function(self, recursive) {
        if (self === void 0) {
            self = false;
        }
        if (recursive === void 0) {
            recursive = false;
        }
        var result = [];
        this.each(function(node) {
            return result.push(node);
        }, self, recursive);
        return result;
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.toString = function(writerOptions) {
        writerOptions = writerOptions || {};
        if (writerOptions.format === undefined) {
            writerOptions.format = "xml";
        }
        return this._serialize(writerOptions);
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.toObject = function(writerOptions) {
        writerOptions = writerOptions || {};
        if (writerOptions.format === undefined) {
            writerOptions.format = "object";
        }
        return this._serialize(writerOptions);
    };
    /** @inheritdoc */ XMLBuilderImpl.prototype.end = function(writerOptions) {
        writerOptions = writerOptions || {};
        if (writerOptions.format === undefined) {
            writerOptions.format = "xml";
        }
        return this.doc()._serialize(writerOptions);
    };
    /**
     * Gets the next descendant of the given node of the tree rooted at `root`
     * in depth-first pre-order. Returns a three-tuple with
     * [descendant, descendant_index, descendant_level].
     *
     * @param root - root node of the tree
     * @param self - whether to visit the current node along with child nodes
     * @param recursive - whether to visit all descendant nodes in tree-order or
     * only the immediate child nodes
     */ XMLBuilderImpl.prototype._getFirstDescendantNode = function(root, self, recursive) {
        if (self) return [
            this._domNode,
            0,
            0
        ];
        else if (recursive) return this._getNextDescendantNode(root, root, recursive, 0, 0);
        else return [
            this._domNode.firstChild,
            0,
            1
        ];
    };
    /**
     * Gets the next descendant of the given node of the tree rooted at `root`
     * in depth-first pre-order. Returns a three-tuple with
     * [descendant, descendant_index, descendant_level].
     *
     * @param root - root node of the tree
     * @param node - current node
     * @param recursive - whether to visit all descendant nodes in tree-order or
     * only the immediate child nodes
     * @param index - child node index
     * @param level - current depth of the XML tree
     */ XMLBuilderImpl.prototype._getNextDescendantNode = function(root, node, recursive, index, level) {
        if (recursive) {
            // traverse child nodes
            if (node.firstChild) return [
                node.firstChild,
                0,
                level + 1
            ];
            if (node === root) return [
                null,
                -1,
                -1
            ];
            // traverse siblings
            if (node.nextSibling) return [
                node.nextSibling,
                index + 1,
                level
            ];
            // traverse parent's next sibling
            var parent = node.parentNode;
            while(parent && parent !== root){
                if (parent.nextSibling) return [
                    parent.nextSibling,
                    algorithm_1.tree_index(parent.nextSibling),
                    level - 1
                ];
                parent = parent.parentNode;
                level--;
            }
        } else {
            if (root === node) return [
                node.firstChild,
                0,
                level + 1
            ];
            else return [
                node.nextSibling,
                index + 1,
                level
            ];
        }
        return [
            null,
            -1,
            -1
        ];
    };
    /**
     * Converts the node into its string or object representation.
     *
     * @param options - serialization options
     */ XMLBuilderImpl.prototype._serialize = function(writerOptions) {
        if (writerOptions.format === "xml") {
            var writer = new writers_1.XMLWriter(this._options, writerOptions);
            return writer.serialize(this.node);
        } else if (writerOptions.format === "map") {
            var writer = new writers_1.MapWriter(this._options, writerOptions);
            return writer.serialize(this.node);
        } else if (writerOptions.format === "object") {
            var writer = new writers_1.ObjectWriter(this._options, writerOptions);
            return writer.serialize(this.node);
        } else if (writerOptions.format === "json") {
            var writer = new writers_1.JSONWriter(this._options, writerOptions);
            return writer.serialize(this.node);
        } else if (writerOptions.format === "yaml") {
            var writer = new writers_1.YAMLWriter(this._options, writerOptions);
            return writer.serialize(this.node);
        } else {
            throw new Error("Invalid writer format: " + writerOptions.format + ". " + this._debugInfo());
        }
    };
    /**
     * Extracts a namespace and name from the given string.
     *
     * @param namespace - namespace
     * @param name - a string containing both a name and namespace separated by an
     * `'@'` character
     * @param ele - `true` if this is an element namespace; otherwise `false`
     */ XMLBuilderImpl.prototype._extractNamespace = function(namespace, name, ele) {
        // extract from name
        var atIndex = name.indexOf("@");
        if (atIndex > 0) {
            if (namespace === undefined) namespace = name.slice(atIndex + 1);
            name = name.slice(0, atIndex);
        }
        if (namespace === undefined) {
            // look-up default namespace
            namespace = ele ? this._options.defaultNamespace.ele : this._options.defaultNamespace.att;
        } else if (namespace !== null && namespace[0] === "@") {
            // look-up namespace aliases
            var alias = namespace.slice(1);
            namespace = this._options.namespaceAlias[alias];
            if (namespace === undefined) {
                throw new Error("Namespace alias `" + alias + "` is not defined. " + this._debugInfo());
            }
        }
        return [
            namespace,
            name
        ];
    };
    /**
     * Updates the element's namespace.
     *
     * @param ns - new namespace
     */ XMLBuilderImpl.prototype._updateNamespace = function(ns) {
        var e_2, _a, e_3, _b;
        var ele = this._domNode;
        if (util_2.Guard.isElementNode(ele) && ns !== null && ele.namespaceURI !== ns) {
            var _c = __read(algorithm_1.namespace_extractQName(ele.prefix ? ele.prefix + ":" + ele.localName : ele.localName), 2), elePrefix = _c[0], eleLocalName = _c[1];
            // re-create the element node if its namespace changed
            // we can't simply change the namespaceURI since its read-only
            var newEle = algorithm_1.create_element(this._doc, eleLocalName, ns, elePrefix);
            try {
                for(var _d = __values(ele.attributes), _e = _d.next(); !_e.done; _e = _d.next()){
                    var attr = _e.value;
                    var attrQName = attr.prefix ? attr.prefix + ":" + attr.localName : attr.localName;
                    var _f = __read(algorithm_1.namespace_extractQName(attrQName), 1), attrPrefix = _f[0];
                    var newAttrNS = attr.namespaceURI;
                    if (newAttrNS === null && attrPrefix !== null) {
                        newAttrNS = ele.lookupNamespaceURI(attrPrefix);
                    }
                    if (newAttrNS === null) {
                        newEle.setAttribute(attrQName, attr.value);
                    } else {
                        newEle.setAttributeNS(newAttrNS, attrQName, attr.value);
                    }
                }
            } catch (e_2_1) {
                e_2 = {
                    error: e_2_1
                };
            } finally{
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                } finally{
                    if (e_2) throw e_2.error;
                }
            }
            // replace the new node in parent node
            var parent = ele.parentNode;
            /* istanbul ignore next */ if (parent === null) {
                throw new Error("Parent node is null." + this._debugInfo());
            }
            parent.replaceChild(newEle, ele);
            this._domNode = newEle;
            try {
                // check child nodes
                for(var _g = __values(ele.childNodes), _h = _g.next(); !_h.done; _h = _g.next()){
                    var childNode = _h.value;
                    var newChildNode = childNode.cloneNode(true);
                    newEle.appendChild(newChildNode);
                    if (util_2.Guard.isElementNode(newChildNode)) {
                        var _j = __read(algorithm_1.namespace_extractQName(newChildNode.prefix ? newChildNode.prefix + ":" + newChildNode.localName : newChildNode.localName), 1), newChildNodePrefix = _j[0];
                        var newChildNodeNS = newEle.lookupNamespaceURI(newChildNodePrefix);
                        new XMLBuilderImpl(newChildNode)._updateNamespace(newChildNodeNS);
                    }
                }
            } catch (e_3_1) {
                e_3 = {
                    error: e_3_1
                };
            } finally{
                try {
                    if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                } finally{
                    if (e_3) throw e_3.error;
                }
            }
        }
    };
    Object.defineProperty(XMLBuilderImpl.prototype, "_doc", {
        /**
         * Returns the document owning this node.
         */ get: function() {
            var node = this.node;
            if (util_2.Guard.isDocumentNode(node)) {
                return node;
            } else {
                var docNode = node.ownerDocument;
                /* istanbul ignore next */ if (!docNode) throw new Error("Owner document is null. " + this._debugInfo());
                return docNode;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns debug information for this node.
     *
     * @param name - node name
     */ XMLBuilderImpl.prototype._debugInfo = function(name) {
        var node = this.node;
        var parentNode = node.parentNode;
        name = name || node.nodeName;
        var parentName = parentNode ? parentNode.nodeName : "";
        if (!parentName) {
            return "node: <" + name + ">";
        } else {
            return "node: <" + name + ">, parent: <" + parentName + ">";
        }
    };
    Object.defineProperty(XMLBuilderImpl.prototype, "_options", {
        /**
         * Gets or sets builder options.
         */ get: function() {
            var doc = this._doc;
            /* istanbul ignore next */ if (doc._xmlBuilderOptions === undefined) {
                throw new Error("Builder options is not set.");
            }
            return doc._xmlBuilderOptions;
        },
        set: function(value) {
            var doc = this._doc;
            doc._xmlBuilderOptions = value;
        },
        enumerable: true,
        configurable: true
    });
    return XMLBuilderImpl;
}();
exports.XMLBuilderImpl = XMLBuilderImpl; //# sourceMappingURL=XMLBuilderImpl.js.map


/***/ }),

/***/ 99178:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var dom_1 = __webpack_require__(10064);
var dom_2 = __webpack_require__(20937);
var util_1 = __webpack_require__(96883);
dom_2.dom.setFeatures(false);
/**
 * Creates an XML document without any child nodes.
 */ function createDocument() {
    var impl = new dom_1.DOMImplementation();
    var doc = impl.createDocument(null, "root", null);
    /* istanbul ignore else */ if (doc.documentElement) {
        doc.removeChild(doc.documentElement);
    }
    return doc;
}
exports.createDocument = createDocument;
/**
 * Sanitizes input strings with user supplied replacement characters.
 *
 * @param str - input string
 * @param replacement - replacement character or function
 */ function sanitizeInput(str, replacement) {
    if (str == null) {
        return str;
    } else if (replacement === undefined) {
        return str + "";
    } else {
        var result = "";
        str = str + "";
        for(var i = 0; i < str.length; i++){
            var n = str.charCodeAt(i);
            // #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]
            if (n === 0x9 || n === 0xA || n === 0xD || n >= 0x20 && n <= 0xD7FF || n >= 0xE000 && n <= 0xFFFD) {
                // valid character - not surrogate pair
                result += str.charAt(i);
            } else if (n >= 0xD800 && n <= 0xDBFF && i < str.length - 1) {
                var n2 = str.charCodeAt(i + 1);
                if (n2 >= 0xDC00 && n2 <= 0xDFFF) {
                    // valid surrogate pair
                    n = (n - 0xD800) * 0x400 + n2 - 0xDC00 + 0x10000;
                    result += String.fromCodePoint(n);
                    i++;
                } else {
                    // invalid lone surrogate
                    result += util_1.isString(replacement) ? replacement : replacement(str.charAt(i), i, str);
                }
            } else {
                // invalid character
                result += util_1.isString(replacement) ? replacement : replacement(str.charAt(i), i, str);
            }
        }
        return result;
    }
}
exports.sanitizeInput = sanitizeInput; //# sourceMappingURL=dom.js.map


/***/ }),

/***/ 94949:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var XMLBuilderImpl_1 = __webpack_require__(96424);
exports.XMLBuilderImpl = XMLBuilderImpl_1.XMLBuilderImpl;
var XMLBuilderCBImpl_1 = __webpack_require__(81855);
exports.XMLBuilderCBImpl = XMLBuilderCBImpl_1.XMLBuilderCBImpl;
var BuilderFunctions_1 = __webpack_require__(71807);
exports.builder = BuilderFunctions_1.builder;
exports.create = BuilderFunctions_1.create;
exports.fragment = BuilderFunctions_1.fragment;
exports.convert = BuilderFunctions_1.convert;
var BuilderFunctionsCB_1 = __webpack_require__(10309);
exports.createCB = BuilderFunctionsCB_1.createCB;
exports.fragmentCB = BuilderFunctionsCB_1.fragmentCB; //# sourceMappingURL=index.js.map


/***/ }),

/***/ 80312:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.nonEntityAmpersandRegex = /&(?![A-Za-z]+;|#\d+;)/g; //# sourceMappingURL=constants.js.map


/***/ }),

/***/ 74846:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;

__webpack_unused_export__ = ({
    value: true
});
var builder_1 = __webpack_require__(94949);
__webpack_unused_export__ = builder_1.builder;
exports.Ue = builder_1.create;
__webpack_unused_export__ = builder_1.fragment;
__webpack_unused_export__ = builder_1.convert;
__webpack_unused_export__ = builder_1.createCB;
__webpack_unused_export__ = builder_1.fragmentCB; //# sourceMappingURL=index.js.map


/***/ }),

/***/ 14859:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Defines default values for builder options.
 */ exports.DefaultBuilderOptions = {
    version: "1.0",
    encoding: undefined,
    standalone: undefined,
    keepNullNodes: false,
    keepNullAttributes: false,
    ignoreConverters: false,
    skipWhitespaceOnlyText: true,
    convert: {
        att: "@",
        ins: "?",
        text: "#",
        cdata: "$",
        comment: "!"
    },
    defaultNamespace: {
        ele: undefined,
        att: undefined
    },
    namespaceAlias: {
        html: "http://www.w3.org/1999/xhtml",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/",
        mathml: "http://www.w3.org/1998/Math/MathML",
        svg: "http://www.w3.org/2000/svg",
        xlink: "http://www.w3.org/1999/xlink"
    },
    invalidCharReplacement: undefined,
    parser: undefined
};
/**
 * Contains keys of `XMLBuilderOptions`.
 */ exports.XMLBuilderOptionKeys = new Set(Object.keys(exports.DefaultBuilderOptions));
/**
 * Defines default values for builder options.
 */ exports.DefaultXMLBuilderCBOptions = {
    format: "xml",
    wellFormed: false,
    prettyPrint: false,
    indent: "  ",
    newline: "\n",
    offset: 0,
    width: 0,
    allowEmptyTags: false,
    spaceBeforeSlash: false,
    keepNullNodes: false,
    keepNullAttributes: false,
    ignoreConverters: false,
    convert: {
        att: "@",
        ins: "?",
        text: "#",
        cdata: "$",
        comment: "!"
    },
    defaultNamespace: {
        ele: undefined,
        att: undefined
    },
    namespaceAlias: {
        html: "http://www.w3.org/1999/xhtml",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/",
        mathml: "http://www.w3.org/1998/Math/MathML",
        svg: "http://www.w3.org/2000/svg",
        xlink: "http://www.w3.org/1999/xlink"
    }
}; //# sourceMappingURL=interfaces.js.map


/***/ }),

/***/ 88912:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var dom_1 = __webpack_require__(99178);
/**
 * Parses XML nodes.
 */ var BaseReader = /** @class */ function() {
    /**
     * Initializes a new instance of `BaseReader`.
     *
     * @param builderOptions - XML builder options
     */ function BaseReader(builderOptions) {
        this._builderOptions = builderOptions;
        if (builderOptions.parser) {
            Object.assign(this, builderOptions.parser);
        }
    }
    BaseReader.prototype._docType = function(parent, name, publicId, systemId) {
        return parent.dtd({
            name: name,
            pubID: publicId,
            sysID: systemId
        });
    };
    BaseReader.prototype._comment = function(parent, data) {
        return parent.com(data);
    };
    BaseReader.prototype._text = function(parent, data) {
        return parent.txt(data);
    };
    BaseReader.prototype._instruction = function(parent, target, data) {
        return parent.ins(target, data);
    };
    BaseReader.prototype._cdata = function(parent, data) {
        return parent.dat(data);
    };
    BaseReader.prototype._element = function(parent, namespace, name) {
        return namespace === undefined ? parent.ele(name) : parent.ele(namespace, name);
    };
    BaseReader.prototype._attribute = function(parent, namespace, name, value) {
        return namespace === undefined ? parent.att(name, value) : parent.att(namespace, name, value);
    };
    BaseReader.prototype._sanitize = function(str) {
        return dom_1.sanitizeInput(str, this._builderOptions.invalidCharReplacement);
    };
    /**
     * Decodes serialized text.
     *
     * @param text - text value to serialize
     */ BaseReader.prototype._decodeText = function(text) {
        if (text == null) return text;
        return text.replace(/&(quot|amp|apos|lt|gt);/g, function(_match, tag) {
            return BaseReader._entityTable[tag];
        }).replace(/&#(?:x([a-fA-F0-9]+)|([0-9]+));/g, function(_match, hexStr, numStr) {
            return String.fromCodePoint(parseInt(hexStr || numStr, hexStr ? 16 : 10));
        });
    };
    /**
     * Decodes serialized attribute value.
     *
     * @param text - attribute value to serialize
     */ BaseReader.prototype._decodeAttributeValue = function(text) {
        return this._decodeText(text);
    };
    /**
     * Main parser function which parses the given object and returns an XMLBuilder.
     *
     * @param node - node to recieve parsed content
     * @param obj - object to parse
     */ BaseReader.prototype.parse = function(node, obj) {
        return this._parse(node, obj);
    };
    /**
     * Creates a DocType node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param name - node name
     * @param publicId - public identifier
     * @param systemId - system identifier
     */ BaseReader.prototype.docType = function(parent, name, publicId, systemId) {
        return this._docType(parent, name, publicId, systemId);
    };
    /**
     * Creates a comment node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param data - node data
     */ BaseReader.prototype.comment = function(parent, data) {
        return this._comment(parent, data);
    };
    /**
     * Creates a text node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param data - node data
     */ BaseReader.prototype.text = function(parent, data) {
        return this._text(parent, data);
    };
    /**
     * Creates a processing instruction node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param target - instruction target
     * @param data - node data
     */ BaseReader.prototype.instruction = function(parent, target, data) {
        return this._instruction(parent, target, data);
    };
    /**
     * Creates a CData section node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param data - node data
     */ BaseReader.prototype.cdata = function(parent, data) {
        return this._cdata(parent, data);
    };
    /**
     * Creates an element node.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param namespace - node namespace
     * @param name - node name
     */ BaseReader.prototype.element = function(parent, namespace, name) {
        return this._element(parent, namespace, name);
    };
    /**
     * Creates an attribute or namespace declaration.
     * The node will be skipped if the function returns `undefined`.
     *
     * @param parent - parent node
     * @param namespace - node namespace
     * @param name - node name
     * @param value - node value
     */ BaseReader.prototype.attribute = function(parent, namespace, name, value) {
        return this._attribute(parent, namespace, name, value);
    };
    /**
     * Sanitizes input strings.
     *
     * @param str - input string
     */ BaseReader.prototype.sanitize = function(str) {
        return this._sanitize(str);
    };
    BaseReader._entityTable = {
        "lt": "<",
        "gt": ">",
        "amp": "&",
        "quot": '"',
        "apos": "'"
    };
    return BaseReader;
}();
exports.BaseReader = BaseReader; //# sourceMappingURL=BaseReader.js.map


/***/ }),

/***/ 47252:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var ObjectReader_1 = __webpack_require__(93242);
var BaseReader_1 = __webpack_require__(88912);
/**
 * Parses XML nodes from a JSON string.
 */ var JSONReader = /** @class */ function(_super) {
    __extends(JSONReader, _super);
    function JSONReader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Parses the given document representation.
     *
     * @param node - node receive parsed XML nodes
     * @param str - JSON string to parse
     */ JSONReader.prototype._parse = function(node, str) {
        return new ObjectReader_1.ObjectReader(this._builderOptions).parse(node, JSON.parse(str));
    };
    return JSONReader;
}(BaseReader_1.BaseReader);
exports.JSONReader = JSONReader; //# sourceMappingURL=JSONReader.js.map


/***/ }),

/***/ 93242:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(96883);
var BaseReader_1 = __webpack_require__(88912);
/**
 * Parses XML nodes from objects and arrays.
 * ES6 maps and sets are also supoorted.
 */ var ObjectReader = /** @class */ function(_super) {
    __extends(ObjectReader, _super);
    function ObjectReader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Parses the given document representation.
     *
     * @param node - node receive parsed XML nodes
     * @param obj - object to parse
     */ ObjectReader.prototype._parse = function(node, obj) {
        var _this = this;
        var options = this._builderOptions;
        var lastChild = null;
        if (util_1.isFunction(obj)) {
            // evaluate if function
            lastChild = this.parse(node, obj.apply(this));
        } else if (util_1.isArray(obj) || util_1.isSet(obj)) {
            util_1.forEachArray(obj, function(item) {
                return lastChild = _this.parse(node, item);
            }, this);
        } else if (util_1.isMap(obj) || util_1.isObject(obj)) {
            // expand if object
            util_1.forEachObject(obj, function(key, val) {
                if (util_1.isFunction(val)) {
                    // evaluate if function
                    val = val.apply(_this);
                }
                if (!options.ignoreConverters && key.indexOf(options.convert.att) === 0) {
                    // assign attributes
                    if (key === options.convert.att) {
                        if (util_1.isArray(val) || util_1.isSet(val)) {
                            throw new Error("Invalid attribute: " + val.toString() + ". " + node._debugInfo());
                        } else /* if (isMap(val) || isObject(val)) */ {
                            util_1.forEachObject(val, function(attrKey, attrVal) {
                                lastChild = _this.attribute(node, undefined, _this.sanitize(attrKey), _this._decodeAttributeValue(_this.sanitize(attrVal))) || lastChild;
                            });
                        }
                    } else {
                        lastChild = _this.attribute(node, undefined, _this.sanitize(key.substr(options.convert.att.length)), _this._decodeAttributeValue(_this.sanitize(val))) || lastChild;
                    }
                } else if (!options.ignoreConverters && key.indexOf(options.convert.text) === 0) {
                    // text node
                    if (util_1.isMap(val) || util_1.isObject(val)) {
                        // if the key is #text expand child nodes under this node to support mixed content
                        lastChild = _this.parse(node, val);
                    } else {
                        lastChild = _this.text(node, _this._decodeText(_this.sanitize(val))) || lastChild;
                    }
                } else if (!options.ignoreConverters && key.indexOf(options.convert.cdata) === 0) {
                    // cdata node
                    if (util_1.isArray(val) || util_1.isSet(val)) {
                        util_1.forEachArray(val, function(item) {
                            return lastChild = _this.cdata(node, _this.sanitize(item)) || lastChild;
                        }, _this);
                    } else {
                        lastChild = _this.cdata(node, _this.sanitize(val)) || lastChild;
                    }
                } else if (!options.ignoreConverters && key.indexOf(options.convert.comment) === 0) {
                    // comment node
                    if (util_1.isArray(val) || util_1.isSet(val)) {
                        util_1.forEachArray(val, function(item) {
                            return lastChild = _this.comment(node, _this.sanitize(item)) || lastChild;
                        }, _this);
                    } else {
                        lastChild = _this.comment(node, _this.sanitize(val)) || lastChild;
                    }
                } else if (!options.ignoreConverters && key.indexOf(options.convert.ins) === 0) {
                    // processing instruction
                    if (util_1.isString(val)) {
                        var insIndex = val.indexOf(" ");
                        var insTarget = insIndex === -1 ? val : val.substr(0, insIndex);
                        var insValue = insIndex === -1 ? "" : val.substr(insIndex + 1);
                        lastChild = _this.instruction(node, _this.sanitize(insTarget), _this.sanitize(insValue)) || lastChild;
                    } else if (util_1.isArray(val) || util_1.isSet(val)) {
                        util_1.forEachArray(val, function(item) {
                            var insIndex = item.indexOf(" ");
                            var insTarget = insIndex === -1 ? item : item.substr(0, insIndex);
                            var insValue = insIndex === -1 ? "" : item.substr(insIndex + 1);
                            lastChild = _this.instruction(node, _this.sanitize(insTarget), _this.sanitize(insValue)) || lastChild;
                        }, _this);
                    } else /* if (isMap(target) || isObject(target)) */ {
                        util_1.forEachObject(val, function(insTarget, insValue) {
                            return lastChild = _this.instruction(node, _this.sanitize(insTarget), _this.sanitize(insValue)) || lastChild;
                        }, _this);
                    }
                } else if ((util_1.isArray(val) || util_1.isSet(val)) && util_1.isEmpty(val)) {
                // skip empty arrays
                } else if ((util_1.isMap(val) || util_1.isObject(val)) && util_1.isEmpty(val)) {
                    // empty objects produce one node
                    lastChild = _this.element(node, undefined, _this.sanitize(key)) || lastChild;
                } else if (!options.keepNullNodes && val == null) {
                // skip null and undefined nodes
                } else if (util_1.isArray(val) || util_1.isSet(val)) {
                    // expand list by creating child nodes
                    util_1.forEachArray(val, function(item) {
                        var childNode = {};
                        childNode[key] = item;
                        lastChild = _this.parse(node, childNode);
                    }, _this);
                } else if (util_1.isMap(val) || util_1.isObject(val)) {
                    // create a parent node
                    var parent = _this.element(node, undefined, _this.sanitize(key));
                    if (parent) {
                        lastChild = parent;
                        // expand child nodes under parent
                        _this.parse(parent, val);
                    }
                } else if (val != null && val !== "") {
                    // leaf element node with a single text node
                    var parent = _this.element(node, undefined, _this.sanitize(key));
                    if (parent) {
                        lastChild = parent;
                        _this.text(parent, _this._decodeText(_this.sanitize(val)));
                    }
                } else {
                    // leaf element node
                    lastChild = _this.element(node, undefined, _this.sanitize(key)) || lastChild;
                }
            }, this);
        } else if (!options.keepNullNodes && obj == null) {
        // skip null and undefined nodes
        } else {
            // text node
            lastChild = this.text(node, this._decodeText(this.sanitize(obj))) || lastChild;
        }
        return lastChild || node;
    };
    return ObjectReader;
}(BaseReader_1.BaseReader);
exports.ObjectReader = ObjectReader; //# sourceMappingURL=ObjectReader.js.map


/***/ }),

/***/ 47224:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var XMLStringLexer_1 = __webpack_require__(28998);
var interfaces_1 = __webpack_require__(3279);
var interfaces_2 = __webpack_require__(52580);
var infra_1 = __webpack_require__(94317);
var algorithm_1 = __webpack_require__(75306);
var BaseReader_1 = __webpack_require__(88912);
/**
 * Parses XML nodes from an XML document string.
 */ var XMLReader = /** @class */ function(_super) {
    __extends(XMLReader, _super);
    function XMLReader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Parses the given document representation.
     *
     * @param node - node receive parsed XML nodes
     * @param str - XML document string to parse
     */ XMLReader.prototype._parse = function(node, str) {
        var e_1, _a, e_2, _b;
        var lexer = new XMLStringLexer_1.XMLStringLexer(str, {
            skipWhitespaceOnlyText: this._builderOptions.skipWhitespaceOnlyText
        });
        var lastChild = node;
        var context = node;
        var token = lexer.nextToken();
        while(token.type !== interfaces_1.TokenType.EOF){
            switch(token.type){
                case interfaces_1.TokenType.Declaration:
                    var declaration = token;
                    var version = this.sanitize(declaration.version);
                    if (version !== "1.0") {
                        throw new Error("Invalid xml version: " + version);
                    }
                    var builderOptions = {
                        version: version
                    };
                    if (declaration.encoding) {
                        builderOptions.encoding = this.sanitize(declaration.encoding);
                    }
                    if (declaration.standalone) {
                        builderOptions.standalone = this.sanitize(declaration.standalone) === "yes";
                    }
                    context.set(builderOptions);
                    break;
                case interfaces_1.TokenType.DocType:
                    var doctype = token;
                    context = this.docType(context, this.sanitize(doctype.name), this.sanitize(doctype.pubId), this.sanitize(doctype.sysId)) || context;
                    break;
                case interfaces_1.TokenType.CDATA:
                    var cdata = token;
                    context = this.cdata(context, this.sanitize(cdata.data)) || context;
                    break;
                case interfaces_1.TokenType.Comment:
                    var comment = token;
                    context = this.comment(context, this.sanitize(comment.data)) || context;
                    break;
                case interfaces_1.TokenType.PI:
                    var pi = token;
                    context = this.instruction(context, this.sanitize(pi.target), this.sanitize(pi.data)) || context;
                    break;
                case interfaces_1.TokenType.Text:
                    if (context.node.nodeType === interfaces_2.NodeType.Document) break;
                    var text = token;
                    context = this.text(context, this._decodeText(this.sanitize(text.data))) || context;
                    break;
                case interfaces_1.TokenType.Element:
                    var element = token;
                    var elementName = this.sanitize(element.name);
                    // inherit namespace from parent
                    var _c = __read(algorithm_1.namespace_extractQName(elementName), 1), prefix = _c[0];
                    var namespace = context.node.lookupNamespaceURI(prefix);
                    // override namespace if there is a namespace declaration
                    // attribute
                    // also lookup namespace declaration attributes
                    var nsDeclarations = {};
                    try {
                        for(var _d = (e_1 = void 0, __values(element.attributes)), _e = _d.next(); !_e.done; _e = _d.next()){
                            var _f = __read(_e.value, 2), attName = _f[0], attValue = _f[1];
                            attName = this.sanitize(attName);
                            attValue = this.sanitize(attValue);
                            if (attName === "xmlns") {
                                namespace = attValue;
                            } else {
                                var _g = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _g[0], attLocalName = _g[1];
                                if (attPrefix === "xmlns") {
                                    if (attLocalName === prefix) {
                                        namespace = attValue;
                                    }
                                    nsDeclarations[attLocalName] = attValue;
                                }
                            }
                        }
                    } catch (e_1_1) {
                        e_1 = {
                            error: e_1_1
                        };
                    } finally{
                        try {
                            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                        } finally{
                            if (e_1) throw e_1.error;
                        }
                    }
                    // create the DOM element node
                    var elementNode = namespace !== null ? this.element(context, namespace, elementName) : this.element(context, undefined, elementName);
                    if (elementNode === undefined) break;
                    if (context.node === node.node) lastChild = elementNode;
                    try {
                        // assign attributes
                        for(var _h = (e_2 = void 0, __values(element.attributes)), _j = _h.next(); !_j.done; _j = _h.next()){
                            var _k = __read(_j.value, 2), attName = _k[0], attValue = _k[1];
                            attName = this.sanitize(attName);
                            attValue = this.sanitize(attValue);
                            var _l = __read(algorithm_1.namespace_extractQName(attName), 2), attPrefix = _l[0], attLocalName = _l[1];
                            var attNamespace = null;
                            if (attPrefix === "xmlns" || attPrefix === null && attLocalName === "xmlns") {
                                // namespace declaration attribute
                                attNamespace = infra_1.namespace.XMLNS;
                            } else {
                                attNamespace = elementNode.node.lookupNamespaceURI(attPrefix);
                                if (attNamespace !== null && elementNode.node.isDefaultNamespace(attNamespace)) {
                                    attNamespace = null;
                                } else if (attNamespace === null && attPrefix !== null) {
                                    attNamespace = nsDeclarations[attPrefix] || null;
                                }
                            }
                            if (attNamespace !== null) this.attribute(elementNode, attNamespace, attName, this._decodeAttributeValue(attValue));
                            else this.attribute(elementNode, undefined, attName, this._decodeAttributeValue(attValue));
                        }
                    } catch (e_2_1) {
                        e_2 = {
                            error: e_2_1
                        };
                    } finally{
                        try {
                            if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
                        } finally{
                            if (e_2) throw e_2.error;
                        }
                    }
                    if (!element.selfClosing) {
                        context = elementNode;
                    }
                    break;
                case interfaces_1.TokenType.ClosingTag:
                    /* istanbul ignore else */ if (context.node.parentNode) {
                        context = context.up();
                    }
                    break;
            }
            token = lexer.nextToken();
        }
        return lastChild;
    };
    return XMLReader;
}(BaseReader_1.BaseReader);
exports.XMLReader = XMLReader; //# sourceMappingURL=XMLReader.js.map


/***/ }),

/***/ 51682:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var ObjectReader_1 = __webpack_require__(93242);
var BaseReader_1 = __webpack_require__(88912);
var js_yaml_1 = __webpack_require__(98986);
/**
 * Parses XML nodes from a YAML string.
 */ var YAMLReader = /** @class */ function(_super) {
    __extends(YAMLReader, _super);
    function YAMLReader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Parses the given document representation.
     *
     * @param node - node receive parsed XML nodes
     * @param str - YAML string to parse
     */ YAMLReader.prototype._parse = function(node, str) {
        var result = js_yaml_1.safeLoad(str);
        /* istanbul ignore next */ if (result === undefined) {
            throw new Error("Unable to parse YAML document.");
        }
        return new ObjectReader_1.ObjectReader(this._builderOptions).parse(node, result);
    };
    return YAMLReader;
}(BaseReader_1.BaseReader);
exports.YAMLReader = YAMLReader; //# sourceMappingURL=YAMLReader.js.map


/***/ }),

/***/ 46450:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var XMLReader_1 = __webpack_require__(47224);
exports.XMLReader = XMLReader_1.XMLReader;
var ObjectReader_1 = __webpack_require__(93242);
exports.ObjectReader = ObjectReader_1.ObjectReader;
var JSONReader_1 = __webpack_require__(47252);
exports.JSONReader = JSONReader_1.JSONReader;
var YAMLReader_1 = __webpack_require__(51682);
exports.YAMLReader = YAMLReader_1.YAMLReader; //# sourceMappingURL=index.js.map


/***/ }),

/***/ 96266:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
/**
 * Pre-serializes XML nodes.
 */ var BaseCBWriter = /** @class */ function() {
    /**
     * Initializes a new instance of `BaseCBWriter`.
     *
     * @param builderOptions - XML builder options
     */ function BaseCBWriter(builderOptions) {
        /**
         * Gets the current depth of the XML tree.
         */ this.level = 0;
        this._builderOptions = builderOptions;
        this._writerOptions = builderOptions;
    }
    return BaseCBWriter;
}();
exports.BaseCBWriter = BaseCBWriter; //# sourceMappingURL=BaseCBWriter.js.map


/***/ }),

/***/ 96798:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (void 0) && (void 0).__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
};
var __spread = (void 0) && (void 0).__spread || function() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var interfaces_1 = __webpack_require__(52580);
var LocalNameSet_1 = __webpack_require__(3367);
var NamespacePrefixMap_1 = __webpack_require__(83771);
var infra_1 = __webpack_require__(94317);
var algorithm_1 = __webpack_require__(75306);
var constants_1 = __webpack_require__(80312);
/**
 * Pre-serializes XML nodes.
 */ var BaseWriter = /** @class */ function() {
    /**
     * Initializes a new instance of `BaseWriter`.
     *
     * @param builderOptions - XML builder options
     */ function BaseWriter(builderOptions) {
        /**
         * Gets the current depth of the XML tree.
         */ this.level = 0;
        this._builderOptions = builderOptions;
    }
    /**
     * Used by derived classes to serialize the XML declaration.
     *
     * @param version - a version number string
     * @param encoding - encoding declaration
     * @param standalone - standalone document declaration
     */ BaseWriter.prototype.declaration = function(version, encoding, standalone) {};
    /**
     * Used by derived classes to serialize a DocType node.
     *
     * @param name - node name
     * @param publicId - public identifier
     * @param systemId - system identifier
     */ BaseWriter.prototype.docType = function(name, publicId, systemId) {};
    /**
     * Used by derived classes to serialize a comment node.
     *
     * @param data - node data
     */ BaseWriter.prototype.comment = function(data) {};
    /**
     * Used by derived classes to serialize a text node.
     *
     * @param data - node data
     */ BaseWriter.prototype.text = function(data) {};
    /**
     * Used by derived classes to serialize a processing instruction node.
     *
     * @param target - instruction target
     * @param data - node data
     */ BaseWriter.prototype.instruction = function(target, data) {};
    /**
     * Used by derived classes to serialize a CData section node.
     *
     * @param data - node data
     */ BaseWriter.prototype.cdata = function(data) {};
    /**
     * Used by derived classes to serialize the beginning of the opening tag of an
     * element node.
     *
     * @param name - node name
     */ BaseWriter.prototype.openTagBegin = function(name) {};
    /**
     * Used by derived classes to serialize the ending of the opening tag of an
     * element node.
     *
     * @param name - node name
     * @param selfClosing - whether the element node is self closing
     * @param voidElement - whether the element node is a HTML void element
     */ BaseWriter.prototype.openTagEnd = function(name, selfClosing, voidElement) {};
    /**
     * Used by derived classes to serialize the closing tag of an element node.
     *
     * @param name - node name
     */ BaseWriter.prototype.closeTag = function(name) {};
    /**
     * Used by derived classes to serialize attributes or namespace declarations.
     *
     * @param attributes - attribute array
     */ BaseWriter.prototype.attributes = function(attributes) {
        var e_1, _a;
        try {
            for(var attributes_1 = __values(attributes), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()){
                var attr = attributes_1_1.value;
                this.attribute(attr[1] === null ? attr[2] : attr[1] + ":" + attr[2], attr[3]);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (attributes_1_1 && !attributes_1_1.done && (_a = attributes_1.return)) _a.call(attributes_1);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
    };
    /**
     * Used by derived classes to serialize an attribute or namespace declaration.
     *
     * @param name - node name
     * @param value - node value
     */ BaseWriter.prototype.attribute = function(name, value) {};
    /**
     * Used by derived classes to perform any pre-processing steps before starting
     * serializing an element node.
     *
     * @param name - node name
     */ BaseWriter.prototype.beginElement = function(name) {};
    /**
     * Used by derived classes to perform any post-processing steps after
     * completing serializing an element node.
     *
     * @param name - node name
     */ BaseWriter.prototype.endElement = function(name) {};
    /**
     * Produces an XML serialization of the given node. The pre-serializer inserts
     * namespace declarations where necessary and produces qualified names for
     * nodes and attributes.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ BaseWriter.prototype.serializeNode = function(node, requireWellFormed) {
        var hasNamespaces = node._nodeDocument !== undefined && node._nodeDocument._hasNamespaces;
        this.level = 0;
        this.currentNode = node;
        if (hasNamespaces) {
            /** From: https://w3c.github.io/DOM-Parsing/#xml-serialization
             *
             * 1. Let namespace be a context namespace with value null.
             * The context namespace tracks the XML serialization algorithm's current
             * default namespace. The context namespace is changed when either an Element
             * Node has a default namespace declaration, or the algorithm generates a
             * default namespace declaration for the Element Node to match its own
             * namespace. The algorithm assumes no namespace (null) to start.
             * 2. Let prefix map be a new namespace prefix map.
             * 3. Add the XML namespace with prefix value "xml" to prefix map.
             * 4. Let prefix index be a generated namespace prefix index with value 1.
             * The generated namespace prefix index is used to generate a new unique
             * prefix value when no suitable existing namespace prefix is available to
             * serialize a node's namespaceURI (or the namespaceURI of one of node's
             * attributes). See the generate a prefix algorithm.
             */ var namespace = null;
            var prefixMap = new NamespacePrefixMap_1.NamespacePrefixMap();
            prefixMap.set("xml", infra_1.namespace.XML);
            var prefixIndex = {
                value: 1
            };
            /**
             * 5. Return the result of running the XML serialization algorithm on node
             * passing the context namespace namespace, namespace prefix map prefix map,
             * generated namespace prefix index reference to prefix index, and the
             * flag require well-formed. If an exception occurs during the execution
             * of the algorithm, then catch that exception and throw an
             * "InvalidStateError" DOMException.
             */ this._serializeNodeNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
        } else {
            this._serializeNode(node, requireWellFormed);
        }
    };
    /**
     * Produces an XML serialization of a node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */ BaseWriter.prototype._serializeNodeNS = function(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        this.currentNode = node;
        switch(node.nodeType){
            case interfaces_1.NodeType.Element:
                this._serializeElementNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
                break;
            case interfaces_1.NodeType.Document:
                this._serializeDocumentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
                break;
            case interfaces_1.NodeType.Comment:
                this._serializeComment(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.Text:
                this._serializeText(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.DocumentFragment:
                this._serializeDocumentFragmentNS(node, namespace, prefixMap, prefixIndex, requireWellFormed);
                break;
            case interfaces_1.NodeType.DocumentType:
                this._serializeDocumentType(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.ProcessingInstruction:
                this._serializeProcessingInstruction(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.CData:
                this._serializeCData(node, requireWellFormed);
                break;
            default:
                throw new Error("Unknown node type: " + node.nodeType);
        }
    };
    /**
     * Produces an XML serialization of a node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ BaseWriter.prototype._serializeNode = function(node, requireWellFormed) {
        this.currentNode = node;
        switch(node.nodeType){
            case interfaces_1.NodeType.Element:
                this._serializeElement(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.Document:
                this._serializeDocument(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.Comment:
                this._serializeComment(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.Text:
                this._serializeText(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.DocumentFragment:
                this._serializeDocumentFragment(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.DocumentType:
                this._serializeDocumentType(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.ProcessingInstruction:
                this._serializeProcessingInstruction(node, requireWellFormed);
                break;
            case interfaces_1.NodeType.CData:
                this._serializeCData(node, requireWellFormed);
                break;
            default:
                throw new Error("Unknown node type: " + node.nodeType);
        }
    };
    /**
     * Produces an XML serialization of an element node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */ BaseWriter.prototype._serializeElementNS = function(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_2, _a;
        var attributes = [];
        /**
         * From: https://w3c.github.io/DOM-Parsing/#xml-serializing-an-element-node
         *
         * 1. If the require well-formed flag is set (its value is true), and this
         * node's localName attribute contains the character ":" (U+003A COLON) or
         * does not match the XML Name production, then throw an exception; the
         * serialization of this node would not be a well-formed element.
         */ if (requireWellFormed && (node.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(node.localName))) {
            throw new Error("Node local name contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the string "<" (U+003C LESS-THAN SIGN).
         * 3. Let qualified name be an empty string.
         * 4. Let skip end tag be a boolean flag with value false.
         * 5. Let ignore namespace definition attribute be a boolean flag with value
         * false.
         * 6. Given prefix map, copy a namespace prefix map and let map be the
         * result.
         * 7. Let local prefixes map be an empty map. The map has unique Node prefix
         * strings as its keys, with corresponding namespaceURI Node values as the
         * map's key values (in this map, the null namespace is represented by the
         * empty string).
         *
         * _Note:_ This map is local to each element. It is used to ensure there
         * are no conflicting prefixes should a new namespace prefix attribute need
         * to be generated. It is also used to enable skipping of duplicate prefix
         * definitions when writing an element's attributes: the map allows the
         * algorithm to distinguish between a prefix in the namespace prefix map
         * that might be locally-defined (to the current Element) and one that is
         * not.
         * 8. Let local default namespace be the result of recording the namespace
         * information for node given map and local prefixes map.
         *
         * _Note:_ The above step will update map with any found namespace prefix
         * definitions, add the found prefix definitions to the local prefixes map
         * and return a local default namespace value defined by a default namespace
         * attribute if one exists. Otherwise it returns null.
         * 9. Let inherited ns be a copy of namespace.
         * 10. Let ns be the value of node's namespaceURI attribute.
         */ var qualifiedName = "";
        var skipEndTag = false;
        var ignoreNamespaceDefinitionAttribute = false;
        var map = prefixMap.copy();
        var localPrefixesMap = {};
        var localDefaultNamespace = this._recordNamespaceInformation(node, map, localPrefixesMap);
        var inheritedNS = namespace;
        var ns = node.namespaceURI;
        /** 11. If inherited ns is equal to ns, then: */ if (inheritedNS === ns) {
            /**
             * 11.1. If local default namespace is not null, then set ignore
             * namespace definition attribute to true.
             */ if (localDefaultNamespace !== null) {
                ignoreNamespaceDefinitionAttribute = true;
            }
            /**
             * 11.2. If ns is the XML namespace, then append to qualified name the
             * concatenation of the string "xml:" and the value of node's localName.
             * 11.3. Otherwise, append to qualified name the value of node's
             * localName. The node's prefix if it exists, is dropped.
             */ if (ns === infra_1.namespace.XML) {
                qualifiedName = "xml:" + node.localName;
            } else {
                qualifiedName = node.localName;
            }
            /** 11.4. Append the value of qualified name to markup. */ this.beginElement(qualifiedName);
            this.openTagBegin(qualifiedName);
        } else {
            /**
             * 12. Otherwise, inherited ns is not equal to ns (the node's own
             * namespace is different from the context namespace of its parent).
             * Run these sub-steps:
             *
             * 12.1. Let prefix be the value of node's prefix attribute.
             * 12.2. Let candidate prefix be the result of retrieving a preferred
             * prefix string prefix from map given namespace ns. The above may return
             * null if no namespace key ns exists in map.
             */ var prefix = node.prefix;
            /**
             * We don't need to run "retrieving a preferred prefix string" algorithm if
             * the element has no prefix and its namespace matches to the default
             * namespace.
             * See: https://github.com/web-platform-tests/wpt/pull/16703
             */ var candidatePrefix = null;
            if (prefix !== null || ns !== localDefaultNamespace) {
                candidatePrefix = map.get(prefix, ns);
            }
            /**
             * 12.3. If the value of prefix matches "xmlns", then run the following
             * steps:
             */ if (prefix === "xmlns") {
                /**
                 * 12.3.1. If the require well-formed flag is set, then throw an error.
                 * An Element with prefix "xmlns" will not legally round-trip in a
                 * conforming XML parser.
                 */ if (requireWellFormed) {
                    throw new Error("An element cannot have the 'xmlns' prefix (well-formed required).");
                }
                /**
                 * 12.3.2. Let candidate prefix be the value of prefix.
                 */ candidatePrefix = prefix;
            }
            /**
             * 12.4.Found a suitable namespace prefix: if candidate prefix is not
             * null (a namespace prefix is defined which maps to ns), then:
             */ if (candidatePrefix !== null) {
                /**
                 * The following may serialize a different prefix than the Element's
                 * existing prefix if it already had one. However, the retrieving a
                 * preferred prefix string algorithm already tried to match the
                 * existing prefix if possible.
                 *
                 * 12.4.1. Append to qualified name the concatenation of candidate
                 * prefix, ":" (U+003A COLON), and node's localName. There exists on
                 * this node or the node's ancestry a namespace prefix definition that
                 * defines the node's namespace.
                 * 12.4.2. If the local default namespace is not null (there exists a
                 * locally-defined default namespace declaration attribute) and its
                 * value is not the XML namespace, then let inherited ns get the value
                 * of local default namespace unless the local default namespace is the
                 * empty string in which case let it get null (the context namespace
                 * is changed to the declared default, rather than this node's own
                 * namespace).
                 *
                 * _Note:_ Any default namespace definitions or namespace prefixes that
                 * define the XML namespace are omitted when serializing this node's
                 * attributes.
                 */ qualifiedName = candidatePrefix + ":" + node.localName;
                if (localDefaultNamespace !== null && localDefaultNamespace !== infra_1.namespace.XML) {
                    inheritedNS = localDefaultNamespace || null;
                }
                /**
                 * 12.4.3. Append the value of qualified name to markup.
                 */ this.beginElement(qualifiedName);
                this.openTagBegin(qualifiedName);
            /** 12.5. Otherwise, if prefix is not null, then: */ } else if (prefix !== null) {
                /**
                 * _Note:_ By this step, there is no namespace or prefix mapping
                 * declaration in this node (or any parent node visited by this
                 * algorithm) that defines prefix otherwise the step labelled Found
                 * a suitable namespace prefix would have been followed. The sub-steps
                 * that follow will create a new namespace prefix declaration for prefix
                 * and ensure that prefix does not conflict with an existing namespace
                 * prefix declaration of the same localName in node's attribute list.
                 *
                 * 12.5.1. If the local prefixes map contains a key matching prefix,
                 * then let prefix be the result of generating a prefix providing as
                 * input map, ns, and prefix index.
                 */ if (prefix in localPrefixesMap) {
                    prefix = this._generatePrefix(ns, map, prefixIndex);
                }
                /**
                 * 12.5.2. Add prefix to map given namespace ns.
                 * 12.5.3. Append to qualified name the concatenation of prefix, ":"
                 * (U+003A COLON), and node's localName.
                 * 12.5.4. Append the value of qualified name to markup.
                 */ map.set(prefix, ns);
                qualifiedName += prefix + ":" + node.localName;
                this.beginElement(qualifiedName);
                this.openTagBegin(qualifiedName);
                /**
                 * 12.5.5. Append the following to markup, in the order listed:
                 *
                 * _Note:_ The following serializes a namespace prefix declaration for
                 * prefix which was just added to the map.
                 *
                 * 12.5.5.1. " " (U+0020 SPACE);
                 * 12.5.5.2. The string "xmlns:";
                 * 12.5.5.3. The value of prefix;
                 * 12.5.5.4. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 12.5.5.5. The result of serializing an attribute value given ns and
                 * the require well-formed flag as input;
                 * 12.5.5.6. """ (U+0022 QUOTATION MARK).
                 */ attributes.push([
                    null,
                    "xmlns",
                    prefix,
                    this._serializeAttributeValue(ns, requireWellFormed)
                ]);
                /**
                 * 12.5.5.7. If local default namespace is not null (there exists a
                 * locally-defined default namespace declaration attribute), then
                 * let inherited ns get the value of local default namespace unless the
                 * local default namespace is the empty string in which case let it get
                 * null.
                 */ if (localDefaultNamespace !== null) {
                    inheritedNS = localDefaultNamespace || null;
                }
            /**
                 * 12.6. Otherwise, if local default namespace is null, or local
                 * default namespace is not null and its value is not equal to ns, then:
                 */ } else if (localDefaultNamespace === null || localDefaultNamespace !== null && localDefaultNamespace !== ns) {
                /**
                 * _Note:_ At this point, the namespace for this node still needs to be
                 * serialized, but there's no prefix (or candidate prefix) available; the
                 * following uses the default namespace declaration to define the
                 * namespace--optionally replacing an existing default declaration
                 * if present.
                 *
                 * 12.6.1. Set the ignore namespace definition attribute flag to true.
                 * 12.6.2. Append to qualified name the value of node's localName.
                 * 12.6.3. Let the value of inherited ns be ns.
                 *
                 * _Note:_ The new default namespace will be used in the serialization
                 * to define this node's namespace and act as the context namespace for
                 * its children.
                 */ ignoreNamespaceDefinitionAttribute = true;
                qualifiedName += node.localName;
                inheritedNS = ns;
                /**
                 * 12.6.4. Append the value of qualified name to markup.
                 */ this.beginElement(qualifiedName);
                this.openTagBegin(qualifiedName);
                /**
                 * 12.6.5. Append the following to markup, in the order listed:
                 *
                 * _Note:_ The following serializes the new (or replacement) default
                 * namespace definition.
                 *
                 * 12.6.5.1. " " (U+0020 SPACE);
                 * 12.6.5.2. The string "xmlns";
                 * 12.6.5.3. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 12.6.5.4. The result of serializing an attribute value given ns
                 * and the require well-formed flag as input;
                 * 12.6.5.5. """ (U+0022 QUOTATION MARK).
                 */ attributes.push([
                    null,
                    null,
                    "xmlns",
                    this._serializeAttributeValue(ns, requireWellFormed)
                ]);
            /**
                 * 12.7. Otherwise, the node has a local default namespace that matches
                 * ns. Append to qualified name the value of node's localName, let the
                 * value of inherited ns be ns, and append the value of qualified name
                 * to markup.
                 */ } else {
                qualifiedName += node.localName;
                inheritedNS = ns;
                this.beginElement(qualifiedName);
                this.openTagBegin(qualifiedName);
            }
        }
        /**
         * 13. Append to markup the result of the XML serialization of node's
         * attributes given map, prefix index, local prefixes map, ignore namespace
         * definition attribute flag, and require well-formed flag.
         */ attributes.push.apply(attributes, __spread(this._serializeAttributesNS(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed)));
        this.attributes(attributes);
        /**
         * 14. If ns is the HTML namespace, and the node's list of children is
         * empty, and the node's localName matches any one of the following void
         * elements: "area", "base", "basefont", "bgsound", "br", "col", "embed",
         * "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta",
         * "param", "source", "track", "wbr"; then append the following to markup,
         * in the order listed:
         * 14.1. " " (U+0020 SPACE);
         * 14.2. "/" (U+002F SOLIDUS).
         * and set the skip end tag flag to true.
         * 15. If ns is not the HTML namespace, and the node's list of children is
         * empty, then append "/" (U+002F SOLIDUS) to markup and set the skip end
         * tag flag to true.
         * 16. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         */ var isHTML = ns === infra_1.namespace.HTML;
        if (isHTML && node.childNodes.length === 0 && BaseWriter._VoidElementNames.has(node.localName)) {
            this.openTagEnd(qualifiedName, true, true);
            this.endElement(qualifiedName);
            skipEndTag = true;
        } else if (!isHTML && node.childNodes.length === 0) {
            this.openTagEnd(qualifiedName, true, false);
            this.endElement(qualifiedName);
            skipEndTag = true;
        } else {
            this.openTagEnd(qualifiedName, false, false);
        }
        /**
         * 17. If the value of skip end tag is true, then return the value of markup
         * and skip the remaining steps. The node is a leaf-node.
         */ if (skipEndTag) return;
        /**
         * 18. If ns is the HTML namespace, and the node's localName matches the
         * string "template", then this is a template element. Append to markup the
         * result of XML serializing a DocumentFragment node given the template
         * element's template contents (a DocumentFragment), providing inherited
         * ns, map, prefix index, and the require well-formed flag.
         *
         * _Note:_ This allows template content to round-trip, given the rules for
         * parsing XHTML documents.
         *
         * 19. Otherwise, append to markup the result of running the XML
         * serialization algorithm on each of node's children, in tree order,
         * providing inherited ns, map, prefix index, and the require well-formed
         * flag.
         */ if (isHTML && node.localName === "template") {
        // TODO: serialize template contents
        } else {
            try {
                for(var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()){
                    var childNode = _c.value;
                    this.level++;
                    this._serializeNodeNS(childNode, inheritedNS, map, prefixIndex, requireWellFormed);
                    this.level--;
                }
            } catch (e_2_1) {
                e_2 = {
                    error: e_2_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally{
                    if (e_2) throw e_2.error;
                }
            }
        }
        /**
         * 20. Append the following to markup, in the order listed:
         * 20.1. "</" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);
         * 20.2. The value of qualified name;
         * 20.3. ">" (U+003E GREATER-THAN SIGN).
         * 21. Return the value of markup.
         */ this.closeTag(qualifiedName);
        this.endElement(qualifiedName);
    };
    /**
     * Produces an XML serialization of an element node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ BaseWriter.prototype._serializeElement = function(node, requireWellFormed) {
        var e_3, _a;
        /**
         * From: https://w3c.github.io/DOM-Parsing/#xml-serializing-an-element-node
         *
         * 1. If the require well-formed flag is set (its value is true), and this
         * node's localName attribute contains the character ":" (U+003A COLON) or
         * does not match the XML Name production, then throw an exception; the
         * serialization of this node would not be a well-formed element.
         */ if (requireWellFormed && (node.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(node.localName))) {
            throw new Error("Node local name contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the string "<" (U+003C LESS-THAN SIGN).
         * 3. Let qualified name be an empty string.
         * 4. Let skip end tag be a boolean flag with value false.
         * 5. Let ignore namespace definition attribute be a boolean flag with value
         * false.
         * 6. Given prefix map, copy a namespace prefix map and let map be the
         * result.
         * 7. Let local prefixes map be an empty map. The map has unique Node prefix
         * strings as its keys, with corresponding namespaceURI Node values as the
         * map's key values (in this map, the null namespace is represented by the
         * empty string).
         *
         * _Note:_ This map is local to each element. It is used to ensure there
         * are no conflicting prefixes should a new namespace prefix attribute need
         * to be generated. It is also used to enable skipping of duplicate prefix
         * definitions when writing an element's attributes: the map allows the
         * algorithm to distinguish between a prefix in the namespace prefix map
         * that might be locally-defined (to the current Element) and one that is
         * not.
         * 8. Let local default namespace be the result of recording the namespace
         * information for node given map and local prefixes map.
         *
         * _Note:_ The above step will update map with any found namespace prefix
         * definitions, add the found prefix definitions to the local prefixes map
         * and return a local default namespace value defined by a default namespace
         * attribute if one exists. Otherwise it returns null.
         * 9. Let inherited ns be a copy of namespace.
         * 10. Let ns be the value of node's namespaceURI attribute.
         */ var skipEndTag = false;
        /** 11. If inherited ns is equal to ns, then: */ /**
         * 11.1. If local default namespace is not null, then set ignore
         * namespace definition attribute to true.
         */ /**
         * 11.2. If ns is the XML namespace, then append to qualified name the
         * concatenation of the string "xml:" and the value of node's localName.
         * 11.3. Otherwise, append to qualified name the value of node's
         * localName. The node's prefix if it exists, is dropped.
         */ var qualifiedName = node.localName;
        /** 11.4. Append the value of qualified name to markup. */ this.beginElement(qualifiedName);
        this.openTagBegin(qualifiedName);
        /**
         * 13. Append to markup the result of the XML serialization of node's
         * attributes given map, prefix index, local prefixes map, ignore namespace
         * definition attribute flag, and require well-formed flag.
         */ var attributes = this._serializeAttributes(node, requireWellFormed);
        this.attributes(attributes);
        /**
         * 14. If ns is the HTML namespace, and the node's list of children is
         * empty, and the node's localName matches any one of the following void
         * elements: "area", "base", "basefont", "bgsound", "br", "col", "embed",
         * "frame", "hr", "img", "input", "keygen", "link", "menuitem", "meta",
         * "param", "source", "track", "wbr"; then append the following to markup,
         * in the order listed:
         * 14.1. " " (U+0020 SPACE);
         * 14.2. "/" (U+002F SOLIDUS).
         * and set the skip end tag flag to true.
         * 15. If ns is not the HTML namespace, and the node's list of children is
         * empty, then append "/" (U+002F SOLIDUS) to markup and set the skip end
         * tag flag to true.
         * 16. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         */ if (!node.hasChildNodes()) {
            this.openTagEnd(qualifiedName, true, false);
            this.endElement(qualifiedName);
            skipEndTag = true;
        } else {
            this.openTagEnd(qualifiedName, false, false);
        }
        /**
         * 17. If the value of skip end tag is true, then return the value of markup
         * and skip the remaining steps. The node is a leaf-node.
         */ if (skipEndTag) return;
        try {
            /**
             * 18. If ns is the HTML namespace, and the node's localName matches the
             * string "template", then this is a template element. Append to markup the
             * result of XML serializing a DocumentFragment node given the template
             * element's template contents (a DocumentFragment), providing inherited
             * ns, map, prefix index, and the require well-formed flag.
             *
             * _Note:_ This allows template content to round-trip, given the rules for
             * parsing XHTML documents.
             *
             * 19. Otherwise, append to markup the result of running the XML
             * serialization algorithm on each of node's children, in tree order,
             * providing inherited ns, map, prefix index, and the require well-formed
             * flag.
             */ for(var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()){
                var childNode = _c.value;
                this.level++;
                this._serializeNode(childNode, requireWellFormed);
                this.level--;
            }
        } catch (e_3_1) {
            e_3 = {
                error: e_3_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_3) throw e_3.error;
            }
        }
        /**
         * 20. Append the following to markup, in the order listed:
         * 20.1. "</" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);
         * 20.2. The value of qualified name;
         * 20.3. ">" (U+003E GREATER-THAN SIGN).
         * 21. Return the value of markup.
         */ this.closeTag(qualifiedName);
        this.endElement(qualifiedName);
    };
    /**
     * Produces an XML serialization of a document node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */ BaseWriter.prototype._serializeDocumentNS = function(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_4, _a;
        /**
         * If the require well-formed flag is set (its value is true), and this node
         * has no documentElement (the documentElement attribute's value is null),
         * then throw an exception; the serialization of this node would not be a
         * well-formed document.
         */ if (requireWellFormed && node.documentElement === null) {
            throw new Error("Missing document element (well-formed required).");
        }
        try {
            /**
             * Otherwise, run the following steps:
             * 1. Let serialized document be an empty string.
             * 2. For each child child of node, in tree order, run the XML
             * serialization algorithm on the child passing along the provided
             * arguments, and append the result to serialized document.
             *
             * _Note:_ This will serialize any number of ProcessingInstruction and
             * Comment nodes both before and after the Document's documentElement node,
             * including at most one DocumentType node. (Text nodes are not allowed as
             * children of the Document.)
             *
             * 3. Return the value of serialized document.
            */ for(var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()){
                var childNode = _c.value;
                this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
            }
        } catch (e_4_1) {
            e_4 = {
                error: e_4_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_4) throw e_4.error;
            }
        }
    };
    /**
     * Produces an XML serialization of a document node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ BaseWriter.prototype._serializeDocument = function(node, requireWellFormed) {
        var e_5, _a;
        /**
         * If the require well-formed flag is set (its value is true), and this node
         * has no documentElement (the documentElement attribute's value is null),
         * then throw an exception; the serialization of this node would not be a
         * well-formed document.
         */ if (requireWellFormed && node.documentElement === null) {
            throw new Error("Missing document element (well-formed required).");
        }
        try {
            /**
             * Otherwise, run the following steps:
             * 1. Let serialized document be an empty string.
             * 2. For each child child of node, in tree order, run the XML
             * serialization algorithm on the child passing along the provided
             * arguments, and append the result to serialized document.
             *
             * _Note:_ This will serialize any number of ProcessingInstruction and
             * Comment nodes both before and after the Document's documentElement node,
             * including at most one DocumentType node. (Text nodes are not allowed as
             * children of the Document.)
             *
             * 3. Return the value of serialized document.
            */ for(var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()){
                var childNode = _c.value;
                this._serializeNode(childNode, requireWellFormed);
            }
        } catch (e_5_1) {
            e_5 = {
                error: e_5_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_5) throw e_5.error;
            }
        }
    };
    /**
     * Produces an XML serialization of a comment node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ BaseWriter.prototype._serializeComment = function(node, requireWellFormed) {
        /**
         * If the require well-formed flag is set (its value is true), and node's
         * data contains characters that are not matched by the XML Char production
         * or contains "--" (two adjacent U+002D HYPHEN-MINUS characters) or that
         * ends with a "-" (U+002D HYPHEN-MINUS) character, then throw an exception;
         * the serialization of this node's data would not be well-formed.
         */ if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) || node.data.indexOf("--") !== -1 || node.data.endsWith("-"))) {
            throw new Error("Comment data contains invalid characters (well-formed required).");
        }
        /**
         * Otherwise, return the concatenation of "<!--", node's data, and "-->".
         */ this.comment(node.data);
    };
    /**
     * Produces an XML serialization of a text node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     * @param level - current depth of the XML tree
     */ BaseWriter.prototype._serializeText = function(node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is set (its value is true), and
         * node's data contains characters that are not matched by the XML Char
         * production, then throw an exception; the serialization of this node's
         * data would not be well-formed.
         */ if (requireWellFormed && !algorithm_1.xml_isLegalChar(node.data)) {
            throw new Error("Text data contains invalid characters (well-formed required).");
        }
        /**
         * 2. Let markup be the value of node's data.
         * 3. Replace any occurrences of "&" in markup by "&amp;".
         * 4. Replace any occurrences of "<" in markup by "&lt;".
         * 5. Replace any occurrences of ">" in markup by "&gt;".
         * 6. Return the value of markup.
         */ var markup = node.data.replace(constants_1.nonEntityAmpersandRegex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        this.text(markup);
    };
    /**
     * Produces an XML serialization of a document fragment node.
     *
     * @param node - node to serialize
     * @param namespace - context namespace
     * @param prefixMap - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param requireWellFormed - whether to check conformance
     */ BaseWriter.prototype._serializeDocumentFragmentNS = function(node, namespace, prefixMap, prefixIndex, requireWellFormed) {
        var e_6, _a;
        try {
            /**
             * 1. Let markup the empty string.
             * 2. For each child child of node, in tree order, run the XML serialization
             * algorithm on the child given namespace, prefix map, a reference to prefix
             * index, and flag require well-formed. Concatenate the result to markup.
             * 3. Return the value of markup.
             */ for(var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()){
                var childNode = _c.value;
                this._serializeNodeNS(childNode, namespace, prefixMap, prefixIndex, requireWellFormed);
            }
        } catch (e_6_1) {
            e_6 = {
                error: e_6_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_6) throw e_6.error;
            }
        }
    };
    /**
     * Produces an XML serialization of a document fragment node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ BaseWriter.prototype._serializeDocumentFragment = function(node, requireWellFormed) {
        var e_7, _a;
        try {
            /**
             * 1. Let markup the empty string.
             * 2. For each child child of node, in tree order, run the XML serialization
             * algorithm on the child given namespace, prefix map, a reference to prefix
             * index, and flag require well-formed. Concatenate the result to markup.
             * 3. Return the value of markup.
             */ for(var _b = __values(node._children), _c = _b.next(); !_c.done; _c = _b.next()){
                var childNode = _c.value;
                this._serializeNode(childNode, requireWellFormed);
            }
        } catch (e_7_1) {
            e_7 = {
                error: e_7_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_7) throw e_7.error;
            }
        }
    };
    /**
     * Produces an XML serialization of a document type node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ BaseWriter.prototype._serializeDocumentType = function(node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is true and the node's publicId
         * attribute contains characters that are not matched by the XML PubidChar
         *  production, then throw an exception; the serialization of this node
         * would not be a well-formed document type declaration.
         */ if (requireWellFormed && !algorithm_1.xml_isPubidChar(node.publicId)) {
            throw new Error("DocType public identifier does not match PubidChar construct (well-formed required).");
        }
        /**
         * 2. If the require well-formed flag is true and the node's systemId
         * attribute contains characters that are not matched by the XML Char
         * production or that contains both a """ (U+0022 QUOTATION MARK) and a
         * "'" (U+0027 APOSTROPHE), then throw an exception; the serialization
         * of this node would not be a well-formed document type declaration.
         */ if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.systemId) || node.systemId.indexOf('"') !== -1 && node.systemId.indexOf("'") !== -1)) {
            throw new Error("DocType system identifier contains invalid characters (well-formed required).");
        }
        /**
         * 3. Let markup be an empty string.
         * 4. Append the string "<!DOCTYPE" to markup.
         * 5. Append " " (U+0020 SPACE) to markup.
         * 6. Append the value of the node's name attribute to markup. For a node
         * belonging to an HTML document, the value will be all lowercase.
         * 7. If the node's publicId is not the empty string then append the
         * following, in the order listed, to markup:
         * 7.1. " " (U+0020 SPACE);
         * 7.2. The string "PUBLIC";
         * 7.3. " " (U+0020 SPACE);
         * 7.4. """ (U+0022 QUOTATION MARK);
         * 7.5. The value of the node's publicId attribute;
         * 7.6. """ (U+0022 QUOTATION MARK).
         * 8. If the node's systemId is not the empty string and the node's publicId
         * is set to the empty string, then append the following, in the order
         * listed, to markup:
         * 8.1. " " (U+0020 SPACE);
         * 8.2. The string "SYSTEM".
         * 9. If the node's systemId is not the empty string then append the
         * following, in the order listed, to markup:
         * 9.2. " " (U+0020 SPACE);
         * 9.3. """ (U+0022 QUOTATION MARK);
         * 9.3. The value of the node's systemId attribute;
         * 9.4. """ (U+0022 QUOTATION MARK).
         * 10. Append ">" (U+003E GREATER-THAN SIGN) to markup.
         * 11. Return the value of markup.
         */ this.docType(node.name, node.publicId, node.systemId);
    };
    /**
     * Produces an XML serialization of a processing instruction node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ BaseWriter.prototype._serializeProcessingInstruction = function(node, requireWellFormed) {
        /**
         * 1. If the require well-formed flag is set (its value is true), and node's
         * target contains a ":" (U+003A COLON) character or is an ASCII
         * case-insensitive match for the string "xml", then throw an exception;
         * the serialization of this node's target would not be well-formed.
         */ if (requireWellFormed && (node.target.indexOf(":") !== -1 || /^xml$/i.test(node.target))) {
            throw new Error("Processing instruction target contains invalid characters (well-formed required).");
        }
        /**
         * 2. If the require well-formed flag is set (its value is true), and node's
         * data contains characters that are not matched by the XML Char production
         * or contains the string "?>" (U+003F QUESTION MARK,
         * U+003E GREATER-THAN SIGN), then throw an exception; the serialization of
         * this node's data would not be well-formed.
         */ if (requireWellFormed && (!algorithm_1.xml_isLegalChar(node.data) || node.data.indexOf("?>") !== -1)) {
            throw new Error("Processing instruction data contains invalid characters (well-formed required).");
        }
        /**
         * 3. Let markup be the concatenation of the following, in the order listed:
         * 3.1. "<?" (U+003C LESS-THAN SIGN, U+003F QUESTION MARK);
         * 3.2. The value of node's target;
         * 3.3. " " (U+0020 SPACE);
         * 3.4. The value of node's data;
         * 3.5. "?>" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN).
         * 4. Return the value of markup.
         */ this.instruction(node.target, node.data);
    };
    /**
     * Produces an XML serialization of a CDATA node.
     *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
     */ BaseWriter.prototype._serializeCData = function(node, requireWellFormed) {
        if (requireWellFormed && node.data.indexOf("]]>") !== -1) {
            throw new Error("CDATA contains invalid characters (well-formed required).");
        }
        this.cdata(node.data);
    };
    /**
    * Produces an XML serialization of the attributes of an element node.
    *
     * @param node - node to serialize
     * @param map - namespace prefix map
     * @param prefixIndex - generated namespace prefix index
     * @param localPrefixesMap - local prefixes map
     * @param ignoreNamespaceDefinitionAttribute - whether to ignore namespace
     * attributes
     * @param requireWellFormed - whether to check conformance
    */ BaseWriter.prototype._serializeAttributesNS = function(node, map, prefixIndex, localPrefixesMap, ignoreNamespaceDefinitionAttribute, requireWellFormed) {
        var e_8, _a;
        /**
         * 1. Let result be the empty string.
         * 2. Let localname set be a new empty namespace localname set. This
         * localname set will contain tuples of unique attribute namespaceURI and
         * localName pairs, and is populated as each attr is processed. This set is
         * used to [optionally] enforce the well-formed constraint that an element
         * cannot have two attributes with the same namespaceURI and localName.
         * This can occur when two otherwise identical attributes on the same
         * element differ only by their prefix values.
         */ var result = [];
        var localNameSet = requireWellFormed ? new LocalNameSet_1.LocalNameSet() : undefined;
        try {
            /**
             * 3. Loop: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */ for(var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()){
                var attr = _c.value;
                // Optimize common case
                if (!requireWellFormed && !ignoreNamespaceDefinitionAttribute && attr.namespaceURI === null) {
                    result.push([
                        null,
                        null,
                        attr.localName,
                        this._serializeAttributeValue(attr.value, requireWellFormed)
                    ]);
                    continue;
                }
                /**
                 * 3.1. If the require well-formed flag is set (its value is true), and the
                 * localname set contains a tuple whose values match those of a new tuple
                 * consisting of attr's namespaceURI attribute and localName attribute,
                 * then throw an exception; the serialization of this attr would fail to
                 * produce a well-formed element serialization.
                 */ if (requireWellFormed && localNameSet && localNameSet.has(attr.namespaceURI, attr.localName)) {
                    throw new Error("Element contains duplicate attributes (well-formed required).");
                }
                /**
                 * 3.2. Create a new tuple consisting of attr's namespaceURI attribute and
                 * localName attribute, and add it to the localname set.
                 * 3.3. Let attribute namespace be the value of attr's namespaceURI value.
                 * 3.4. Let candidate prefix be null.
                 */ if (requireWellFormed && localNameSet) localNameSet.set(attr.namespaceURI, attr.localName);
                var attributeNamespace = attr.namespaceURI;
                var candidatePrefix = null;
                /** 3.5. If attribute namespace is not null, then run these sub-steps: */ if (attributeNamespace !== null) {
                    /**
                     * 3.5.1. Let candidate prefix be the result of retrieving a preferred
                     * prefix string from map given namespace attribute namespace with
                     * preferred prefix being attr's prefix value.
                     */ candidatePrefix = map.get(attr.prefix, attributeNamespace);
                    /**
                     * 3.5.2. If the value of attribute namespace is the XMLNS namespace,
                     * then run these steps:
                     */ if (attributeNamespace === infra_1.namespace.XMLNS) {
                        /**
                         * 3.5.2.1. If any of the following are true, then stop running these
                         * steps and goto Loop to visit the next attribute:
                         * - the attr's value is the XML namespace;
                         * _Note:_ The XML namespace cannot be redeclared and survive
                         * round-tripping (unless it defines the prefix "xml"). To avoid this
                         * problem, this algorithm always prefixes elements in the XML
                         * namespace with "xml" and drops any related definitions as seen
                         * in the above condition.
                         * - the attr's prefix is null and the ignore namespace definition
                         * attribute flag is true (the Element's default namespace attribute
                         * should be skipped);
                         * - the attr's prefix is not null and either
                         *   * the attr's localName is not a key contained in the local
                         *     prefixes map, or
                         *   * the attr's localName is present in the local prefixes map but
                         *     the value of the key does not match attr's value
                         * and furthermore that the attr's localName (as the prefix to find)
                         * is found in the namespace prefix map given the namespace consisting
                         * of the attr's value (the current namespace prefix definition was
                         * exactly defined previously--on an ancestor element not the current
                         * element whose attributes are being processed).
                         */ if (attr.value === infra_1.namespace.XML || attr.prefix === null && ignoreNamespaceDefinitionAttribute || attr.prefix !== null && (!(attr.localName in localPrefixesMap) || localPrefixesMap[attr.localName] !== attr.value) && map.has(attr.localName, attr.value)) continue;
                        /**
                         * 3.5.2.2. If the require well-formed flag is set (its value is true),
                         * and the value of attr's value attribute matches the XMLNS
                         * namespace, then throw an exception; the serialization of this
                         * attribute would produce invalid XML because the XMLNS namespace
                         * is reserved and cannot be applied as an element's namespace via
                         * XML parsing.
                         *
                         * _Note:_ DOM APIs do allow creation of elements in the XMLNS
                         * namespace but with strict qualifications.
                         */ if (requireWellFormed && attr.value === infra_1.namespace.XMLNS) {
                            throw new Error("XMLNS namespace is reserved (well-formed required).");
                        }
                        /**
                         * 3.5.2.3. If the require well-formed flag is set (its value is true),
                         * and the value of attr's value attribute is the empty string, then
                         * throw an exception; namespace prefix declarations cannot be used
                         * to undeclare a namespace (use a default namespace declaration
                         * instead).
                         */ if (requireWellFormed && attr.value === "") {
                            throw new Error("Namespace prefix declarations cannot be used to undeclare a namespace (well-formed required).");
                        }
                        /**
                         * 3.5.2.4. the attr's prefix matches the string "xmlns", then let
                         * candidate prefix be the string "xmlns".
                         */ if (attr.prefix === "xmlns") candidatePrefix = "xmlns";
                    /**
                         * 3.5.3. Otherwise, the attribute namespace is not the XMLNS namespace.
                         * Run these steps:
                         *
                         * _Note:_ The (candidatePrefix === null) check is not in the spec.
                         * We deviate from the spec here. Otherwise a prefix is generated for
                         * all attributes with namespaces.
                         */ } else if (candidatePrefix === null) {
                        if (attr.prefix !== null && (!map.hasPrefix(attr.prefix) || map.has(attr.prefix, attributeNamespace))) {
                            /**
                             * Check if we can use the attribute's own prefix.
                             * We deviate from the spec here.
                             * TODO: This is not an efficient way of searching for prefixes.
                             * Follow developments to the spec.
                             */ candidatePrefix = attr.prefix;
                        } else {
                            /**
                             * 3.5.3.1. Let candidate prefix be the result of generating a prefix
                             * providing map, attribute namespace, and prefix index as input.
                             */ candidatePrefix = this._generatePrefix(attributeNamespace, map, prefixIndex);
                        }
                        /**
                         * 3.5.3.2. Append the following to result, in the order listed:
                         * 3.5.3.2.1. " " (U+0020 SPACE);
                         * 3.5.3.2.2. The string "xmlns:";
                         * 3.5.3.2.3. The value of candidate prefix;
                         * 3.5.3.2.4. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                         * 3.5.3.2.5. The result of serializing an attribute value given
                         * attribute namespace and the require well-formed flag as input;
                         * 3.5.3.2.6. """ (U+0022 QUOTATION MARK).
                        */ result.push([
                            null,
                            "xmlns",
                            candidatePrefix,
                            this._serializeAttributeValue(attributeNamespace, requireWellFormed)
                        ]);
                    }
                }
                /**
                 * 3.6. Append a " " (U+0020 SPACE) to result.
                 * 3.7. If candidate prefix is not null, then append to result the
                 * concatenation of candidate prefix with ":" (U+003A COLON).
                 */ var attrName = "";
                if (candidatePrefix !== null) {
                    attrName = candidatePrefix;
                }
                /**
                 * 3.8. If the require well-formed flag is set (its value is true), and
                 * this attr's localName attribute contains the character
                 * ":" (U+003A COLON) or does not match the XML Name production or
                 * equals "xmlns" and attribute namespace is null, then throw an
                 * exception; the serialization of this attr would not be a
                 * well-formed attribute.
                 */ if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attr.localName) || attr.localName === "xmlns" && attributeNamespace === null)) {
                    throw new Error("Attribute local name contains invalid characters (well-formed required).");
                }
                /**
                 * 3.9. Append the following strings to result, in the order listed:
                 * 3.9.1. The value of attr's localName;
                 * 3.9.2. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 3.9.3. The result of serializing an attribute value given attr's value
                 * attribute and the require well-formed flag as input;
                 * 3.9.4. """ (U+0022 QUOTATION MARK).
                 */ result.push([
                    attributeNamespace,
                    candidatePrefix,
                    attr.localName,
                    this._serializeAttributeValue(attr.value, requireWellFormed)
                ]);
            }
        } catch (e_8_1) {
            e_8 = {
                error: e_8_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_8) throw e_8.error;
            }
        }
        /**
         * 4. Return the value of result.
         */ return result;
    };
    /**
    * Produces an XML serialization of the attributes of an element node.
    *
     * @param node - node to serialize
     * @param requireWellFormed - whether to check conformance
    */ BaseWriter.prototype._serializeAttributes = function(node, requireWellFormed) {
        var e_9, _a;
        /**
         * 1. Let result be the empty string.
         * 2. Let localname set be a new empty namespace localname set. This
         * localname set will contain tuples of unique attribute namespaceURI and
         * localName pairs, and is populated as each attr is processed. This set is
         * used to [optionally] enforce the well-formed constraint that an element
         * cannot have two attributes with the same namespaceURI and localName.
         * This can occur when two otherwise identical attributes on the same
         * element differ only by their prefix values.
         */ var result = [];
        var localNameSet = requireWellFormed ? {} : undefined;
        try {
            /**
             * 3. Loop: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */ for(var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()){
                var attr = _c.value;
                // Optimize common case
                if (!requireWellFormed) {
                    result.push([
                        null,
                        null,
                        attr.localName,
                        this._serializeAttributeValue(attr.value, requireWellFormed)
                    ]);
                    continue;
                }
                /**
                 * 3.1. If the require well-formed flag is set (its value is true), and the
                 * localname set contains a tuple whose values match those of a new tuple
                 * consisting of attr's namespaceURI attribute and localName attribute,
                 * then throw an exception; the serialization of this attr would fail to
                 * produce a well-formed element serialization.
                 */ if (requireWellFormed && localNameSet && attr.localName in localNameSet) {
                    throw new Error("Element contains duplicate attributes (well-formed required).");
                }
                /**
                 * 3.2. Create a new tuple consisting of attr's namespaceURI attribute and
                 * localName attribute, and add it to the localname set.
                 * 3.3. Let attribute namespace be the value of attr's namespaceURI value.
                 * 3.4. Let candidate prefix be null.
                 */ /* istanbul ignore else */ if (requireWellFormed && localNameSet) localNameSet[attr.localName] = true;
                /** 3.5. If attribute namespace is not null, then run these sub-steps: */ /**
                 * 3.6. Append a " " (U+0020 SPACE) to result.
                 * 3.7. If candidate prefix is not null, then append to result the
                 * concatenation of candidate prefix with ":" (U+003A COLON).
                 */ /**
                 * 3.8. If the require well-formed flag is set (its value is true), and
                 * this attr's localName attribute contains the character
                 * ":" (U+003A COLON) or does not match the XML Name production or
                 * equals "xmlns" and attribute namespace is null, then throw an
                 * exception; the serialization of this attr would not be a
                 * well-formed attribute.
                 */ if (requireWellFormed && (attr.localName.indexOf(":") !== -1 || !algorithm_1.xml_isName(attr.localName))) {
                    throw new Error("Attribute local name contains invalid characters (well-formed required).");
                }
                /**
                 * 3.9. Append the following strings to result, in the order listed:
                 * 3.9.1. The value of attr's localName;
                 * 3.9.2. "="" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);
                 * 3.9.3. The result of serializing an attribute value given attr's value
                 * attribute and the require well-formed flag as input;
                 * 3.9.4. """ (U+0022 QUOTATION MARK).
                 */ result.push([
                    null,
                    null,
                    attr.localName,
                    this._serializeAttributeValue(attr.value, requireWellFormed)
                ]);
            }
        } catch (e_9_1) {
            e_9 = {
                error: e_9_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_9) throw e_9.error;
            }
        }
        /**
         * 4. Return the value of result.
         */ return result;
    };
    /**
    * Records namespace information for the given element and returns the
    * default namespace attribute value.
    *
    * @param node - element node to process
    * @param map - namespace prefix map
    * @param localPrefixesMap - local prefixes map
    */ BaseWriter.prototype._recordNamespaceInformation = function(node, map, localPrefixesMap) {
        var e_10, _a;
        /**
         * 1. Let default namespace attr value be null.
         */ var defaultNamespaceAttrValue = null;
        try {
            /**
             * 2. Main: For each attribute attr in element's attributes, in the order
             * they are specified in the element's attribute list:
             */ for(var _b = __values(node.attributes), _c = _b.next(); !_c.done; _c = _b.next()){
                var attr = _c.value;
                /**
                 * _Note:_ The following conditional steps find namespace prefixes. Only
                 * attributes in the XMLNS namespace are considered (e.g., attributes made
                 * to look like namespace declarations via
                 * setAttribute("xmlns:pretend-prefix", "pretend-namespace") are not
                 * included).
                 */ /** 2.1. Let attribute namespace be the value of attr's namespaceURI value. */ var attributeNamespace = attr.namespaceURI;
                /** 2.2. Let attribute prefix be the value of attr's prefix. */ var attributePrefix = attr.prefix;
                /** 2.3. If the attribute namespace is the XMLNS namespace, then: */ if (attributeNamespace === infra_1.namespace.XMLNS) {
                    /**
                     * 2.3.1. If attribute prefix is null, then attr is a default namespace
                     * declaration. Set the default namespace attr value to attr's value and
                     * stop running these steps, returning to Main to visit the next
                     * attribute.
                     */ if (attributePrefix === null) {
                        defaultNamespaceAttrValue = attr.value;
                        continue;
                    /**
                         * 2.3.2. Otherwise, the attribute prefix is not null and attr is a
                         * namespace prefix definition. Run the following steps:
                         */ } else {
                        /** 2.3.2.1. Let prefix definition be the value of attr's localName. */ var prefixDefinition = attr.localName;
                        /** 2.3.2.2. Let namespace definition be the value of attr's value. */ var namespaceDefinition = attr.value;
                        /**
                         * 2.3.2.3. If namespace definition is the XML namespace, then stop
                         * running these steps, and return to Main to visit the next
                         * attribute.
                         *
                         * _Note:_ XML namespace definitions in prefixes are completely
                         * ignored (in order to avoid unnecessary work when there might be
                         * prefix conflicts). XML namespaced elements are always handled
                         * uniformly by prefixing (and overriding if necessary) the element's
                         * localname with the reserved "xml" prefix.
                         */ if (namespaceDefinition === infra_1.namespace.XML) {
                            continue;
                        }
                        /**
                         * 2.3.2.4. If namespace definition is the empty string (the
                         * declarative form of having no namespace), then let namespace
                         * definition be null instead.
                         */ if (namespaceDefinition === "") {
                            namespaceDefinition = null;
                        }
                        /**
                         * 2.3.2.5. If prefix definition is found in map given the namespace
                         * namespace definition, then stop running these steps, and return to
                         * Main to visit the next attribute.
                         *
                         * _Note:_ This step avoids adding duplicate prefix definitions for
                         * the same namespace in the map. This has the side-effect of avoiding
                         * later serialization of duplicate namespace prefix declarations in
                         * any descendant nodes.
                         */ if (map.has(prefixDefinition, namespaceDefinition)) {
                            continue;
                        }
                        /**
                         * 2.3.2.6. Add the prefix prefix definition to map given namespace
                         * namespace definition.
                         */ map.set(prefixDefinition, namespaceDefinition);
                        /**
                         * 2.3.2.7. Add the value of prefix definition as a new key to the
                         * local prefixes map, with the namespace definition as the key's
                         * value replacing the value of null with the empty string if
                         * applicable.
                         */ localPrefixesMap[prefixDefinition] = namespaceDefinition || "";
                    }
                }
            }
        } catch (e_10_1) {
            e_10 = {
                error: e_10_1
            };
        } finally{
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally{
                if (e_10) throw e_10.error;
            }
        }
        /**
         * 3. Return the value of default namespace attr value.
         *
         * _Note:_ The empty string is a legitimate return value and is not
         * converted to null.
         */ return defaultNamespaceAttrValue;
    };
    /**
    * Generates a new prefix for the given namespace.
    *
    * @param newNamespace - a namespace to generate prefix for
    * @param prefixMap - namespace prefix map
    * @param prefixIndex - generated namespace prefix index
    */ BaseWriter.prototype._generatePrefix = function(newNamespace, prefixMap, prefixIndex) {
        /**
         * 1. Let generated prefix be the concatenation of the string "ns" and the
         * current numerical value of prefix index.
         * 2. Let the value of prefix index be incremented by one.
         * 3. Add to map the generated prefix given the new namespace namespace.
         * 4. Return the value of generated prefix.
         */ var generatedPrefix = "ns" + prefixIndex.value.toString();
        prefixIndex.value++;
        prefixMap.set(generatedPrefix, newNamespace);
        return generatedPrefix;
    };
    /**
     * Produces an XML serialization of an attribute value.
     *
     * @param value - attribute value
     * @param requireWellFormed - whether to check conformance
     */ BaseWriter.prototype._serializeAttributeValue = function(value, requireWellFormed) {
        /**
         * From: https://w3c.github.io/DOM-Parsing/#dfn-serializing-an-attribute-value
         *
         * 1. If the require well-formed flag is set (its value is true), and
         * attribute value contains characters that are not matched by the XML Char
         * production, then throw an exception; the serialization of this attribute
         * value would fail to produce a well-formed element serialization.
         */ if (requireWellFormed && value !== null && !algorithm_1.xml_isLegalChar(value)) {
            throw new Error("Invalid characters in attribute value.");
        }
        /**
         * 2. If attribute value is null, then return the empty string.
         */ if (value === null) return "";
        /**
         * 3. Otherwise, attribute value is a string. Return the value of attribute
         * value, first replacing any occurrences of the following:
         * - "&" with "&amp;"
         * - """ with "&quot;"
         * - "<" with "&lt;"
         * - ">" with "&gt;"
         * NOTE
         * This matches behavior present in browsers, and goes above and beyond the
         * grammar requirement in the XML specification's AttValue production by
         * also replacing ">" characters.
         */ return value.replace(constants_1.nonEntityAmpersandRegex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    };
    BaseWriter._VoidElementNames = new Set([
        "area",
        "base",
        "basefont",
        "bgsound",
        "br",
        "col",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "keygen",
        "link",
        "menuitem",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
    ]);
    return BaseWriter;
}();
exports.BaseWriter = BaseWriter; //# sourceMappingURL=BaseWriter.js.map


/***/ }),

/***/ 93265:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var BaseCBWriter_1 = __webpack_require__(96266);
/**
 * Serializes XML nodes.
 */ var JSONCBWriter = /** @class */ function(_super) {
    __extends(JSONCBWriter, _super);
    /**
     * Initializes a new instance of `JSONCBWriter`.
     *
     * @param builderOptions - XML builder options
     */ function JSONCBWriter(builderOptions) {
        var _this = _super.call(this, builderOptions) || this;
        _this._hasChildren = [];
        _this._additionalLevel = 0;
        return _this;
    }
    /** @inheritdoc */ JSONCBWriter.prototype.frontMatter = function() {
        return "";
    };
    /** @inheritdoc */ JSONCBWriter.prototype.declaration = function(version, encoding, standalone) {
        return "";
    };
    /** @inheritdoc */ JSONCBWriter.prototype.docType = function(name, publicId, systemId) {
        return "";
    };
    /** @inheritdoc */ JSONCBWriter.prototype.comment = function(data) {
        // { "!": "hello" }
        return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.comment) + this._sep() + this._val(data) + this._sep() + "}";
    };
    /** @inheritdoc */ JSONCBWriter.prototype.text = function(data) {
        // { "#": "hello" }
        return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.text) + this._sep() + this._val(data) + this._sep() + "}";
    };
    /** @inheritdoc */ JSONCBWriter.prototype.instruction = function(target, data) {
        // { "?": "target hello" }
        return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.ins) + this._sep() + this._val(data ? target + " " + data : target) + this._sep() + "}";
    };
    /** @inheritdoc */ JSONCBWriter.prototype.cdata = function(data) {
        // { "$": "hello" }
        return this._comma() + this._beginLine() + "{" + this._sep() + this._key(this._builderOptions.convert.cdata) + this._sep() + this._val(data) + this._sep() + "}";
    };
    /** @inheritdoc */ JSONCBWriter.prototype.attribute = function(name, value) {
        // { "@name": "val" }
        return this._comma() + this._beginLine(1) + "{" + this._sep() + this._key(this._builderOptions.convert.att + name) + this._sep() + this._val(value) + this._sep() + "}";
    };
    /** @inheritdoc */ JSONCBWriter.prototype.openTagBegin = function(name) {
        // { "node": { "#": [
        var str = this._comma() + this._beginLine() + "{" + this._sep() + this._key(name) + this._sep() + "{";
        this._additionalLevel++;
        this.hasData = true;
        str += this._beginLine() + this._key(this._builderOptions.convert.text) + this._sep() + "[";
        this._hasChildren.push(false);
        return str;
    };
    /** @inheritdoc */ JSONCBWriter.prototype.openTagEnd = function(name, selfClosing, voidElement) {
        if (selfClosing) {
            var str = this._sep() + "]";
            this._additionalLevel--;
            str += this._beginLine() + "}" + this._sep() + "}";
            return str;
        } else {
            return "";
        }
    };
    /** @inheritdoc */ JSONCBWriter.prototype.closeTag = function(name) {
        // ] } }
        var str = this._beginLine() + "]";
        this._additionalLevel--;
        str += this._beginLine() + "}" + this._sep() + "}";
        return str;
    };
    /** @inheritdoc */ JSONCBWriter.prototype.beginElement = function(name) {};
    /** @inheritdoc */ JSONCBWriter.prototype.endElement = function(name) {
        this._hasChildren.pop();
    };
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     */ JSONCBWriter.prototype._beginLine = function(additionalOffset) {
        if (additionalOffset === void 0) {
            additionalOffset = 0;
        }
        if (this._writerOptions.prettyPrint) {
            return (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level + additionalOffset);
        } else {
            return "";
        }
    };
    /**
     * Produces an indentation string.
     *
     * @param level - depth of the tree
     */ JSONCBWriter.prototype._indent = function(level) {
        if (level + this._additionalLevel <= 0) {
            return "";
        } else {
            return this._writerOptions.indent.repeat(level + this._additionalLevel);
        }
    };
    /**
     * Produces a comma before a child node if it has previous siblings.
     */ JSONCBWriter.prototype._comma = function() {
        var str = this._hasChildren[this._hasChildren.length - 1] ? "," : "";
        if (this._hasChildren.length > 0) {
            this._hasChildren[this._hasChildren.length - 1] = true;
        }
        return str;
    };
    /**
     * Produces a separator string.
     */ JSONCBWriter.prototype._sep = function() {
        return this._writerOptions.prettyPrint ? " " : "";
    };
    /**
     * Produces a JSON key string delimited with double quotes.
     */ JSONCBWriter.prototype._key = function(key) {
        return '"' + key + '":';
    };
    /**
     * Produces a JSON value string delimited with double quotes.
     */ JSONCBWriter.prototype._val = function(val) {
        return JSON.stringify(val);
    };
    return JSONCBWriter;
}(BaseCBWriter_1.BaseCBWriter);
exports.JSONCBWriter = JSONCBWriter; //# sourceMappingURL=JSONCBWriter.js.map


/***/ }),

/***/ 10467:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var ObjectWriter_1 = __webpack_require__(75216);
var util_1 = __webpack_require__(96883);
var BaseWriter_1 = __webpack_require__(96798);
/**
 * Serializes XML nodes into a JSON string.
 */ var JSONWriter = /** @class */ function(_super) {
    __extends(JSONWriter, _super);
    /**
     * Initializes a new instance of `JSONWriter`.
     *
     * @param builderOptions - XML builder options
     * @param writerOptions - serialization options
     */ function JSONWriter(builderOptions, writerOptions) {
        var _this = _super.call(this, builderOptions) || this;
        // provide default options
        _this._writerOptions = util_1.applyDefaults(writerOptions, {
            wellFormed: false,
            prettyPrint: false,
            indent: "  ",
            newline: "\n",
            offset: 0,
            group: false,
            verbose: false
        });
        return _this;
    }
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     * @param writerOptions - serialization options
     */ JSONWriter.prototype.serialize = function(node) {
        // convert to object
        var objectWriterOptions = util_1.applyDefaults(this._writerOptions, {
            format: "object",
            wellFormed: false
        });
        var objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);
        var val = objectWriter.serialize(node);
        // recursively convert object into JSON string
        return this._beginLine(this._writerOptions, 0) + this._convertObject(val, this._writerOptions);
    };
    /**
     * Produces an XML serialization of the given object.
     *
     * @param obj - object to serialize
     * @param options - serialization options
     * @param level - depth of the XML tree
     */ JSONWriter.prototype._convertObject = function(obj, options, level) {
        var e_1, _a;
        var _this = this;
        if (level === void 0) {
            level = 0;
        }
        var markup = "";
        var isLeaf = this._isLeafNode(obj);
        if (util_1.isArray(obj)) {
            markup += "[";
            var len = obj.length;
            var i = 0;
            try {
                for(var obj_1 = __values(obj), obj_1_1 = obj_1.next(); !obj_1_1.done; obj_1_1 = obj_1.next()){
                    var val = obj_1_1.value;
                    markup += this._endLine(options, level + 1) + this._beginLine(options, level + 1) + this._convertObject(val, options, level + 1);
                    if (i < len - 1) {
                        markup += ",";
                    }
                    i++;
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (obj_1_1 && !obj_1_1.done && (_a = obj_1.return)) _a.call(obj_1);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            markup += this._endLine(options, level) + this._beginLine(options, level);
            markup += "]";
        } else if (util_1.isObject(obj)) {
            markup += "{";
            var len_1 = util_1.objectLength(obj);
            var i_1 = 0;
            util_1.forEachObject(obj, function(key, val) {
                if (isLeaf && options.prettyPrint) {
                    markup += " ";
                } else {
                    markup += _this._endLine(options, level + 1) + _this._beginLine(options, level + 1);
                }
                markup += _this._key(key);
                if (options.prettyPrint) {
                    markup += " ";
                }
                markup += _this._convertObject(val, options, level + 1);
                if (i_1 < len_1 - 1) {
                    markup += ",";
                }
                i_1++;
            }, this);
            if (isLeaf && options.prettyPrint) {
                markup += " ";
            } else {
                markup += this._endLine(options, level) + this._beginLine(options, level);
            }
            markup += "}";
        } else {
            markup += this._val(obj);
        }
        return markup;
    };
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     *
     * @param options - serialization options
     * @param level - current depth of the XML tree
     */ JSONWriter.prototype._beginLine = function(options, level) {
        if (!options.prettyPrint) {
            return "";
        } else {
            var indentLevel = options.offset + level + 1;
            if (indentLevel > 0) {
                return new Array(indentLevel).join(options.indent);
            }
        }
        return "";
    };
    /**
     * Produces characters to be appended to a line of string in pretty-print
     * mode.
     *
     * @param options - serialization options
     * @param level - current depth of the XML tree
     */ JSONWriter.prototype._endLine = function(options, level) {
        if (!options.prettyPrint) {
            return "";
        } else {
            return options.newline;
        }
    };
    /**
     * Produces a JSON key string delimited with double quotes.
     */ JSONWriter.prototype._key = function(key) {
        return '"' + key + '":';
    };
    /**
     * Produces a JSON value string delimited with double quotes.
     */ JSONWriter.prototype._val = function(val) {
        return JSON.stringify(val);
    };
    /**
     * Determines if an object is a leaf node.
     *
     * @param obj
     */ JSONWriter.prototype._isLeafNode = function(obj) {
        return this._descendantCount(obj) <= 1;
    };
    /**
     * Counts the number of descendants of the given object.
     *
     * @param obj
     * @param count
     */ JSONWriter.prototype._descendantCount = function(obj, count) {
        var _this = this;
        if (count === void 0) {
            count = 0;
        }
        if (util_1.isArray(obj)) {
            util_1.forEachArray(obj, function(val) {
                return count += _this._descendantCount(val, count);
            }, this);
        } else if (util_1.isObject(obj)) {
            util_1.forEachObject(obj, function(key, val) {
                return count += _this._descendantCount(val, count);
            }, this);
        } else {
            count++;
        }
        return count;
    };
    return JSONWriter;
}(BaseWriter_1.BaseWriter);
exports.JSONWriter = JSONWriter; //# sourceMappingURL=JSONWriter.js.map


/***/ }),

/***/ 98102:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(96883);
var ObjectWriter_1 = __webpack_require__(75216);
var BaseWriter_1 = __webpack_require__(96798);
/**
 * Serializes XML nodes into ES6 maps and arrays.
 */ var MapWriter = /** @class */ function(_super) {
    __extends(MapWriter, _super);
    /**
     * Initializes a new instance of `MapWriter`.
     *
     * @param builderOptions - XML builder options
     * @param writerOptions - serialization options
     */ function MapWriter(builderOptions, writerOptions) {
        var _this = _super.call(this, builderOptions) || this;
        // provide default options
        _this._writerOptions = util_1.applyDefaults(writerOptions, {
            format: "map",
            wellFormed: false,
            group: false,
            verbose: false
        });
        return _this;
    }
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     */ MapWriter.prototype.serialize = function(node) {
        // convert to object
        var objectWriterOptions = util_1.applyDefaults(this._writerOptions, {
            format: "object",
            wellFormed: false,
            verbose: false
        });
        var objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);
        var val = objectWriter.serialize(node);
        // recursively convert object into Map
        return this._convertObject(val);
    };
    /**
     * Recursively converts a JS object into an ES5 map.
     *
     * @param obj - a JS object
     */ MapWriter.prototype._convertObject = function(obj) {
        if (util_1.isArray(obj)) {
            for(var i = 0; i < obj.length; i++){
                obj[i] = this._convertObject(obj[i]);
            }
            return obj;
        } else if (util_1.isObject(obj)) {
            var map = new Map();
            for(var key in obj){
                map.set(key, this._convertObject(obj[key]));
            }
            return map;
        } else {
            return obj;
        }
    };
    return MapWriter;
}(BaseWriter_1.BaseWriter);
exports.MapWriter = MapWriter; //# sourceMappingURL=MapWriter.js.map


/***/ }),

/***/ 75216:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(96883);
var interfaces_1 = __webpack_require__(52580);
var BaseWriter_1 = __webpack_require__(96798);
/**
 * Serializes XML nodes into objects and arrays.
 */ var ObjectWriter = /** @class */ function(_super) {
    __extends(ObjectWriter, _super);
    /**
     * Initializes a new instance of `ObjectWriter`.
     *
     * @param builderOptions - XML builder options
     * @param writerOptions - serialization options
     */ function ObjectWriter(builderOptions, writerOptions) {
        var _this = _super.call(this, builderOptions) || this;
        _this._writerOptions = util_1.applyDefaults(writerOptions, {
            format: "object",
            wellFormed: false,
            group: false,
            verbose: false
        });
        return _this;
    }
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     */ ObjectWriter.prototype.serialize = function(node) {
        this._currentList = [];
        this._currentIndex = 0;
        this._listRegister = [
            this._currentList
        ];
        /**
         * First pass, serialize nodes
         * This creates a list of nodes grouped under node types while preserving
         * insertion order. For example:
         * [
         *   root: [
         *     node: [
         *       { "@" : { "att1": "val1", "att2": "val2" }
         *       { "#": "node text" }
         *       { childNode: [] }
         *       { "#": "more text" }
         *     ],
         *     node: [
         *       { "@" : { "att": "val" }
         *       { "#": [ "text line1", "text line2" ] }
         *     ]
         *   ]
         * ]
         */ this.serializeNode(node, this._writerOptions.wellFormed);
        /**
         * Second pass, process node lists. Above example becomes:
         * {
         *   root: {
         *     node: [
         *       {
         *         "@att1": "val1",
         *         "@att2": "val2",
         *         "#1": "node text",
         *         childNode: {},
         *         "#2": "more text"
         *       },
         *       {
         *         "@att": "val",
         *         "#": [ "text line1", "text line2" ]
         *       }
         *     ]
         *   }
         * }
         */ return this._process(this._currentList, this._writerOptions);
    };
    ObjectWriter.prototype._process = function(items, options) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (items.length === 0) return {};
        // determine if there are non-unique element names
        var namesSeen = {};
        var hasNonUniqueNames = false;
        var textCount = 0;
        var commentCount = 0;
        var instructionCount = 0;
        var cdataCount = 0;
        for(var i = 0; i < items.length; i++){
            var item = items[i];
            var key = Object.keys(item)[0];
            switch(key){
                case "@":
                    continue;
                case "#":
                    textCount++;
                    break;
                case "!":
                    commentCount++;
                    break;
                case "?":
                    instructionCount++;
                    break;
                case "$":
                    cdataCount++;
                    break;
                default:
                    if (namesSeen[key]) {
                        hasNonUniqueNames = true;
                    } else {
                        namesSeen[key] = true;
                    }
                    break;
            }
        }
        var defAttrKey = this._getAttrKey();
        var defTextKey = this._getNodeKey(interfaces_1.NodeType.Text);
        var defCommentKey = this._getNodeKey(interfaces_1.NodeType.Comment);
        var defInstructionKey = this._getNodeKey(interfaces_1.NodeType.ProcessingInstruction);
        var defCdataKey = this._getNodeKey(interfaces_1.NodeType.CData);
        if (textCount === 1 && items.length === 1 && util_1.isString(items[0]["#"])) {
            // special case of an element node with a single text node
            return items[0]["#"];
        } else if (hasNonUniqueNames) {
            var obj = {};
            // process attributes first
            for(var i = 0; i < items.length; i++){
                var item = items[i];
                var key = Object.keys(item)[0];
                if (key === "@") {
                    var attrs = item["@"];
                    var attrKeys = Object.keys(attrs);
                    if (attrKeys.length === 1) {
                        obj[defAttrKey + attrKeys[0]] = attrs[attrKeys[0]];
                    } else {
                        obj[defAttrKey] = item["@"];
                    }
                }
            }
            // list contains element nodes with non-unique names
            // return an array with mixed content notation
            var result = [];
            for(var i = 0; i < items.length; i++){
                var item = items[i];
                var key = Object.keys(item)[0];
                switch(key){
                    case "@":
                        break;
                    case "#":
                        result.push((_a = {}, _a[defTextKey] = item["#"], _a));
                        break;
                    case "!":
                        result.push((_b = {}, _b[defCommentKey] = item["!"], _b));
                        break;
                    case "?":
                        result.push((_c = {}, _c[defInstructionKey] = item["?"], _c));
                        break;
                    case "$":
                        result.push((_d = {}, _d[defCdataKey] = item["$"], _d));
                        break;
                    default:
                        // element node
                        var ele = item;
                        if (ele[key].length !== 0 && util_1.isArray(ele[key][0])) {
                            // group of element nodes
                            var eleGroup = [];
                            var listOfLists = ele[key];
                            for(var i_1 = 0; i_1 < listOfLists.length; i_1++){
                                eleGroup.push(this._process(listOfLists[i_1], options));
                            }
                            result.push((_e = {}, _e[key] = eleGroup, _e));
                        } else {
                            // single element node
                            if (options.verbose) {
                                result.push((_f = {}, _f[key] = [
                                    this._process(ele[key], options)
                                ], _f));
                            } else {
                                result.push((_g = {}, _g[key] = this._process(ele[key], options), _g));
                            }
                        }
                        break;
                }
            }
            obj[defTextKey] = result;
            return obj;
        } else {
            // all element nodes have unique names
            // return an object while prefixing data node keys
            var textId = 1;
            var commentId = 1;
            var instructionId = 1;
            var cdataId = 1;
            var obj = {};
            for(var i = 0; i < items.length; i++){
                var item = items[i];
                var key = Object.keys(item)[0];
                switch(key){
                    case "@":
                        var attrs = item["@"];
                        var attrKeys = Object.keys(attrs);
                        if (!options.group || attrKeys.length === 1) {
                            for(var attrName in attrs){
                                obj[defAttrKey + attrName] = attrs[attrName];
                            }
                        } else {
                            obj[defAttrKey] = attrs;
                        }
                        break;
                    case "#":
                        textId = this._processSpecItem(item["#"], obj, options.group, defTextKey, textCount, textId);
                        break;
                    case "!":
                        commentId = this._processSpecItem(item["!"], obj, options.group, defCommentKey, commentCount, commentId);
                        break;
                    case "?":
                        instructionId = this._processSpecItem(item["?"], obj, options.group, defInstructionKey, instructionCount, instructionId);
                        break;
                    case "$":
                        cdataId = this._processSpecItem(item["$"], obj, options.group, defCdataKey, cdataCount, cdataId);
                        break;
                    default:
                        // element node
                        var ele = item;
                        if (ele[key].length !== 0 && util_1.isArray(ele[key][0])) {
                            // group of element nodes
                            var eleGroup = [];
                            var listOfLists = ele[key];
                            for(var i_2 = 0; i_2 < listOfLists.length; i_2++){
                                eleGroup.push(this._process(listOfLists[i_2], options));
                            }
                            obj[key] = eleGroup;
                        } else {
                            // single element node
                            if (options.verbose) {
                                obj[key] = [
                                    this._process(ele[key], options)
                                ];
                            } else {
                                obj[key] = this._process(ele[key], options);
                            }
                        }
                        break;
                }
            }
            return obj;
        }
    };
    ObjectWriter.prototype._processSpecItem = function(item, obj, group, defKey, count, id) {
        var e_1, _a;
        if (!group && util_1.isArray(item) && count + item.length > 2) {
            try {
                for(var item_1 = __values(item), item_1_1 = item_1.next(); !item_1_1.done; item_1_1 = item_1.next()){
                    var subItem = item_1_1.value;
                    var key = defKey + (id++).toString();
                    obj[key] = subItem;
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (item_1_1 && !item_1_1.done && (_a = item_1.return)) _a.call(item_1);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
        } else {
            var key = count > 1 ? defKey + (id++).toString() : defKey;
            obj[key] = item;
        }
        return id;
    };
    /** @inheritdoc */ ObjectWriter.prototype.beginElement = function(name) {
        var _a, _b;
        var childItems = [];
        if (this._currentList.length === 0) {
            this._currentList.push((_a = {}, _a[name] = childItems, _a));
        } else {
            var lastItem = this._currentList[this._currentList.length - 1];
            if (this._isElementNode(lastItem, name)) {
                if (lastItem[name].length !== 0 && util_1.isArray(lastItem[name][0])) {
                    var listOfLists = lastItem[name];
                    listOfLists.push(childItems);
                } else {
                    lastItem[name] = [
                        lastItem[name],
                        childItems
                    ];
                }
            } else {
                this._currentList.push((_b = {}, _b[name] = childItems, _b));
            }
        }
        this._currentIndex++;
        if (this._listRegister.length > this._currentIndex) {
            this._listRegister[this._currentIndex] = childItems;
        } else {
            this._listRegister.push(childItems);
        }
        this._currentList = childItems;
    };
    /** @inheritdoc */ ObjectWriter.prototype.endElement = function() {
        this._currentList = this._listRegister[--this._currentIndex];
    };
    /** @inheritdoc */ ObjectWriter.prototype.attribute = function(name, value) {
        var _a, _b;
        if (this._currentList.length === 0) {
            this._currentList.push({
                "@": (_a = {}, _a[name] = value, _a)
            });
        } else {
            var lastItem = this._currentList[this._currentList.length - 1];
            /* istanbul ignore else */ if (this._isAttrNode(lastItem)) {
                lastItem["@"][name] = value;
            } else {
                this._currentList.push({
                    "@": (_b = {}, _b[name] = value, _b)
                });
            }
        }
    };
    /** @inheritdoc */ ObjectWriter.prototype.comment = function(data) {
        if (this._currentList.length === 0) {
            this._currentList.push({
                "!": data
            });
        } else {
            var lastItem = this._currentList[this._currentList.length - 1];
            if (this._isCommentNode(lastItem)) {
                if (util_1.isArray(lastItem["!"])) {
                    lastItem["!"].push(data);
                } else {
                    lastItem["!"] = [
                        lastItem["!"],
                        data
                    ];
                }
            } else {
                this._currentList.push({
                    "!": data
                });
            }
        }
    };
    /** @inheritdoc */ ObjectWriter.prototype.text = function(data) {
        if (this._currentList.length === 0) {
            this._currentList.push({
                "#": data
            });
        } else {
            var lastItem = this._currentList[this._currentList.length - 1];
            if (this._isTextNode(lastItem)) {
                if (util_1.isArray(lastItem["#"])) {
                    lastItem["#"].push(data);
                } else {
                    lastItem["#"] = [
                        lastItem["#"],
                        data
                    ];
                }
            } else {
                this._currentList.push({
                    "#": data
                });
            }
        }
    };
    /** @inheritdoc */ ObjectWriter.prototype.instruction = function(target, data) {
        var value = data === "" ? target : target + " " + data;
        if (this._currentList.length === 0) {
            this._currentList.push({
                "?": value
            });
        } else {
            var lastItem = this._currentList[this._currentList.length - 1];
            if (this._isInstructionNode(lastItem)) {
                if (util_1.isArray(lastItem["?"])) {
                    lastItem["?"].push(value);
                } else {
                    lastItem["?"] = [
                        lastItem["?"],
                        value
                    ];
                }
            } else {
                this._currentList.push({
                    "?": value
                });
            }
        }
    };
    /** @inheritdoc */ ObjectWriter.prototype.cdata = function(data) {
        if (this._currentList.length === 0) {
            this._currentList.push({
                "$": data
            });
        } else {
            var lastItem = this._currentList[this._currentList.length - 1];
            if (this._isCDATANode(lastItem)) {
                if (util_1.isArray(lastItem["$"])) {
                    lastItem["$"].push(data);
                } else {
                    lastItem["$"] = [
                        lastItem["$"],
                        data
                    ];
                }
            } else {
                this._currentList.push({
                    "$": data
                });
            }
        }
    };
    ObjectWriter.prototype._isAttrNode = function(x) {
        return "@" in x;
    };
    ObjectWriter.prototype._isTextNode = function(x) {
        return "#" in x;
    };
    ObjectWriter.prototype._isCommentNode = function(x) {
        return "!" in x;
    };
    ObjectWriter.prototype._isInstructionNode = function(x) {
        return "?" in x;
    };
    ObjectWriter.prototype._isCDATANode = function(x) {
        return "$" in x;
    };
    ObjectWriter.prototype._isElementNode = function(x, name) {
        return name in x;
    };
    /**
     * Returns an object key for an attribute or namespace declaration.
     */ ObjectWriter.prototype._getAttrKey = function() {
        return this._builderOptions.convert.att;
    };
    /**
     * Returns an object key for the given node type.
     *
     * @param nodeType - node type to get a key for
     */ ObjectWriter.prototype._getNodeKey = function(nodeType) {
        switch(nodeType){
            case interfaces_1.NodeType.Comment:
                return this._builderOptions.convert.comment;
            case interfaces_1.NodeType.Text:
                return this._builderOptions.convert.text;
            case interfaces_1.NodeType.ProcessingInstruction:
                return this._builderOptions.convert.ins;
            case interfaces_1.NodeType.CData:
                return this._builderOptions.convert.cdata;
            /* istanbul ignore next */ default:
                throw new Error("Invalid node type.");
        }
    };
    return ObjectWriter;
}(BaseWriter_1.BaseWriter);
exports.ObjectWriter = ObjectWriter; //# sourceMappingURL=ObjectWriter.js.map


/***/ }),

/***/ 29494:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var BaseCBWriter_1 = __webpack_require__(96266);
/**
 * Serializes XML nodes.
 */ var XMLCBWriter = /** @class */ function(_super) {
    __extends(XMLCBWriter, _super);
    /**
     * Initializes a new instance of `XMLCBWriter`.
     *
     * @param builderOptions - XML builder options
     */ function XMLCBWriter(builderOptions) {
        var _this = _super.call(this, builderOptions) || this;
        _this._lineLength = 0;
        return _this;
    }
    /** @inheritdoc */ XMLCBWriter.prototype.frontMatter = function() {
        return "";
    };
    /** @inheritdoc */ XMLCBWriter.prototype.declaration = function(version, encoding, standalone) {
        var markup = this._beginLine() + "<?xml";
        markup += ' version="' + version + '"';
        if (encoding !== undefined) {
            markup += ' encoding="' + encoding + '"';
        }
        if (standalone !== undefined) {
            markup += ' standalone="' + (standalone ? "yes" : "no") + '"';
        }
        markup += "?>";
        return markup;
    };
    /** @inheritdoc */ XMLCBWriter.prototype.docType = function(name, publicId, systemId) {
        var markup = this._beginLine();
        if (publicId && systemId) {
            markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '" "' + systemId + '">';
        } else if (publicId) {
            markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '">';
        } else if (systemId) {
            markup += "<!DOCTYPE " + name + ' SYSTEM "' + systemId + '">';
        } else {
            markup += "<!DOCTYPE " + name + ">";
        }
        return markup;
    };
    /** @inheritdoc */ XMLCBWriter.prototype.comment = function(data) {
        return this._beginLine() + "<!--" + data + "-->";
    };
    /** @inheritdoc */ XMLCBWriter.prototype.text = function(data) {
        return this._beginLine() + data;
    };
    /** @inheritdoc */ XMLCBWriter.prototype.instruction = function(target, data) {
        if (data) {
            return this._beginLine() + "<?" + target + " " + data + "?>";
        } else {
            return this._beginLine() + "<?" + target + "?>";
        }
    };
    /** @inheritdoc */ XMLCBWriter.prototype.cdata = function(data) {
        return this._beginLine() + "<![CDATA[" + data + "]]>";
    };
    /** @inheritdoc */ XMLCBWriter.prototype.openTagBegin = function(name) {
        this._lineLength += 1 + name.length;
        return this._beginLine() + "<" + name;
    };
    /** @inheritdoc */ XMLCBWriter.prototype.openTagEnd = function(name, selfClosing, voidElement) {
        if (voidElement) {
            return " />";
        } else if (selfClosing) {
            if (this._writerOptions.allowEmptyTags) {
                return "></" + name + ">";
            } else if (this._writerOptions.spaceBeforeSlash) {
                return " />";
            } else {
                return "/>";
            }
        } else {
            return ">";
        }
    };
    /** @inheritdoc */ XMLCBWriter.prototype.closeTag = function(name) {
        return this._beginLine() + "</" + name + ">";
    };
    /** @inheritdoc */ XMLCBWriter.prototype.attribute = function(name, value) {
        var str = name + '="' + value + '"';
        if (this._writerOptions.prettyPrint && this._writerOptions.width > 0 && this._lineLength + 1 + str.length > this._writerOptions.width) {
            str = this._beginLine() + this._indent(1) + str;
            this._lineLength = str.length;
            return str;
        } else {
            this._lineLength += 1 + str.length;
            return " " + str;
        }
    };
    /** @inheritdoc */ XMLCBWriter.prototype.beginElement = function(name) {};
    /** @inheritdoc */ XMLCBWriter.prototype.endElement = function(name) {};
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     */ XMLCBWriter.prototype._beginLine = function() {
        if (this._writerOptions.prettyPrint) {
            var str = (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level);
            this._lineLength = str.length;
            return str;
        } else {
            return "";
        }
    };
    /**
     * Produces an indentation string.
     *
     * @param level - depth of the tree
     */ XMLCBWriter.prototype._indent = function(level) {
        if (level <= 0) {
            return "";
        } else {
            return this._writerOptions.indent.repeat(level);
        }
    };
    return XMLCBWriter;
}(BaseCBWriter_1.BaseCBWriter);
exports.XMLCBWriter = XMLCBWriter; //# sourceMappingURL=XMLCBWriter.js.map


/***/ }),

/***/ 96835:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var util_1 = __webpack_require__(96883);
var interfaces_1 = __webpack_require__(52580);
var BaseWriter_1 = __webpack_require__(96798);
var util_2 = __webpack_require__(57294);
/**
 * Serializes XML nodes into strings.
 */ var XMLWriter = /** @class */ function(_super) {
    __extends(XMLWriter, _super);
    /**
     * Initializes a new instance of `XMLWriter`.
     *
     * @param builderOptions - XML builder options
     * @param writerOptions - serialization options
     */ function XMLWriter(builderOptions, writerOptions) {
        var _this = _super.call(this, builderOptions) || this;
        _this._indentation = {};
        _this._lengthToLastNewline = 0;
        // provide default options
        _this._writerOptions = util_1.applyDefaults(writerOptions, {
            wellFormed: false,
            headless: false,
            prettyPrint: false,
            indent: "  ",
            newline: "\n",
            offset: 0,
            width: 0,
            allowEmptyTags: false,
            indentTextOnlyNodes: false,
            spaceBeforeSlash: false
        });
        return _this;
    }
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     */ XMLWriter.prototype.serialize = function(node) {
        this._refs = {
            suppressPretty: false,
            emptyNode: false,
            markup: ""
        };
        // Serialize XML declaration
        if (node.nodeType === interfaces_1.NodeType.Document && !this._writerOptions.headless) {
            this.declaration(this._builderOptions.version, this._builderOptions.encoding, this._builderOptions.standalone);
        }
        // recursively serialize node
        this.serializeNode(node, this._writerOptions.wellFormed);
        // remove trailing newline
        if (this._writerOptions.prettyPrint && this._refs.markup.slice(-this._writerOptions.newline.length) === this._writerOptions.newline) {
            this._refs.markup = this._refs.markup.slice(0, -this._writerOptions.newline.length);
        }
        return this._refs.markup;
    };
    /** @inheritdoc */ XMLWriter.prototype.declaration = function(version, encoding, standalone) {
        this._beginLine();
        this._refs.markup += '<?xml version="' + version + '"';
        if (encoding !== undefined) {
            this._refs.markup += ' encoding="' + encoding + '"';
        }
        if (standalone !== undefined) {
            this._refs.markup += ' standalone="' + (standalone ? "yes" : "no") + '"';
        }
        this._refs.markup += "?>";
        this._endLine();
    };
    /** @inheritdoc */ XMLWriter.prototype.docType = function(name, publicId, systemId) {
        this._beginLine();
        if (publicId && systemId) {
            this._refs.markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '" "' + systemId + '">';
        } else if (publicId) {
            this._refs.markup += "<!DOCTYPE " + name + ' PUBLIC "' + publicId + '">';
        } else if (systemId) {
            this._refs.markup += "<!DOCTYPE " + name + ' SYSTEM "' + systemId + '">';
        } else {
            this._refs.markup += "<!DOCTYPE " + name + ">";
        }
        this._endLine();
    };
    /** @inheritdoc */ XMLWriter.prototype.openTagBegin = function(name) {
        this._beginLine();
        this._refs.markup += "<" + name;
    };
    /** @inheritdoc */ XMLWriter.prototype.openTagEnd = function(name, selfClosing, voidElement) {
        // do not indent text only elements or elements with empty text nodes
        this._refs.suppressPretty = false;
        this._refs.emptyNode = false;
        if (this._writerOptions.prettyPrint && !selfClosing && !voidElement) {
            var textOnlyNode = true;
            var emptyNode = true;
            var childNode = this.currentNode.firstChild;
            var cdataCount = 0;
            var textCount = 0;
            while(childNode){
                if (util_2.Guard.isExclusiveTextNode(childNode)) {
                    textCount++;
                } else if (util_2.Guard.isCDATASectionNode(childNode)) {
                    cdataCount++;
                } else {
                    textOnlyNode = false;
                    emptyNode = false;
                    break;
                }
                if (childNode.data !== "") {
                    emptyNode = false;
                }
                childNode = childNode.nextSibling;
            }
            this._refs.suppressPretty = !this._writerOptions.indentTextOnlyNodes && textOnlyNode && (cdataCount <= 1 && textCount === 0 || cdataCount === 0);
            this._refs.emptyNode = emptyNode;
        }
        if ((voidElement || selfClosing || this._refs.emptyNode) && this._writerOptions.allowEmptyTags) {
            this._refs.markup += "></" + name + ">";
        } else {
            this._refs.markup += voidElement ? " />" : selfClosing || this._refs.emptyNode ? this._writerOptions.spaceBeforeSlash ? " />" : "/>" : ">";
        }
        this._endLine();
    };
    /** @inheritdoc */ XMLWriter.prototype.closeTag = function(name) {
        if (!this._refs.emptyNode) {
            this._beginLine();
            this._refs.markup += "</" + name + ">";
        }
        this._refs.suppressPretty = false;
        this._refs.emptyNode = false;
        this._endLine();
    };
    /** @inheritdoc */ XMLWriter.prototype.attribute = function(name, value) {
        var str = name + '="' + value + '"';
        if (this._writerOptions.prettyPrint && this._writerOptions.width > 0 && this._refs.markup.length - this._lengthToLastNewline + 1 + str.length > this._writerOptions.width) {
            this._endLine();
            this._beginLine();
            this._refs.markup += this._indent(1) + str;
        } else {
            this._refs.markup += " " + str;
        }
    };
    /** @inheritdoc */ XMLWriter.prototype.text = function(data) {
        if (data !== "") {
            this._beginLine();
            this._refs.markup += data;
            this._endLine();
        }
    };
    /** @inheritdoc */ XMLWriter.prototype.cdata = function(data) {
        if (data !== "") {
            this._beginLine();
            this._refs.markup += "<![CDATA[" + data + "]]>";
            this._endLine();
        }
    };
    /** @inheritdoc */ XMLWriter.prototype.comment = function(data) {
        this._beginLine();
        this._refs.markup += "<!--" + data + "-->";
        this._endLine();
    };
    /** @inheritdoc */ XMLWriter.prototype.instruction = function(target, data) {
        this._beginLine();
        this._refs.markup += "<?" + (data === "" ? target : target + " " + data) + "?>";
        this._endLine();
    };
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     */ XMLWriter.prototype._beginLine = function() {
        if (this._writerOptions.prettyPrint && !this._refs.suppressPretty) {
            this._refs.markup += this._indent(this._writerOptions.offset + this.level);
        }
    };
    /**
     * Produces characters to be appended to a line of string in pretty-print
     * mode.
     */ XMLWriter.prototype._endLine = function() {
        if (this._writerOptions.prettyPrint && !this._refs.suppressPretty) {
            this._refs.markup += this._writerOptions.newline;
            this._lengthToLastNewline = this._refs.markup.length;
        }
    };
    /**
     * Produces an indentation string.
     *
     * @param level - depth of the tree
     */ XMLWriter.prototype._indent = function(level) {
        if (level <= 0) {
            return "";
        } else if (this._indentation[level] !== undefined) {
            return this._indentation[level];
        } else {
            var str = this._writerOptions.indent.repeat(level);
            this._indentation[level] = str;
            return str;
        }
    };
    return XMLWriter;
}(BaseWriter_1.BaseWriter);
exports.XMLWriter = XMLWriter; //# sourceMappingURL=XMLWriter.js.map


/***/ }),

/***/ 51043:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var BaseCBWriter_1 = __webpack_require__(96266);
/**
 * Serializes XML nodes.
 */ var YAMLCBWriter = /** @class */ function(_super) {
    __extends(YAMLCBWriter, _super);
    /**
     * Initializes a new instance of `BaseCBWriter`.
     *
     * @param builderOptions - XML builder options
     */ function YAMLCBWriter(builderOptions) {
        var _this = _super.call(this, builderOptions) || this;
        _this._rootWritten = false;
        _this._additionalLevel = 0;
        if (builderOptions.indent.length < 2) {
            throw new Error("YAML indententation string must be at least two characters long.");
        }
        if (builderOptions.offset < 0) {
            throw new Error("YAML offset should be zero or a positive number.");
        }
        return _this;
    }
    /** @inheritdoc */ YAMLCBWriter.prototype.frontMatter = function() {
        return this._beginLine() + "---";
    };
    /** @inheritdoc */ YAMLCBWriter.prototype.declaration = function(version, encoding, standalone) {
        return "";
    };
    /** @inheritdoc */ YAMLCBWriter.prototype.docType = function(name, publicId, systemId) {
        return "";
    };
    /** @inheritdoc */ YAMLCBWriter.prototype.comment = function(data) {
        // "!": "hello"
        return this._beginLine() + this._key(this._builderOptions.convert.comment) + " " + this._val(data);
    };
    /** @inheritdoc */ YAMLCBWriter.prototype.text = function(data) {
        // "#": "hello"
        return this._beginLine() + this._key(this._builderOptions.convert.text) + " " + this._val(data);
    };
    /** @inheritdoc */ YAMLCBWriter.prototype.instruction = function(target, data) {
        // "?": "target hello"
        return this._beginLine() + this._key(this._builderOptions.convert.ins) + " " + this._val(data ? target + " " + data : target);
    };
    /** @inheritdoc */ YAMLCBWriter.prototype.cdata = function(data) {
        // "$": "hello"
        return this._beginLine() + this._key(this._builderOptions.convert.cdata) + " " + this._val(data);
    };
    /** @inheritdoc */ YAMLCBWriter.prototype.attribute = function(name, value) {
        // "@name": "val"
        this._additionalLevel++;
        var str = this._beginLine() + this._key(this._builderOptions.convert.att + name) + " " + this._val(value);
        this._additionalLevel--;
        return str;
    };
    /** @inheritdoc */ YAMLCBWriter.prototype.openTagBegin = function(name) {
        // "node":
        //   "#":
        //   -
        var str = this._beginLine() + this._key(name);
        if (!this._rootWritten) {
            this._rootWritten = true;
        }
        this.hasData = true;
        this._additionalLevel++;
        str += this._beginLine(true) + this._key(this._builderOptions.convert.text);
        return str;
    };
    /** @inheritdoc */ YAMLCBWriter.prototype.openTagEnd = function(name, selfClosing, voidElement) {
        if (selfClosing) {
            return " " + this._val("");
        }
        return "";
    };
    /** @inheritdoc */ YAMLCBWriter.prototype.closeTag = function(name) {
        this._additionalLevel--;
        return "";
    };
    /** @inheritdoc */ YAMLCBWriter.prototype.beginElement = function(name) {};
    /** @inheritdoc */ YAMLCBWriter.prototype.endElement = function(name) {};
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     */ YAMLCBWriter.prototype._beginLine = function(suppressArray) {
        if (suppressArray === void 0) {
            suppressArray = false;
        }
        return (this.hasData ? this._writerOptions.newline : "") + this._indent(this._writerOptions.offset + this.level, suppressArray);
    };
    /**
     * Produces an indentation string.
     *
     * @param level - depth of the tree
     * @param suppressArray - whether the suppress array marker
     */ YAMLCBWriter.prototype._indent = function(level, suppressArray) {
        if (level + this._additionalLevel <= 0) {
            return "";
        } else {
            var chars = this._writerOptions.indent.repeat(level + this._additionalLevel);
            if (!suppressArray && this._rootWritten) {
                return chars.substr(0, chars.length - 2) + "-" + chars.substr(-1, 1);
            }
            return chars;
        }
    };
    /**
     * Produces a YAML key string delimited with double quotes.
     */ YAMLCBWriter.prototype._key = function(key) {
        return '"' + key + '":';
    };
    /**
     * Produces a YAML value string delimited with double quotes.
     */ YAMLCBWriter.prototype._val = function(val) {
        return JSON.stringify(val);
    };
    return YAMLCBWriter;
}(BaseCBWriter_1.BaseCBWriter);
exports.YAMLCBWriter = YAMLCBWriter; //# sourceMappingURL=YAMLCBWriter.js.map


/***/ }),

/***/ 98363:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


var __extends = (void 0) && (void 0).__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __values = (void 0) && (void 0).__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var ObjectWriter_1 = __webpack_require__(75216);
var util_1 = __webpack_require__(96883);
var BaseWriter_1 = __webpack_require__(96798);
/**
 * Serializes XML nodes into a YAML string.
 */ var YAMLWriter = /** @class */ function(_super) {
    __extends(YAMLWriter, _super);
    /**
     * Initializes a new instance of `YAMLWriter`.
     *
     * @param builderOptions - XML builder options
     * @param writerOptions - serialization options
     */ function YAMLWriter(builderOptions, writerOptions) {
        var _this = _super.call(this, builderOptions) || this;
        // provide default options
        _this._writerOptions = util_1.applyDefaults(writerOptions, {
            wellFormed: false,
            indent: "  ",
            newline: "\n",
            offset: 0,
            group: false,
            verbose: false
        });
        if (_this._writerOptions.indent.length < 2) {
            throw new Error("YAML indententation string must be at least two characters long.");
        }
        if (_this._writerOptions.offset < 0) {
            throw new Error("YAML offset should be zero or a positive number.");
        }
        return _this;
    }
    /**
     * Produces an XML serialization of the given node.
     *
     * @param node - node to serialize
     * @param writerOptions - serialization options
     */ YAMLWriter.prototype.serialize = function(node) {
        // convert to object
        var objectWriterOptions = util_1.applyDefaults(this._writerOptions, {
            format: "object",
            wellFormed: false
        });
        var objectWriter = new ObjectWriter_1.ObjectWriter(this._builderOptions, objectWriterOptions);
        var val = objectWriter.serialize(node);
        var markup = this._beginLine(this._writerOptions, 0) + "---" + this._endLine(this._writerOptions) + this._convertObject(val, this._writerOptions, 0);
        // remove trailing newline
        /* istanbul ignore else */ if (markup.slice(-this._writerOptions.newline.length) === this._writerOptions.newline) {
            markup = markup.slice(0, -this._writerOptions.newline.length);
        }
        return markup;
    };
    /**
     * Produces an XML serialization of the given object.
     *
     * @param obj - object to serialize
     * @param options - serialization options
     * @param level - depth of the XML tree
     * @param indentLeaf - indents leaf nodes
     */ YAMLWriter.prototype._convertObject = function(obj, options, level, suppressIndent) {
        var e_1, _a;
        var _this = this;
        if (suppressIndent === void 0) {
            suppressIndent = false;
        }
        var markup = "";
        if (util_1.isArray(obj)) {
            try {
                for(var obj_1 = __values(obj), obj_1_1 = obj_1.next(); !obj_1_1.done; obj_1_1 = obj_1.next()){
                    var val = obj_1_1.value;
                    markup += this._beginLine(options, level, true);
                    if (!util_1.isObject(val)) {
                        markup += this._val(val) + this._endLine(options);
                    } else if (util_1.isEmpty(val)) {
                        markup += '""' + this._endLine(options);
                    } else {
                        markup += this._convertObject(val, options, level, true);
                    }
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (obj_1_1 && !obj_1_1.done && (_a = obj_1.return)) _a.call(obj_1);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
        } else /* if (isObject(obj)) */ {
            util_1.forEachObject(obj, function(key, val) {
                if (suppressIndent) {
                    markup += _this._key(key);
                    suppressIndent = false;
                } else {
                    markup += _this._beginLine(options, level) + _this._key(key);
                }
                if (!util_1.isObject(val)) {
                    markup += " " + _this._val(val) + _this._endLine(options);
                } else if (util_1.isEmpty(val)) {
                    markup += ' ""' + _this._endLine(options);
                } else {
                    markup += _this._endLine(options) + _this._convertObject(val, options, level + 1);
                }
            }, this);
        }
        return markup;
    };
    /**
     * Produces characters to be prepended to a line of string in pretty-print
     * mode.
     *
     * @param options - serialization options
     * @param level - current depth of the XML tree
     * @param isArray - whether this line is an array item
     */ YAMLWriter.prototype._beginLine = function(options, level, isArray) {
        if (isArray === void 0) {
            isArray = false;
        }
        var indentLevel = options.offset + level + 1;
        var chars = new Array(indentLevel).join(options.indent);
        if (isArray) {
            return chars.substr(0, chars.length - 2) + "-" + chars.substr(-1, 1);
        } else {
            return chars;
        }
    };
    /**
     * Produces characters to be appended to a line of string in pretty-print
     * mode.
     *
     * @param options - serialization options
     */ YAMLWriter.prototype._endLine = function(options) {
        return options.newline;
    };
    /**
     * Produces a YAML key string delimited with double quotes.
     */ YAMLWriter.prototype._key = function(key) {
        return '"' + key + '":';
    };
    /**
     * Produces a YAML value string delimited with double quotes.
     */ YAMLWriter.prototype._val = function(val) {
        return JSON.stringify(val);
    };
    return YAMLWriter;
}(BaseWriter_1.BaseWriter);
exports.YAMLWriter = YAMLWriter; //# sourceMappingURL=YAMLWriter.js.map


/***/ }),

/***/ 17020:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var MapWriter_1 = __webpack_require__(98102);
exports.MapWriter = MapWriter_1.MapWriter;
var XMLWriter_1 = __webpack_require__(96835);
exports.XMLWriter = XMLWriter_1.XMLWriter;
var ObjectWriter_1 = __webpack_require__(75216);
exports.ObjectWriter = ObjectWriter_1.ObjectWriter;
var JSONWriter_1 = __webpack_require__(10467);
exports.JSONWriter = JSONWriter_1.JSONWriter;
var YAMLWriter_1 = __webpack_require__(98363);
exports.YAMLWriter = YAMLWriter_1.YAMLWriter; //# sourceMappingURL=index.js.map


/***/ }),

/***/ 98986:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var yaml = __webpack_require__(9266);
module.exports = yaml;


/***/ }),

/***/ 9266:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var loader = __webpack_require__(15240);
var dumper = __webpack_require__(46360);
function deprecated(name) {
    return function() {
        throw new Error("Function " + name + " is deprecated and cannot be used.");
    };
}
module.exports.Type = __webpack_require__(97869);
module.exports.Schema = __webpack_require__(50315);
module.exports.FAILSAFE_SCHEMA = __webpack_require__(57389);
module.exports.JSON_SCHEMA = __webpack_require__(68116);
module.exports.CORE_SCHEMA = __webpack_require__(22023);
module.exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(45783);
module.exports.DEFAULT_FULL_SCHEMA = __webpack_require__(49845);
module.exports.load = loader.load;
module.exports.loadAll = loader.loadAll;
module.exports.safeLoad = loader.safeLoad;
module.exports.safeLoadAll = loader.safeLoadAll;
module.exports.dump = dumper.dump;
module.exports.safeDump = dumper.safeDump;
module.exports.YAMLException = __webpack_require__(3056);
// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = __webpack_require__(57389);
module.exports.SAFE_SCHEMA = __webpack_require__(45783);
module.exports.DEFAULT_SCHEMA = __webpack_require__(49845);
// Deprecated functions from JS-YAML 1.x.x
module.exports.scan = deprecated("scan");
module.exports.parse = deprecated("parse");
module.exports.compose = deprecated("compose");
module.exports.addConstructor = deprecated("addConstructor");


/***/ }),

/***/ 37929:
/***/ ((module) => {


function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
    return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if (isNothing(sequence)) return [];
    return [
        sequence
    ];
}
function extend(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
        sourceKeys = Object.keys(source);
        for(index = 0, length = sourceKeys.length; index < length; index += 1){
            key = sourceKeys[index];
            target[key] = source[key];
        }
    }
    return target;
}
function repeat(string, count) {
    var result = "", cycle;
    for(cycle = 0; cycle < count; cycle += 1){
        result += string;
    }
    return result;
}
function isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
module.exports.isNothing = isNothing;
module.exports.isObject = isObject;
module.exports.toArray = toArray;
module.exports.repeat = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend = extend;


/***/ }),

/***/ 46360:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/*eslint-disable no-use-before-define*/ var common = __webpack_require__(37929);
var YAMLException = __webpack_require__(3056);
var DEFAULT_FULL_SCHEMA = __webpack_require__(49845);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(45783);
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_TAB = 0x09; /* Tab */ 
var CHAR_LINE_FEED = 0x0A; /* LF */ 
var CHAR_CARRIAGE_RETURN = 0x0D; /* CR */ 
var CHAR_SPACE = 0x20; /* Space */ 
var CHAR_EXCLAMATION = 0x21; /* ! */ 
var CHAR_DOUBLE_QUOTE = 0x22; /* " */ 
var CHAR_SHARP = 0x23; /* # */ 
var CHAR_PERCENT = 0x25; /* % */ 
var CHAR_AMPERSAND = 0x26; /* & */ 
var CHAR_SINGLE_QUOTE = 0x27; /* ' */ 
var CHAR_ASTERISK = 0x2A; /* * */ 
var CHAR_COMMA = 0x2C; /* , */ 
var CHAR_MINUS = 0x2D; /* - */ 
var CHAR_COLON = 0x3A; /* : */ 
var CHAR_EQUALS = 0x3D; /* = */ 
var CHAR_GREATER_THAN = 0x3E; /* > */ 
var CHAR_QUESTION = 0x3F; /* ? */ 
var CHAR_COMMERCIAL_AT = 0x40; /* @ */ 
var CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */ 
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */ 
var CHAR_GRAVE_ACCENT = 0x60; /* ` */ 
var CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */ 
var CHAR_VERTICAL_LINE = 0x7C; /* | */ 
var CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */ 
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0x00] = "\\0";
ESCAPE_SEQUENCES[0x07] = "\\a";
ESCAPE_SEQUENCES[0x08] = "\\b";
ESCAPE_SEQUENCES[0x09] = "\\t";
ESCAPE_SEQUENCES[0x0A] = "\\n";
ESCAPE_SEQUENCES[0x0B] = "\\v";
ESCAPE_SEQUENCES[0x0C] = "\\f";
ESCAPE_SEQUENCES[0x0D] = "\\r";
ESCAPE_SEQUENCES[0x1B] = "\\e";
ESCAPE_SEQUENCES[0x22] = '\\"';
ESCAPE_SEQUENCES[0x5C] = "\\\\";
ESCAPE_SEQUENCES[0x85] = "\\N";
ESCAPE_SEQUENCES[0xA0] = "\\_";
ESCAPE_SEQUENCES[0x2028] = "\\L";
ESCAPE_SEQUENCES[0x2029] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
];
function compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;
    if (map === null) return {};
    result = {};
    keys = Object.keys(map);
    for(index = 0, length = keys.length; index < length; index += 1){
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
            tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
            style = type.styleAliases[style];
        }
        result[tag] = style;
    }
    return result;
}
function encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();
    if (character <= 0xFF) {
        handle = "x";
        length = 2;
    } else if (character <= 0xFFFF) {
        handle = "u";
        length = 4;
    } else if (character <= 0xFFFFFFFF) {
        handle = "U";
        length = 8;
    } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common.repeat("0", length - string.length) + string;
}
function State(options) {
    this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
    this.indent = Math.max(1, options["indent"] || 2);
    this.noArrayIndent = options["noArrayIndent"] || false;
    this.skipInvalid = options["skipInvalid"] || false;
    this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
    this.sortKeys = options["sortKeys"] || false;
    this.lineWidth = options["lineWidth"] || 80;
    this.noRefs = options["noRefs"] || false;
    this.noCompatMode = options["noCompatMode"] || false;
    this.condenseFlow = options["condenseFlow"] || false;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
}
// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
    var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
    while(position < length){
        next = string.indexOf("\n", position);
        if (next === -1) {
            line = string.slice(position);
            position = length;
        } else {
            line = string.slice(position, next + 1);
            position = next + 1;
        }
        if (line.length && line !== "\n") result += ind;
        result += line;
    }
    return result;
}
function generateNextLine(state, level) {
    return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str) {
    var index, length, type;
    for(index = 0, length = state.implicitTypes.length; index < length; index += 1){
        type = state.implicitTypes[index];
        if (type.resolve(str)) {
            return true;
        }
    }
    return false;
}
// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
}
// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isn’t mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
    return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF /* BOM */  || 0x10000 <= c && c <= 0x10FFFF;
}
// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// [24] b-line-feed       ::=     #xA    /* LF */
// [25] b-carriage-return ::=     #xD    /* CR */
// [3]  c-byte-order-mark ::=     #xFEFF
function isNsChar(c) {
    return isPrintable(c) && !isWhitespace(c) && c !== 0xFEFF && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c, prev) {
    // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
    // where nb-char ::= c-printable - b-char - c-byte-order-mark.
    return isPrintable(c) && c !== 0xFEFF && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
}
// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
    // Uses a subset of ns-char - c-indicator
    // where ns-char = nb-char - s-white.
    return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) // - s-white
     && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
    var i;
    var char, prev_char;
    var hasLineBreak = false;
    var hasFoldableLine = false; // only checked if shouldTrackWidth
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1; // count the first line correctly
    var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
    if (singleLineOnly) {
        // Case: no block styles.
        // Check for disallowed characters to rule out plain and single.
        for(i = 0; i < string.length; i++){
            char = string.charCodeAt(i);
            if (!isPrintable(char)) {
                return STYLE_DOUBLE;
            }
            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
            plain = plain && isPlainSafe(char, prev_char);
        }
    } else {
        // Case: block styles permitted.
        for(i = 0; i < string.length; i++){
            char = string.charCodeAt(i);
            if (char === CHAR_LINE_FEED) {
                hasLineBreak = true;
                // Check if any line can be folded.
                if (shouldTrackWidth) {
                    hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
                    i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
                    previousLineBreak = i;
                }
            } else if (!isPrintable(char)) {
                return STYLE_DOUBLE;
            }
            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
            plain = plain && isPlainSafe(char, prev_char);
        }
        // in case the end is missing a \n
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
    }
    // Although every style can represent \n without escaping, prefer block styles
    // for multiline, since they're more readable and they don't add empty lines.
    // Also prefer folding a super-long line.
    if (!hasLineBreak && !hasFoldableLine) {
        // Strings interpretable as another type have to be quoted;
        // e.g. the string 'true' vs. the boolean true.
        return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
    }
    // Edge case: block indentation indicator can only have one digit.
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
    }
    // At this point we know block styles are valid.
    // Prefer literal style unless we want to fold.
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}
// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//    • No ending newline => unaffected; already using strip "-" chomping.
//    • Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
    state.dump = function() {
        if (string.length === 0) {
            return "''";
        }
        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
            return "'" + string + "'";
        }
        var indent = state.indent * Math.max(1, level); // no 0-indent scalars
        // As indentation gets deeper, let the width decrease monotonically
        // to the lower bound min(state.lineWidth, 40).
        // Note that this implies
        //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
        //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
        // This behaves better than a constant minimum width which disallows narrower options,
        // or an indent threshold which causes the width to suddenly increase.
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        // Without knowing if keys are implicit/explicit, assume implicit for safety.
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string) {
            return testImplicitResolving(state, string);
        }
        switch(chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)){
            case STYLE_PLAIN:
                return string;
            case STYLE_SINGLE:
                return "'" + string.replace(/'/g, "''") + "'";
            case STYLE_LITERAL:
                return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
            case STYLE_FOLDED:
                return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
            case STYLE_DOUBLE:
                return '"' + escapeString(string, lineWidth) + '"';
            default:
                throw new YAMLException("impossible error: invalid scalar style");
        }
    }();
}
// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
    // note the special case: the string '\n' counts as a "trailing" empty line.
    var clip = string[string.length - 1] === "\n";
    var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
}
// (See the note for writeScalar.)
function dropEndingNewline(string) {
    return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
    // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
    // unless they're before or after a more-indented line, or at the very
    // beginning or end, in which case $k$ maps to $k$.
    // Therefore, parse each chunk as newline(s) followed by a content line.
    var lineRe = /(\n+)([^\n]*)/g;
    // first line (possibly an empty line)
    var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
    }();
    // If we haven't reached the first content line yet, don't add an extra \n.
    var prevMoreIndented = string[0] === "\n" || string[0] === " ";
    var moreIndented;
    // rest of the lines
    var match;
    while(match = lineRe.exec(string)){
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
    }
    return result;
}
// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
    if (line === "" || line[0] === " ") return line;
    // Since a more-indented line adds a \n, breaks can't be followed by a space.
    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
    var match;
    // start is an inclusive index. end, curr, and next are exclusive.
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    // Invariants: 0 <= start <= length-1.
    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
    // Inside the loop:
    //   A match implies length >= 2, so curr and next are <= length-2.
    while(match = breakRe.exec(line)){
        next = match.index;
        // maintain invariant: curr - start <= width
        if (next - start > width) {
            end = curr > start ? curr : next; // derive end <= length-2
            result += "\n" + line.slice(start, end);
            // skip the space that was output as \n
            start = end + 1; // derive start <= length-1
        }
        curr = next;
    }
    // By the invariants, start <= length-1, so there is something left over.
    // It is either the whole string or a part starting from non-whitespace.
    result += "\n";
    // Insert a break if the remainder is too long and there is a break available.
    if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
    } else {
        result += line.slice(start);
    }
    return result.slice(1); // drop extra \n joiner
}
// Escapes a double-quoted string.
function escapeString(string) {
    var result = "";
    var char, nextChar;
    var escapeSeq;
    for(var i = 0; i < string.length; i++){
        char = string.charCodeAt(i);
        // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
        if (char >= 0xD800 && char <= 0xDBFF /* high surrogate */ ) {
            nextChar = string.charCodeAt(i + 1);
            if (nextChar >= 0xDC00 && nextChar <= 0xDFFF /* low surrogate */ ) {
                // Combine the surrogate pair and store it escaped.
                result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
                // Advance index one extra since we already used that char here.
                i++;
                continue;
            }
        }
        escapeSeq = ESCAPE_SEQUENCES[char];
        result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
    }
    return result;
}
function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length;
    for(index = 0, length = object.length; index < length; index += 1){
        // Write only valid elements.
        if (writeNode(state, level, object[index], false, false)) {
            if (index !== 0) _result += "," + (!state.condenseFlow ? " " : "");
            _result += state.dump;
        }
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length;
    for(index = 0, length = object.length; index < length; index += 1){
        // Write only valid elements.
        if (writeNode(state, level + 1, object[index], true, true)) {
            if (!compact || index !== 0) {
                _result += generateNextLine(state, level);
            }
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                _result += "-";
            } else {
                _result += "- ";
            }
            _result += state.dump;
        }
    }
    state.tag = _tag;
    state.dump = _result || "[]"; // Empty sequence if no valid values.
}
function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for(index = 0, length = objectKeyList.length; index < length; index += 1){
        pairBuffer = "";
        if (index !== 0) pairBuffer += ", ";
        if (state.condenseFlow) pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level, objectKey, false, false)) {
            continue; // Skip this pair because of invalid key;
        }
        if (state.dump.length > 1024) pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
            continue; // Skip this pair because of invalid value.
        }
        pairBuffer += state.dump;
        // Both key and value are valid.
        _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    // Allow sorting keys so that the output file is deterministic
    if (state.sortKeys === true) {
        // Default sorting
        objectKeyList.sort();
    } else if (typeof state.sortKeys === "function") {
        // Custom sort function
        objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
        // Something is wrong
        throw new YAMLException("sortKeys must be a boolean or a function");
    }
    for(index = 0, length = objectKeyList.length; index < length; index += 1){
        pairBuffer = "";
        if (!compact || index !== 0) {
            pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
            continue; // Skip this pair because of invalid key.
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                pairBuffer += "?";
            } else {
                pairBuffer += "? ";
            }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
            pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
            continue; // Skip this pair because of invalid value.
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += ":";
        } else {
            pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        // Both key and value are valid.
        _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}"; // Empty mapping if no valid pairs.
}
function detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for(index = 0, length = typeList.length; index < length; index += 1){
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
            state.tag = explicit ? type.tag : "?";
            if (type.represent) {
                style = state.styleMap[type.tag] || type.defaultStyle;
                if (_toString.call(type.represent) === "[object Function]") {
                    _result = type.represent(object, style);
                } else if (_hasOwnProperty.call(type.represent, style)) {
                    _result = type.represent[style](object, style);
                } else {
                    throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
                }
                state.dump = _result;
            }
            return true;
        }
    }
    return false;
}
// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) {
        detectType(state, object, true);
    }
    var type = _toString.call(state.dump);
    if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
    }
    var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
    } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
            state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
            if (block && Object.keys(state.dump).length !== 0) {
                writeBlockMapping(state, level, state.dump, compact);
                if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + state.dump;
                }
            } else {
                writeFlowMapping(state, level, state.dump);
                if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                }
            }
        } else if (type === "[object Array]") {
            var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
            if (block && state.dump.length !== 0) {
                writeBlockSequence(state, arrayLevel, state.dump, compact);
                if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + state.dump;
                }
            } else {
                writeFlowSequence(state, arrayLevel, state.dump);
                if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                }
            }
        } else if (type === "[object String]") {
            if (state.tag !== "?") {
                writeScalar(state, state.dump, level, iskey);
            }
        } else {
            if (state.skipInvalid) return false;
            throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
            state.dump = "!<" + state.tag + "> " + state.dump;
        }
    }
    return true;
}
function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    inspectNode(object, objects, duplicatesIndexes);
    for(index = 0, length = duplicatesIndexes.length; index < length; index += 1){
        state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
            if (duplicatesIndexes.indexOf(index) === -1) {
                duplicatesIndexes.push(index);
            }
        } else {
            objects.push(object);
            if (Array.isArray(object)) {
                for(index = 0, length = object.length; index < length; index += 1){
                    inspectNode(object[index], objects, duplicatesIndexes);
                }
            } else {
                objectKeyList = Object.keys(object);
                for(index = 0, length = objectKeyList.length; index < length; index += 1){
                    inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
                }
            }
        }
    }
}
function dump(input, options) {
    options = options || {};
    var state = new State(options);
    if (!state.noRefs) getDuplicateReferences(input, state);
    if (writeNode(state, 0, input, true, true)) return state.dump + "\n";
    return "";
}
function safeDump(input, options) {
    return dump(input, common.extend({
        schema: DEFAULT_SAFE_SCHEMA
    }, options));
}
module.exports.dump = dump;
module.exports.safeDump = safeDump;


/***/ }),

/***/ 3056:
/***/ ((module) => {

// YAML error class. http://stackoverflow.com/questions/8458984
//

function YAMLException(reason, mark) {
    // Super constructor
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
    // Include stack trace in error object
    if (Error.captureStackTrace) {
        // Chrome and NodeJS
        Error.captureStackTrace(this, this.constructor);
    } else {
        // FF, IE 10+ and Safari 6+. Fallback for others
        this.stack = new Error().stack || "";
    }
}
// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;
YAMLException.prototype.toString = function toString(compact) {
    var result = this.name + ": ";
    result += this.reason || "(unknown reason)";
    if (!compact && this.mark) {
        result += " " + this.mark.toString();
    }
    return result;
};
module.exports = YAMLException;


/***/ }),

/***/ 15240:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/*eslint-disable max-len,no-use-before-define*/ var common = __webpack_require__(37929);
var YAMLException = __webpack_require__(3056);
var Mark = __webpack_require__(65337);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(45783);
var DEFAULT_FULL_SCHEMA = __webpack_require__(49845);
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
    return Object.prototype.toString.call(obj);
}
function is_EOL(c) {
    return c === 0x0A /* LF */  || c === 0x0D /* CR */ ;
}
function is_WHITE_SPACE(c) {
    return c === 0x09 /* Tab */  || c === 0x20 /* Space */ ;
}
function is_WS_OR_EOL(c) {
    return c === 0x09 /* Tab */  || c === 0x20 /* Space */  || c === 0x0A /* LF */  || c === 0x0D /* CR */ ;
}
function is_FLOW_INDICATOR(c) {
    return c === 0x2C /* , */  || c === 0x5B /* [ */  || c === 0x5D /* ] */  || c === 0x7B /* { */  || c === 0x7D /* } */ ;
}
function fromHexCode(c) {
    var lc;
    if (0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ) {
        return c - 0x30;
    }
    /*eslint-disable no-bitwise*/ lc = c | 0x20;
    if (0x61 /* a */  <= lc && lc <= 0x66 /* f */ ) {
        return lc - 0x61 + 10;
    }
    return -1;
}
function escapedHexLen(c) {
    if (c === 0x78 /* x */ ) {
        return 2;
    }
    if (c === 0x75 /* u */ ) {
        return 4;
    }
    if (c === 0x55 /* U */ ) {
        return 8;
    }
    return 0;
}
function fromDecimalCode(c) {
    if (0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ) {
        return c - 0x30;
    }
    return -1;
}
function simpleEscapeSequence(c) {
    /* eslint-disable indent */ return c === 0x30 /* 0 */  ? "\x00" : c === 0x61 /* a */  ? "\x07" : c === 0x62 /* b */  ? "\b" : c === 0x74 /* t */  ? "	" : c === 0x09 /* Tab */  ? "	" : c === 0x6E /* n */  ? "\n" : c === 0x76 /* v */  ? "\v" : c === 0x66 /* f */  ? "\f" : c === 0x72 /* r */  ? "\r" : c === 0x65 /* e */  ? "\x1b" : c === 0x20 /* Space */  ? " " : c === 0x22 /* " */  ? '"' : c === 0x2F /* / */  ? "/" : c === 0x5C /* \ */  ? "\\" : c === 0x4E /* N */  ? "\x85" : c === 0x5F /* _ */  ? "\xa0" : c === 0x4C /* L */  ? "\u2028" : c === 0x50 /* P */  ? "\u2029" : "";
}
function charFromCodepoint(c) {
    if (c <= 0xFFFF) {
        return String.fromCharCode(c);
    }
    // Encode UTF-16 surrogate pair
    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
    return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
}
var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for(var i = 0; i < 256; i++){
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
}
function State(input, options) {
    this.input = input;
    this.filename = options["filename"] || null;
    this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
    this.onWarning = options["onWarning"] || null;
    this.legacy = options["legacy"] || false;
    this.json = options["json"] || false;
    this.listener = options["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.documents = [];
/*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/ }
function generateError(state, message) {
    return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
}
function throwError(state, message) {
    throw generateError(state, message);
}
function throwWarning(state, message) {
    if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
    }
}
var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
            throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
            throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
            throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
            throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
            throwWarning(state, "unsupported YAML version of the document");
        }
    },
    TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
            throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
            throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
            throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
            throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        state.tagMap[handle] = prefix;
    }
};
function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
            for(_position = 0, _length = _result.length; _position < _length; _position += 1){
                _character = _result.charCodeAt(_position);
                if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {
                    throwError(state, "expected valid JSON character");
                }
            }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
            throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
    }
}
function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for(index = 0, quantity = sourceKeys.length; index < quantity; index += 1){
        key = sourceKeys[index];
        if (!_hasOwnProperty.call(destination, key)) {
            destination[key] = source[key];
            overridableKeys[key] = true;
        }
    }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
    var index, quantity;
    // The output is a plain object here, so keys can only be strings.
    // We need to convert keyNode to a string, but doing so can hang the process
    // (deeply nested arrays that explode exponentially using aliases).
    if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for(index = 0, quantity = keyNode.length; index < quantity; index += 1){
            if (Array.isArray(keyNode[index])) {
                throwError(state, "nested arrays are not supported inside keys");
            }
            if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
                keyNode[index] = "[object Object]";
            }
        }
    }
    // Avoid code execution in load() via toString property
    // (still use its own toString for arrays, timestamps,
    // and whatever user schema extensions happen to have @@toStringTag)
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
        _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
            for(index = 0, quantity = valueNode.length; index < quantity; index += 1){
                mergeMappings(state, _result, valueNode[index], overridableKeys);
            }
        } else {
            mergeMappings(state, _result, valueNode, overridableKeys);
        }
    } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
            state.line = startLine || state.line;
            state.position = startPos || state.position;
            throwError(state, "duplicated mapping key");
        }
        _result[keyNode] = valueNode;
        delete overridableKeys[keyNode];
    }
    return _result;
}
function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x0A /* LF */ ) {
        state.position++;
    } else if (ch === 0x0D /* CR */ ) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 0x0A /* LF */ ) {
            state.position++;
        }
    } else {
        throwError(state, "a line break is expected");
    }
    state.line += 1;
    state.lineStart = state.position;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        while(is_WHITE_SPACE(ch)){
            ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 0x23 /* # */ ) {
            do {
                ch = state.input.charCodeAt(++state.position);
            }while (ch !== 0x0A /* LF */  && ch !== 0x0D /* CR */  && ch !== 0);
        }
        if (is_EOL(ch)) {
            readLineBreak(state);
            ch = state.input.charCodeAt(state.position);
            lineBreaks++;
            state.lineIndent = 0;
            while(ch === 0x20 /* Space */ ){
                state.lineIndent++;
                ch = state.input.charCodeAt(++state.position);
            }
        } else {
            break;
        }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
    }
    return lineBreaks;
}
function testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    // Condition state.position === state.lineStart is tested
    // in parent on each call, for efficiency. No needs to test here again.
    if ((ch === 0x2D /* - */  || ch === 0x2E /* . */ ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
            return true;
        }
    }
    return false;
}
function writeFoldedLines(state, count) {
    if (count === 1) {
        state.result += " ";
    } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
    }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23 /* # */  || ch === 0x26 /* & */  || ch === 0x2A /* * */  || ch === 0x21 /* ! */  || ch === 0x7C /* | */  || ch === 0x3E /* > */  || ch === 0x27 /* ' */  || ch === 0x22 /* " */  || ch === 0x25 /* % */  || ch === 0x40 /* @ */  || ch === 0x60 /* ` */ ) {
        return false;
    }
    if (ch === 0x3F /* ? */  || ch === 0x2D /* - */ ) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            return false;
        }
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while(ch !== 0){
        if (ch === 0x3A /* : */ ) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
                break;
            }
        } else if (ch === 0x23 /* # */ ) {
            preceding = state.input.charCodeAt(state.position - 1);
            if (is_WS_OR_EOL(preceding)) {
                break;
            }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
            break;
        } else if (is_EOL(ch)) {
            _line = state.line;
            _lineStart = state.lineStart;
            _lineIndent = state.lineIndent;
            skipSeparationSpace(state, false, -1);
            if (state.lineIndent >= nodeIndent) {
                hasPendingContent = true;
                ch = state.input.charCodeAt(state.position);
                continue;
            } else {
                state.position = captureEnd;
                state.line = _line;
                state.lineStart = _lineStart;
                state.lineIndent = _lineIndent;
                break;
            }
        }
        if (hasPendingContent) {
            captureSegment(state, captureStart, captureEnd, false);
            writeFoldedLines(state, state.line - _line);
            captureStart = captureEnd = state.position;
            hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
            captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
        return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x27 /* ' */ ) {
        return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        if (ch === 0x27 /* ' */ ) {
            captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if (ch === 0x27 /* ' */ ) {
                captureStart = state.position;
                state.position++;
                captureEnd = state.position;
            } else {
                return true;
            }
        } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true);
            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
            throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
            state.position++;
            captureEnd = state.position;
        }
    }
    throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x22 /* " */ ) {
        return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        if (ch === 0x22 /* " */ ) {
            captureSegment(state, captureStart, state.position, true);
            state.position++;
            return true;
        } else if (ch === 0x5C /* \ */ ) {
            captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if (is_EOL(ch)) {
                skipSeparationSpace(state, false, nodeIndent);
            // TODO: rework to inline fn with no type cast?
            } else if (ch < 256 && simpleEscapeCheck[ch]) {
                state.result += simpleEscapeMap[ch];
                state.position++;
            } else if ((tmp = escapedHexLen(ch)) > 0) {
                hexLength = tmp;
                hexResult = 0;
                for(; hexLength > 0; hexLength--){
                    ch = state.input.charCodeAt(++state.position);
                    if ((tmp = fromHexCode(ch)) >= 0) {
                        hexResult = (hexResult << 4) + tmp;
                    } else {
                        throwError(state, "expected hexadecimal character");
                    }
                }
                state.result += charFromCodepoint(hexResult);
                state.position++;
            } else {
                throwError(state, "unknown escape sequence");
            }
            captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true);
            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
            throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
            state.position++;
            captureEnd = state.position;
        }
    }
    throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x5B /* [ */ ) {
        terminator = 0x5D; /* ] */ 
        isMapping = false;
        _result = [];
    } else if (ch === 0x7B /* { */ ) {
        terminator = 0x7D; /* } */ 
        isMapping = true;
        _result = {};
    } else {
        return false;
    }
    if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(++state.position);
    while(ch !== 0){
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
            state.position++;
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = isMapping ? "mapping" : "sequence";
            state.result = _result;
            return true;
        } else if (!readNext) {
            throwError(state, "missed comma between flow collection entries");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 0x3F /* ? */ ) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following)) {
                isPair = isExplicitPair = true;
                state.position++;
                skipSeparationSpace(state, true, nodeIndent);
            }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 0x3A /* : */ ) {
            isPair = true;
            ch = state.input.charCodeAt(++state.position);
            skipSeparationSpace(state, true, nodeIndent);
            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
            valueNode = state.result;
        }
        if (isMapping) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
        } else if (isPair) {
            _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
        } else {
            _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 0x2C /* , */ ) {
            readNext = true;
            ch = state.input.charCodeAt(++state.position);
        } else {
            readNext = false;
        }
    }
    throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x7C /* | */ ) {
        folding = false;
    } else if (ch === 0x3E /* > */ ) {
        folding = true;
    } else {
        return false;
    }
    state.kind = "scalar";
    state.result = "";
    while(ch !== 0){
        ch = state.input.charCodeAt(++state.position);
        if (ch === 0x2B /* + */  || ch === 0x2D /* - */ ) {
            if (CHOMPING_CLIP === chomping) {
                chomping = ch === 0x2B /* + */  ? CHOMPING_KEEP : CHOMPING_STRIP;
            } else {
                throwError(state, "repeat of a chomping mode identifier");
            }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
            if (tmp === 0) {
                throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
            } else if (!detectedIndent) {
                textIndent = nodeIndent + tmp - 1;
                detectedIndent = true;
            } else {
                throwError(state, "repeat of an indentation width identifier");
            }
        } else {
            break;
        }
    }
    if (is_WHITE_SPACE(ch)) {
        do {
            ch = state.input.charCodeAt(++state.position);
        }while (is_WHITE_SPACE(ch));
        if (ch === 0x23 /* # */ ) {
            do {
                ch = state.input.charCodeAt(++state.position);
            }while (!is_EOL(ch) && ch !== 0);
        }
    }
    while(ch !== 0){
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20 /* Space */ ){
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
            textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
            emptyLines++;
            continue;
        }
        // End of the scalar.
        if (state.lineIndent < textIndent) {
            // Perform the chomping.
            if (chomping === CHOMPING_KEEP) {
                state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            } else if (chomping === CHOMPING_CLIP) {
                if (didReadContent) {
                    state.result += "\n";
                }
            }
            break;
        }
        // Folded style: use fancy rules to handle line breaks.
        if (folding) {
            // Lines starting with white space characters (more-indented lines) are not folded.
            if (is_WHITE_SPACE(ch)) {
                atMoreIndented = true;
                // except for the first content line (cf. Example 8.1)
                state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            // End of more-indented block.
            } else if (atMoreIndented) {
                atMoreIndented = false;
                state.result += common.repeat("\n", emptyLines + 1);
            // Just one line break - perceive as the same line.
            } else if (emptyLines === 0) {
                if (didReadContent) {
                    state.result += " ";
                }
            // Several line breaks - perceive as different lines.
            } else {
                state.result += common.repeat("\n", emptyLines);
            }
        // Literal style: just add exact number of line breaks between content lines.
        } else {
            // Keep all line breaks except the header line break.
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while(!is_EOL(ch) && ch !== 0){
            ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
    }
    return true;
}
function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        if (ch !== 0x2D /* - */ ) {
            break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
            break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
            if (state.lineIndent <= nodeIndent) {
                _result.push(null);
                ch = state.input.charCodeAt(state.position);
                continue;
            }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
            throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
            break;
        }
    }
    if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
    }
    return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while(ch !== 0){
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line; // Save the current line.
        _pos = state.position;
        //
        // Explicit notation case. There are two separate blocks:
        // first for the key (denoted by "?") and second for the value (denoted by ":")
        //
        if ((ch === 0x3F /* ? */  || ch === 0x3A /* : */ ) && is_WS_OR_EOL(following)) {
            if (ch === 0x3F /* ? */ ) {
                if (atExplicitKey) {
                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                    keyTag = keyNode = valueNode = null;
                }
                detected = true;
                atExplicitKey = true;
                allowCompact = true;
            } else if (atExplicitKey) {
                // i.e. 0x3A/* : */ === character after the explicit key.
                atExplicitKey = false;
                allowCompact = true;
            } else {
                throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
            }
            state.position += 1;
            ch = following;
        //
        // Implicit notation case. Flow-style node as the key first, then ":", and the value.
        //
        } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
            if (state.line === _line) {
                ch = state.input.charCodeAt(state.position);
                while(is_WHITE_SPACE(ch)){
                    ch = state.input.charCodeAt(++state.position);
                }
                if (ch === 0x3A /* : */ ) {
                    ch = state.input.charCodeAt(++state.position);
                    if (!is_WS_OR_EOL(ch)) {
                        throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
                    }
                    if (atExplicitKey) {
                        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                        keyTag = keyNode = valueNode = null;
                    }
                    detected = true;
                    atExplicitKey = false;
                    allowCompact = false;
                    keyTag = state.tag;
                    keyNode = state.result;
                } else if (detected) {
                    throwError(state, "can not read an implicit mapping pair; a colon is missed");
                } else {
                    state.tag = _tag;
                    state.anchor = _anchor;
                    return true; // Keep the result of `composeNode`.
                }
            } else if (detected) {
                throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
            } else {
                state.tag = _tag;
                state.anchor = _anchor;
                return true; // Keep the result of `composeNode`.
            }
        } else {
            break; // Reading is done. Go to the epilogue.
        }
        //
        // Common reading code for both explicit and implicit notations.
        //
        if (state.line === _line || state.lineIndent > nodeIndent) {
            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
                if (atExplicitKey) {
                    keyNode = state.result;
                } else {
                    valueNode = state.result;
                }
            }
            if (!atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
                keyTag = keyNode = valueNode = null;
            }
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && ch !== 0) {
            throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
            break;
        }
    }
    //
    // Epilogue.
    //
    // Special case: last mapping's node contains only the key in explicit notation.
    if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
    }
    // Expose the resulting mapping.
    if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
    }
    return detected;
}
function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x21 /* ! */ ) return false;
    if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
    }
    ch = state.input.charCodeAt(++state.position);
    if (ch === 0x3C /* < */ ) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
    } else if (ch === 0x21 /* ! */ ) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
    } else {
        tagHandle = "!";
    }
    _position = state.position;
    if (isVerbatim) {
        do {
            ch = state.input.charCodeAt(++state.position);
        }while (ch !== 0 && ch !== 0x3E /* > */ );
        if (state.position < state.length) {
            tagName = state.input.slice(_position, state.position);
            ch = state.input.charCodeAt(++state.position);
        } else {
            throwError(state, "unexpected end of the stream within a verbatim tag");
        }
    } else {
        while(ch !== 0 && !is_WS_OR_EOL(ch)){
            if (ch === 0x21 /* ! */ ) {
                if (!isNamed) {
                    tagHandle = state.input.slice(_position - 1, state.position + 1);
                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                        throwError(state, "named tag handle cannot contain such characters");
                    }
                    isNamed = true;
                    _position = state.position + 1;
                } else {
                    throwError(state, "tag suffix cannot contain exclamation marks");
                }
            }
            ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
            throwError(state, "tag suffix cannot contain flow indicator characters");
        }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
    }
    if (isVerbatim) {
        state.tag = tagName;
    } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
    } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
}
function readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x26 /* & */ ) return false;
    if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while(ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)){
        ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
}
function readAlias(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x2A /* * */ ) return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while(ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)){
        ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
    }
    alias = state.input.slice(_position, state.position);
    if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
    if (state.listener !== null) {
        state.listener("open", state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            if (state.lineIndent > parentIndent) {
                indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
                indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
                indentStatus = -1;
            }
        }
    }
    if (indentStatus === 1) {
        while(readTagProperty(state) || readAnchorProperty(state)){
            if (skipSeparationSpace(state, true, -1)) {
                atNewLine = true;
                allowBlockCollections = allowBlockStyles;
                if (state.lineIndent > parentIndent) {
                    indentStatus = 1;
                } else if (state.lineIndent === parentIndent) {
                    indentStatus = 0;
                } else if (state.lineIndent < parentIndent) {
                    indentStatus = -1;
                }
            } else {
                allowBlockCollections = false;
            }
        }
    }
    if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
            flowIndent = parentIndent;
        } else {
            flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
            if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
                hasContent = true;
            } else {
                if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
                    hasContent = true;
                } else if (readAlias(state)) {
                    hasContent = true;
                    if (state.tag !== null || state.anchor !== null) {
                        throwError(state, "alias node should not have any properties");
                    }
                } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                    hasContent = true;
                    if (state.tag === null) {
                        state.tag = "?";
                    }
                }
                if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                }
            }
        } else if (indentStatus === 0) {
            // Special case: block sequences are allowed to have same indentation level as the parent.
            // http://www.yaml.org/spec/1.2/spec.html#id2799784
            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
    }
    if (state.tag !== null && state.tag !== "!") {
        if (state.tag === "?") {
            // Implicit resolving is not allowed for non-scalar types, and '?'
            // non-specific tag is only automatically assigned to plain scalars.
            //
            // We only need to check kind conformity in case user explicitly assigns '?'
            // tag, for example like this: "!<?> [0]"
            //
            if (state.result !== null && state.kind !== "scalar") {
                throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
            }
            for(typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1){
                type = state.implicitTypes[typeIndex];
                if (type.resolve(state.result)) {
                    state.result = type.construct(state.result);
                    state.tag = type.tag;
                    if (state.anchor !== null) {
                        state.anchorMap[state.anchor] = state.result;
                    }
                    break;
                }
            }
        } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
            type = state.typeMap[state.kind || "fallback"][state.tag];
            if (state.result !== null && type.kind !== state.kind) {
                throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
            }
            if (!type.resolve(state.result)) {
                throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
            } else {
                state.result = type.construct(state.result);
                if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                }
            }
        } else {
            throwError(state, "unknown tag !<" + state.tag + ">");
        }
    }
    if (state.listener !== null) {
        state.listener("close", state);
    }
    return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = {};
    state.anchorMap = {};
    while((ch = state.input.charCodeAt(state.position)) !== 0){
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 0x25 /* % */ ) {
            break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while(ch !== 0 && !is_WS_OR_EOL(ch)){
            ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
            throwError(state, "directive name must not be less than one character in length");
        }
        while(ch !== 0){
            while(is_WHITE_SPACE(ch)){
                ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 0x23 /* # */ ) {
                do {
                    ch = state.input.charCodeAt(++state.position);
                }while (ch !== 0 && !is_EOL(ch));
                break;
            }
            if (is_EOL(ch)) break;
            _position = state.position;
            while(ch !== 0 && !is_WS_OR_EOL(ch)){
                ch = state.input.charCodeAt(++state.position);
            }
            directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0) readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
            directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
            throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D /* - */  && state.input.charCodeAt(state.position + 1) === 0x2D /* - */  && state.input.charCodeAt(state.position + 2) === 0x2D /* - */ ) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 0x2E /* . */ ) {
            state.position += 3;
            skipSeparationSpace(state, true, -1);
        }
        return;
    }
    if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
    } else {
        return;
    }
}
function loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
        // Add tailing `\n` if not exists
        if (input.charCodeAt(input.length - 1) !== 0x0A /* LF */  && input.charCodeAt(input.length - 1) !== 0x0D /* CR */ ) {
            input += "\n";
        }
        // Strip BOM
        if (input.charCodeAt(0) === 0xFEFF) {
            input = input.slice(1);
        }
    }
    var state = new State(input, options);
    var nullpos = input.indexOf("\x00");
    if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
    }
    // Use 0 as string terminator. That significantly simplifies bounds check.
    state.input += "\x00";
    while(state.input.charCodeAt(state.position) === 0x20 /* Space */ ){
        state.lineIndent += 1;
        state.position += 1;
    }
    while(state.position < state.length - 1){
        readDocument(state);
    }
    return state.documents;
}
function loadAll(input, iterator, options) {
    if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
    }
    var documents = loadDocuments(input, options);
    if (typeof iterator !== "function") {
        return documents;
    }
    for(var index = 0, length = documents.length; index < length; index += 1){
        iterator(documents[index]);
    }
}
function load(input, options) {
    var documents = loadDocuments(input, options);
    if (documents.length === 0) {
        /*eslint-disable no-undefined*/ return undefined;
    } else if (documents.length === 1) {
        return documents[0];
    }
    throw new YAMLException("expected a single document in the stream, but found more");
}
function safeLoadAll(input, iterator, options) {
    if (typeof iterator === "object" && iterator !== null && typeof options === "undefined") {
        options = iterator;
        iterator = null;
    }
    return loadAll(input, iterator, common.extend({
        schema: DEFAULT_SAFE_SCHEMA
    }, options));
}
function safeLoad(input, options) {
    return load(input, common.extend({
        schema: DEFAULT_SAFE_SCHEMA
    }, options));
}
module.exports.loadAll = loadAll;
module.exports.load = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad = safeLoad;


/***/ }),

/***/ 65337:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var common = __webpack_require__(37929);
function Mark(name, buffer, position, line, column) {
    this.name = name;
    this.buffer = buffer;
    this.position = position;
    this.line = line;
    this.column = column;
}
Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
    var head, start, tail, end, snippet;
    if (!this.buffer) return null;
    indent = indent || 4;
    maxLength = maxLength || 75;
    head = "";
    start = this.position;
    while(start > 0 && "\x00\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1){
        start -= 1;
        if (this.position - start > maxLength / 2 - 1) {
            head = " ... ";
            start += 5;
            break;
        }
    }
    tail = "";
    end = this.position;
    while(end < this.buffer.length && "\x00\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1){
        end += 1;
        if (end - this.position > maxLength / 2 - 1) {
            tail = " ... ";
            end -= 5;
            break;
        }
    }
    snippet = this.buffer.slice(start, end);
    return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start + head.length) + "^";
};
Mark.prototype.toString = function toString(compact) {
    var snippet, where = "";
    if (this.name) {
        where += 'in "' + this.name + '" ';
    }
    where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
    if (!compact) {
        snippet = this.getSnippet();
        if (snippet) {
            where += ":\n" + snippet;
        }
    }
    return where;
};
module.exports = Mark;


/***/ }),

/***/ 50315:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/*eslint-disable max-len*/ var common = __webpack_require__(37929);
var YAMLException = __webpack_require__(3056);
var Type = __webpack_require__(97869);
function compileList(schema, name, result) {
    var exclude = [];
    schema.include.forEach(function(includedSchema) {
        result = compileList(includedSchema, name, result);
    });
    schema[name].forEach(function(currentType) {
        result.forEach(function(previousType, previousIndex) {
            if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
                exclude.push(previousIndex);
            }
        });
        result.push(currentType);
    });
    return result.filter(function(type, index) {
        return exclude.indexOf(index) === -1;
    });
}
function compileMap() {
    var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
    }, index, length;
    function collectType(type) {
        result[type.kind][type.tag] = result["fallback"][type.tag] = type;
    }
    for(index = 0, length = arguments.length; index < length; index += 1){
        arguments[index].forEach(collectType);
    }
    return result;
}
function Schema(definition) {
    this.include = definition.include || [];
    this.implicit = definition.implicit || [];
    this.explicit = definition.explicit || [];
    this.implicit.forEach(function(type) {
        if (type.loadKind && type.loadKind !== "scalar") {
            throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
    });
    this.compiledImplicit = compileList(this, "implicit", []);
    this.compiledExplicit = compileList(this, "explicit", []);
    this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
}
Schema.DEFAULT = null;
Schema.create = function createSchema() {
    var schemas, types;
    switch(arguments.length){
        case 1:
            schemas = Schema.DEFAULT;
            types = arguments[0];
            break;
        case 2:
            schemas = arguments[0];
            types = arguments[1];
            break;
        default:
            throw new YAMLException("Wrong number of arguments for Schema.create function");
    }
    schemas = common.toArray(schemas);
    types = common.toArray(types);
    if (!schemas.every(function(schema) {
        return schema instanceof Schema;
    })) {
        throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
    }
    if (!types.every(function(type) {
        return type instanceof Type;
    })) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    return new Schema({
        include: schemas,
        explicit: types
    });
};
module.exports = Schema;


/***/ }),

/***/ 22023:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.

var Schema = __webpack_require__(50315);
module.exports = new Schema({
    include: [
        __webpack_require__(68116)
    ]
});


/***/ }),

/***/ 49845:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.

var Schema = __webpack_require__(50315);
module.exports = Schema.DEFAULT = new Schema({
    include: [
        __webpack_require__(45783)
    ],
    explicit: [
        __webpack_require__(8093),
        __webpack_require__(80701),
        __webpack_require__(7837)
    ]
});


/***/ }),

/***/ 45783:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)

var Schema = __webpack_require__(50315);
module.exports = new Schema({
    include: [
        __webpack_require__(22023)
    ],
    implicit: [
        __webpack_require__(59337),
        __webpack_require__(72375)
    ],
    explicit: [
        __webpack_require__(81770),
        __webpack_require__(99886),
        __webpack_require__(86854),
        __webpack_require__(80235)
    ]
});


/***/ }),

/***/ 57389:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346

var Schema = __webpack_require__(50315);
module.exports = new Schema({
    explicit: [
        __webpack_require__(81344),
        __webpack_require__(23241),
        __webpack_require__(61089)
    ]
});


/***/ }),

/***/ 68116:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.

var Schema = __webpack_require__(50315);
module.exports = new Schema({
    include: [
        __webpack_require__(57389)
    ],
    implicit: [
        __webpack_require__(28025),
        __webpack_require__(34591),
        __webpack_require__(5358),
        __webpack_require__(82688)
    ]
});


/***/ }),

/***/ 97869:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var YAMLException = __webpack_require__(3056);
var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "defaultStyle",
    "styleAliases"
];
var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
];
function compileStyleAliases(map) {
    var result = {};
    if (map !== null) {
        Object.keys(map).forEach(function(style) {
            map[style].forEach(function(alias) {
                result[String(alias)] = style;
            });
        });
    }
    return result;
}
function Type(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
            throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
    });
    // TODO: Add tag format check.
    this.tag = tag;
    this.kind = options["kind"] || null;
    this.resolve = options["resolve"] || function() {
        return true;
    };
    this.construct = options["construct"] || function(data) {
        return data;
    };
    this.instanceOf = options["instanceOf"] || null;
    this.predicate = options["predicate"] || null;
    this.represent = options["represent"] || null;
    this.defaultStyle = options["defaultStyle"] || null;
    this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
}
module.exports = Type;


/***/ }),

/***/ 81770:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/*eslint-disable no-bitwise*/ var NodeBuffer;
try {
    // A trick for browserified version, to not include `Buffer` shim
    var _require = undefined;
    NodeBuffer = (__webpack_require__(14300).Buffer);
} catch (__) {}
var Type = __webpack_require__(97869);
// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
    if (data === null) return false;
    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
    // Convert one by one.
    for(idx = 0; idx < max; idx++){
        code = map.indexOf(data.charAt(idx));
        // Skip CR/LF
        if (code > 64) continue;
        // Fail on illegal characters
        if (code < 0) return false;
        bitlen += 6;
    }
    // If there are any bits left, source was corrupted
    return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
    // Collect by 6*4 bits (3 bytes)
    for(idx = 0; idx < max; idx++){
        if (idx % 4 === 0 && idx) {
            result.push(bits >> 16 & 0xFF);
            result.push(bits >> 8 & 0xFF);
            result.push(bits & 0xFF);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
    }
    // Dump tail
    tailbits = max % 4 * 6;
    if (tailbits === 0) {
        result.push(bits >> 16 & 0xFF);
        result.push(bits >> 8 & 0xFF);
        result.push(bits & 0xFF);
    } else if (tailbits === 18) {
        result.push(bits >> 10 & 0xFF);
        result.push(bits >> 2 & 0xFF);
    } else if (tailbits === 12) {
        result.push(bits >> 4 & 0xFF);
    }
    // Wrap into Buffer for NodeJS and leave Array for browser
    if (NodeBuffer) {
        // Support node 6.+ Buffer API when available
        return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
    }
    return result;
}
function representYamlBinary(object /*, style*/ ) {
    var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
    // Convert every three bytes to 4 ASCII characters.
    for(idx = 0; idx < max; idx++){
        if (idx % 3 === 0 && idx) {
            result += map[bits >> 18 & 0x3F];
            result += map[bits >> 12 & 0x3F];
            result += map[bits >> 6 & 0x3F];
            result += map[bits & 0x3F];
        }
        bits = (bits << 8) + object[idx];
    }
    // Dump tail
    tail = max % 3;
    if (tail === 0) {
        result += map[bits >> 18 & 0x3F];
        result += map[bits >> 12 & 0x3F];
        result += map[bits >> 6 & 0x3F];
        result += map[bits & 0x3F];
    } else if (tail === 2) {
        result += map[bits >> 10 & 0x3F];
        result += map[bits >> 4 & 0x3F];
        result += map[bits << 2 & 0x3F];
        result += map[64];
    } else if (tail === 1) {
        result += map[bits >> 2 & 0x3F];
        result += map[bits << 4 & 0x3F];
        result += map[64];
        result += map[64];
    }
    return result;
}
function isBinary(object) {
    return NodeBuffer && NodeBuffer.isBuffer(object);
}
module.exports = new Type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
});


/***/ }),

/***/ 34591:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var Type = __webpack_require__(97869);
function resolveYamlBoolean(data) {
    if (data === null) return false;
    var max = data.length;
    return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
}
module.exports = new Type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
        lowercase: function(object) {
            return object ? "true" : "false";
        },
        uppercase: function(object) {
            return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
            return object ? "True" : "False";
        }
    },
    defaultStyle: "lowercase"
});


/***/ }),

/***/ 82688:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var common = __webpack_require__(37929);
var Type = __webpack_require__(97869);
var YAML_FLOAT_PATTERN = new RegExp(// 2.5e4, 2.5 and integers
"^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?" + // .2e4, .2
// special case, seems not from spec
"|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?" + // 20:59
"|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*" + // .inf
"|[-+]?\\.(?:inf|Inf|INF)" + // .nan
"|\\.(?:nan|NaN|NAN))$");
function resolveYamlFloat(data) {
    if (data === null) return false;
    if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === "_") {
        return false;
    }
    return true;
}
function constructYamlFloat(data) {
    var value, sign, base, digits;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    digits = [];
    if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
    }
    if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === ".nan") {
        return NaN;
    } else if (value.indexOf(":") >= 0) {
        value.split(":").forEach(function(v) {
            digits.unshift(parseFloat(v, 10));
        });
        value = 0.0;
        base = 1;
        digits.forEach(function(d) {
            value += d * base;
            base *= 60;
        });
        return sign * value;
    }
    return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) {
        switch(style){
            case "lowercase":
                return ".nan";
            case "uppercase":
                return ".NAN";
            case "camelcase":
                return ".NaN";
        }
    } else if (Number.POSITIVE_INFINITY === object) {
        switch(style){
            case "lowercase":
                return ".inf";
            case "uppercase":
                return ".INF";
            case "camelcase":
                return ".Inf";
        }
    } else if (Number.NEGATIVE_INFINITY === object) {
        switch(style){
            case "lowercase":
                return "-.inf";
            case "uppercase":
                return "-.INF";
            case "camelcase":
                return "-.Inf";
        }
    } else if (common.isNegativeZero(object)) {
        return "-0.0";
    }
    res = object.toString(10);
    // JS stringifier can build scientific format without dots: 5e-100,
    // while YAML requres dot: 5.e-100. Fix it with simple hack
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
module.exports = new Type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
});


/***/ }),

/***/ 5358:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var common = __webpack_require__(37929);
var Type = __webpack_require__(97869);
function isHexCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x39 /* 9 */  || 0x41 /* A */  <= c && c <= 0x46 /* F */  || 0x61 /* a */  <= c && c <= 0x66 /* f */ ;
}
function isOctCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x37 /* 7 */ ;
}
function isDecCode(c) {
    return 0x30 /* 0 */  <= c && c <= 0x39 /* 9 */ ;
}
function resolveYamlInteger(data) {
    if (data === null) return false;
    var max = data.length, index = 0, hasDigits = false, ch;
    if (!max) return false;
    ch = data[index];
    // sign
    if (ch === "-" || ch === "+") {
        ch = data[++index];
    }
    if (ch === "0") {
        // 0
        if (index + 1 === max) return true;
        ch = data[++index];
        // base 2, base 8, base 16
        if (ch === "b") {
            // base 2
            index++;
            for(; index < max; index++){
                ch = data[index];
                if (ch === "_") continue;
                if (ch !== "0" && ch !== "1") return false;
                hasDigits = true;
            }
            return hasDigits && ch !== "_";
        }
        if (ch === "x") {
            // base 16
            index++;
            for(; index < max; index++){
                ch = data[index];
                if (ch === "_") continue;
                if (!isHexCode(data.charCodeAt(index))) return false;
                hasDigits = true;
            }
            return hasDigits && ch !== "_";
        }
        // base 8
        for(; index < max; index++){
            ch = data[index];
            if (ch === "_") continue;
            if (!isOctCode(data.charCodeAt(index))) return false;
            hasDigits = true;
        }
        return hasDigits && ch !== "_";
    }
    // base 10 (except 0) or base 60
    // value should not start with `_`;
    if (ch === "_") return false;
    for(; index < max; index++){
        ch = data[index];
        if (ch === "_") continue;
        if (ch === ":") break;
        if (!isDecCode(data.charCodeAt(index))) {
            return false;
        }
        hasDigits = true;
    }
    // Should have digits and should not end with `_`
    if (!hasDigits || ch === "_") return false;
    // if !base60 - done;
    if (ch !== ":") return true;
    // base60 almost not used, no needs to optimize
    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}
function constructYamlInteger(data) {
    var value = data, sign = 1, ch, base, digits = [];
    if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
    }
    ch = value[0];
    if (ch === "-" || ch === "+") {
        if (ch === "-") sign = -1;
        value = value.slice(1);
        ch = value[0];
    }
    if (value === "0") return 0;
    if (ch === "0") {
        if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x") return sign * parseInt(value, 16);
        return sign * parseInt(value, 8);
    }
    if (value.indexOf(":") !== -1) {
        value.split(":").forEach(function(v) {
            digits.unshift(parseInt(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d) {
            value += d * base;
            base *= 60;
        });
        return sign * value;
    }
    return sign * parseInt(value, 10);
}
function isInteger(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common.isNegativeZero(object);
}
module.exports = new Type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
        binary: function(obj) {
            return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
            return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
            return obj.toString(10);
        },
        /* eslint-disable max-len */ hexadecimal: function(obj) {
            return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
    },
    defaultStyle: "decimal",
    styleAliases: {
        binary: [
            2,
            "bin"
        ],
        octal: [
            8,
            "oct"
        ],
        decimal: [
            10,
            "dec"
        ],
        hexadecimal: [
            16,
            "hex"
        ]
    }
});


/***/ }),

/***/ 7837:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var esprima;
// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
    // workaround to exclude package from browserify list.
    var _require = undefined;
    esprima = __webpack_require__(35914);
} catch (_) {
    /* eslint-disable no-redeclare */ /* global window */ if (false) {}
}
var Type = __webpack_require__(97869);
function resolveJavascriptFunction(data) {
    if (data === null) return false;
    try {
        var source = "(" + data + ")", ast = esprima.parse(source, {
            range: true
        });
        if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
            return false;
        }
        return true;
    } catch (err) {
        return false;
    }
}
function constructJavascriptFunction(data) {
    /*jslint evil:true*/ var source = "(" + data + ")", ast = esprima.parse(source, {
        range: true
    }), params = [], body;
    if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
        throw new Error("Failed to resolve function");
    }
    ast.body[0].expression.params.forEach(function(param) {
        params.push(param.name);
    });
    body = ast.body[0].expression.body.range;
    // Esprima's ranges include the first '{' and the last '}' characters on
    // function expressions. So cut them out.
    if (ast.body[0].expression.body.type === "BlockStatement") {
        /*eslint-disable no-new-func*/ return new Function(params, source.slice(body[0] + 1, body[1] - 1));
    }
    // ES6 arrow functions can omit the BlockStatement. In that case, just return
    // the body.
    /*eslint-disable no-new-func*/ return new Function(params, "return " + source.slice(body[0], body[1]));
}
function representJavascriptFunction(object /*, style*/ ) {
    return object.toString();
}
function isFunction(object) {
    return Object.prototype.toString.call(object) === "[object Function]";
}
module.exports = new Type("tag:yaml.org,2002:js/function", {
    kind: "scalar",
    resolve: resolveJavascriptFunction,
    construct: constructJavascriptFunction,
    predicate: isFunction,
    represent: representJavascriptFunction
});


/***/ }),

/***/ 80701:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var Type = __webpack_require__(97869);
function resolveJavascriptRegExp(data) {
    if (data === null) return false;
    if (data.length === 0) return false;
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    // if regexp starts with '/' it can have modifiers and must be properly closed
    // `/foo/gim` - modifiers tail can be maximum 3 chars
    if (regexp[0] === "/") {
        if (tail) modifiers = tail[1];
        if (modifiers.length > 3) return false;
        // if expression starts with /, is should be properly terminated
        if (regexp[regexp.length - modifiers.length - 1] !== "/") return false;
    }
    return true;
}
function constructJavascriptRegExp(data) {
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    // `/foo/gim` - tail can be maximum 4 chars
    if (regexp[0] === "/") {
        if (tail) modifiers = tail[1];
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
    }
    return new RegExp(regexp, modifiers);
}
function representJavascriptRegExp(object /*, style*/ ) {
    var result = "/" + object.source + "/";
    if (object.global) result += "g";
    if (object.multiline) result += "m";
    if (object.ignoreCase) result += "i";
    return result;
}
function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
}
module.exports = new Type("tag:yaml.org,2002:js/regexp", {
    kind: "scalar",
    resolve: resolveJavascriptRegExp,
    construct: constructJavascriptRegExp,
    predicate: isRegExp,
    represent: representJavascriptRegExp
});


/***/ }),

/***/ 8093:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var Type = __webpack_require__(97869);
function resolveJavascriptUndefined() {
    return true;
}
function constructJavascriptUndefined() {
    /*eslint-disable no-undefined*/ return undefined;
}
function representJavascriptUndefined() {
    return "";
}
function isUndefined(object) {
    return typeof object === "undefined";
}
module.exports = new Type("tag:yaml.org,2002:js/undefined", {
    kind: "scalar",
    resolve: resolveJavascriptUndefined,
    construct: constructJavascriptUndefined,
    predicate: isUndefined,
    represent: representJavascriptUndefined
});


/***/ }),

/***/ 61089:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var Type = __webpack_require__(97869);
module.exports = new Type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
        return data !== null ? data : {};
    }
});


/***/ }),

/***/ 72375:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var Type = __webpack_require__(97869);
function resolveYamlMerge(data) {
    return data === "<<" || data === null;
}
module.exports = new Type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
});


/***/ }),

/***/ 28025:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var Type = __webpack_require__(97869);
function resolveYamlNull(data) {
    if (data === null) return true;
    var max = data.length;
    return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
    return null;
}
function isNull(object) {
    return object === null;
}
module.exports = new Type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
        canonical: function() {
            return "~";
        },
        lowercase: function() {
            return "null";
        },
        uppercase: function() {
            return "NULL";
        },
        camelcase: function() {
            return "Null";
        }
    },
    defaultStyle: "lowercase"
});


/***/ }),

/***/ 99886:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var Type = __webpack_require__(97869);
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString = Object.prototype.toString;
function resolveYamlOmap(data) {
    if (data === null) return true;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]") return false;
        for(pairKey in pair){
            if (_hasOwnProperty.call(pair, pairKey)) {
                if (!pairHasKey) pairHasKey = true;
                else return false;
            }
        }
        if (!pairHasKey) return false;
        if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
        else return false;
    }
    return true;
}
function constructYamlOmap(data) {
    return data !== null ? data : [];
}
module.exports = new Type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
});


/***/ }),

/***/ 86854:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var Type = __webpack_require__(97869);
var _toString = Object.prototype.toString;
function resolveYamlPairs(data) {
    if (data === null) return true;
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        if (_toString.call(pair) !== "[object Object]") return false;
        keys = Object.keys(pair);
        if (keys.length !== 1) return false;
        result[index] = [
            keys[0],
            pair[keys[0]]
        ];
    }
    return true;
}
function constructYamlPairs(data) {
    if (data === null) return [];
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for(index = 0, length = object.length; index < length; index += 1){
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [
            keys[0],
            pair[keys[0]]
        ];
    }
    return result;
}
module.exports = new Type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
});


/***/ }),

/***/ 23241:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var Type = __webpack_require__(97869);
module.exports = new Type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
        return data !== null ? data : [];
    }
});


/***/ }),

/***/ 80235:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var Type = __webpack_require__(97869);
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
    if (data === null) return true;
    var key, object = data;
    for(key in object){
        if (_hasOwnProperty.call(object, key)) {
            if (object[key] !== null) return false;
        }
    }
    return true;
}
function constructYamlSet(data) {
    return data !== null ? data : {};
}
module.exports = new Type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
});


/***/ }),

/***/ 81344:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var Type = __webpack_require__(97869);
module.exports = new Type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
        return data !== null ? data : "";
    }
});


/***/ }),

/***/ 59337:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var Type = __webpack_require__(97869);
var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])" + // [1] year
"-([0-9][0-9])" + // [2] month
"-([0-9][0-9])$"); // [3] day
var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])" + // [1] year
"-([0-9][0-9]?)" + // [2] month
"-([0-9][0-9]?)" + // [3] day
"(?:[Tt]|[ \\t]+)" + // ...
"([0-9][0-9]?)" + // [4] hour
":([0-9][0-9])" + // [5] minute
":([0-9][0-9])" + // [6] second
"(?:\\.([0-9]*))?" + // [7] fraction
"(?:[ \\t]*(Z|([-+])([0-9][0-9]?)" + // [8] tz [9] tz_sign [10] tz_hour
"(?::([0-9][0-9]))?))?$"); // [11] tz_minute
function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
}
function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null) throw new Error("Date resolve error");
    // match: [1] year [2] month [3] day
    year = +match[1];
    month = +match[2] - 1; // JS month starts with 0
    day = +match[3];
    if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
    }
    // match: [4] hour [5] minute [6] second [7] fraction
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
        fraction = match[7].slice(0, 3);
        while(fraction.length < 3){
            fraction += "0";
        }
        fraction = +fraction;
    }
    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute
    if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
        if (match[9] === "-") delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta) date.setTime(date.getTime() - delta);
    return date;
}
function representYamlTimestamp(object /*, style*/ ) {
    return object.toISOString();
}
module.exports = new Type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
});


/***/ }),

/***/ 79158:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z: () => (/* binding */ esm_v4)
});

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6113);
;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm/native.js

/* harmony default export */ const esm_native = ({
    randomUUID: external_crypto_.randomUUID
});

;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm/rng.js

const rnds8Pool = new Uint8Array(256);
let poolPtr = rnds8Pool.length;
function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
        (0,external_crypto_.randomFillSync)(rnds8Pool);
        poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm/stringify.js

const byteToHex = [];
for(let i = 0; i < 256; ++i){
    byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!validate(uuid)) {
        throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
}
/* harmony default export */ const esm_stringify = ((/* unused pure expression or super */ null && (stringify)));

;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm/v4.js



function v4(options, buf, offset) {
    if (esm_native.randomUUID && !buf && !options) {
        return esm_native.randomUUID();
    }
    options = options || {};
    const rnds = options.random ?? options.rng?.() ?? rng();
    if (rnds.length < 16) {
        throw new Error("Random bytes length must be >= 16");
    }
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80;
    if (buf) {
        offset = offset || 0;
        if (offset < 0 || offset + 16 > buf.length) {
            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
        }
        for(let i = 0; i < 16; ++i){
            buf[offset + i] = rnds[i];
        }
        return buf;
    }
    return unsafeStringify(rnds);
}
/* harmony default export */ const esm_v4 = (v4);


/***/ })

};
;