exports.id = 9050;
exports.ids = [9050];
exports.modules = {

/***/ 33426:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CsvFormatterStream = void 0;
const stream_1 = __webpack_require__(12781);
const formatter_1 = __webpack_require__(25886);
class CsvFormatterStream extends stream_1.Transform {
    constructor(formatterOptions){
        super({
            writableObjectMode: formatterOptions.objectMode
        });
        this.hasWrittenBOM = false;
        this.formatterOptions = formatterOptions;
        this.rowFormatter = new formatter_1.RowFormatter(formatterOptions);
        // if writeBOM is false then set to true
        // if writeBOM is true then set to false by default so it is written out
        this.hasWrittenBOM = !formatterOptions.writeBOM;
    }
    transform(transformFunction) {
        this.rowFormatter.rowTransform = transformFunction;
        return this;
    }
    _transform(row, encoding, cb) {
        let cbCalled = false;
        try {
            if (!this.hasWrittenBOM) {
                this.push(this.formatterOptions.BOM);
                this.hasWrittenBOM = true;
            }
            this.rowFormatter.format(row, (err, rows)=>{
                if (err) {
                    cbCalled = true;
                    return cb(err);
                }
                if (rows) {
                    rows.forEach((r)=>{
                        this.push(Buffer.from(r, "utf8"));
                    });
                }
                cbCalled = true;
                return cb();
            });
        } catch (e) {
            if (cbCalled) {
                throw e;
            }
            cb(e);
        }
    }
    _flush(cb) {
        this.rowFormatter.finish((err, rows)=>{
            if (err) {
                return cb(err);
            }
            if (rows) {
                rows.forEach((r)=>{
                    this.push(Buffer.from(r, "utf8"));
                });
            }
            return cb();
        });
    }
}
exports.CsvFormatterStream = CsvFormatterStream; //# sourceMappingURL=CsvFormatterStream.js.map


/***/ }),

/***/ 33538:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.FormatterOptions = void 0;
class FormatterOptions {
    constructor(opts = {}){
        var _a;
        this.objectMode = true;
        this.delimiter = ",";
        this.rowDelimiter = "\n";
        this.quote = '"';
        this.escape = this.quote;
        this.quoteColumns = false;
        this.quoteHeaders = this.quoteColumns;
        this.headers = null;
        this.includeEndRowDelimiter = false;
        this.writeBOM = false;
        this.BOM = "\uFEFF";
        this.alwaysWriteHeaders = false;
        Object.assign(this, opts || {});
        if (typeof (opts === null || opts === void 0 ? void 0 : opts.quoteHeaders) === "undefined") {
            this.quoteHeaders = this.quoteColumns;
        }
        if ((opts === null || opts === void 0 ? void 0 : opts.quote) === true) {
            this.quote = '"';
        } else if ((opts === null || opts === void 0 ? void 0 : opts.quote) === false) {
            this.quote = "";
        }
        if (typeof (opts === null || opts === void 0 ? void 0 : opts.escape) !== "string") {
            this.escape = this.quote;
        }
        this.shouldWriteHeaders = !!this.headers && ((_a = opts.writeHeaders) !== null && _a !== void 0 ? _a : true);
        this.headers = Array.isArray(this.headers) ? this.headers : null;
        this.escapedQuote = `${this.escape}${this.quote}`;
    }
}
exports.FormatterOptions = FormatterOptions; //# sourceMappingURL=FormatterOptions.js.map


/***/ }),

/***/ 94649:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __importDefault = (void 0) && (void 0).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.FieldFormatter = void 0;
const lodash_isboolean_1 = __importDefault(__webpack_require__(93002));
const lodash_isnil_1 = __importDefault(__webpack_require__(78594));
const lodash_escaperegexp_1 = __importDefault(__webpack_require__(5676));
class FieldFormatter {
    constructor(formatterOptions){
        this._headers = null;
        this.formatterOptions = formatterOptions;
        if (formatterOptions.headers !== null) {
            this.headers = formatterOptions.headers;
        }
        this.REPLACE_REGEXP = new RegExp(formatterOptions.quote, "g");
        const escapePattern = `[${formatterOptions.delimiter}${lodash_escaperegexp_1.default(formatterOptions.rowDelimiter)}|\r|\n]`;
        this.ESCAPE_REGEXP = new RegExp(escapePattern);
    }
    set headers(headers) {
        this._headers = headers;
    }
    shouldQuote(fieldIndex, isHeader) {
        const quoteConfig = isHeader ? this.formatterOptions.quoteHeaders : this.formatterOptions.quoteColumns;
        if (lodash_isboolean_1.default(quoteConfig)) {
            return quoteConfig;
        }
        if (Array.isArray(quoteConfig)) {
            return quoteConfig[fieldIndex];
        }
        if (this._headers !== null) {
            return quoteConfig[this._headers[fieldIndex]];
        }
        return false;
    }
    format(field, fieldIndex, isHeader) {
        const preparedField = `${lodash_isnil_1.default(field) ? "" : field}`.replace(/\0/g, "");
        const { formatterOptions } = this;
        if (formatterOptions.quote !== "") {
            const shouldEscape = preparedField.indexOf(formatterOptions.quote) !== -1;
            if (shouldEscape) {
                return this.quoteField(preparedField.replace(this.REPLACE_REGEXP, formatterOptions.escapedQuote));
            }
        }
        const hasEscapeCharacters = preparedField.search(this.ESCAPE_REGEXP) !== -1;
        if (hasEscapeCharacters || this.shouldQuote(fieldIndex, isHeader)) {
            return this.quoteField(preparedField);
        }
        return preparedField;
    }
    quoteField(field) {
        const { quote } = this.formatterOptions;
        return `${quote}${field}${quote}`;
    }
}
exports.FieldFormatter = FieldFormatter; //# sourceMappingURL=FieldFormatter.js.map


/***/ }),

/***/ 488:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __importDefault = (void 0) && (void 0).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.RowFormatter = void 0;
const lodash_isfunction_1 = __importDefault(__webpack_require__(79009));
const lodash_isequal_1 = __importDefault(__webpack_require__(52053));
const FieldFormatter_1 = __webpack_require__(94649);
const types_1 = __webpack_require__(91335);
class RowFormatter {
    constructor(formatterOptions){
        this.rowCount = 0;
        this.formatterOptions = formatterOptions;
        this.fieldFormatter = new FieldFormatter_1.FieldFormatter(formatterOptions);
        this.headers = formatterOptions.headers;
        this.shouldWriteHeaders = formatterOptions.shouldWriteHeaders;
        this.hasWrittenHeaders = false;
        if (this.headers !== null) {
            this.fieldFormatter.headers = this.headers;
        }
        if (formatterOptions.transform) {
            this.rowTransform = formatterOptions.transform;
        }
    }
    static isRowHashArray(row) {
        if (Array.isArray(row)) {
            return Array.isArray(row[0]) && row[0].length === 2;
        }
        return false;
    }
    static isRowArray(row) {
        return Array.isArray(row) && !this.isRowHashArray(row);
    }
    // get headers from a row item
    static gatherHeaders(row) {
        if (RowFormatter.isRowHashArray(row)) {
            // lets assume a multi-dimesional array with item 0 being the header
            return row.map((it)=>it[0]);
        }
        if (Array.isArray(row)) {
            return row;
        }
        return Object.keys(row);
    }
    // eslint-disable-next-line @typescript-eslint/no-shadow
    static createTransform(transformFunction) {
        if (types_1.isSyncTransform(transformFunction)) {
            return (row, cb)=>{
                let transformedRow = null;
                try {
                    transformedRow = transformFunction(row);
                } catch (e) {
                    return cb(e);
                }
                return cb(null, transformedRow);
            };
        }
        return (row, cb)=>{
            transformFunction(row, cb);
        };
    }
    set rowTransform(transformFunction) {
        if (!lodash_isfunction_1.default(transformFunction)) {
            throw new TypeError("The transform should be a function");
        }
        this._rowTransform = RowFormatter.createTransform(transformFunction);
    }
    format(row, cb) {
        this.callTransformer(row, (err, transformedRow)=>{
            if (err) {
                return cb(err);
            }
            if (!row) {
                return cb(null);
            }
            const rows = [];
            if (transformedRow) {
                const { shouldFormatColumns, headers } = this.checkHeaders(transformedRow);
                if (this.shouldWriteHeaders && headers && !this.hasWrittenHeaders) {
                    rows.push(this.formatColumns(headers, true));
                    this.hasWrittenHeaders = true;
                }
                if (shouldFormatColumns) {
                    const columns = this.gatherColumns(transformedRow);
                    rows.push(this.formatColumns(columns, false));
                }
            }
            return cb(null, rows);
        });
    }
    finish(cb) {
        const rows = [];
        // check if we should write headers and we didnt get any rows
        if (this.formatterOptions.alwaysWriteHeaders && this.rowCount === 0) {
            if (!this.headers) {
                return cb(new Error("`alwaysWriteHeaders` option is set to true but `headers` option not provided."));
            }
            rows.push(this.formatColumns(this.headers, true));
        }
        if (this.formatterOptions.includeEndRowDelimiter) {
            rows.push(this.formatterOptions.rowDelimiter);
        }
        return cb(null, rows);
    }
    // check if we need to write header return true if we should also write a row
    // could be false if headers is true and the header row(first item) is passed in
    checkHeaders(row) {
        if (this.headers) {
            // either the headers were provided by the user or we have already gathered them.
            return {
                shouldFormatColumns: true,
                headers: this.headers
            };
        }
        const headers = RowFormatter.gatherHeaders(row);
        this.headers = headers;
        this.fieldFormatter.headers = headers;
        if (!this.shouldWriteHeaders) {
            // if we are not supposed to write the headers then
            // always format the columns
            return {
                shouldFormatColumns: true,
                headers: null
            };
        }
        // if the row is equal to headers dont format
        return {
            shouldFormatColumns: !lodash_isequal_1.default(headers, row),
            headers
        };
    }
    // todo change this method to unknown[]
    gatherColumns(row) {
        if (this.headers === null) {
            throw new Error("Headers is currently null");
        }
        if (!Array.isArray(row)) {
            return this.headers.map((header)=>row[header]);
        }
        if (RowFormatter.isRowHashArray(row)) {
            return this.headers.map((header, i)=>{
                const col = row[i];
                if (col) {
                    return col[1];
                }
                return "";
            });
        }
        // if its a one dimensional array and headers were not provided
        // then just return the row
        if (RowFormatter.isRowArray(row) && !this.shouldWriteHeaders) {
            return row;
        }
        return this.headers.map((header, i)=>row[i]);
    }
    callTransformer(row, cb) {
        if (!this._rowTransform) {
            return cb(null, row);
        }
        return this._rowTransform(row, cb);
    }
    formatColumns(columns, isHeadersRow) {
        const formattedCols = columns.map((field, i)=>this.fieldFormatter.format(field, i, isHeadersRow)).join(this.formatterOptions.delimiter);
        const { rowCount } = this;
        this.rowCount += 1;
        if (rowCount) {
            return [
                this.formatterOptions.rowDelimiter,
                formattedCols
            ].join("");
        }
        return formattedCols;
    }
}
exports.RowFormatter = RowFormatter; //# sourceMappingURL=RowFormatter.js.map


/***/ }),

/***/ 25886:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.FieldFormatter = exports.RowFormatter = void 0;
var RowFormatter_1 = __webpack_require__(488);
Object.defineProperty(exports, "RowFormatter", ({
    enumerable: true,
    get: function() {
        return RowFormatter_1.RowFormatter;
    }
}));
var FieldFormatter_1 = __webpack_require__(94649);
Object.defineProperty(exports, "FieldFormatter", ({
    enumerable: true,
    get: function() {
        return FieldFormatter_1.FieldFormatter;
    }
})); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 29321:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = (void 0) && (void 0).__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.writeToPath = exports.writeToString = exports.writeToBuffer = exports.writeToStream = exports.write = exports.format = exports.FormatterOptions = exports.CsvFormatterStream = void 0;
const util_1 = __webpack_require__(73837);
const stream_1 = __webpack_require__(12781);
const fs = __importStar(__webpack_require__(57147));
const FormatterOptions_1 = __webpack_require__(33538);
const CsvFormatterStream_1 = __webpack_require__(33426);
__exportStar(__webpack_require__(91335), exports);
var CsvFormatterStream_2 = __webpack_require__(33426);
Object.defineProperty(exports, "CsvFormatterStream", ({
    enumerable: true,
    get: function() {
        return CsvFormatterStream_2.CsvFormatterStream;
    }
}));
var FormatterOptions_2 = __webpack_require__(33538);
Object.defineProperty(exports, "FormatterOptions", ({
    enumerable: true,
    get: function() {
        return FormatterOptions_2.FormatterOptions;
    }
}));
exports.format = (options)=>new CsvFormatterStream_1.CsvFormatterStream(new FormatterOptions_1.FormatterOptions(options));
exports.write = (rows, options)=>{
    const csvStream = exports.format(options);
    const promiseWrite = util_1.promisify((row, cb)=>{
        csvStream.write(row, undefined, cb);
    });
    rows.reduce((prev, row)=>prev.then(()=>promiseWrite(row)), Promise.resolve()).then(()=>csvStream.end()).catch((err)=>{
        csvStream.emit("error", err);
    });
    return csvStream;
};
exports.writeToStream = (ws, rows, options)=>exports.write(rows, options).pipe(ws);
exports.writeToBuffer = (rows, opts = {})=>{
    const buffers = [];
    const ws = new stream_1.Writable({
        write (data, enc, writeCb) {
            buffers.push(data);
            writeCb();
        }
    });
    return new Promise((res, rej)=>{
        ws.on("error", rej).on("finish", ()=>res(Buffer.concat(buffers)));
        exports.write(rows, opts).pipe(ws);
    });
};
exports.writeToString = (rows, options)=>exports.writeToBuffer(rows, options).then((buffer)=>buffer.toString());
exports.writeToPath = (path, rows, options)=>{
    const stream = fs.createWriteStream(path, {
        encoding: "utf8"
    });
    return exports.write(rows, options).pipe(stream);
}; //# sourceMappingURL=index.js.map


/***/ }),

/***/ 91335:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isSyncTransform = void 0;
exports.isSyncTransform = (transform)=>transform.length === 1; //# sourceMappingURL=types.js.map


/***/ }),

/***/ 3393:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CsvParserStream = void 0;
const string_decoder_1 = __webpack_require__(71576);
const stream_1 = __webpack_require__(12781);
const transforms_1 = __webpack_require__(80084);
const parser_1 = __webpack_require__(82075);
class CsvParserStream extends stream_1.Transform {
    constructor(parserOptions){
        super({
            objectMode: parserOptions.objectMode
        });
        this.lines = "";
        this.rowCount = 0;
        this.parsedRowCount = 0;
        this.parsedLineCount = 0;
        this.endEmitted = false;
        this.headersEmitted = false;
        this.parserOptions = parserOptions;
        this.parser = new parser_1.Parser(parserOptions);
        this.headerTransformer = new transforms_1.HeaderTransformer(parserOptions);
        this.decoder = new string_decoder_1.StringDecoder(parserOptions.encoding);
        this.rowTransformerValidator = new transforms_1.RowTransformerValidator();
    }
    get hasHitRowLimit() {
        return this.parserOptions.limitRows && this.rowCount >= this.parserOptions.maxRows;
    }
    get shouldEmitRows() {
        return this.parsedRowCount > this.parserOptions.skipRows;
    }
    get shouldSkipLine() {
        return this.parsedLineCount <= this.parserOptions.skipLines;
    }
    transform(transformFunction) {
        this.rowTransformerValidator.rowTransform = transformFunction;
        return this;
    }
    validate(validateFunction) {
        this.rowTransformerValidator.rowValidator = validateFunction;
        return this;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    emit(event, ...rest) {
        if (event === "end") {
            if (!this.endEmitted) {
                this.endEmitted = true;
                super.emit("end", this.rowCount);
            }
            return false;
        }
        return super.emit(event, ...rest);
    }
    _transform(data, encoding, done) {
        // if we have hit our maxRows parsing limit then skip parsing
        if (this.hasHitRowLimit) {
            return done();
        }
        const wrappedCallback = CsvParserStream.wrapDoneCallback(done);
        try {
            const { lines } = this;
            const newLine = lines + this.decoder.write(data);
            const rows = this.parse(newLine, true);
            return this.processRows(rows, wrappedCallback);
        } catch (e) {
            return wrappedCallback(e);
        }
    }
    _flush(done) {
        const wrappedCallback = CsvParserStream.wrapDoneCallback(done);
        // if we have hit our maxRows parsing limit then skip parsing
        if (this.hasHitRowLimit) {
            return wrappedCallback();
        }
        try {
            const newLine = this.lines + this.decoder.end();
            const rows = this.parse(newLine, false);
            return this.processRows(rows, wrappedCallback);
        } catch (e) {
            return wrappedCallback(e);
        }
    }
    parse(data, hasMoreData) {
        if (!data) {
            return [];
        }
        const { line, rows } = this.parser.parse(data, hasMoreData);
        this.lines = line;
        return rows;
    }
    processRows(rows, cb) {
        const rowsLength = rows.length;
        const iterate = (i)=>{
            const callNext = (err)=>{
                if (err) {
                    return cb(err);
                }
                if (i % 100 === 0) {
                    // incase the transform are sync insert a next tick to prevent stack overflow
                    setImmediate(()=>iterate(i + 1));
                    return undefined;
                }
                return iterate(i + 1);
            };
            this.checkAndEmitHeaders();
            // if we have emitted all rows or we have hit the maxRows limit option
            // then end
            if (i >= rowsLength || this.hasHitRowLimit) {
                return cb();
            }
            this.parsedLineCount += 1;
            if (this.shouldSkipLine) {
                return callNext();
            }
            const row = rows[i];
            this.rowCount += 1;
            this.parsedRowCount += 1;
            const nextRowCount = this.rowCount;
            return this.transformRow(row, (err, transformResult)=>{
                if (err) {
                    this.rowCount -= 1;
                    return callNext(err);
                }
                if (!transformResult) {
                    return callNext(new Error("expected transform result"));
                }
                if (!transformResult.isValid) {
                    this.emit("data-invalid", transformResult.row, nextRowCount, transformResult.reason);
                } else if (transformResult.row) {
                    return this.pushRow(transformResult.row, callNext);
                }
                return callNext();
            });
        };
        iterate(0);
    }
    transformRow(parsedRow, cb) {
        try {
            this.headerTransformer.transform(parsedRow, (err, withHeaders)=>{
                if (err) {
                    return cb(err);
                }
                if (!withHeaders) {
                    return cb(new Error("Expected result from header transform"));
                }
                if (!withHeaders.isValid) {
                    if (this.shouldEmitRows) {
                        return cb(null, {
                            isValid: false,
                            row: parsedRow
                        });
                    }
                    // skipped because of skipRows option remove from total row count
                    return this.skipRow(cb);
                }
                if (withHeaders.row) {
                    if (this.shouldEmitRows) {
                        return this.rowTransformerValidator.transformAndValidate(withHeaders.row, cb);
                    }
                    // skipped because of skipRows option remove from total row count
                    return this.skipRow(cb);
                }
                // this is a header row dont include in the rowCount or parsedRowCount
                this.rowCount -= 1;
                this.parsedRowCount -= 1;
                return cb(null, {
                    row: null,
                    isValid: true
                });
            });
        } catch (e) {
            cb(e);
        }
    }
    checkAndEmitHeaders() {
        if (!this.headersEmitted && this.headerTransformer.headers) {
            this.headersEmitted = true;
            this.emit("headers", this.headerTransformer.headers);
        }
    }
    skipRow(cb) {
        // skipped because of skipRows option remove from total row count
        this.rowCount -= 1;
        return cb(null, {
            row: null,
            isValid: true
        });
    }
    pushRow(row, cb) {
        try {
            if (!this.parserOptions.objectMode) {
                this.push(JSON.stringify(row));
            } else {
                this.push(row);
            }
            cb();
        } catch (e) {
            cb(e);
        }
    }
    static wrapDoneCallback(done) {
        let errorCalled = false;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return (err, ...args)=>{
            if (err) {
                if (errorCalled) {
                    throw err;
                }
                errorCalled = true;
                done(err);
                return;
            }
            done(...args);
        };
    }
}
exports.CsvParserStream = CsvParserStream; //# sourceMappingURL=CsvParserStream.js.map


/***/ }),

/***/ 11387:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __importDefault = (void 0) && (void 0).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ParserOptions = void 0;
const lodash_escaperegexp_1 = __importDefault(__webpack_require__(5676));
const lodash_isnil_1 = __importDefault(__webpack_require__(78594));
class ParserOptions {
    constructor(opts){
        var _a;
        this.objectMode = true;
        this.delimiter = ",";
        this.ignoreEmpty = false;
        this.quote = '"';
        this.escape = null;
        this.escapeChar = this.quote;
        this.comment = null;
        this.supportsComments = false;
        this.ltrim = false;
        this.rtrim = false;
        this.trim = false;
        this.headers = null;
        this.renameHeaders = false;
        this.strictColumnHandling = false;
        this.discardUnmappedColumns = false;
        this.carriageReturn = "\r";
        this.encoding = "utf8";
        this.limitRows = false;
        this.maxRows = 0;
        this.skipLines = 0;
        this.skipRows = 0;
        Object.assign(this, opts || {});
        if (this.delimiter.length > 1) {
            throw new Error("delimiter option must be one character long");
        }
        this.escapedDelimiter = lodash_escaperegexp_1.default(this.delimiter);
        this.escapeChar = (_a = this.escape) !== null && _a !== void 0 ? _a : this.quote;
        this.supportsComments = !lodash_isnil_1.default(this.comment);
        this.NEXT_TOKEN_REGEXP = new RegExp(`([^\\s]|\\r\\n|\\n|\\r|${this.escapedDelimiter})`);
        if (this.maxRows > 0) {
            this.limitRows = true;
        }
    }
}
exports.ParserOptions = ParserOptions; //# sourceMappingURL=ParserOptions.js.map


/***/ }),

/***/ 27108:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = (void 0) && (void 0).__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (void 0) && (void 0).__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parseString = exports.parseFile = exports.parseStream = exports.parse = exports.ParserOptions = exports.CsvParserStream = void 0;
const fs = __importStar(__webpack_require__(57147));
const stream_1 = __webpack_require__(12781);
const ParserOptions_1 = __webpack_require__(11387);
const CsvParserStream_1 = __webpack_require__(3393);
__exportStar(__webpack_require__(18914), exports);
var CsvParserStream_2 = __webpack_require__(3393);
Object.defineProperty(exports, "CsvParserStream", ({
    enumerable: true,
    get: function() {
        return CsvParserStream_2.CsvParserStream;
    }
}));
var ParserOptions_2 = __webpack_require__(11387);
Object.defineProperty(exports, "ParserOptions", ({
    enumerable: true,
    get: function() {
        return ParserOptions_2.ParserOptions;
    }
}));
exports.parse = (args)=>new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(args));
exports.parseStream = (stream, options)=>stream.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
exports.parseFile = (location, options = {})=>fs.createReadStream(location).pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
exports.parseString = (string, options)=>{
    const rs = new stream_1.Readable();
    rs.push(string);
    rs.push(null);
    return rs.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
}; //# sourceMappingURL=index.js.map


/***/ }),

/***/ 15699:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Parser = void 0;
const Scanner_1 = __webpack_require__(99999);
const RowParser_1 = __webpack_require__(63552);
const Token_1 = __webpack_require__(60097);
class Parser {
    constructor(parserOptions){
        this.parserOptions = parserOptions;
        this.rowParser = new RowParser_1.RowParser(this.parserOptions);
    }
    static removeBOM(line) {
        // Catches EFBBBF (UTF-8 BOM) because the buffer-to-string
        // conversion translates it to FEFF (UTF-16 BOM)
        if (line && line.charCodeAt(0) === 0xfeff) {
            return line.slice(1);
        }
        return line;
    }
    parse(line, hasMoreData) {
        const scanner = new Scanner_1.Scanner({
            line: Parser.removeBOM(line),
            parserOptions: this.parserOptions,
            hasMoreData
        });
        if (this.parserOptions.supportsComments) {
            return this.parseWithComments(scanner);
        }
        return this.parseWithoutComments(scanner);
    }
    parseWithoutComments(scanner) {
        const rows = [];
        let shouldContinue = true;
        while(shouldContinue){
            shouldContinue = this.parseRow(scanner, rows);
        }
        return {
            line: scanner.line,
            rows
        };
    }
    parseWithComments(scanner) {
        const { parserOptions } = this;
        const rows = [];
        for(let nextToken = scanner.nextCharacterToken; nextToken !== null; nextToken = scanner.nextCharacterToken){
            if (Token_1.Token.isTokenComment(nextToken, parserOptions)) {
                const cursor = scanner.advancePastLine();
                if (cursor === null) {
                    return {
                        line: scanner.lineFromCursor,
                        rows
                    };
                }
                if (!scanner.hasMoreCharacters) {
                    return {
                        line: scanner.lineFromCursor,
                        rows
                    };
                }
                scanner.truncateToCursor();
            } else if (!this.parseRow(scanner, rows)) {
                break;
            }
        }
        return {
            line: scanner.line,
            rows
        };
    }
    parseRow(scanner, rows) {
        const nextToken = scanner.nextNonSpaceToken;
        if (!nextToken) {
            return false;
        }
        const row = this.rowParser.parse(scanner);
        if (row === null) {
            return false;
        }
        if (this.parserOptions.ignoreEmpty && RowParser_1.RowParser.isEmptyRow(row)) {
            return true;
        }
        rows.push(row);
        return true;
    }
}
exports.Parser = Parser; //# sourceMappingURL=Parser.js.map


/***/ }),

/***/ 63552:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.RowParser = void 0;
const column_1 = __webpack_require__(39279);
const Token_1 = __webpack_require__(60097);
const EMPTY_STRING = "";
class RowParser {
    constructor(parserOptions){
        this.parserOptions = parserOptions;
        this.columnParser = new column_1.ColumnParser(parserOptions);
    }
    static isEmptyRow(row) {
        return row.join(EMPTY_STRING).replace(/\s+/g, EMPTY_STRING) === EMPTY_STRING;
    }
    parse(scanner) {
        const { parserOptions } = this;
        const { hasMoreData } = scanner;
        const currentScanner = scanner;
        const columns = [];
        let currentToken = this.getStartToken(currentScanner, columns);
        while(currentToken){
            if (Token_1.Token.isTokenRowDelimiter(currentToken)) {
                currentScanner.advancePastToken(currentToken);
                // if ends with CR and there is more data, keep unparsed due to possible
                // coming LF in CRLF
                if (!currentScanner.hasMoreCharacters && Token_1.Token.isTokenCarriageReturn(currentToken, parserOptions) && hasMoreData) {
                    return null;
                }
                currentScanner.truncateToCursor();
                return columns;
            }
            if (!this.shouldSkipColumnParse(currentScanner, currentToken, columns)) {
                const item = this.columnParser.parse(currentScanner);
                if (item === null) {
                    return null;
                }
                columns.push(item);
            }
            currentToken = currentScanner.nextNonSpaceToken;
        }
        if (!hasMoreData) {
            currentScanner.truncateToCursor();
            return columns;
        }
        return null;
    }
    getStartToken(scanner, columns) {
        const currentToken = scanner.nextNonSpaceToken;
        if (currentToken !== null && Token_1.Token.isTokenDelimiter(currentToken, this.parserOptions)) {
            columns.push("");
            return scanner.nextNonSpaceToken;
        }
        return currentToken;
    }
    shouldSkipColumnParse(scanner, currentToken, columns) {
        const { parserOptions } = this;
        if (Token_1.Token.isTokenDelimiter(currentToken, parserOptions)) {
            scanner.advancePastToken(currentToken);
            // if the delimiter is at the end of a line
            const nextToken = scanner.nextCharacterToken;
            if (!scanner.hasMoreCharacters || nextToken !== null && Token_1.Token.isTokenRowDelimiter(nextToken)) {
                columns.push("");
                return true;
            }
            if (nextToken !== null && Token_1.Token.isTokenDelimiter(nextToken, parserOptions)) {
                columns.push("");
                return true;
            }
        }
        return false;
    }
}
exports.RowParser = RowParser; //# sourceMappingURL=RowParser.js.map


/***/ }),

/***/ 99999:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Scanner = void 0;
const Token_1 = __webpack_require__(60097);
const ROW_DELIMITER = /((?:\r\n)|\n|\r)/;
class Scanner {
    constructor(args){
        this.cursor = 0;
        this.line = args.line;
        this.lineLength = this.line.length;
        this.parserOptions = args.parserOptions;
        this.hasMoreData = args.hasMoreData;
        this.cursor = args.cursor || 0;
    }
    get hasMoreCharacters() {
        return this.lineLength > this.cursor;
    }
    get nextNonSpaceToken() {
        const { lineFromCursor } = this;
        const regex = this.parserOptions.NEXT_TOKEN_REGEXP;
        if (lineFromCursor.search(regex) === -1) {
            return null;
        }
        const match = regex.exec(lineFromCursor);
        if (match == null) {
            return null;
        }
        const token = match[1];
        const startCursor = this.cursor + (match.index || 0);
        return new Token_1.Token({
            token,
            startCursor,
            endCursor: startCursor + token.length - 1
        });
    }
    get nextCharacterToken() {
        const { cursor, lineLength } = this;
        if (lineLength <= cursor) {
            return null;
        }
        return new Token_1.Token({
            token: this.line[cursor],
            startCursor: cursor,
            endCursor: cursor
        });
    }
    get lineFromCursor() {
        return this.line.substr(this.cursor);
    }
    advancePastLine() {
        const match = ROW_DELIMITER.exec(this.lineFromCursor);
        if (!match) {
            if (this.hasMoreData) {
                return null;
            }
            this.cursor = this.lineLength;
            return this;
        }
        this.cursor += (match.index || 0) + match[0].length;
        return this;
    }
    advanceTo(cursor) {
        this.cursor = cursor;
        return this;
    }
    advanceToToken(token) {
        this.cursor = token.startCursor;
        return this;
    }
    advancePastToken(token) {
        this.cursor = token.endCursor + 1;
        return this;
    }
    truncateToCursor() {
        this.line = this.lineFromCursor;
        this.lineLength = this.line.length;
        this.cursor = 0;
        return this;
    }
}
exports.Scanner = Scanner; //# sourceMappingURL=Scanner.js.map


/***/ }),

/***/ 60097:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Token = void 0;
class Token {
    constructor(tokenArgs){
        this.token = tokenArgs.token;
        this.startCursor = tokenArgs.startCursor;
        this.endCursor = tokenArgs.endCursor;
    }
    static isTokenRowDelimiter(token) {
        const content = token.token;
        return content === "\r" || content === "\n" || content === "\r\n";
    }
    static isTokenCarriageReturn(token, parserOptions) {
        return token.token === parserOptions.carriageReturn;
    }
    static isTokenComment(token, parserOptions) {
        return parserOptions.supportsComments && !!token && token.token === parserOptions.comment;
    }
    static isTokenEscapeCharacter(token, parserOptions) {
        return token.token === parserOptions.escapeChar;
    }
    static isTokenQuote(token, parserOptions) {
        return token.token === parserOptions.quote;
    }
    static isTokenDelimiter(token, parserOptions) {
        return token.token === parserOptions.delimiter;
    }
}
exports.Token = Token; //# sourceMappingURL=Token.js.map


/***/ }),

/***/ 56547:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ColumnFormatter = void 0;
class ColumnFormatter {
    constructor(parserOptions){
        if (parserOptions.trim) {
            this.format = (col)=>col.trim();
        } else if (parserOptions.ltrim) {
            this.format = (col)=>col.trimLeft();
        } else if (parserOptions.rtrim) {
            this.format = (col)=>col.trimRight();
        } else {
            this.format = (col)=>col;
        }
    }
}
exports.ColumnFormatter = ColumnFormatter; //# sourceMappingURL=ColumnFormatter.js.map


/***/ }),

/***/ 29330:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ColumnParser = void 0;
const NonQuotedColumnParser_1 = __webpack_require__(73821);
const QuotedColumnParser_1 = __webpack_require__(30035);
const Token_1 = __webpack_require__(60097);
class ColumnParser {
    constructor(parserOptions){
        this.parserOptions = parserOptions;
        this.quotedColumnParser = new QuotedColumnParser_1.QuotedColumnParser(parserOptions);
        this.nonQuotedColumnParser = new NonQuotedColumnParser_1.NonQuotedColumnParser(parserOptions);
    }
    parse(scanner) {
        const { nextNonSpaceToken } = scanner;
        if (nextNonSpaceToken !== null && Token_1.Token.isTokenQuote(nextNonSpaceToken, this.parserOptions)) {
            scanner.advanceToToken(nextNonSpaceToken);
            return this.quotedColumnParser.parse(scanner);
        }
        return this.nonQuotedColumnParser.parse(scanner);
    }
}
exports.ColumnParser = ColumnParser; //# sourceMappingURL=ColumnParser.js.map


/***/ }),

/***/ 73821:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NonQuotedColumnParser = void 0;
const ColumnFormatter_1 = __webpack_require__(56547);
const Token_1 = __webpack_require__(60097);
class NonQuotedColumnParser {
    constructor(parserOptions){
        this.parserOptions = parserOptions;
        this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);
    }
    parse(scanner) {
        if (!scanner.hasMoreCharacters) {
            return null;
        }
        const { parserOptions } = this;
        const characters = [];
        let nextToken = scanner.nextCharacterToken;
        for(; nextToken; nextToken = scanner.nextCharacterToken){
            if (Token_1.Token.isTokenDelimiter(nextToken, parserOptions) || Token_1.Token.isTokenRowDelimiter(nextToken)) {
                break;
            }
            characters.push(nextToken.token);
            scanner.advancePastToken(nextToken);
        }
        return this.columnFormatter.format(characters.join(""));
    }
}
exports.NonQuotedColumnParser = NonQuotedColumnParser; //# sourceMappingURL=NonQuotedColumnParser.js.map


/***/ }),

/***/ 30035:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.QuotedColumnParser = void 0;
const ColumnFormatter_1 = __webpack_require__(56547);
const Token_1 = __webpack_require__(60097);
class QuotedColumnParser {
    constructor(parserOptions){
        this.parserOptions = parserOptions;
        this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);
    }
    parse(scanner) {
        if (!scanner.hasMoreCharacters) {
            return null;
        }
        const originalCursor = scanner.cursor;
        const { foundClosingQuote, col } = this.gatherDataBetweenQuotes(scanner);
        if (!foundClosingQuote) {
            // reset the cursor to the original
            scanner.advanceTo(originalCursor);
            // if we didnt find a closing quote but we potentially have more data then skip the parsing
            // and return the original scanner.
            if (!scanner.hasMoreData) {
                throw new Error(`Parse Error: missing closing: '${this.parserOptions.quote || ""}' in line: at '${scanner.lineFromCursor.replace(/[\r\n]/g, "\\n'")}'`);
            }
            return null;
        }
        this.checkForMalformedColumn(scanner);
        return col;
    }
    gatherDataBetweenQuotes(scanner) {
        const { parserOptions } = this;
        let foundStartingQuote = false;
        let foundClosingQuote = false;
        const characters = [];
        let nextToken = scanner.nextCharacterToken;
        for(; !foundClosingQuote && nextToken !== null; nextToken = scanner.nextCharacterToken){
            const isQuote = Token_1.Token.isTokenQuote(nextToken, parserOptions);
            // ignore first quote
            if (!foundStartingQuote && isQuote) {
                foundStartingQuote = true;
            } else if (foundStartingQuote) {
                if (Token_1.Token.isTokenEscapeCharacter(nextToken, parserOptions)) {
                    // advance past the escape character so we can get the next one in line
                    scanner.advancePastToken(nextToken);
                    const tokenFollowingEscape = scanner.nextCharacterToken;
                    // if the character following the escape is a quote character then just add
                    // the quote and advance to that character
                    if (tokenFollowingEscape !== null && (Token_1.Token.isTokenQuote(tokenFollowingEscape, parserOptions) || Token_1.Token.isTokenEscapeCharacter(tokenFollowingEscape, parserOptions))) {
                        characters.push(tokenFollowingEscape.token);
                        nextToken = tokenFollowingEscape;
                    } else if (isQuote) {
                        // if the escape is also a quote then we found our closing quote and finish early
                        foundClosingQuote = true;
                    } else {
                        // other wise add the escape token to the characters since it wast escaping anything
                        characters.push(nextToken.token);
                    }
                } else if (isQuote) {
                    // we found our closing quote!
                    foundClosingQuote = true;
                } else {
                    // add the token to the characters
                    characters.push(nextToken.token);
                }
            }
            scanner.advancePastToken(nextToken);
        }
        return {
            col: this.columnFormatter.format(characters.join("")),
            foundClosingQuote
        };
    }
    checkForMalformedColumn(scanner) {
        const { parserOptions } = this;
        const { nextNonSpaceToken } = scanner;
        if (nextNonSpaceToken) {
            const isNextTokenADelimiter = Token_1.Token.isTokenDelimiter(nextNonSpaceToken, parserOptions);
            const isNextTokenARowDelimiter = Token_1.Token.isTokenRowDelimiter(nextNonSpaceToken);
            if (!(isNextTokenADelimiter || isNextTokenARowDelimiter)) {
                // if the final quote was NOT followed by a column (,) or row(\n) delimiter then its a bad column
                // tldr: only part of the column was quoted
                const linePreview = scanner.lineFromCursor.substr(0, 10).replace(/[\r\n]/g, "\\n'");
                throw new Error(`Parse Error: expected: '${parserOptions.escapedDelimiter}' OR new line got: '${nextNonSpaceToken.token}'. at '${linePreview}`);
            }
            scanner.advanceToToken(nextNonSpaceToken);
        } else if (!scanner.hasMoreData) {
            scanner.advancePastLine();
        }
    }
}
exports.QuotedColumnParser = QuotedColumnParser; //# sourceMappingURL=QuotedColumnParser.js.map


/***/ }),

/***/ 39279:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ColumnFormatter = exports.QuotedColumnParser = exports.NonQuotedColumnParser = exports.ColumnParser = void 0;
var ColumnParser_1 = __webpack_require__(29330);
Object.defineProperty(exports, "ColumnParser", ({
    enumerable: true,
    get: function() {
        return ColumnParser_1.ColumnParser;
    }
}));
var NonQuotedColumnParser_1 = __webpack_require__(73821);
Object.defineProperty(exports, "NonQuotedColumnParser", ({
    enumerable: true,
    get: function() {
        return NonQuotedColumnParser_1.NonQuotedColumnParser;
    }
}));
var QuotedColumnParser_1 = __webpack_require__(30035);
Object.defineProperty(exports, "QuotedColumnParser", ({
    enumerable: true,
    get: function() {
        return QuotedColumnParser_1.QuotedColumnParser;
    }
}));
var ColumnFormatter_1 = __webpack_require__(56547);
Object.defineProperty(exports, "ColumnFormatter", ({
    enumerable: true,
    get: function() {
        return ColumnFormatter_1.ColumnFormatter;
    }
})); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 82075:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.QuotedColumnParser = exports.NonQuotedColumnParser = exports.ColumnParser = exports.Token = exports.Scanner = exports.RowParser = exports.Parser = void 0;
var Parser_1 = __webpack_require__(15699);
Object.defineProperty(exports, "Parser", ({
    enumerable: true,
    get: function() {
        return Parser_1.Parser;
    }
}));
var RowParser_1 = __webpack_require__(63552);
Object.defineProperty(exports, "RowParser", ({
    enumerable: true,
    get: function() {
        return RowParser_1.RowParser;
    }
}));
var Scanner_1 = __webpack_require__(99999);
Object.defineProperty(exports, "Scanner", ({
    enumerable: true,
    get: function() {
        return Scanner_1.Scanner;
    }
}));
var Token_1 = __webpack_require__(60097);
Object.defineProperty(exports, "Token", ({
    enumerable: true,
    get: function() {
        return Token_1.Token;
    }
}));
var column_1 = __webpack_require__(39279);
Object.defineProperty(exports, "ColumnParser", ({
    enumerable: true,
    get: function() {
        return column_1.ColumnParser;
    }
}));
Object.defineProperty(exports, "NonQuotedColumnParser", ({
    enumerable: true,
    get: function() {
        return column_1.NonQuotedColumnParser;
    }
}));
Object.defineProperty(exports, "QuotedColumnParser", ({
    enumerable: true,
    get: function() {
        return column_1.QuotedColumnParser;
    }
})); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 56739:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __importDefault = (void 0) && (void 0).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.HeaderTransformer = void 0;
const lodash_isundefined_1 = __importDefault(__webpack_require__(62085));
const lodash_isfunction_1 = __importDefault(__webpack_require__(79009));
const lodash_uniq_1 = __importDefault(__webpack_require__(22377));
const lodash_groupby_1 = __importDefault(__webpack_require__(39449));
class HeaderTransformer {
    constructor(parserOptions){
        this.headers = null;
        this.receivedHeaders = false;
        this.shouldUseFirstRow = false;
        this.processedFirstRow = false;
        this.headersLength = 0;
        this.parserOptions = parserOptions;
        if (parserOptions.headers === true) {
            this.shouldUseFirstRow = true;
        } else if (Array.isArray(parserOptions.headers)) {
            this.setHeaders(parserOptions.headers);
        } else if (lodash_isfunction_1.default(parserOptions.headers)) {
            this.headersTransform = parserOptions.headers;
        }
    }
    transform(row, cb) {
        if (!this.shouldMapRow(row)) {
            return cb(null, {
                row: null,
                isValid: true
            });
        }
        return cb(null, this.processRow(row));
    }
    shouldMapRow(row) {
        const { parserOptions } = this;
        if (!this.headersTransform && parserOptions.renameHeaders && !this.processedFirstRow) {
            if (!this.receivedHeaders) {
                throw new Error("Error renaming headers: new headers must be provided in an array");
            }
            this.processedFirstRow = true;
            return false;
        }
        if (!this.receivedHeaders && Array.isArray(row)) {
            if (this.headersTransform) {
                this.setHeaders(this.headersTransform(row));
            } else if (this.shouldUseFirstRow) {
                this.setHeaders(row);
            } else {
                // dont do anything with the headers if we didnt receive a transform or shouldnt use the first row.
                return true;
            }
            return false;
        }
        return true;
    }
    processRow(row) {
        if (!this.headers) {
            return {
                row: row,
                isValid: true
            };
        }
        const { parserOptions } = this;
        if (!parserOptions.discardUnmappedColumns && row.length > this.headersLength) {
            if (!parserOptions.strictColumnHandling) {
                throw new Error(`Unexpected Error: column header mismatch expected: ${this.headersLength} columns got: ${row.length}`);
            }
            return {
                row: row,
                isValid: false,
                reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row.length}`
            };
        }
        if (parserOptions.strictColumnHandling && row.length < this.headersLength) {
            return {
                row: row,
                isValid: false,
                reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row.length}`
            };
        }
        return {
            row: this.mapHeaders(row),
            isValid: true
        };
    }
    mapHeaders(row) {
        const rowMap = {};
        const { headers, headersLength } = this;
        for(let i = 0; i < headersLength; i += 1){
            const header = headers[i];
            if (!lodash_isundefined_1.default(header)) {
                const val = row[i];
                // eslint-disable-next-line no-param-reassign
                if (lodash_isundefined_1.default(val)) {
                    rowMap[header] = "";
                } else {
                    rowMap[header] = val;
                }
            }
        }
        return rowMap;
    }
    setHeaders(headers) {
        var _a;
        const filteredHeaders = headers.filter((h)=>!!h);
        if (lodash_uniq_1.default(filteredHeaders).length !== filteredHeaders.length) {
            const grouped = lodash_groupby_1.default(filteredHeaders);
            const duplicates = Object.keys(grouped).filter((dup)=>grouped[dup].length > 1);
            throw new Error(`Duplicate headers found ${JSON.stringify(duplicates)}`);
        }
        this.headers = headers;
        this.receivedHeaders = true;
        this.headersLength = ((_a = this.headers) === null || _a === void 0 ? void 0 : _a.length) || 0;
    }
}
exports.HeaderTransformer = HeaderTransformer; //# sourceMappingURL=HeaderTransformer.js.map


/***/ }),

/***/ 24470:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var __importDefault = (void 0) && (void 0).__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.RowTransformerValidator = void 0;
const lodash_isfunction_1 = __importDefault(__webpack_require__(79009));
const types_1 = __webpack_require__(18914);
class RowTransformerValidator {
    constructor(){
        this._rowTransform = null;
        this._rowValidator = null;
    }
    // eslint-disable-next-line @typescript-eslint/no-shadow
    static createTransform(transformFunction) {
        if (types_1.isSyncTransform(transformFunction)) {
            return (row, cb)=>{
                let transformed = null;
                try {
                    transformed = transformFunction(row);
                } catch (e) {
                    return cb(e);
                }
                return cb(null, transformed);
            };
        }
        return transformFunction;
    }
    static createValidator(validateFunction) {
        if (types_1.isSyncValidate(validateFunction)) {
            return (row, cb)=>{
                cb(null, {
                    row,
                    isValid: validateFunction(row)
                });
            };
        }
        return (row, cb)=>{
            validateFunction(row, (err, isValid, reason)=>{
                if (err) {
                    return cb(err);
                }
                if (isValid) {
                    return cb(null, {
                        row,
                        isValid,
                        reason
                    });
                }
                return cb(null, {
                    row,
                    isValid: false,
                    reason
                });
            });
        };
    }
    set rowTransform(transformFunction) {
        if (!lodash_isfunction_1.default(transformFunction)) {
            throw new TypeError("The transform should be a function");
        }
        this._rowTransform = RowTransformerValidator.createTransform(transformFunction);
    }
    set rowValidator(validateFunction) {
        if (!lodash_isfunction_1.default(validateFunction)) {
            throw new TypeError("The validate should be a function");
        }
        this._rowValidator = RowTransformerValidator.createValidator(validateFunction);
    }
    transformAndValidate(row, cb) {
        return this.callTransformer(row, (transformErr, transformedRow)=>{
            if (transformErr) {
                return cb(transformErr);
            }
            if (!transformedRow) {
                return cb(null, {
                    row: null,
                    isValid: true
                });
            }
            return this.callValidator(transformedRow, (validateErr, validationResult)=>{
                if (validateErr) {
                    return cb(validateErr);
                }
                if (validationResult && !validationResult.isValid) {
                    return cb(null, {
                        row: transformedRow,
                        isValid: false,
                        reason: validationResult.reason
                    });
                }
                return cb(null, {
                    row: transformedRow,
                    isValid: true
                });
            });
        });
    }
    callTransformer(row, cb) {
        if (!this._rowTransform) {
            return cb(null, row);
        }
        return this._rowTransform(row, cb);
    }
    callValidator(row, cb) {
        if (!this._rowValidator) {
            return cb(null, {
                row,
                isValid: true
            });
        }
        return this._rowValidator(row, cb);
    }
}
exports.RowTransformerValidator = RowTransformerValidator; //# sourceMappingURL=RowTransformerValidator.js.map


/***/ }),

/***/ 80084:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.HeaderTransformer = exports.RowTransformerValidator = void 0;
var RowTransformerValidator_1 = __webpack_require__(24470);
Object.defineProperty(exports, "RowTransformerValidator", ({
    enumerable: true,
    get: function() {
        return RowTransformerValidator_1.RowTransformerValidator;
    }
}));
var HeaderTransformer_1 = __webpack_require__(56739);
Object.defineProperty(exports, "HeaderTransformer", ({
    enumerable: true,
    get: function() {
        return HeaderTransformer_1.HeaderTransformer;
    }
})); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 18914:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isSyncValidate = exports.isSyncTransform = void 0;
exports.isSyncTransform = (transform)=>transform.length === 1;
exports.isSyncValidate = (validate)=>validate.length === 1; //# sourceMappingURL=types.js.map


/***/ }),

/***/ 12697:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * archiver-utils
 *
 * Copyright (c) 2012-2014 Chris Talkington, contributors.
 * Licensed under the MIT license.
 * https://github.com/archiverjs/node-archiver/blob/master/LICENSE-MIT
 */ 
var fs = __webpack_require__(33362);
var path = __webpack_require__(71017);
var flatten = __webpack_require__(95918);
var difference = __webpack_require__(4212);
var union = __webpack_require__(25372);
var isPlainObject = __webpack_require__(22557);
var glob = __webpack_require__(85642);
var file = module.exports = {};
var pathSeparatorRe = /[\/\\]/g;
// Process specified wildcard glob patterns or filenames against a
// callback, excluding and uniquing files in the result set.
var processPatterns = function(patterns, fn) {
    // Filepaths to return.
    var result = [];
    // Iterate over flattened patterns array.
    flatten(patterns).forEach(function(pattern) {
        // If the first character is ! it should be omitted
        var exclusion = pattern.indexOf("!") === 0;
        // If the pattern is an exclusion, remove the !
        if (exclusion) {
            pattern = pattern.slice(1);
        }
        // Find all matching files for this pattern.
        var matches = fn(pattern);
        if (exclusion) {
            // If an exclusion, remove matching files.
            result = difference(result, matches);
        } else {
            // Otherwise add matching files.
            result = union(result, matches);
        }
    });
    return result;
};
// True if the file path exists.
file.exists = function() {
    var filepath = path.join.apply(path, arguments);
    return fs.existsSync(filepath);
};
// Return an array of all file paths that match the given wildcard patterns.
file.expand = function(...args) {
    // If the first argument is an options object, save those options to pass
    // into the File.prototype.glob.sync method.
    var options = isPlainObject(args[0]) ? args.shift() : {};
    // Use the first argument if it's an Array, otherwise convert the arguments
    // object to an array and use that.
    var patterns = Array.isArray(args[0]) ? args[0] : args;
    // Return empty set if there are no patterns or filepaths.
    if (patterns.length === 0) {
        return [];
    }
    // Return all matching filepaths.
    var matches = processPatterns(patterns, function(pattern) {
        // Find all matching files for this pattern.
        return glob.sync(pattern, options);
    });
    // Filter result set?
    if (options.filter) {
        matches = matches.filter(function(filepath) {
            filepath = path.join(options.cwd || "", filepath);
            try {
                if (typeof options.filter === "function") {
                    return options.filter(filepath);
                } else {
                    // If the file is of the right type and exists, this should work.
                    return fs.statSync(filepath)[options.filter]();
                }
            } catch (e) {
                // Otherwise, it's probably not the right type.
                return false;
            }
        });
    }
    return matches;
};
// Build a multi task "files" object dynamically.
file.expandMapping = function(patterns, destBase, options) {
    options = Object.assign({
        rename: function(destBase, destPath) {
            return path.join(destBase || "", destPath);
        }
    }, options);
    var files = [];
    var fileByDest = {};
    // Find all files matching pattern, using passed-in options.
    file.expand(options, patterns).forEach(function(src) {
        var destPath = src;
        // Flatten?
        if (options.flatten) {
            destPath = path.basename(destPath);
        }
        // Change the extension?
        if (options.ext) {
            destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
        }
        // Generate destination filename.
        var dest = options.rename(destBase, destPath, options);
        // Prepend cwd to src path if necessary.
        if (options.cwd) {
            src = path.join(options.cwd, src);
        }
        // Normalize filepaths to be unix-style.
        dest = dest.replace(pathSeparatorRe, "/");
        src = src.replace(pathSeparatorRe, "/");
        // Map correct src path to dest path.
        if (fileByDest[dest]) {
            // If dest already exists, push this src onto that dest's src array.
            fileByDest[dest].src.push(src);
        } else {
            // Otherwise create a new src-dest file mapping object.
            files.push({
                src: [
                    src
                ],
                dest: dest
            });
            // And store a reference for later use.
            fileByDest[dest] = files[files.length - 1];
        }
    });
    return files;
};
// reusing bits of grunt's multi-task source normalization
file.normalizeFilesArray = function(data) {
    var files = [];
    data.forEach(function(obj) {
        var prop;
        if ("src" in obj || "dest" in obj) {
            files.push(obj);
        }
    });
    if (files.length === 0) {
        return [];
    }
    files = _(files).chain().forEach(function(obj) {
        if (!("src" in obj) || !obj.src) {
            return;
        }
        // Normalize .src properties to flattened array.
        if (Array.isArray(obj.src)) {
            obj.src = flatten(obj.src);
        } else {
            obj.src = [
                obj.src
            ];
        }
    }).map(function(obj) {
        // Build options object, removing unwanted properties.
        var expandOptions = Object.assign({}, obj);
        delete expandOptions.src;
        delete expandOptions.dest;
        // Expand file mappings.
        if (obj.expand) {
            return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {
                // Copy obj properties to result.
                var result = Object.assign({}, obj);
                // Make a clone of the orig obj available.
                result.orig = Object.assign({}, obj);
                // Set .src and .dest, processing both as templates.
                result.src = mapObj.src;
                result.dest = mapObj.dest;
                // Remove unwanted properties.
                [
                    "expand",
                    "cwd",
                    "flatten",
                    "rename",
                    "ext"
                ].forEach(function(prop) {
                    delete result[prop];
                });
                return result;
            });
        }
        // Copy obj properties to result, adding an .orig property.
        var result = Object.assign({}, obj);
        // Make a clone of the orig obj available.
        result.orig = Object.assign({}, obj);
        if ("src" in result) {
            // Expose an expand-on-demand getter method as .src.
            Object.defineProperty(result, "src", {
                enumerable: true,
                get: function fn() {
                    var src;
                    if (!("result" in fn)) {
                        src = obj.src;
                        // If src is an array, flatten it. Otherwise, make it into an array.
                        src = Array.isArray(src) ? flatten(src) : [
                            src
                        ];
                        // Expand src files, memoizing result.
                        fn.result = file.expand(expandOptions, src);
                    }
                    return fn.result;
                }
            });
        }
        if ("dest" in result) {
            result.dest = obj.dest;
        }
        return result;
    }).flatten().value();
    return files;
};


/***/ }),

/***/ 62499:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * archiver-utils
 *
 * Copyright (c) 2015 Chris Talkington.
 * Licensed under the MIT license.
 * https://github.com/archiverjs/archiver-utils/blob/master/LICENSE
 */ 
var fs = __webpack_require__(33362);
var path = __webpack_require__(71017);
var nutil = __webpack_require__(73837);
var lazystream = __webpack_require__(28507);
var normalizePath = __webpack_require__(26218);
var defaults = __webpack_require__(25377);
var Stream = (__webpack_require__(12781).Stream);
var PassThrough = (__webpack_require__(83231).PassThrough);
var utils = module.exports = {};
utils.file = __webpack_require__(12697);
function assertPath(path) {
    if (typeof path !== "string") {
        throw new TypeError("Path must be a string. Received " + nutils.inspect(path));
    }
}
utils.collectStream = function(source, callback) {
    var collection = [];
    var size = 0;
    source.on("error", callback);
    source.on("data", function(chunk) {
        collection.push(chunk);
        size += chunk.length;
    });
    source.on("end", function() {
        var buf = new Buffer(size);
        var offset = 0;
        collection.forEach(function(data) {
            data.copy(buf, offset);
            offset += data.length;
        });
        callback(null, buf);
    });
};
utils.dateify = function(dateish) {
    dateish = dateish || new Date();
    if (dateish instanceof Date) {
        dateish = dateish;
    } else if (typeof dateish === "string") {
        dateish = new Date(dateish);
    } else {
        dateish = new Date();
    }
    return dateish;
};
// this is slightly different from lodash version
utils.defaults = function(object, source, guard) {
    var args = arguments;
    args[0] = args[0] || {};
    return defaults(...args);
};
utils.isStream = function(source) {
    return source instanceof Stream;
};
utils.lazyReadStream = function(filepath) {
    return new lazystream.Readable(function() {
        return fs.createReadStream(filepath);
    });
};
utils.normalizeInputSource = function(source) {
    if (source === null) {
        return new Buffer(0);
    } else if (typeof source === "string") {
        return new Buffer(source);
    } else if (utils.isStream(source) && !source._readableState) {
        var normalized = new PassThrough();
        source.pipe(normalized);
        return normalized;
    }
    return source;
};
utils.sanitizePath = function(filepath) {
    return normalizePath(filepath, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
};
utils.trailingSlashIt = function(str) {
    return str.slice(-1) !== "/" ? str + "/" : str;
};
utils.unixifyPath = function(filepath) {
    return normalizePath(filepath, false).replace(/^\w+:/, "");
};
utils.walkdir = function(dirpath, base, callback) {
    var results = [];
    if (typeof base === "function") {
        callback = base;
        base = dirpath;
    }
    fs.readdir(dirpath, function(err, list) {
        var i = 0;
        var file;
        var filepath;
        if (err) {
            return callback(err);
        }
        (function next() {
            file = list[i++];
            if (!file) {
                return callback(null, results);
            }
            filepath = path.join(dirpath, file);
            fs.stat(filepath, function(err, stats) {
                results.push({
                    path: filepath,
                    relative: path.relative(base, filepath).replace(/\\/g, "/"),
                    stats: stats
                });
                if (stats && stats.isDirectory()) {
                    utils.walkdir(filepath, base, function(err, res) {
                        res.forEach(function(dirEntry) {
                            results.push(dirEntry);
                        });
                        next();
                    });
                } else {
                    next();
                }
            });
        })();
    });
};


/***/ }),

/***/ 91837:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/ var pna = __webpack_require__(11210);
/*</replacement>*/ /*<replacement>*/ var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for(var key in obj){
        keys.push(key);
    }
    return keys;
};
/*</replacement>*/ module.exports = Duplex;
/*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ var Readable = __webpack_require__(40959);
var Writable = __webpack_require__(59368);
util.inherits(Duplex, Readable);
{
    // avoid scope creep, the keys array can then be collected
    var keys = objectKeys(Writable.prototype);
    for(var v = 0; v < keys.length; v++){
        var method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
}function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
}
Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
        return this._writableState.highWaterMark;
    }
});
// the no-half-open enforcer
function onend() {
    // if we allow half-open state, or if the writable side ended,
    // then we're ok.
    if (this.allowHalfOpen || this._writableState.ended) return;
    // no more data can be written.
    // But allow more writes to happen in this tick.
    pna.nextTick(onEndNT, this);
}
function onEndNT(self) {
    self.end();
}
Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
        if (this._readableState === undefined || this._writableState === undefined) {
            return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});
Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
};


/***/ }),

/***/ 19782:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;
var Transform = __webpack_require__(77641);
/*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ util.inherits(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};


/***/ }),

/***/ 40959:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/ var pna = __webpack_require__(11210);
/*</replacement>*/ module.exports = Readable;
/*<replacement>*/ var isArray = __webpack_require__(46405);
/*</replacement>*/ /*<replacement>*/ var Duplex;
/*</replacement>*/ Readable.ReadableState = ReadableState;
/*<replacement>*/ var EE = (__webpack_require__(82361).EventEmitter);
var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
};
/*</replacement>*/ /*<replacement>*/ var Stream = __webpack_require__(97618);
/*</replacement>*/ /*<replacement>*/ var Buffer = (__webpack_require__(6873).Buffer);
var OurUint8Array = (typeof global !== "undefined" ? global :  false ? 0 : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/ /*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ /*<replacement>*/ var debugUtil = __webpack_require__(73837);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
} else {
    debug = function() {};
}
/*</replacement>*/ var BufferList = __webpack_require__(72176);
var destroyImpl = __webpack_require__(28837);
var StringDecoder;
util.inherits(Readable, Stream);
var kProxyEvents = [
    "error",
    "close",
    "destroy",
    "pause",
    "resume"
];
function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [
        fn,
        emitter._events[event]
    ];
}
function ReadableState(options, stream) {
    Duplex = Duplex || __webpack_require__(91837);
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    var isDuplex = stream instanceof Duplex;
    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    // cast to ints.
    this.highWaterMark = Math.floor(this.highWaterMark);
    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true;
    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    // has it been destroyed
    this.destroyed = false;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;
    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!StringDecoder) StringDecoder = (__webpack_require__(66884)/* .StringDecoder */ .s);
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    Duplex = Duplex || __webpack_require__(91837);
    if (!(this instanceof Readable)) return new Readable(options);
    this._readableState = new ReadableState(options, this);
    // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
}
Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
        if (this._readableState === undefined) {
            return false;
        }
        return this._readableState.destroyed;
    },
    set: function(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
};
// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = "";
            }
            skipChunkCheck = true;
        }
    } else {
        skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};
// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
            stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
                if (state.endEmitted) stream.emit("error", new Error("stream.unshift() after end event"));
                else addChunk(stream, state, chunk, true);
            } else if (state.ended) {
                stream.emit("error", new Error("stream.push() after EOF"));
            } else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                    else maybeReadMore(stream, state);
                } else {
                    addChunk(stream, state, chunk, false);
                }
            }
        } else if (!addToFront) {
            state.reading = false;
        }
    }
    return needMoreData(state);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
    } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
}
// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
};
// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(66884)/* .StringDecoder */ .s);
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
};
// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
        n = MAX_HWM;
    } else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
}
// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false;
    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
    }
    n = howMuchToRead(n, state);
    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
    }
    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug("need readable", doRead);
    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
    }
    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
    } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = fromList(n, state);
    else ret = null;
    if (ret === null) {
        state.needReadable = true;
        n = 0;
    } else {
        state.length -= n;
    }
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;
        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
};
function onEofChunk(stream, state) {
    if (state.ended) return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    // emit 'readable' now to make sure it gets picked up.
    emitReadable(stream);
}
// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync) pna.nextTick(emitReadable_, stream);
        else emitReadable_(stream);
    }
}
function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
}
// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    var len = state.length;
    while(!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark){
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) break;
        else len = state.length;
    }
    state.readingMore = false;
}
// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch(state.pipesCount){
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [
                state.pipes,
                dest
            ];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) pna.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug("onend");
        dest.end();
    }
    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
        debug("cleanup");
        // cleanup event handlers once the pipe is broken
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    // If the user pushes more data while we're writing to dest then we'll end up
    // in ondata again. However, we only want to increase awaitDrain once because
    // dest will only emit one 'drain' event for the multiple writes.
    // => Introduce a guard on increasing awaitDrain.
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug("false write response, pause", state.awaitDrain);
                state.awaitDrain++;
                increasedAwaitDrain = true;
            }
            src.pause();
        }
    }
    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    // Make sure our error handler is attached before userland ones.
    prependListener(dest, "error", onerror);
    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
    }
    // tell the dest that it's being piped to
    dest.emit("pipe", src);
    // start the flow if it hasn't been started already.
    if (!state.flowing) {
        debug("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src) {
    return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    };
    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;
    // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
    }
    // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for(var i = 0; i < len; i++){
            dests[i].emit("unpipe", this, {
                hasUnpiped: false
            });
        }
        return this;
    }
    // try to find the right one.
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
        // Start flowing on next tick if stream isn't explicitly paused
        if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) {
                pna.nextTick(nReadingNextTick, this);
            } else if (state.length) {
                emitReadable(this);
            }
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self1) {
    debug("readable nexttick read 0");
    self1.read(0);
}
// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
    }
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
    }
}
function resume_(stream, state) {
    if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    return this;
};
function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while(state.flowing && stream.read() !== null){}
}
// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    });
    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for(var i in stream){
        if (this[i] === undefined && typeof stream[i] === "function") {
            this[i] = function(method) {
                return function() {
                    return stream[method].apply(stream, arguments);
                };
            }(i);
        }
    }
    // proxy certain important events.
    for(var n = 0; n < kProxyEvents.length; n++){
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};
Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
        return this._readableState.highWaterMark;
    }
});
// exposed for testing purposes only.
Readable._fromList = fromList;
// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.head.data;
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else {
        // read part of list
        ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
}
// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
        // slice is the same for buffers and strings
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
        // first chunk is a perfect match
        ret = list.shift();
    } else {
        // result spans more than one buffer
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
}
// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while(p = p.next){
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;
        else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
            if (nb === str.length) {
                ++c;
                if (p.next) list.head = p.next;
                else list.head = list.tail = null;
            } else {
                list.head = p;
                p.data = str.slice(nb);
            }
            break;
        }
        ++c;
    }
    list.length -= c;
    return ret;
}
// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
    var ret = Buffer.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while(p = p.next){
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
            if (nb === buf.length) {
                ++c;
                if (p.next) list.head = p.next;
                else list.head = list.tail = null;
            } else {
                list.head = p;
                p.data = buf.slice(nb);
            }
            break;
        }
        ++c;
    }
    list.length -= c;
    return ret;
}
function endReadable(stream) {
    var state = stream._readableState;
    // If we get here before consuming all the bytes, then that is a
    // bug in node.  Should never happen.
    if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
    }
}
function indexOf(xs, x) {
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}


/***/ }),

/***/ 77641:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;
var Duplex = __webpack_require__(91837);
/*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ util.inherits(Transform, Duplex);
function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
    }
}
function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
    };
    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;
    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;
    if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
    }
    // When the writable side finishes, then flush out anything remaining.
    this.on("prefinish", prefinish);
}
function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
        this._flush(function(er, data) {
            done(_this, er, data);
        });
    } else {
        done(this, null, null);
    }
}
Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
};
// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
};
Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
};
// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
    }
};
Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
    });
};
function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null) stream.push(data);
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream.push(null);
}


/***/ }),

/***/ 59368:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

/*<replacement>*/ var pna = __webpack_require__(11210);
/*</replacement>*/ module.exports = Writable;
/* <replacement> */ function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
}
// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
        onCorkedFinish(_this, state);
    };
}
/* </replacement> */ /*<replacement>*/ var asyncWrite =  true && [
    "v0.10",
    "v0.9."
].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/ /*<replacement>*/ var Duplex;
/*</replacement>*/ Writable.WritableState = WritableState;
/*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ /*<replacement>*/ var internalUtil = {
    deprecate: __webpack_require__(62337)
};
/*</replacement>*/ /*<replacement>*/ var Stream = __webpack_require__(97618);
/*</replacement>*/ /*<replacement>*/ var Buffer = (__webpack_require__(6873).Buffer);
var OurUint8Array = (typeof global !== "undefined" ? global :  false ? 0 : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/ var destroyImpl = __webpack_require__(28837);
util.inherits(Writable, Stream);
function nop() {}
function WritableState(options, stream) {
    Duplex = Duplex || __webpack_require__(91837);
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    var isDuplex = stream instanceof Duplex;
    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    // cast to ints.
    this.highWaterMark = Math.floor(this.highWaterMark);
    // if _final has been called
    this.finalCalled = false;
    // drain event flag.
    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;
    // has it been destroyed
    this.destroyed = false;
    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;
    // a flag to see when we're in the middle of a write.
    this.writing = false;
    // when true all writes will be buffered until .uncork() call
    this.corked = 0;
    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;
    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;
    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function(er) {
        onwrite(stream, er);
    };
    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;
    // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;
    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;
    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;
    // count buffered requests
    this.bufferedRequestCount = 0;
    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while(current){
        out.push(current);
        current = current.next;
    }
    return out;
};
(function() {
    try {
        Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function() {
                return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
        });
    } catch (_) {}
})();
// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
        }
    });
} else {
    realHasInstance = function(object) {
        return object instanceof this;
    };
}
function Writable(options) {
    Duplex = Duplex || __webpack_require__(91837);
    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
}
// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
};
function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    // TODO: defer error events consistently everywhere, not just the cb
    stream.emit("error", er);
    pna.nextTick(cb, er);
}
// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
        er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
    }
    return valid;
}
Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
};
Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!([
        "hex",
        "utf8",
        "utf-8",
        "ascii",
        "binary",
        "base64",
        "ucs2",
        "ucs-2",
        "utf16le",
        "utf-16le",
        "raw"
    ].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer.from(chunk, encoding);
    }
    return chunk;
}
Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
        return this._writableState.highWaterMark;
    }
});
// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) {
            last.next = state.lastBufferedRequest;
        } else {
            state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
    } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        pna.nextTick(cb, er);
        // this can emit finish, and it will always happen
        // after error
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
    } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        // this can emit finish, but finish must
        // always follow error
        finishMaybe(stream, state);
    }
}
function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
        }
        if (sync) {
            /*<replacement>*/ asyncWrite(afterWrite, stream, state, finished, cb);
        /*</replacement>*/ } else {
            afterWrite(stream, state, finished, cb);
        }
    }
}
function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
}
// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
    }
}
// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while(entry){
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        } else {
            state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
    } else {
        // Slow case, write chunks one-by-one
        while(entry){
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) {
                break;
            }
        }
        if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
    // .end() fully uncorks
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    // ignore unnecessary end() calls.
    if (!state.ending) endWritable(this, state, cb);
};
function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
    stream._final(function(err) {
        state.pendingcb--;
        if (err) {
            stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
    });
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
            state.pendingcb++;
            state.finalCalled = true;
            pna.nextTick(callFinal, stream, state);
        } else {
            state.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
        }
    }
    return need;
}
function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
        if (state.finished) pna.nextTick(cb);
        else stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while(entry){
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
    }
    // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
        if (this._writableState === undefined) {
            return false;
        }
        return this._writableState.destroyed;
    },
    set: function(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._writableState.destroyed = value;
    }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
};


/***/ }),

/***/ 72176:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
var Buffer = (__webpack_require__(6873).Buffer);
var util = __webpack_require__(73837);
function copyBuffer(src, target, offset) {
    src.copy(target, offset);
}
module.exports = function() {
    function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
        var entry = {
            data: v,
            next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
        var entry = {
            data: v,
            next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
    };
    BufferList.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
    };
    BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
    };
    BufferList.prototype.join = function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while(p = p.next){
            ret += s + p.data;
        }
        return ret;
    };
    BufferList.prototype.concat = function concat(n) {
        if (this.length === 0) return Buffer.alloc(0);
        var ret = Buffer.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while(p){
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
        }
        return ret;
    };
    return BufferList;
}();
if (util && util.inspect && util.inspect.custom) {
    module.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({
            length: this.length
        });
        return this.constructor.name + " " + obj;
    };
}


/***/ }),

/***/ 28837:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*<replacement>*/ var pna = __webpack_require__(11210);
/*</replacement>*/ // undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) {
            cb(err);
        } else if (err) {
            if (!this._writableState) {
                pna.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                pna.nextTick(emitErrorNT, this, err);
            }
        }
        return this;
    }
    // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) {
        this._readableState.destroyed = true;
    }
    // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) {
        this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err) {
        if (!cb && err) {
            if (!_this._writableState) {
                pna.nextTick(emitErrorNT, _this, err);
            } else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                pna.nextTick(emitErrorNT, _this, err);
            }
        } else if (cb) {
            cb(err);
        }
    });
    return this;
}
function undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function emitErrorNT(self, err) {
    self.emit("error", err);
}
module.exports = {
    destroy: destroy,
    undestroy: undestroy
};


/***/ }),

/***/ 97618:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(12781);


/***/ }),

/***/ 83231:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

var Stream = __webpack_require__(12781);
if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream;
    exports = module.exports = Stream.Readable;
    exports.Readable = Stream.Readable;
    exports.Writable = Stream.Writable;
    exports.Duplex = Stream.Duplex;
    exports.Transform = Stream.Transform;
    exports.PassThrough = Stream.PassThrough;
    exports.Stream = Stream;
} else {
    exports = module.exports = __webpack_require__(40959);
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = __webpack_require__(59368);
    exports.Duplex = __webpack_require__(91837);
    exports.Transform = __webpack_require__(77641);
    exports.PassThrough = __webpack_require__(19782);
}


/***/ }),

/***/ 6873:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* eslint-disable node/no-deprecated-api */ 
var buffer = __webpack_require__(14300);
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src){
        dst[key] = src[key];
    }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
} else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
    }
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === "string") {
            buf.fill(fill, encoding);
        } else {
            buf.fill(fill);
        }
    } else {
        buf.fill(0);
    }
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
};


/***/ }),

/***/ 66884:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/ var Buffer = (__webpack_require__(6873).Buffer);
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch(encoding && encoding.toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while(true){
        switch(enc){
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return enc;
            default:
                if (retried) return; // undefined
                enc = ("" + enc).toLowerCase();
                retried = true;
        }
    }
}
;
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.s = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return "";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return "";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return "";
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "";
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}


/***/ }),

/***/ 75985:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Archiver Vending
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */ 
var Archiver = __webpack_require__(17507);
var formats = {};
/**
 * Dispenses a new Archiver instance.
 *
 * @constructor
 * @param  {String} format The archive format to use.
 * @param  {Object} options See [Archiver]{@link Archiver}
 * @return {Archiver}
 */ var vending = function(format, options) {
    return vending.create(format, options);
};
/**
 * Creates a new Archiver instance.
 *
 * @param  {String} format The archive format to use.
 * @param  {Object} options See [Archiver]{@link Archiver}
 * @return {Archiver}
 */ vending.create = function(format, options) {
    if (formats[format]) {
        var instance = new Archiver(format, options);
        instance.setFormat(format);
        instance.setModule(new formats[format](options));
        return instance;
    } else {
        throw new Error("create(" + format + "): format not registered");
    }
};
/**
 * Registers a format for use with archiver.
 *
 * @param  {String} format The name of the format.
 * @param  {Function} module The function for archiver to interact with.
 * @return void
 */ vending.registerFormat = function(format, module1) {
    if (formats[format]) {
        throw new Error("register(" + format + "): format already registered");
    }
    if (typeof module1 !== "function") {
        throw new Error("register(" + format + "): format module invalid");
    }
    if (typeof module1.prototype.append !== "function" || typeof module1.prototype.finalize !== "function") {
        throw new Error("register(" + format + "): format module missing methods");
    }
    formats[format] = module1;
};
/**
 * Check if the format is already registered.
 * 
 * @param {String} format the name of the format.
 * @return boolean
 */ vending.isRegisteredFormat = function(format) {
    if (formats[format]) {
        return true;
    }
    return false;
};
vending.registerFormat("zip", __webpack_require__(85896));
vending.registerFormat("tar", __webpack_require__(60513));
vending.registerFormat("json", __webpack_require__(57482));
module.exports = vending;


/***/ }),

/***/ 17507:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Archiver Core
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */ 
var fs = __webpack_require__(57147);
var glob = __webpack_require__(31413);
var async = __webpack_require__(77762);
var path = __webpack_require__(71017);
var util = __webpack_require__(62499);
var inherits = (__webpack_require__(73837).inherits);
var ArchiverError = __webpack_require__(96941);
var Transform = (__webpack_require__(98323).Transform);
var win32 = process.platform === "win32";
/**
 * @constructor
 * @param {String} format The archive format to use.
 * @param {(CoreOptions|TransformOptions)} options See also {@link ZipOptions} and {@link TarOptions}.
 */ var Archiver = function(format, options) {
    if (!(this instanceof Archiver)) {
        return new Archiver(format, options);
    }
    if (typeof format !== "string") {
        options = format;
        format = "zip";
    }
    options = this.options = util.defaults(options, {
        highWaterMark: 1024 * 1024,
        statConcurrency: 4
    });
    Transform.call(this, options);
    this._format = false;
    this._module = false;
    this._pending = 0;
    this._pointer = 0;
    this._entriesCount = 0;
    this._entriesProcessedCount = 0;
    this._fsEntriesTotalBytes = 0;
    this._fsEntriesProcessedBytes = 0;
    this._queue = async.queue(this._onQueueTask.bind(this), 1);
    this._queue.drain(this._onQueueDrain.bind(this));
    this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);
    this._statQueue.drain(this._onQueueDrain.bind(this));
    this._state = {
        aborted: false,
        finalize: false,
        finalizing: false,
        finalized: false,
        modulePiped: false
    };
    this._streams = [];
};
inherits(Archiver, Transform);
/**
 * Internal logic for `abort`.
 *
 * @private
 * @return void
 */ Archiver.prototype._abort = function() {
    this._state.aborted = true;
    this._queue.kill();
    this._statQueue.kill();
    if (this._queue.idle()) {
        this._shutdown();
    }
};
/**
 * Internal helper for appending files.
 *
 * @private
 * @param  {String} filepath The source filepath.
 * @param  {EntryData} data The entry data.
 * @return void
 */ Archiver.prototype._append = function(filepath, data) {
    data = data || {};
    var task = {
        source: null,
        filepath: filepath
    };
    if (!data.name) {
        data.name = filepath;
    }
    data.sourcePath = filepath;
    task.data = data;
    this._entriesCount++;
    if (data.stats && data.stats instanceof fs.Stats) {
        task = this._updateQueueTaskWithStats(task, data.stats);
        if (task) {
            if (data.stats.size) {
                this._fsEntriesTotalBytes += data.stats.size;
            }
            this._queue.push(task);
        }
    } else {
        this._statQueue.push(task);
    }
};
/**
 * Internal logic for `finalize`.
 *
 * @private
 * @return void
 */ Archiver.prototype._finalize = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        return;
    }
    this._state.finalizing = true;
    this._moduleFinalize();
    this._state.finalizing = false;
    this._state.finalized = true;
};
/**
 * Checks the various state variables to determine if we can `finalize`.
 *
 * @private
 * @return {Boolean}
 */ Archiver.prototype._maybeFinalize = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        return false;
    }
    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
        this._finalize();
        return true;
    }
    return false;
};
/**
 * Appends an entry to the module.
 *
 * @private
 * @fires  Archiver#entry
 * @param  {(Buffer|Stream)} source
 * @param  {EntryData} data
 * @param  {Function} callback
 * @return void
 */ Archiver.prototype._moduleAppend = function(source, data, callback) {
    if (this._state.aborted) {
        callback();
        return;
    }
    this._module.append(source, data, (function(err) {
        this._task = null;
        if (this._state.aborted) {
            this._shutdown();
            return;
        }
        if (err) {
            this.emit("error", err);
            setImmediate(callback);
            return;
        }
        /**
     * Fires when the entry's input has been processed and appended to the archive.
     *
     * @event Archiver#entry
     * @type {EntryData}
     */ this.emit("entry", data);
        this._entriesProcessedCount++;
        if (data.stats && data.stats.size) {
            this._fsEntriesProcessedBytes += data.stats.size;
        }
        /**
     * @event Archiver#progress
     * @type {ProgressData}
     */ this.emit("progress", {
            entries: {
                total: this._entriesCount,
                processed: this._entriesProcessedCount
            },
            fs: {
                totalBytes: this._fsEntriesTotalBytes,
                processedBytes: this._fsEntriesProcessedBytes
            }
        });
        setImmediate(callback);
    }).bind(this));
};
/**
 * Finalizes the module.
 *
 * @private
 * @return void
 */ Archiver.prototype._moduleFinalize = function() {
    if (typeof this._module.finalize === "function") {
        this._module.finalize();
    } else if (typeof this._module.end === "function") {
        this._module.end();
    } else {
        this.emit("error", new ArchiverError("NOENDMETHOD"));
    }
};
/**
 * Pipes the module to our internal stream with error bubbling.
 *
 * @private
 * @return void
 */ Archiver.prototype._modulePipe = function() {
    this._module.on("error", this._onModuleError.bind(this));
    this._module.pipe(this);
    this._state.modulePiped = true;
};
/**
 * Determines if the current module supports a defined feature.
 *
 * @private
 * @param  {String} key
 * @return {Boolean}
 */ Archiver.prototype._moduleSupports = function(key) {
    if (!this._module.supports || !this._module.supports[key]) {
        return false;
    }
    return this._module.supports[key];
};
/**
 * Unpipes the module from our internal stream.
 *
 * @private
 * @return void
 */ Archiver.prototype._moduleUnpipe = function() {
    this._module.unpipe(this);
    this._state.modulePiped = false;
};
/**
 * Normalizes entry data with fallbacks for key properties.
 *
 * @private
 * @param  {Object} data
 * @param  {fs.Stats} stats
 * @return {Object}
 */ Archiver.prototype._normalizeEntryData = function(data, stats) {
    data = util.defaults(data, {
        type: "file",
        name: null,
        date: null,
        mode: null,
        prefix: null,
        sourcePath: null,
        stats: false
    });
    if (stats && data.stats === false) {
        data.stats = stats;
    }
    var isDir = data.type === "directory";
    if (data.name) {
        if (typeof data.prefix === "string" && "" !== data.prefix) {
            data.name = data.prefix + "/" + data.name;
            data.prefix = null;
        }
        data.name = util.sanitizePath(data.name);
        if (data.type !== "symlink" && data.name.slice(-1) === "/") {
            isDir = true;
            data.type = "directory";
        } else if (isDir) {
            data.name += "/";
        }
    }
    // 511 === 0777; 493 === 0755; 438 === 0666; 420 === 0644
    if (typeof data.mode === "number") {
        if (win32) {
            data.mode &= 511;
        } else {
            data.mode &= 4095;
        }
    } else if (data.stats && data.mode === null) {
        if (win32) {
            data.mode = data.stats.mode & 511;
        } else {
            data.mode = data.stats.mode & 4095;
        }
        // stat isn't reliable on windows; force 0755 for dir
        if (win32 && isDir) {
            data.mode = 493;
        }
    } else if (data.mode === null) {
        data.mode = isDir ? 493 : 420;
    }
    if (data.stats && data.date === null) {
        data.date = data.stats.mtime;
    } else {
        data.date = util.dateify(data.date);
    }
    return data;
};
/**
 * Error listener that re-emits error on to our internal stream.
 *
 * @private
 * @param  {Error} err
 * @return void
 */ Archiver.prototype._onModuleError = function(err) {
    /**
   * @event Archiver#error
   * @type {ErrorData}
   */ this.emit("error", err);
};
/**
 * Checks the various state variables after queue has drained to determine if
 * we need to `finalize`.
 *
 * @private
 * @return void
 */ Archiver.prototype._onQueueDrain = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        return;
    }
    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
        this._finalize();
    }
};
/**
 * Appends each queue task to the module.
 *
 * @private
 * @param  {Object} task
 * @param  {Function} callback
 * @return void
 */ Archiver.prototype._onQueueTask = function(task, callback) {
    var fullCallback = ()=>{
        if (task.data.callback) {
            task.data.callback();
        }
        callback();
    };
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        fullCallback();
        return;
    }
    this._task = task;
    this._moduleAppend(task.source, task.data, fullCallback);
};
/**
 * Performs a file stat and reinjects the task back into the queue.
 *
 * @private
 * @param  {Object} task
 * @param  {Function} callback
 * @return void
 */ Archiver.prototype._onStatQueueTask = function(task, callback) {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        callback();
        return;
    }
    fs.lstat(task.filepath, (function(err, stats) {
        if (this._state.aborted) {
            setImmediate(callback);
            return;
        }
        if (err) {
            this._entriesCount--;
            /**
       * @event Archiver#warning
       * @type {ErrorData}
       */ this.emit("warning", err);
            setImmediate(callback);
            return;
        }
        task = this._updateQueueTaskWithStats(task, stats);
        if (task) {
            if (stats.size) {
                this._fsEntriesTotalBytes += stats.size;
            }
            this._queue.push(task);
        }
        setImmediate(callback);
    }).bind(this));
};
/**
 * Unpipes the module and ends our internal stream.
 *
 * @private
 * @return void
 */ Archiver.prototype._shutdown = function() {
    this._moduleUnpipe();
    this.end();
};
/**
 * Tracks the bytes emitted by our internal stream.
 *
 * @private
 * @param  {Buffer} chunk
 * @param  {String} encoding
 * @param  {Function} callback
 * @return void
 */ Archiver.prototype._transform = function(chunk, encoding, callback) {
    if (chunk) {
        this._pointer += chunk.length;
    }
    callback(null, chunk);
};
/**
 * Updates and normalizes a queue task using stats data.
 *
 * @private
 * @param  {Object} task
 * @param  {fs.Stats} stats
 * @return {Object}
 */ Archiver.prototype._updateQueueTaskWithStats = function(task, stats) {
    if (stats.isFile()) {
        task.data.type = "file";
        task.data.sourceType = "stream";
        task.source = util.lazyReadStream(task.filepath);
    } else if (stats.isDirectory() && this._moduleSupports("directory")) {
        task.data.name = util.trailingSlashIt(task.data.name);
        task.data.type = "directory";
        task.data.sourcePath = util.trailingSlashIt(task.filepath);
        task.data.sourceType = "buffer";
        task.source = Buffer.concat([]);
    } else if (stats.isSymbolicLink() && this._moduleSupports("symlink")) {
        var linkPath = fs.readlinkSync(task.filepath);
        var dirName = path.dirname(task.filepath);
        task.data.type = "symlink";
        task.data.linkname = path.relative(dirName, path.resolve(dirName, linkPath));
        task.data.sourceType = "buffer";
        task.source = Buffer.concat([]);
    } else {
        if (stats.isDirectory()) {
            this.emit("warning", new ArchiverError("DIRECTORYNOTSUPPORTED", task.data));
        } else if (stats.isSymbolicLink()) {
            this.emit("warning", new ArchiverError("SYMLINKNOTSUPPORTED", task.data));
        } else {
            this.emit("warning", new ArchiverError("ENTRYNOTSUPPORTED", task.data));
        }
        return null;
    }
    task.data = this._normalizeEntryData(task.data, stats);
    return task;
};
/**
 * Aborts the archiving process, taking a best-effort approach, by:
 *
 * - removing any pending queue tasks
 * - allowing any active queue workers to finish
 * - detaching internal module pipes
 * - ending both sides of the Transform stream
 *
 * It will NOT drain any remaining sources.
 *
 * @return {this}
 */ Archiver.prototype.abort = function() {
    if (this._state.aborted || this._state.finalized) {
        return this;
    }
    this._abort();
    return this;
};
/**
 * Appends an input source (text string, buffer, or stream) to the instance.
 *
 * When the instance has received, processed, and emitted the input, the `entry`
 * event is fired.
 *
 * @fires  Archiver#entry
 * @param  {(Buffer|Stream|String)} source The input source.
 * @param  {EntryData} data See also {@link ZipEntryData} and {@link TarEntryData}.
 * @return {this}
 */ Archiver.prototype.append = function(source, data) {
    if (this._state.finalize || this._state.aborted) {
        this.emit("error", new ArchiverError("QUEUECLOSED"));
        return this;
    }
    data = this._normalizeEntryData(data);
    if (typeof data.name !== "string" || data.name.length === 0) {
        this.emit("error", new ArchiverError("ENTRYNAMEREQUIRED"));
        return this;
    }
    if (data.type === "directory" && !this._moduleSupports("directory")) {
        this.emit("error", new ArchiverError("DIRECTORYNOTSUPPORTED", {
            name: data.name
        }));
        return this;
    }
    source = util.normalizeInputSource(source);
    if (Buffer.isBuffer(source)) {
        data.sourceType = "buffer";
    } else if (util.isStream(source)) {
        data.sourceType = "stream";
    } else {
        this.emit("error", new ArchiverError("INPUTSTEAMBUFFERREQUIRED", {
            name: data.name
        }));
        return this;
    }
    this._entriesCount++;
    this._queue.push({
        data: data,
        source: source
    });
    return this;
};
/**
 * Appends a directory and its files, recursively, given its dirpath.
 *
 * @param  {String} dirpath The source directory path.
 * @param  {String} destpath The destination path within the archive.
 * @param  {(EntryData|Function)} data See also [ZipEntryData]{@link ZipEntryData} and
 * [TarEntryData]{@link TarEntryData}.
 * @return {this}
 */ Archiver.prototype.directory = function(dirpath, destpath, data) {
    if (this._state.finalize || this._state.aborted) {
        this.emit("error", new ArchiverError("QUEUECLOSED"));
        return this;
    }
    if (typeof dirpath !== "string" || dirpath.length === 0) {
        this.emit("error", new ArchiverError("DIRECTORYDIRPATHREQUIRED"));
        return this;
    }
    this._pending++;
    if (destpath === false) {
        destpath = "";
    } else if (typeof destpath !== "string") {
        destpath = dirpath;
    }
    var dataFunction = false;
    if (typeof data === "function") {
        dataFunction = data;
        data = {};
    } else if (typeof data !== "object") {
        data = {};
    }
    var globOptions = {
        stat: true,
        dot: true
    };
    function onGlobEnd() {
        this._pending--;
        this._maybeFinalize();
    }
    function onGlobError(err) {
        this.emit("error", err);
    }
    function onGlobMatch(match) {
        globber.pause();
        var ignoreMatch = false;
        var entryData = Object.assign({}, data);
        entryData.name = match.relative;
        entryData.prefix = destpath;
        entryData.stats = match.stat;
        entryData.callback = globber.resume.bind(globber);
        try {
            if (dataFunction) {
                entryData = dataFunction(entryData);
                if (entryData === false) {
                    ignoreMatch = true;
                } else if (typeof entryData !== "object") {
                    throw new ArchiverError("DIRECTORYFUNCTIONINVALIDDATA", {
                        dirpath: dirpath
                    });
                }
            }
        } catch (e) {
            this.emit("error", e);
            return;
        }
        if (ignoreMatch) {
            globber.resume();
            return;
        }
        this._append(match.absolute, entryData);
    }
    var globber = glob(dirpath, globOptions);
    globber.on("error", onGlobError.bind(this));
    globber.on("match", onGlobMatch.bind(this));
    globber.on("end", onGlobEnd.bind(this));
    return this;
};
/**
 * Appends a file given its filepath using a
 * [lazystream]{@link https://github.com/jpommerening/node-lazystream} wrapper to
 * prevent issues with open file limits.
 *
 * When the instance has received, processed, and emitted the file, the `entry`
 * event is fired.
 *
 * @param  {String} filepath The source filepath.
 * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and
 * [TarEntryData]{@link TarEntryData}.
 * @return {this}
 */ Archiver.prototype.file = function(filepath, data) {
    if (this._state.finalize || this._state.aborted) {
        this.emit("error", new ArchiverError("QUEUECLOSED"));
        return this;
    }
    if (typeof filepath !== "string" || filepath.length === 0) {
        this.emit("error", new ArchiverError("FILEFILEPATHREQUIRED"));
        return this;
    }
    this._append(filepath, data);
    return this;
};
/**
 * Appends multiple files that match a glob pattern.
 *
 * @param  {String} pattern The [glob pattern]{@link https://github.com/isaacs/minimatch} to match.
 * @param  {Object} options See [node-readdir-glob]{@link https://github.com/yqnn/node-readdir-glob#options}.
 * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and
 * [TarEntryData]{@link TarEntryData}.
 * @return {this}
 */ Archiver.prototype.glob = function(pattern, options, data) {
    this._pending++;
    options = util.defaults(options, {
        stat: true,
        pattern: pattern
    });
    function onGlobEnd() {
        this._pending--;
        this._maybeFinalize();
    }
    function onGlobError(err) {
        this.emit("error", err);
    }
    function onGlobMatch(match) {
        globber.pause();
        var entryData = Object.assign({}, data);
        entryData.callback = globber.resume.bind(globber);
        entryData.stats = match.stat;
        entryData.name = match.relative;
        this._append(match.absolute, entryData);
    }
    var globber = glob(options.cwd || ".", options);
    globber.on("error", onGlobError.bind(this));
    globber.on("match", onGlobMatch.bind(this));
    globber.on("end", onGlobEnd.bind(this));
    return this;
};
/**
 * Finalizes the instance and prevents further appending to the archive
 * structure (queue will continue til drained).
 *
 * The `end`, `close` or `finish` events on the destination stream may fire
 * right after calling this method so you should set listeners beforehand to
 * properly detect stream completion.
 *
 * @return {Promise}
 */ Archiver.prototype.finalize = function() {
    if (this._state.aborted) {
        var abortedError = new ArchiverError("ABORTED");
        this.emit("error", abortedError);
        return Promise.reject(abortedError);
    }
    if (this._state.finalize) {
        var finalizingError = new ArchiverError("FINALIZING");
        this.emit("error", finalizingError);
        return Promise.reject(finalizingError);
    }
    this._state.finalize = true;
    if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
        this._finalize();
    }
    var self = this;
    return new Promise(function(resolve, reject) {
        var errored;
        self._module.on("end", function() {
            if (!errored) {
                resolve();
            }
        });
        self._module.on("error", function(err) {
            errored = true;
            reject(err);
        });
    });
};
/**
 * Sets the module format name used for archiving.
 *
 * @param {String} format The name of the format.
 * @return {this}
 */ Archiver.prototype.setFormat = function(format) {
    if (this._format) {
        this.emit("error", new ArchiverError("FORMATSET"));
        return this;
    }
    this._format = format;
    return this;
};
/**
 * Sets the module used for archiving.
 *
 * @param {Function} module The function for archiver to interact with.
 * @return {this}
 */ Archiver.prototype.setModule = function(module1) {
    if (this._state.aborted) {
        this.emit("error", new ArchiverError("ABORTED"));
        return this;
    }
    if (this._state.module) {
        this.emit("error", new ArchiverError("MODULESET"));
        return this;
    }
    this._module = module1;
    this._modulePipe();
    return this;
};
/**
 * Appends a symlink to the instance.
 *
 * This does NOT interact with filesystem and is used for programmatically creating symlinks.
 *
 * @param  {String} filepath The symlink path (within archive).
 * @param  {String} target The target path (within archive).
 * @param  {Number} mode Sets the entry permissions.
 * @return {this}
 */ Archiver.prototype.symlink = function(filepath, target, mode) {
    if (this._state.finalize || this._state.aborted) {
        this.emit("error", new ArchiverError("QUEUECLOSED"));
        return this;
    }
    if (typeof filepath !== "string" || filepath.length === 0) {
        this.emit("error", new ArchiverError("SYMLINKFILEPATHREQUIRED"));
        return this;
    }
    if (typeof target !== "string" || target.length === 0) {
        this.emit("error", new ArchiverError("SYMLINKTARGETREQUIRED", {
            filepath: filepath
        }));
        return this;
    }
    if (!this._moduleSupports("symlink")) {
        this.emit("error", new ArchiverError("SYMLINKNOTSUPPORTED", {
            filepath: filepath
        }));
        return this;
    }
    var data = {};
    data.type = "symlink";
    data.name = filepath.replace(/\\/g, "/");
    data.linkname = target.replace(/\\/g, "/");
    data.sourceType = "buffer";
    if (typeof mode === "number") {
        data.mode = mode;
    }
    this._entriesCount++;
    this._queue.push({
        data: data,
        source: Buffer.concat([])
    });
    return this;
};
/**
 * Returns the current length (in bytes) that has been emitted.
 *
 * @return {Number}
 */ Archiver.prototype.pointer = function() {
    return this._pointer;
};
/**
 * Middleware-like helper that has yet to be fully implemented.
 *
 * @private
 * @param  {Function} plugin
 * @return {this}
 */ Archiver.prototype.use = function(plugin) {
    this._streams.push(plugin);
    return this;
};
module.exports = Archiver; /**
 * @typedef {Object} CoreOptions
 * @global
 * @property {Number} [statConcurrency=4] Sets the number of workers used to
 * process the internal fs stat queue.
 */  /**
 * @typedef {Object} TransformOptions
 * @property {Boolean} [allowHalfOpen=true] If set to false, then the stream
 * will automatically end the readable side when the writable side ends and vice
 * versa.
 * @property {Boolean} [readableObjectMode=false] Sets objectMode for readable
 * side of the stream. Has no effect if objectMode is true.
 * @property {Boolean} [writableObjectMode=false] Sets objectMode for writable
 * side of the stream. Has no effect if objectMode is true.
 * @property {Boolean} [decodeStrings=true] Whether or not to decode strings
 * into Buffers before passing them to _write(). `Writable`
 * @property {String} [encoding=NULL] If specified, then buffers will be decoded
 * to strings using the specified encoding. `Readable`
 * @property {Number} [highWaterMark=16kb] The maximum number of bytes to store
 * in the internal buffer before ceasing to read from the underlying resource.
 * `Readable` `Writable`
 * @property {Boolean} [objectMode=false] Whether this stream should behave as a
 * stream of objects. Meaning that stream.read(n) returns a single value instead
 * of a Buffer of size n. `Readable` `Writable`
 */  /**
 * @typedef {Object} EntryData
 * @property {String} name Sets the entry name including internal path.
 * @property {(String|Date)} [date=NOW()] Sets the entry date.
 * @property {Number} [mode=D:0755/F:0644] Sets the entry permissions.
 * @property {String} [prefix] Sets a path prefix for the entry name. Useful
 * when working with methods like `directory` or `glob`.
 * @property {fs.Stats} [stats] Sets the fs stat data for this entry allowing
 * for reduction of fs stat calls when stat data is already known.
 */  /**
 * @typedef {Object} ErrorData
 * @property {String} message The message of the error.
 * @property {String} code The error code assigned to this error.
 * @property {String} data Additional data provided for reporting or debugging (where available).
 */  /**
 * @typedef {Object} ProgressData
 * @property {Object} entries
 * @property {Number} entries.total Number of entries that have been appended.
 * @property {Number} entries.processed Number of entries that have been processed.
 * @property {Object} fs
 * @property {Number} fs.totalBytes Number of bytes that have been appended. Calculated asynchronously and might not be accurate: it growth while entries are added. (based on fs.Stats)
 * @property {Number} fs.processedBytes Number of bytes that have been processed. (based on fs.Stats)
 */ 


/***/ }),

/***/ 96941:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/**
 * Archiver Core
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */ 
var util = __webpack_require__(73837);
const ERROR_CODES = {
    "ABORTED": "archive was aborted",
    "DIRECTORYDIRPATHREQUIRED": "diretory dirpath argument must be a non-empty string value",
    "DIRECTORYFUNCTIONINVALIDDATA": "invalid data returned by directory custom data function",
    "ENTRYNAMEREQUIRED": "entry name must be a non-empty string value",
    "FILEFILEPATHREQUIRED": "file filepath argument must be a non-empty string value",
    "FINALIZING": "archive already finalizing",
    "QUEUECLOSED": "queue closed",
    "NOENDMETHOD": "no suitable finalize/end method defined by module",
    "DIRECTORYNOTSUPPORTED": "support for directory entries not defined by module",
    "FORMATSET": "archive format already set",
    "INPUTSTEAMBUFFERREQUIRED": "input source must be valid Stream or Buffer instance",
    "MODULESET": "module already set",
    "SYMLINKNOTSUPPORTED": "support for symlink entries not defined by module",
    "SYMLINKFILEPATHREQUIRED": "symlink filepath argument must be a non-empty string value",
    "SYMLINKTARGETREQUIRED": "symlink target argument must be a non-empty string value",
    "ENTRYNOTSUPPORTED": "entry not supported"
};
function ArchiverError(code, data) {
    Error.captureStackTrace(this, this.constructor);
    //this.name = this.constructor.name;
    this.message = ERROR_CODES[code] || code;
    this.code = code;
    this.data = data;
}
util.inherits(ArchiverError, Error);
exports = module.exports = ArchiverError;


/***/ }),

/***/ 57482:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * JSON Format Plugin
 *
 * @module plugins/json
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */ 
var inherits = (__webpack_require__(73837).inherits);
var Transform = (__webpack_require__(98323).Transform);
var crc32 = __webpack_require__(78177);
var util = __webpack_require__(62499);
/**
 * @constructor
 * @param {(JsonOptions|TransformOptions)} options
 */ var Json = function(options) {
    if (!(this instanceof Json)) {
        return new Json(options);
    }
    options = this.options = util.defaults(options, {});
    Transform.call(this, options);
    this.supports = {
        directory: true,
        symlink: true
    };
    this.files = [];
};
inherits(Json, Transform);
/**
 * [_transform description]
 *
 * @private
 * @param  {Buffer}   chunk
 * @param  {String}   encoding
 * @param  {Function} callback
 * @return void
 */ Json.prototype._transform = function(chunk, encoding, callback) {
    callback(null, chunk);
};
/**
 * [_writeStringified description]
 *
 * @private
 * @return void
 */ Json.prototype._writeStringified = function() {
    var fileString = JSON.stringify(this.files);
    this.write(fileString);
};
/**
 * [append description]
 *
 * @param  {(Buffer|Stream)}   source
 * @param  {EntryData}   data
 * @param  {Function} callback
 * @return void
 */ Json.prototype.append = function(source, data, callback) {
    var self = this;
    data.crc32 = 0;
    function onend(err, sourceBuffer) {
        if (err) {
            callback(err);
            return;
        }
        data.size = sourceBuffer.length || 0;
        data.crc32 = crc32.unsigned(sourceBuffer);
        self.files.push(data);
        callback(null, data);
    }
    if (data.sourceType === "buffer") {
        onend(null, source);
    } else if (data.sourceType === "stream") {
        util.collectStream(source, onend);
    }
};
/**
 * [finalize description]
 *
 * @return void
 */ Json.prototype.finalize = function() {
    this._writeStringified();
    this.end();
};
module.exports = Json; /**
 * @typedef {Object} JsonOptions
 * @global
 */ 


/***/ }),

/***/ 60513:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * TAR Format Plugin
 *
 * @module plugins/tar
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */ 
var zlib = __webpack_require__(59796);
var engine = __webpack_require__(71202);
var util = __webpack_require__(62499);
/**
 * @constructor
 * @param {TarOptions} options
 */ var Tar = function(options) {
    if (!(this instanceof Tar)) {
        return new Tar(options);
    }
    options = this.options = util.defaults(options, {
        gzip: false
    });
    if (typeof options.gzipOptions !== "object") {
        options.gzipOptions = {};
    }
    this.supports = {
        directory: true,
        symlink: true
    };
    this.engine = engine.pack(options);
    this.compressor = false;
    if (options.gzip) {
        this.compressor = zlib.createGzip(options.gzipOptions);
        this.compressor.on("error", this._onCompressorError.bind(this));
    }
};
/**
 * [_onCompressorError description]
 *
 * @private
 * @param  {Error} err
 * @return void
 */ Tar.prototype._onCompressorError = function(err) {
    this.engine.emit("error", err);
};
/**
 * [append description]
 *
 * @param  {(Buffer|Stream)} source
 * @param  {TarEntryData} data
 * @param  {Function} callback
 * @return void
 */ Tar.prototype.append = function(source, data, callback) {
    var self = this;
    data.mtime = data.date;
    function append(err, sourceBuffer) {
        if (err) {
            callback(err);
            return;
        }
        self.engine.entry(data, sourceBuffer, function(err) {
            callback(err, data);
        });
    }
    if (data.sourceType === "buffer") {
        append(null, source);
    } else if (data.sourceType === "stream" && data.stats) {
        data.size = data.stats.size;
        var entry = self.engine.entry(data, function(err) {
            callback(err, data);
        });
        source.pipe(entry);
    } else if (data.sourceType === "stream") {
        util.collectStream(source, append);
    }
};
/**
 * [finalize description]
 *
 * @return void
 */ Tar.prototype.finalize = function() {
    this.engine.finalize();
};
/**
 * [on description]
 *
 * @return this.engine
 */ Tar.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
};
/**
 * [pipe description]
 *
 * @param  {String} destination
 * @param  {Object} options
 * @return this.engine
 */ Tar.prototype.pipe = function(destination, options) {
    if (this.compressor) {
        return this.engine.pipe.apply(this.engine, [
            this.compressor
        ]).pipe(destination, options);
    } else {
        return this.engine.pipe.apply(this.engine, arguments);
    }
};
/**
 * [unpipe description]
 *
 * @return this.engine
 */ Tar.prototype.unpipe = function() {
    if (this.compressor) {
        return this.compressor.unpipe.apply(this.compressor, arguments);
    } else {
        return this.engine.unpipe.apply(this.engine, arguments);
    }
};
module.exports = Tar; /**
 * @typedef {Object} TarOptions
 * @global
 * @property {Boolean} [gzip=false] Compress the tar archive using gzip.
 * @property {Object} [gzipOptions] Passed to [zlib]{@link https://nodejs.org/api/zlib.html#zlib_class_options}
 * to control compression.
 * @property {*} [*] See [tar-stream]{@link https://github.com/mafintosh/tar-stream} documentation for additional properties.
 */  /**
 * @typedef {Object} TarEntryData
 * @global
 * @property {String} name Sets the entry name including internal path.
 * @property {(String|Date)} [date=NOW()] Sets the entry date.
 * @property {Number} [mode=D:0755/F:0644] Sets the entry permissions.
 * @property {String} [prefix] Sets a path prefix for the entry name. Useful
 * when working with methods like `directory` or `glob`.
 * @property {fs.Stats} [stats] Sets the fs stat data for this entry allowing
 * for reduction of fs stat calls when stat data is already known.
 */  /**
 * TarStream Module
 * @external TarStream
 * @see {@link https://github.com/mafintosh/tar-stream}
 */ 


/***/ }),

/***/ 85896:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * ZIP Format Plugin
 *
 * @module plugins/zip
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */ 
var engine = __webpack_require__(78295);
var util = __webpack_require__(62499);
/**
 * @constructor
 * @param {ZipOptions} [options]
 * @param {String} [options.comment] Sets the zip archive comment.
 * @param {Boolean} [options.forceLocalTime=false] Forces the archive to contain local file times instead of UTC.
 * @param {Boolean} [options.forceZip64=false] Forces the archive to contain ZIP64 headers.
 * @param {Boolean} [options.namePrependSlash=false] Prepends a forward slash to archive file paths.
 * @param {Boolean} [options.store=false] Sets the compression method to STORE.
 * @param {Object} [options.zlib] Passed to [zlib]{@link https://nodejs.org/api/zlib.html#zlib_class_options}
 */ var Zip = function(options) {
    if (!(this instanceof Zip)) {
        return new Zip(options);
    }
    options = this.options = util.defaults(options, {
        comment: "",
        forceUTC: false,
        namePrependSlash: false,
        store: false
    });
    this.supports = {
        directory: true,
        symlink: true
    };
    this.engine = new engine(options);
};
/**
 * @param  {(Buffer|Stream)} source
 * @param  {ZipEntryData} data
 * @param  {String} data.name Sets the entry name including internal path.
 * @param  {(String|Date)} [data.date=NOW()] Sets the entry date.
 * @param  {Number} [data.mode=D:0755/F:0644] Sets the entry permissions.
 * @param  {String} [data.prefix] Sets a path prefix for the entry name. Useful
 * when working with methods like `directory` or `glob`.
 * @param  {fs.Stats} [data.stats] Sets the fs stat data for this entry allowing
 * for reduction of fs stat calls when stat data is already known.
 * @param  {Boolean} [data.store=ZipOptions.store] Sets the compression method to STORE.
 * @param  {Function} callback
 * @return void
 */ Zip.prototype.append = function(source, data, callback) {
    this.engine.entry(source, data, callback);
};
/**
 * @return void
 */ Zip.prototype.finalize = function() {
    this.engine.finalize();
};
/**
 * @return this.engine
 */ Zip.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
};
/**
 * @return this.engine
 */ Zip.prototype.pipe = function() {
    return this.engine.pipe.apply(this.engine, arguments);
};
/**
 * @return this.engine
 */ Zip.prototype.unpipe = function() {
    return this.engine.unpipe.apply(this.engine, arguments);
};
module.exports = Zip; /**
 * @typedef {Object} ZipOptions
 * @global
 * @property {String} [comment] Sets the zip archive comment.
 * @property {Boolean} [forceLocalTime=false] Forces the archive to contain local file times instead of UTC.
 * @property {Boolean} [forceZip64=false] Forces the archive to contain ZIP64 headers.
 * @prpperty {Boolean} [namePrependSlash=false] Prepends a forward slash to archive file paths.
 * @property {Boolean} [store=false] Sets the compression method to STORE.
 * @property {Object} [zlib] Passed to [zlib]{@link https://nodejs.org/api/zlib.html#zlib_class_options}
 * to control compression.
 * @property {*} [*] See [zip-stream]{@link https://archiverjs.com/zip-stream/ZipStream.html} documentation for current list of properties.
 */  /**
 * @typedef {Object} ZipEntryData
 * @global
 * @property {String} name Sets the entry name including internal path.
 * @property {(String|Date)} [date=NOW()] Sets the entry date.
 * @property {Number} [mode=D:0755/F:0644] Sets the entry permissions.
 * @property {Boolean} [namePrependSlash=ZipOptions.namePrependSlash] Prepends a forward slash to archive file paths.
 * @property {String} [prefix] Sets a path prefix for the entry name. Useful
 * when working with methods like `directory` or `glob`.
 * @property {fs.Stats} [stats] Sets the fs stat data for this entry allowing
 * for reduction of fs stat calls when stat data is already known.
 * @property {Boolean} [store=ZipOptions.store] Sets the compression method to STORE.
 */  /**
 * ZipStream Module
 * @external ZipStream
 * @see {@link https://www.archiverjs.com/zip-stream/ZipStream.html}
 */ 


/***/ }),

/***/ 77762:
/***/ (function(__unused_webpack_module, exports) {

(function(global, factory) {
     true ? factory(exports) : 0;
})(this, function(exports1) {
    "use strict";
    /**
     * Creates a continuation function with some arguments already applied.
     *
     * Useful as a shorthand when combined with other control flow functions. Any
     * arguments passed to the returned function are added to the arguments
     * originally passed to apply.
     *
     * @name apply
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {Function} fn - The function you want to eventually apply all
     * arguments to. Invokes with (arguments...).
     * @param {...*} arguments... - Any number of arguments to automatically apply
     * when the continuation is called.
     * @returns {Function} the partially-applied function
     * @example
     *
     * // using apply
     * async.parallel([
     *     async.apply(fs.writeFile, 'testfile1', 'test1'),
     *     async.apply(fs.writeFile, 'testfile2', 'test2')
     * ]);
     *
     *
     * // the same process without using apply
     * async.parallel([
     *     function(callback) {
     *         fs.writeFile('testfile1', 'test1', callback);
     *     },
     *     function(callback) {
     *         fs.writeFile('testfile2', 'test2', callback);
     *     }
     * ]);
     *
     * // It's possible to pass any number of additional arguments when calling the
     * // continuation:
     *
     * node> var fn = async.apply(sys.puts, 'one');
     * node> fn('two', 'three');
     * one
     * two
     * three
     */ function apply(fn, ...args) {
        return (...callArgs)=>fn(...args, ...callArgs);
    }
    function initialParams(fn) {
        return function(...args /*, callback*/ ) {
            var callback = args.pop();
            return fn.call(this, args, callback);
        };
    }
    /* istanbul ignore file */ var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
    var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
        setTimeout(fn, 0);
    }
    function wrap(defer) {
        return (fn, ...args)=>defer(()=>fn(...args));
    }
    var _defer$1;
    if (hasQueueMicrotask) {
        _defer$1 = queueMicrotask;
    } else if (hasSetImmediate) {
        _defer$1 = setImmediate;
    } else if (hasNextTick) {
        _defer$1 = process.nextTick;
    } else {
        _defer$1 = fallback;
    }
    var setImmediate$1 = wrap(_defer$1);
    /**
     * Take a sync function and make it async, passing its return value to a
     * callback. This is useful for plugging sync functions into a waterfall,
     * series, or other async functions. Any arguments passed to the generated
     * function will be passed to the wrapped function (except for the final
     * callback argument). Errors thrown will be passed to the callback.
     *
     * If the function passed to `asyncify` returns a Promise, that promises's
     * resolved/rejected state will be used to call the callback, rather than simply
     * the synchronous return value.
     *
     * This also means you can asyncify ES2017 `async` functions.
     *
     * @name asyncify
     * @static
     * @memberOf module:Utils
     * @method
     * @alias wrapSync
     * @category Util
     * @param {Function} func - The synchronous function, or Promise-returning
     * function to convert to an {@link AsyncFunction}.
     * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
     * invoked with `(args..., callback)`.
     * @example
     *
     * // passing a regular synchronous function
     * async.waterfall([
     *     async.apply(fs.readFile, filename, "utf8"),
     *     async.asyncify(JSON.parse),
     *     function (data, next) {
     *         // data is the result of parsing the text.
     *         // If there was a parsing error, it would have been caught.
     *     }
     * ], callback);
     *
     * // passing a function returning a promise
     * async.waterfall([
     *     async.apply(fs.readFile, filename, "utf8"),
     *     async.asyncify(function (contents) {
     *         return db.model.create(contents);
     *     }),
     *     function (model, next) {
     *         // `model` is the instantiated model object.
     *         // If there was an error, this function would be skipped.
     *     }
     * ], callback);
     *
     * // es2017 example, though `asyncify` is not needed if your JS environment
     * // supports async functions out of the box
     * var q = async.queue(async.asyncify(async function(file) {
     *     var intermediateStep = await processFile(file);
     *     return await somePromise(intermediateStep)
     * }));
     *
     * q.push(files);
     */ function asyncify(func) {
        if (isAsync(func)) {
            return function(...args /*, callback*/ ) {
                const callback = args.pop();
                const promise = func.apply(this, args);
                return handlePromise(promise, callback);
            };
        }
        return initialParams(function(args, callback) {
            var result;
            try {
                result = func.apply(this, args);
            } catch (e) {
                return callback(e);
            }
            // if result is Promise object
            if (result && typeof result.then === "function") {
                return handlePromise(result, callback);
            } else {
                callback(null, result);
            }
        });
    }
    function handlePromise(promise, callback) {
        return promise.then((value)=>{
            invokeCallback(callback, null, value);
        }, (err)=>{
            invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
        });
    }
    function invokeCallback(callback, error, value) {
        try {
            callback(error, value);
        } catch (err) {
            setImmediate$1((e)=>{
                throw e;
            }, err);
        }
    }
    function isAsync(fn) {
        return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
        return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable(obj) {
        return typeof obj[Symbol.asyncIterator] === "function";
    }
    function wrapAsync(asyncFn) {
        if (typeof asyncFn !== "function") throw new Error("expected a function");
        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
    }
    // conditionally promisify a function.
    // only return a promise if a callback is omitted
    function awaitify(asyncFn, arity) {
        if (!arity) arity = asyncFn.length;
        if (!arity) throw new Error("arity is undefined");
        function awaitable(...args) {
            if (typeof args[arity - 1] === "function") {
                return asyncFn.apply(this, args);
            }
            return new Promise((resolve, reject)=>{
                args[arity - 1] = (err, ...cbArgs)=>{
                    if (err) return reject(err);
                    resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
                };
                asyncFn.apply(this, args);
            });
        }
        return awaitable;
    }
    function applyEach$1(eachfn) {
        return function applyEach(fns, ...callArgs) {
            const go = awaitify(function(callback) {
                var that = this;
                return eachfn(fns, (fn, cb)=>{
                    wrapAsync(fn).apply(that, callArgs.concat(cb));
                }, callback);
            });
            return go;
        };
    }
    function _asyncMap(eachfn, arr, iteratee, callback) {
        arr = arr || [];
        var results = [];
        var counter = 0;
        var _iteratee = wrapAsync(iteratee);
        return eachfn(arr, (value, _, iterCb)=>{
            var index = counter++;
            _iteratee(value, (err, v)=>{
                results[index] = v;
                iterCb(err);
            });
        }, (err)=>{
            callback(err, results);
        });
    }
    function isArrayLike(value) {
        return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
    }
    // A temporary value used to identify if the loop should be broken.
    // See #1064, #1293
    const breakLoop = {};
    function once(fn) {
        function wrapper(...args) {
            if (fn === null) return;
            var callFn = fn;
            fn = null;
            callFn.apply(this, args);
        }
        Object.assign(wrapper, fn);
        return wrapper;
    }
    function getIterator(coll) {
        return coll[Symbol.iterator] && coll[Symbol.iterator]();
    }
    function createArrayIterator(coll) {
        var i = -1;
        var len = coll.length;
        return function next() {
            return ++i < len ? {
                value: coll[i],
                key: i
            } : null;
        };
    }
    function createES2015Iterator(iterator) {
        var i = -1;
        return function next() {
            var item = iterator.next();
            if (item.done) return null;
            i++;
            return {
                value: item.value,
                key: i
            };
        };
    }
    function createObjectIterator(obj) {
        var okeys = obj ? Object.keys(obj) : [];
        var i = -1;
        var len = okeys.length;
        return function next() {
            var key = okeys[++i];
            if (key === "__proto__") {
                return next();
            }
            return i < len ? {
                value: obj[key],
                key
            } : null;
        };
    }
    function createIterator(coll) {
        if (isArrayLike(coll)) {
            return createArrayIterator(coll);
        }
        var iterator = getIterator(coll);
        return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    function onlyOnce(fn) {
        return function(...args) {
            if (fn === null) throw new Error("Callback was already called.");
            var callFn = fn;
            fn = null;
            callFn.apply(this, args);
        };
    }
    // for async generators
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
        let done = false;
        let canceled = false;
        let awaiting = false;
        let running = 0;
        let idx = 0;
        function replenish() {
            //console.log('replenish')
            if (running >= limit || awaiting || done) return;
            //console.log('replenish awaiting')
            awaiting = true;
            generator.next().then(({ value, done: iterDone })=>{
                //console.log('got value', value)
                if (canceled || done) return;
                awaiting = false;
                if (iterDone) {
                    done = true;
                    if (running <= 0) {
                        //console.log('done nextCb')
                        callback(null);
                    }
                    return;
                }
                running++;
                iteratee(value, idx, iterateeCallback);
                idx++;
                replenish();
            }).catch(handleError);
        }
        function iterateeCallback(err, result) {
            //console.log('iterateeCallback')
            running -= 1;
            if (canceled) return;
            if (err) return handleError(err);
            if (err === false) {
                done = true;
                canceled = true;
                return;
            }
            if (result === breakLoop || done && running <= 0) {
                done = true;
                //console.log('done iterCb')
                return callback(null);
            }
            replenish();
        }
        function handleError(err) {
            if (canceled) return;
            awaiting = false;
            done = true;
            callback(err);
        }
        replenish();
    }
    var eachOfLimit$2 = (limit)=>{
        return (obj, iteratee, callback)=>{
            callback = once(callback);
            if (limit <= 0) {
                throw new RangeError("concurrency limit cannot be less than 1");
            }
            if (!obj) {
                return callback(null);
            }
            if (isAsyncGenerator(obj)) {
                return asyncEachOfLimit(obj, limit, iteratee, callback);
            }
            if (isAsyncIterable(obj)) {
                return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
            }
            var nextElem = createIterator(obj);
            var done = false;
            var canceled = false;
            var running = 0;
            var looping = false;
            function iterateeCallback(err, value) {
                if (canceled) return;
                running -= 1;
                if (err) {
                    done = true;
                    callback(err);
                } else if (err === false) {
                    done = true;
                    canceled = true;
                } else if (value === breakLoop || done && running <= 0) {
                    done = true;
                    return callback(null);
                } else if (!looping) {
                    replenish();
                }
            }
            function replenish() {
                looping = true;
                while(running < limit && !done){
                    var elem = nextElem();
                    if (elem === null) {
                        done = true;
                        if (running <= 0) {
                            callback(null);
                        }
                        return;
                    }
                    running += 1;
                    iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
                }
                looping = false;
            }
            replenish();
        };
    };
    /**
     * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name eachOfLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.eachOf]{@link module:Collections.eachOf}
     * @alias forEachOfLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async function to apply to each
     * item in `coll`. The `key` is the item's key, or index in the case of an
     * array.
     * Invoked with (item, key, callback).
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     */ function eachOfLimit(coll, limit, iteratee, callback) {
        return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);
    }
    var eachOfLimit$1 = awaitify(eachOfLimit, 4);
    // eachOf implementation optimized for array-likes
    function eachOfArrayLike(coll, iteratee, callback) {
        callback = once(callback);
        var index = 0, completed = 0, { length } = coll, canceled = false;
        if (length === 0) {
            callback(null);
        }
        function iteratorCallback(err, value) {
            if (err === false) {
                canceled = true;
            }
            if (canceled === true) return;
            if (err) {
                callback(err);
            } else if (++completed === length || value === breakLoop) {
                callback(null);
            }
        }
        for(; index < length; index++){
            iteratee(coll[index], index, onlyOnce(iteratorCallback));
        }
    }
    // a generic version of eachOf which can handle array, object, and iterator cases.
    function eachOfGeneric(coll, iteratee, callback) {
        return eachOfLimit$1(coll, Infinity, iteratee, callback);
    }
    /**
     * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
     * to the iteratee.
     *
     * @name eachOf
     * @static
     * @memberOf module:Collections
     * @method
     * @alias forEachOf
     * @category Collection
     * @see [async.each]{@link module:Collections.each}
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each
     * item in `coll`.
     * The `key` is the item's key, or index in the case of an array.
     * Invoked with (item, key, callback).
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     * @example
     *
     * // dev.json is a file containing a valid json object config for dev environment
     * // dev.json is a file containing a valid json object config for test environment
     * // prod.json is a file containing a valid json object config for prod environment
     * // invalid.json is a file with a malformed json object
     *
     * let configs = {}; //global variable
     * let validConfigFileMap = {dev: 'dev.json', test: 'test.json', prod: 'prod.json'};
     * let invalidConfigFileMap = {dev: 'dev.json', test: 'test.json', invalid: 'invalid.json'};
     *
     * // asynchronous function that reads a json file and parses the contents as json object
     * function parseFile(file, key, callback) {
     *     fs.readFile(file, "utf8", function(err, data) {
     *         if (err) return calback(err);
     *         try {
     *             configs[key] = JSON.parse(data);
     *         } catch (e) {
     *             return callback(e);
     *         }
     *         callback();
     *     });
     * }
     *
     * // Using callbacks
     * async.forEachOf(validConfigFileMap, parseFile, function (err) {
     *     if (err) {
     *         console.error(err);
     *     } else {
     *         console.log(configs);
     *         // configs is now a map of JSON data, e.g.
     *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
     *     }
     * });
     *
     * //Error handing
     * async.forEachOf(invalidConfigFileMap, parseFile, function (err) {
     *     if (err) {
     *         console.error(err);
     *         // JSON parse error exception
     *     } else {
     *         console.log(configs);
     *     }
     * });
     *
     * // Using Promises
     * async.forEachOf(validConfigFileMap, parseFile)
     * .then( () => {
     *     console.log(configs);
     *     // configs is now a map of JSON data, e.g.
     *     // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
     * }).catch( err => {
     *     console.error(err);
     * });
     *
     * //Error handing
     * async.forEachOf(invalidConfigFileMap, parseFile)
     * .then( () => {
     *     console.log(configs);
     * }).catch( err => {
     *     console.error(err);
     *     // JSON parse error exception
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.forEachOf(validConfigFileMap, parseFile);
     *         console.log(configs);
     *         // configs is now a map of JSON data, e.g.
     *         // { dev: //parsed dev.json, test: //parsed test.json, prod: //parsed prod.json}
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * //Error handing
     * async () => {
     *     try {
     *         let result = await async.forEachOf(invalidConfigFileMap, parseFile);
     *         console.log(configs);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // JSON parse error exception
     *     }
     * }
     *
     */ function eachOf(coll, iteratee, callback) {
        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
        return eachOfImplementation(coll, wrapAsync(iteratee), callback);
    }
    var eachOf$1 = awaitify(eachOf, 3);
    /**
     * Produces a new collection of values by mapping each value in `coll` through
     * the `iteratee` function. The `iteratee` is called with an item from `coll`
     * and a callback for when it has finished processing. Each of these callbacks
     * takes 2 arguments: an `error`, and the transformed item from `coll`. If
     * `iteratee` passes an error to its callback, the main `callback` (for the
     * `map` function) is immediately called with the error.
     *
     * Note, that since this function applies the `iteratee` to each item in
     * parallel, there is no guarantee that the `iteratee` functions will complete
     * in order. However, the results array will be in the same order as the
     * original `coll`.
     *
     * If `map` is passed an Object, the results will be an Array.  The results
     * will roughly be in the order of the original Objects' keys (but this can
     * vary across JavaScript engines).
     *
     * @name map
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with the transformed item.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Results is an Array of the
     * transformed items from the `coll`. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * // file1.txt is a file that is 1000 bytes in size
     * // file2.txt is a file that is 2000 bytes in size
     * // file3.txt is a file that is 3000 bytes in size
     * // file4.txt does not exist
     *
     * const fileList = ['file1.txt','file2.txt','file3.txt'];
     * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];
     *
     * // asynchronous function that returns the file size in bytes
     * function getFileSizeInBytes(file, callback) {
     *     fs.stat(file, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         callback(null, stat.size);
     *     });
     * }
     *
     * // Using callbacks
     * async.map(fileList, getFileSizeInBytes, function(err, results) {
     *     if (err) {
     *         console.log(err);
     *     } else {
     *         console.log(results);
     *         // results is now an array of the file size in bytes for each file, e.g.
     *         // [ 1000, 2000, 3000]
     *     }
     * });
     *
     * // Error Handling
     * async.map(withMissingFileList, getFileSizeInBytes, function(err, results) {
     *     if (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     } else {
     *         console.log(results);
     *     }
     * });
     *
     * // Using Promises
     * async.map(fileList, getFileSizeInBytes)
     * .then( results => {
     *     console.log(results);
     *     // results is now an array of the file size in bytes for each file, e.g.
     *     // [ 1000, 2000, 3000]
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Error Handling
     * async.map(withMissingFileList, getFileSizeInBytes)
     * .then( results => {
     *     console.log(results);
     * }).catch( err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let results = await async.map(fileList, getFileSizeInBytes);
     *         console.log(results);
     *         // results is now an array of the file size in bytes for each file, e.g.
     *         // [ 1000, 2000, 3000]
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // Error Handling
     * async () => {
     *     try {
     *         let results = await async.map(withMissingFileList, getFileSizeInBytes);
     *         console.log(results);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     }
     * }
     *
     */ function map(coll, iteratee, callback) {
        return _asyncMap(eachOf$1, coll, iteratee, callback);
    }
    var map$1 = awaitify(map, 3);
    /**
     * Applies the provided arguments to each function in the array, calling
     * `callback` after all functions have completed. If you only provide the first
     * argument, `fns`, then it will return a function which lets you pass in the
     * arguments as if it were a single function call. If more arguments are
     * provided, `callback` is required while `args` is still optional. The results
     * for each of the applied async functions are passed to the final callback
     * as an array.
     *
     * @name applyEach
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s
     * to all call with the same arguments
     * @param {...*} [args] - any number of separate arguments to pass to the
     * function.
     * @param {Function} [callback] - the final argument should be the callback,
     * called when all functions have completed processing.
     * @returns {AsyncFunction} - Returns a function that takes no args other than
     * an optional callback, that is the result of applying the `args` to each
     * of the functions.
     * @example
     *
     * const appliedFn = async.applyEach([enableSearch, updateSchema], 'bucket')
     *
     * appliedFn((err, results) => {
     *     // results[0] is the results for `enableSearch`
     *     // results[1] is the results for `updateSchema`
     * });
     *
     * // partial application example:
     * async.each(
     *     buckets,
     *     async (bucket) => async.applyEach([enableSearch, updateSchema], bucket)(),
     *     callback
     * );
     */ var applyEach = applyEach$1(map$1);
    /**
     * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
     *
     * @name eachOfSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.eachOf]{@link module:Collections.eachOf}
     * @alias forEachOfSeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * Invoked with (item, key, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     */ function eachOfSeries(coll, iteratee, callback) {
        return eachOfLimit$1(coll, 1, iteratee, callback);
    }
    var eachOfSeries$1 = awaitify(eachOfSeries, 3);
    /**
     * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.
     *
     * @name mapSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.map]{@link module:Collections.map}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with the transformed item.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Results is an array of the
     * transformed items from the `coll`. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     */ function mapSeries(coll, iteratee, callback) {
        return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
    }
    var mapSeries$1 = awaitify(mapSeries, 3);
    /**
     * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.
     *
     * @name applyEachSeries
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.applyEach]{@link module:ControlFlow.applyEach}
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} fns - A collection of {@link AsyncFunction}s to all
     * call with the same arguments
     * @param {...*} [args] - any number of separate arguments to pass to the
     * function.
     * @param {Function} [callback] - the final argument should be the callback,
     * called when all functions have completed processing.
     * @returns {AsyncFunction} - A function, that when called, is the result of
     * appling the `args` to the list of functions.  It takes no args, other than
     * a callback.
     */ var applyEachSeries = applyEach$1(mapSeries$1);
    const PROMISE_SYMBOL = Symbol("promiseCallback");
    function promiseCallback() {
        let resolve, reject;
        function callback(err, ...args) {
            if (err) return reject(err);
            resolve(args.length > 1 ? args : args[0]);
        }
        callback[PROMISE_SYMBOL] = new Promise((res, rej)=>{
            resolve = res, reject = rej;
        });
        return callback;
    }
    /**
     * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on
     * their requirements. Each function can optionally depend on other functions
     * being completed first, and each function is run as soon as its requirements
     * are satisfied.
     *
     * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence
     * will stop. Further tasks will not execute (so any other functions depending
     * on it will not run), and the main `callback` is immediately called with the
     * error.
     *
     * {@link AsyncFunction}s also receive an object containing the results of functions which
     * have completed so far as the first argument, if they have dependencies. If a
     * task function has no dependencies, it will only be passed a callback.
     *
     * @name auto
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Object} tasks - An object. Each of its properties is either a
     * function or an array of requirements, with the {@link AsyncFunction} itself the last item
     * in the array. The object's key of a property serves as the name of the task
     * defined by that property, i.e. can be used when specifying requirements for
     * other tasks. The function receives one or two arguments:
     * * a `results` object, containing the results of the previously executed
     *   functions, only passed if the task has any dependencies,
     * * a `callback(err, result)` function, which must be called when finished,
     *   passing an `error` (which can be `null`) and the result of the function's
     *   execution.
     * @param {number} [concurrency=Infinity] - An optional `integer` for
     * determining the maximum number of tasks that can be run in parallel. By
     * default, as many as possible.
     * @param {Function} [callback] - An optional callback which is called when all
     * the tasks have been completed. It receives the `err` argument if any `tasks`
     * pass an error to their callback. Results are always returned; however, if an
     * error occurs, no further `tasks` will be performed, and the results object
     * will only contain partial results. Invoked with (err, results).
     * @returns {Promise} a promise, if a callback is not passed
     * @example
     *
     * //Using Callbacks
     * async.auto({
     *     get_data: function(callback) {
     *         // async code to get some data
     *         callback(null, 'data', 'converted to array');
     *     },
     *     make_folder: function(callback) {
     *         // async code to create a directory to store a file in
     *         // this is run at the same time as getting the data
     *         callback(null, 'folder');
     *     },
     *     write_file: ['get_data', 'make_folder', function(results, callback) {
     *         // once there is some data and the directory exists,
     *         // write the data to a file in the directory
     *         callback(null, 'filename');
     *     }],
     *     email_link: ['write_file', function(results, callback) {
     *         // once the file is written let's email a link to it...
     *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
     *     }]
     * }, function(err, results) {
     *     if (err) {
     *         console.log('err = ', err);
     *     }
     *     console.log('results = ', results);
     *     // results = {
     *     //     get_data: ['data', 'converted to array']
     *     //     make_folder; 'folder',
     *     //     write_file: 'filename'
     *     //     email_link: { file: 'filename', email: 'user@example.com' }
     *     // }
     * });
     *
     * //Using Promises
     * async.auto({
     *     get_data: function(callback) {
     *         console.log('in get_data');
     *         // async code to get some data
     *         callback(null, 'data', 'converted to array');
     *     },
     *     make_folder: function(callback) {
     *         console.log('in make_folder');
     *         // async code to create a directory to store a file in
     *         // this is run at the same time as getting the data
     *         callback(null, 'folder');
     *     },
     *     write_file: ['get_data', 'make_folder', function(results, callback) {
     *         // once there is some data and the directory exists,
     *         // write the data to a file in the directory
     *         callback(null, 'filename');
     *     }],
     *     email_link: ['write_file', function(results, callback) {
     *         // once the file is written let's email a link to it...
     *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
     *     }]
     * }).then(results => {
     *     console.log('results = ', results);
     *     // results = {
     *     //     get_data: ['data', 'converted to array']
     *     //     make_folder; 'folder',
     *     //     write_file: 'filename'
     *     //     email_link: { file: 'filename', email: 'user@example.com' }
     *     // }
     * }).catch(err => {
     *     console.log('err = ', err);
     * });
     *
     * //Using async/await
     * async () => {
     *     try {
     *         let results = await async.auto({
     *             get_data: function(callback) {
     *                 // async code to get some data
     *                 callback(null, 'data', 'converted to array');
     *             },
     *             make_folder: function(callback) {
     *                 // async code to create a directory to store a file in
     *                 // this is run at the same time as getting the data
     *                 callback(null, 'folder');
     *             },
     *             write_file: ['get_data', 'make_folder', function(results, callback) {
     *                 // once there is some data and the directory exists,
     *                 // write the data to a file in the directory
     *                 callback(null, 'filename');
     *             }],
     *             email_link: ['write_file', function(results, callback) {
     *                 // once the file is written let's email a link to it...
     *                 callback(null, {'file':results.write_file, 'email':'user@example.com'});
     *             }]
     *         });
     *         console.log('results = ', results);
     *         // results = {
     *         //     get_data: ['data', 'converted to array']
     *         //     make_folder; 'folder',
     *         //     write_file: 'filename'
     *         //     email_link: { file: 'filename', email: 'user@example.com' }
     *         // }
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */ function auto(tasks, concurrency, callback) {
        if (typeof concurrency !== "number") {
            // concurrency is optional, shift the args.
            callback = concurrency;
            concurrency = null;
        }
        callback = once(callback || promiseCallback());
        var numTasks = Object.keys(tasks).length;
        if (!numTasks) {
            return callback(null);
        }
        if (!concurrency) {
            concurrency = numTasks;
        }
        var results = {};
        var runningTasks = 0;
        var canceled = false;
        var hasError = false;
        var listeners = Object.create(null);
        var readyTasks = [];
        // for cycle detection:
        var readyToCheck = []; // tasks that have been identified as reachable
        // without the possibility of returning to an ancestor task
        var uncheckedDependencies = {};
        Object.keys(tasks).forEach((key)=>{
            var task = tasks[key];
            if (!Array.isArray(task)) {
                // no dependencies
                enqueueTask(key, [
                    task
                ]);
                readyToCheck.push(key);
                return;
            }
            var dependencies = task.slice(0, task.length - 1);
            var remainingDependencies = dependencies.length;
            if (remainingDependencies === 0) {
                enqueueTask(key, task);
                readyToCheck.push(key);
                return;
            }
            uncheckedDependencies[key] = remainingDependencies;
            dependencies.forEach((dependencyName)=>{
                if (!tasks[dependencyName]) {
                    throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
                }
                addListener(dependencyName, ()=>{
                    remainingDependencies--;
                    if (remainingDependencies === 0) {
                        enqueueTask(key, task);
                    }
                });
            });
        });
        checkForDeadlocks();
        processQueue();
        function enqueueTask(key, task) {
            readyTasks.push(()=>runTask(key, task));
        }
        function processQueue() {
            if (canceled) return;
            if (readyTasks.length === 0 && runningTasks === 0) {
                return callback(null, results);
            }
            while(readyTasks.length && runningTasks < concurrency){
                var run = readyTasks.shift();
                run();
            }
        }
        function addListener(taskName, fn) {
            var taskListeners = listeners[taskName];
            if (!taskListeners) {
                taskListeners = listeners[taskName] = [];
            }
            taskListeners.push(fn);
        }
        function taskComplete(taskName) {
            var taskListeners = listeners[taskName] || [];
            taskListeners.forEach((fn)=>fn());
            processQueue();
        }
        function runTask(key, task) {
            if (hasError) return;
            var taskCallback = onlyOnce((err, ...result)=>{
                runningTasks--;
                if (err === false) {
                    canceled = true;
                    return;
                }
                if (result.length < 2) {
                    [result] = result;
                }
                if (err) {
                    var safeResults = {};
                    Object.keys(results).forEach((rkey)=>{
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[key] = result;
                    hasError = true;
                    listeners = Object.create(null);
                    if (canceled) return;
                    callback(err, safeResults);
                } else {
                    results[key] = result;
                    taskComplete(key);
                }
            });
            runningTasks++;
            var taskFn = wrapAsync(task[task.length - 1]);
            if (task.length > 1) {
                taskFn(results, taskCallback);
            } else {
                taskFn(taskCallback);
            }
        }
        function checkForDeadlocks() {
            // Kahn's algorithm
            // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
            // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
            var currentTask;
            var counter = 0;
            while(readyToCheck.length){
                currentTask = readyToCheck.pop();
                counter++;
                getDependents(currentTask).forEach((dependent)=>{
                    if (--uncheckedDependencies[dependent] === 0) {
                        readyToCheck.push(dependent);
                    }
                });
            }
            if (counter !== numTasks) {
                throw new Error("async.auto cannot execute tasks due to a recursive dependency");
            }
        }
        function getDependents(taskName) {
            var result = [];
            Object.keys(tasks).forEach((key)=>{
                const task = tasks[key];
                if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
                    result.push(key);
                }
            });
            return result;
        }
        return callback[PROMISE_SYMBOL];
    }
    var FN_ARGS = /^(?:async\s)?(?:function)?\s*(?:\w+\s*)?\(([^)]+)\)(?:\s*{)/;
    var ARROW_FN_ARGS = /^(?:async\s)?\s*(?:\(\s*)?((?:[^)=\s]\s*)*)(?:\)\s*)?=>/;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /(=.+)?(\s*)$/;
    function stripComments(string) {
        let stripped = "";
        let index = 0;
        let endBlockComment = string.indexOf("*/");
        while(index < string.length){
            if (string[index] === "/" && string[index + 1] === "/") {
                // inline comment
                let endIndex = string.indexOf("\n", index);
                index = endIndex === -1 ? string.length : endIndex;
            } else if (endBlockComment !== -1 && string[index] === "/" && string[index + 1] === "*") {
                // block comment
                let endIndex = string.indexOf("*/", index);
                if (endIndex !== -1) {
                    index = endIndex + 2;
                    endBlockComment = string.indexOf("*/", index);
                } else {
                    stripped += string[index];
                    index++;
                }
            } else {
                stripped += string[index];
                index++;
            }
        }
        return stripped;
    }
    function parseParams(func) {
        const src = stripComments(func.toString());
        let match = src.match(FN_ARGS);
        if (!match) {
            match = src.match(ARROW_FN_ARGS);
        }
        if (!match) throw new Error("could not parse args in autoInject\nSource:\n" + src);
        let [, args] = match;
        return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg)=>arg.replace(FN_ARG, "").trim());
    }
    /**
     * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
     * tasks are specified as parameters to the function, after the usual callback
     * parameter, with the parameter names matching the names of the tasks it
     * depends on. This can provide even more readable task graphs which can be
     * easier to maintain.
     *
     * If a final callback is specified, the task results are similarly injected,
     * specified as named parameters after the initial error parameter.
     *
     * The autoInject function is purely syntactic sugar and its semantics are
     * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.
     *
     * @name autoInject
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.auto]{@link module:ControlFlow.auto}
     * @category Control Flow
     * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of
     * the form 'func([dependencies...], callback). The object's key of a property
     * serves as the name of the task defined by that property, i.e. can be used
     * when specifying requirements for other tasks.
     * * The `callback` parameter is a `callback(err, result)` which must be called
     *   when finished, passing an `error` (which can be `null`) and the result of
     *   the function's execution. The remaining parameters name other tasks on
     *   which the task is dependent, and the results from those tasks are the
     *   arguments of those parameters.
     * @param {Function} [callback] - An optional callback which is called when all
     * the tasks have been completed. It receives the `err` argument if any `tasks`
     * pass an error to their callback, and a `results` object with any completed
     * task results, similar to `auto`.
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * //  The example from `auto` can be rewritten as follows:
     * async.autoInject({
     *     get_data: function(callback) {
     *         // async code to get some data
     *         callback(null, 'data', 'converted to array');
     *     },
     *     make_folder: function(callback) {
     *         // async code to create a directory to store a file in
     *         // this is run at the same time as getting the data
     *         callback(null, 'folder');
     *     },
     *     write_file: function(get_data, make_folder, callback) {
     *         // once there is some data and the directory exists,
     *         // write the data to a file in the directory
     *         callback(null, 'filename');
     *     },
     *     email_link: function(write_file, callback) {
     *         // once the file is written let's email a link to it...
     *         // write_file contains the filename returned by write_file.
     *         callback(null, {'file':write_file, 'email':'user@example.com'});
     *     }
     * }, function(err, results) {
     *     console.log('err = ', err);
     *     console.log('email_link = ', results.email_link);
     * });
     *
     * // If you are using a JS minifier that mangles parameter names, `autoInject`
     * // will not work with plain functions, since the parameter names will be
     * // collapsed to a single letter identifier.  To work around this, you can
     * // explicitly specify the names of the parameters your task function needs
     * // in an array, similar to Angular.js dependency injection.
     *
     * // This still has an advantage over plain `auto`, since the results a task
     * // depends on are still spread into arguments.
     * async.autoInject({
     *     //...
     *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {
     *         callback(null, 'filename');
     *     }],
     *     email_link: ['write_file', function(write_file, callback) {
     *         callback(null, {'file':write_file, 'email':'user@example.com'});
     *     }]
     *     //...
     * }, function(err, results) {
     *     console.log('err = ', err);
     *     console.log('email_link = ', results.email_link);
     * });
     */ function autoInject(tasks, callback) {
        var newTasks = {};
        Object.keys(tasks).forEach((key)=>{
            var taskFn = tasks[key];
            var params;
            var fnIsAsync = isAsync(taskFn);
            var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
            if (Array.isArray(taskFn)) {
                params = [
                    ...taskFn
                ];
                taskFn = params.pop();
                newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
            } else if (hasNoDeps) {
                // no dependencies, use the function as-is
                newTasks[key] = taskFn;
            } else {
                params = parseParams(taskFn);
                if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
                    throw new Error("autoInject task functions require explicit parameters.");
                }
                // remove callback param
                if (!fnIsAsync) params.pop();
                newTasks[key] = params.concat(newTask);
            }
            function newTask(results, taskCb) {
                var newArgs = params.map((name)=>results[name]);
                newArgs.push(taskCb);
                wrapAsync(taskFn)(...newArgs);
            }
        });
        return auto(newTasks, callback);
    }
    // Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
    // used for queues. This implementation assumes that the node provided by the user can be modified
    // to adjust the next and last properties. We implement only the minimal functionality
    // for queue support.
    class DLL {
        constructor(){
            this.head = this.tail = null;
            this.length = 0;
        }
        removeLink(node) {
            if (node.prev) node.prev.next = node.next;
            else this.head = node.next;
            if (node.next) node.next.prev = node.prev;
            else this.tail = node.prev;
            node.prev = node.next = null;
            this.length -= 1;
            return node;
        }
        empty() {
            while(this.head)this.shift();
            return this;
        }
        insertAfter(node, newNode) {
            newNode.prev = node;
            newNode.next = node.next;
            if (node.next) node.next.prev = newNode;
            else this.tail = newNode;
            node.next = newNode;
            this.length += 1;
        }
        insertBefore(node, newNode) {
            newNode.prev = node.prev;
            newNode.next = node;
            if (node.prev) node.prev.next = newNode;
            else this.head = newNode;
            node.prev = newNode;
            this.length += 1;
        }
        unshift(node) {
            if (this.head) this.insertBefore(this.head, node);
            else setInitial(this, node);
        }
        push(node) {
            if (this.tail) this.insertAfter(this.tail, node);
            else setInitial(this, node);
        }
        shift() {
            return this.head && this.removeLink(this.head);
        }
        pop() {
            return this.tail && this.removeLink(this.tail);
        }
        toArray() {
            return [
                ...this
            ];
        }
        *[Symbol.iterator]() {
            var cur = this.head;
            while(cur){
                yield cur.data;
                cur = cur.next;
            }
        }
        remove(testFn) {
            var curr = this.head;
            while(curr){
                var { next } = curr;
                if (testFn(curr)) {
                    this.removeLink(curr);
                }
                curr = next;
            }
            return this;
        }
    }
    function setInitial(dll, node) {
        dll.length = 1;
        dll.head = dll.tail = node;
    }
    function queue$1(worker, concurrency, payload) {
        if (concurrency == null) {
            concurrency = 1;
        } else if (concurrency === 0) {
            throw new RangeError("Concurrency must not be zero");
        }
        var _worker = wrapAsync(worker);
        var numRunning = 0;
        var workersList = [];
        const events = {
            error: [],
            drain: [],
            saturated: [],
            unsaturated: [],
            empty: []
        };
        function on(event, handler) {
            events[event].push(handler);
        }
        function once(event, handler) {
            const handleAndRemove = (...args)=>{
                off(event, handleAndRemove);
                handler(...args);
            };
            events[event].push(handleAndRemove);
        }
        function off(event, handler) {
            if (!event) return Object.keys(events).forEach((ev)=>events[ev] = []);
            if (!handler) return events[event] = [];
            events[event] = events[event].filter((ev)=>ev !== handler);
        }
        function trigger(event, ...args) {
            events[event].forEach((handler)=>handler(...args));
        }
        var processingScheduled = false;
        function _insert(data, insertAtFront, rejectOnError, callback) {
            if (callback != null && typeof callback !== "function") {
                throw new Error("task callback must be a function");
            }
            q.started = true;
            var res, rej;
            function promiseCallback(err, ...args) {
                // we don't care about the error, let the global error handler
                // deal with it
                if (err) return rejectOnError ? rej(err) : res();
                if (args.length <= 1) return res(args[0]);
                res(args);
            }
            var item = q._createTaskItem(data, rejectOnError ? promiseCallback : callback || promiseCallback);
            if (insertAtFront) {
                q._tasks.unshift(item);
            } else {
                q._tasks.push(item);
            }
            if (!processingScheduled) {
                processingScheduled = true;
                setImmediate$1(()=>{
                    processingScheduled = false;
                    q.process();
                });
            }
            if (rejectOnError || !callback) {
                return new Promise((resolve, reject)=>{
                    res = resolve;
                    rej = reject;
                });
            }
        }
        function _createCB(tasks) {
            return function(err, ...args) {
                numRunning -= 1;
                for(var i = 0, l = tasks.length; i < l; i++){
                    var task = tasks[i];
                    var index = workersList.indexOf(task);
                    if (index === 0) {
                        workersList.shift();
                    } else if (index > 0) {
                        workersList.splice(index, 1);
                    }
                    task.callback(err, ...args);
                    if (err != null) {
                        trigger("error", err, task.data);
                    }
                }
                if (numRunning <= q.concurrency - q.buffer) {
                    trigger("unsaturated");
                }
                if (q.idle()) {
                    trigger("drain");
                }
                q.process();
            };
        }
        function _maybeDrain(data) {
            if (data.length === 0 && q.idle()) {
                // call drain immediately if there are no tasks
                setImmediate$1(()=>trigger("drain"));
                return true;
            }
            return false;
        }
        const eventMethod = (name)=>(handler)=>{
                if (!handler) {
                    return new Promise((resolve, reject)=>{
                        once(name, (err, data)=>{
                            if (err) return reject(err);
                            resolve(data);
                        });
                    });
                }
                off(name);
                on(name, handler);
            };
        var isProcessing = false;
        var q = {
            _tasks: new DLL(),
            _createTaskItem (data, callback) {
                return {
                    data,
                    callback
                };
            },
            *[Symbol.iterator] () {
                yield* q._tasks[Symbol.iterator]();
            },
            concurrency,
            payload,
            buffer: concurrency / 4,
            started: false,
            paused: false,
            push (data, callback) {
                if (Array.isArray(data)) {
                    if (_maybeDrain(data)) return;
                    return data.map((datum)=>_insert(datum, false, false, callback));
                }
                return _insert(data, false, false, callback);
            },
            pushAsync (data, callback) {
                if (Array.isArray(data)) {
                    if (_maybeDrain(data)) return;
                    return data.map((datum)=>_insert(datum, false, true, callback));
                }
                return _insert(data, false, true, callback);
            },
            kill () {
                off();
                q._tasks.empty();
            },
            unshift (data, callback) {
                if (Array.isArray(data)) {
                    if (_maybeDrain(data)) return;
                    return data.map((datum)=>_insert(datum, true, false, callback));
                }
                return _insert(data, true, false, callback);
            },
            unshiftAsync (data, callback) {
                if (Array.isArray(data)) {
                    if (_maybeDrain(data)) return;
                    return data.map((datum)=>_insert(datum, true, true, callback));
                }
                return _insert(data, true, true, callback);
            },
            remove (testFn) {
                q._tasks.remove(testFn);
            },
            process () {
                // Avoid trying to start too many processing operations. This can occur
                // when callbacks resolve synchronously (#1267).
                if (isProcessing) {
                    return;
                }
                isProcessing = true;
                while(!q.paused && numRunning < q.concurrency && q._tasks.length){
                    var tasks = [], data = [];
                    var l = q._tasks.length;
                    if (q.payload) l = Math.min(l, q.payload);
                    for(var i = 0; i < l; i++){
                        var node = q._tasks.shift();
                        tasks.push(node);
                        workersList.push(node);
                        data.push(node.data);
                    }
                    numRunning += 1;
                    if (q._tasks.length === 0) {
                        trigger("empty");
                    }
                    if (numRunning === q.concurrency) {
                        trigger("saturated");
                    }
                    var cb = onlyOnce(_createCB(tasks));
                    _worker(data, cb);
                }
                isProcessing = false;
            },
            length () {
                return q._tasks.length;
            },
            running () {
                return numRunning;
            },
            workersList () {
                return workersList;
            },
            idle () {
                return q._tasks.length + numRunning === 0;
            },
            pause () {
                q.paused = true;
            },
            resume () {
                if (q.paused === false) {
                    return;
                }
                q.paused = false;
                setImmediate$1(q.process);
            }
        };
        // define these as fixed properties, so people get useful errors when updating
        Object.defineProperties(q, {
            saturated: {
                writable: false,
                value: eventMethod("saturated")
            },
            unsaturated: {
                writable: false,
                value: eventMethod("unsaturated")
            },
            empty: {
                writable: false,
                value: eventMethod("empty")
            },
            drain: {
                writable: false,
                value: eventMethod("drain")
            },
            error: {
                writable: false,
                value: eventMethod("error")
            }
        });
        return q;
    }
    /**
     * Creates a `cargo` object with the specified payload. Tasks added to the
     * cargo will be processed altogether (up to the `payload` limit). If the
     * `worker` is in progress, the task is queued until it becomes available. Once
     * the `worker` has completed some tasks, each callback of those tasks is
     * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
     * for how `cargo` and `queue` work.
     *
     * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
     * at a time, cargo passes an array of tasks to a single worker, repeating
     * when the worker is finished.
     *
     * @name cargo
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.queue]{@link module:ControlFlow.queue}
     * @category Control Flow
     * @param {AsyncFunction} worker - An asynchronous function for processing an array
     * of queued tasks. Invoked with `(tasks, callback)`.
     * @param {number} [payload=Infinity] - An optional `integer` for determining
     * how many tasks should be processed per round; if omitted, the default is
     * unlimited.
     * @returns {module:ControlFlow.QueueObject} A cargo object to manage the tasks. Callbacks can
     * attached as certain properties to listen for specific events during the
     * lifecycle of the cargo and inner queue.
     * @example
     *
     * // create a cargo object with payload 2
     * var cargo = async.cargo(function(tasks, callback) {
     *     for (var i=0; i<tasks.length; i++) {
     *         console.log('hello ' + tasks[i].name);
     *     }
     *     callback();
     * }, 2);
     *
     * // add some items
     * cargo.push({name: 'foo'}, function(err) {
     *     console.log('finished processing foo');
     * });
     * cargo.push({name: 'bar'}, function(err) {
     *     console.log('finished processing bar');
     * });
     * await cargo.push({name: 'baz'});
     * console.log('finished processing baz');
     */ function cargo$1(worker, payload) {
        return queue$1(worker, 1, payload);
    }
    /**
     * Creates a `cargoQueue` object with the specified payload. Tasks added to the
     * cargoQueue will be processed together (up to the `payload` limit) in `concurrency` parallel workers.
     * If the all `workers` are in progress, the task is queued until one becomes available. Once
     * a `worker` has completed some tasks, each callback of those tasks is
     * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
     * for how `cargo` and `queue` work.
     *
     * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
     * at a time, and [`cargo`]{@link module:ControlFlow.cargo} passes an array of tasks to a single worker,
     * the cargoQueue passes an array of tasks to multiple parallel workers.
     *
     * @name cargoQueue
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.queue]{@link module:ControlFlow.queue}
     * @see [async.cargo]{@link module:ControlFLow.cargo}
     * @category Control Flow
     * @param {AsyncFunction} worker - An asynchronous function for processing an array
     * of queued tasks. Invoked with `(tasks, callback)`.
     * @param {number} [concurrency=1] - An `integer` for determining how many
     * `worker` functions should be run in parallel.  If omitted, the concurrency
     * defaults to `1`.  If the concurrency is `0`, an error is thrown.
     * @param {number} [payload=Infinity] - An optional `integer` for determining
     * how many tasks should be processed per round; if omitted, the default is
     * unlimited.
     * @returns {module:ControlFlow.QueueObject} A cargoQueue object to manage the tasks. Callbacks can
     * attached as certain properties to listen for specific events during the
     * lifecycle of the cargoQueue and inner queue.
     * @example
     *
     * // create a cargoQueue object with payload 2 and concurrency 2
     * var cargoQueue = async.cargoQueue(function(tasks, callback) {
     *     for (var i=0; i<tasks.length; i++) {
     *         console.log('hello ' + tasks[i].name);
     *     }
     *     callback();
     * }, 2, 2);
     *
     * // add some items
     * cargoQueue.push({name: 'foo'}, function(err) {
     *     console.log('finished processing foo');
     * });
     * cargoQueue.push({name: 'bar'}, function(err) {
     *     console.log('finished processing bar');
     * });
     * cargoQueue.push({name: 'baz'}, function(err) {
     *     console.log('finished processing baz');
     * });
     * cargoQueue.push({name: 'boo'}, function(err) {
     *     console.log('finished processing boo');
     * });
     */ function cargo(worker, concurrency, payload) {
        return queue$1(worker, concurrency, payload);
    }
    /**
     * Reduces `coll` into a single value using an async `iteratee` to return each
     * successive step. `memo` is the initial state of the reduction. This function
     * only operates in series.
     *
     * For performance reasons, it may make sense to split a call to this function
     * into a parallel map, and then use the normal `Array.prototype.reduce` on the
     * results. This function is for situations where each step in the reduction
     * needs to be async; if you can get the data before reducing it, then it's
     * probably a good idea to do so.
     *
     * @name reduce
     * @static
     * @memberOf module:Collections
     * @method
     * @alias inject
     * @alias foldl
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {*} memo - The initial state of the reduction.
     * @param {AsyncFunction} iteratee - A function applied to each item in the
     * array to produce the next step in the reduction.
     * The `iteratee` should complete with the next state of the reduction.
     * If the iteratee completes with an error, the reduction is stopped and the
     * main `callback` is immediately called with the error.
     * Invoked with (memo, item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result is the reduced value. Invoked with
     * (err, result).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * // file1.txt is a file that is 1000 bytes in size
     * // file2.txt is a file that is 2000 bytes in size
     * // file3.txt is a file that is 3000 bytes in size
     * // file4.txt does not exist
     *
     * const fileList = ['file1.txt','file2.txt','file3.txt'];
     * const withMissingFileList = ['file1.txt','file2.txt','file3.txt', 'file4.txt'];
     *
     * // asynchronous function that computes the file size in bytes
     * // file size is added to the memoized value, then returned
     * function getFileSizeInBytes(memo, file, callback) {
     *     fs.stat(file, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         callback(null, memo + stat.size);
     *     });
     * }
     *
     * // Using callbacks
     * async.reduce(fileList, 0, getFileSizeInBytes, function(err, result) {
     *     if (err) {
     *         console.log(err);
     *     } else {
     *         console.log(result);
     *         // 6000
     *         // which is the sum of the file sizes of the three files
     *     }
     * });
     *
     * // Error Handling
     * async.reduce(withMissingFileList, 0, getFileSizeInBytes, function(err, result) {
     *     if (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     } else {
     *         console.log(result);
     *     }
     * });
     *
     * // Using Promises
     * async.reduce(fileList, 0, getFileSizeInBytes)
     * .then( result => {
     *     console.log(result);
     *     // 6000
     *     // which is the sum of the file sizes of the three files
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Error Handling
     * async.reduce(withMissingFileList, 0, getFileSizeInBytes)
     * .then( result => {
     *     console.log(result);
     * }).catch( err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.reduce(fileList, 0, getFileSizeInBytes);
     *         console.log(result);
     *         // 6000
     *         // which is the sum of the file sizes of the three files
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // Error Handling
     * async () => {
     *     try {
     *         let result = await async.reduce(withMissingFileList, 0, getFileSizeInBytes);
     *         console.log(result);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     }
     * }
     *
     */ function reduce(coll, memo, iteratee, callback) {
        callback = once(callback);
        var _iteratee = wrapAsync(iteratee);
        return eachOfSeries$1(coll, (x, i, iterCb)=>{
            _iteratee(memo, x, (err, v)=>{
                memo = v;
                iterCb(err);
            });
        }, (err)=>callback(err, memo));
    }
    var reduce$1 = awaitify(reduce, 4);
    /**
     * Version of the compose function that is more natural to read. Each function
     * consumes the return value of the previous function. It is the equivalent of
     * [compose]{@link module:ControlFlow.compose} with the arguments reversed.
     *
     * Each function is executed with the `this` binding of the composed function.
     *
     * @name seq
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.compose]{@link module:ControlFlow.compose}
     * @category Control Flow
     * @param {...AsyncFunction} functions - the asynchronous functions to compose
     * @returns {Function} a function that composes the `functions` in order
     * @example
     *
     * // Requires lodash (or underscore), express3 and dresende's orm2.
     * // Part of an app, that fetches cats of the logged user.
     * // This example uses `seq` function to avoid overnesting and error
     * // handling clutter.
     * app.get('/cats', function(request, response) {
     *     var User = request.models.User;
     *     async.seq(
     *         User.get.bind(User),  // 'User.get' has signature (id, callback(err, data))
     *         function(user, fn) {
     *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
     *         }
     *     )(req.session.user_id, function (err, cats) {
     *         if (err) {
     *             console.error(err);
     *             response.json({ status: 'error', message: err.message });
     *         } else {
     *             response.json({ status: 'ok', message: 'Cats found', data: cats });
     *         }
     *     });
     * });
     */ function seq(...functions) {
        var _functions = functions.map(wrapAsync);
        return function(...args) {
            var that = this;
            var cb = args[args.length - 1];
            if (typeof cb == "function") {
                args.pop();
            } else {
                cb = promiseCallback();
            }
            reduce$1(_functions, args, (newargs, fn, iterCb)=>{
                fn.apply(that, newargs.concat((err, ...nextargs)=>{
                    iterCb(err, nextargs);
                }));
            }, (err, results)=>cb(err, ...results));
            return cb[PROMISE_SYMBOL];
        };
    }
    /**
     * Creates a function which is a composition of the passed asynchronous
     * functions. Each function consumes the return value of the function that
     * follows. Composing functions `f()`, `g()`, and `h()` would produce the result
     * of `f(g(h()))`, only this version uses callbacks to obtain the return values.
     *
     * If the last argument to the composed function is not a function, a promise
     * is returned when you call it.
     *
     * Each function is executed with the `this` binding of the composed function.
     *
     * @name compose
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {...AsyncFunction} functions - the asynchronous functions to compose
     * @returns {Function} an asynchronous function that is the composed
     * asynchronous `functions`
     * @example
     *
     * function add1(n, callback) {
     *     setTimeout(function () {
     *         callback(null, n + 1);
     *     }, 10);
     * }
     *
     * function mul3(n, callback) {
     *     setTimeout(function () {
     *         callback(null, n * 3);
     *     }, 10);
     * }
     *
     * var add1mul3 = async.compose(mul3, add1);
     * add1mul3(4, function (err, result) {
     *     // result now equals 15
     * });
     */ function compose(...args) {
        return seq(...args.reverse());
    }
    /**
     * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.
     *
     * @name mapLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.map]{@link module:Collections.map}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with the transformed item.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Results is an array of the
     * transformed items from the `coll`. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     */ function mapLimit(coll, limit, iteratee, callback) {
        return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var mapLimit$1 = awaitify(mapLimit, 4);
    /**
     * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.
     *
     * @name concatLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.concat]{@link module:Collections.concat}
     * @category Collection
     * @alias flatMapLimit
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
     * which should use an array as its result. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished, or an error occurs. Results is an array
     * containing the concatenated results of the `iteratee` function. Invoked with
     * (err, results).
     * @returns A Promise, if no callback is passed
     */ function concatLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb)=>{
            _iteratee(val, (err, ...args)=>{
                if (err) return iterCb(err);
                return iterCb(err, args);
            });
        }, (err, mapResults)=>{
            var result = [];
            for(var i = 0; i < mapResults.length; i++){
                if (mapResults[i]) {
                    result = result.concat(...mapResults[i]);
                }
            }
            return callback(err, result);
        });
    }
    var concatLimit$1 = awaitify(concatLimit, 4);
    /**
     * Applies `iteratee` to each item in `coll`, concatenating the results. Returns
     * the concatenated list. The `iteratee`s are called in parallel, and the
     * results are concatenated as they return. The results array will be returned in
     * the original order of `coll` passed to the `iteratee` function.
     *
     * @name concat
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @alias flatMap
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
     * which should use an array as its result. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished, or an error occurs. Results is an array
     * containing the concatenated results of the `iteratee` function. Invoked with
     * (err, results).
     * @returns A Promise, if no callback is passed
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     * // dir4 does not exist
     *
     * let directoryList = ['dir1','dir2','dir3'];
     * let withMissingDirectoryList = ['dir1','dir2','dir3', 'dir4'];
     *
     * // Using callbacks
     * async.concat(directoryList, fs.readdir, function(err, results) {
     *    if (err) {
     *        console.log(err);
     *    } else {
     *        console.log(results);
     *        // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]
     *    }
     * });
     *
     * // Error Handling
     * async.concat(withMissingDirectoryList, fs.readdir, function(err, results) {
     *    if (err) {
     *        console.log(err);
     *        // [ Error: ENOENT: no such file or directory ]
     *        // since dir4 does not exist
     *    } else {
     *        console.log(results);
     *    }
     * });
     *
     * // Using Promises
     * async.concat(directoryList, fs.readdir)
     * .then(results => {
     *     console.log(results);
     *     // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]
     * }).catch(err => {
     *      console.log(err);
     * });
     *
     * // Error Handling
     * async.concat(withMissingDirectoryList, fs.readdir)
     * .then(results => {
     *     console.log(results);
     * }).catch(err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     *     // since dir4 does not exist
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let results = await async.concat(directoryList, fs.readdir);
     *         console.log(results);
     *         // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]
     *     } catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // Error Handling
     * async () => {
     *     try {
     *         let results = await async.concat(withMissingDirectoryList, fs.readdir);
     *         console.log(results);
     *     } catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *         // since dir4 does not exist
     *     }
     * }
     *
     */ function concat(coll, iteratee, callback) {
        return concatLimit$1(coll, Infinity, iteratee, callback);
    }
    var concat$1 = awaitify(concat, 3);
    /**
     * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.
     *
     * @name concatSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.concat]{@link module:Collections.concat}
     * @category Collection
     * @alias flatMapSeries
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.
     * The iteratee should complete with an array an array of results.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished, or an error occurs. Results is an array
     * containing the concatenated results of the `iteratee` function. Invoked with
     * (err, results).
     * @returns A Promise, if no callback is passed
     */ function concatSeries(coll, iteratee, callback) {
        return concatLimit$1(coll, 1, iteratee, callback);
    }
    var concatSeries$1 = awaitify(concatSeries, 3);
    /**
     * Returns a function that when called, calls-back with the values provided.
     * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to
     * [`auto`]{@link module:ControlFlow.auto}.
     *
     * @name constant
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {...*} arguments... - Any number of arguments to automatically invoke
     * callback with.
     * @returns {AsyncFunction} Returns a function that when invoked, automatically
     * invokes the callback with the previous given arguments.
     * @example
     *
     * async.waterfall([
     *     async.constant(42),
     *     function (value, next) {
     *         // value === 42
     *     },
     *     //...
     * ], callback);
     *
     * async.waterfall([
     *     async.constant(filename, "utf8"),
     *     fs.readFile,
     *     function (fileData, next) {
     *         //...
     *     }
     *     //...
     * ], callback);
     *
     * async.auto({
     *     hostname: async.constant("https://server.net/"),
     *     port: findFreePort,
     *     launchServer: ["hostname", "port", function (options, cb) {
     *         startServer(options, cb);
     *     }],
     *     //...
     * }, callback);
     */ function constant$1(...args) {
        return function(...ignoredArgs /*, callback*/ ) {
            var callback = ignoredArgs.pop();
            return callback(null, ...args);
        };
    }
    function _createTester(check, getResult) {
        return (eachfn, arr, _iteratee, cb)=>{
            var testPassed = false;
            var testResult;
            const iteratee = wrapAsync(_iteratee);
            eachfn(arr, (value, _, callback)=>{
                iteratee(value, (err, result)=>{
                    if (err || err === false) return callback(err);
                    if (check(result) && !testResult) {
                        testPassed = true;
                        testResult = getResult(true, value);
                        return callback(null, breakLoop);
                    }
                    callback();
                });
            }, (err)=>{
                if (err) return cb(err);
                cb(null, testPassed ? testResult : getResult(false));
            });
        };
    }
    /**
     * Returns the first value in `coll` that passes an async truth test. The
     * `iteratee` is applied in parallel, meaning the first iteratee to return
     * `true` will fire the detect `callback` with that result. That means the
     * result might not be the first item in the original `coll` (in terms of order)
     * that passes the test.

     * If order within the original `coll` is important, then look at
     * [`detectSeries`]{@link module:Collections.detectSeries}.
     *
     * @name detect
     * @static
     * @memberOf module:Collections
     * @method
     * @alias find
     * @category Collections
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
     * The iteratee must complete with a boolean value as its result.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the `iteratee` functions have finished.
     * Result will be the first item in the array that passes the truth test
     * (iteratee) or the value `undefined` if none passed. Invoked with
     * (err, result).
     * @returns {Promise} a promise, if a callback is omitted
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     *
     * // asynchronous function that checks if a file exists
     * function fileExists(file, callback) {
     *    fs.access(file, fs.constants.F_OK, (err) => {
     *        callback(null, !err);
     *    });
     * }
     *
     * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists,
     *    function(err, result) {
     *        console.log(result);
     *        // dir1/file1.txt
     *        // result now equals the first file in the list that exists
     *    }
     *);
     *
     * // Using Promises
     * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists)
     * .then(result => {
     *     console.log(result);
     *     // dir1/file1.txt
     *     // result now equals the first file in the list that exists
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists);
     *         console.log(result);
     *         // dir1/file1.txt
     *         // result now equals the file in the list that exists
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */ function detect(coll, iteratee, callback) {
        return _createTester((bool)=>bool, (res, item)=>item)(eachOf$1, coll, iteratee, callback);
    }
    var detect$1 = awaitify(detect, 3);
    /**
     * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name detectLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.detect]{@link module:Collections.detect}
     * @alias findLimit
     * @category Collections
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
     * The iteratee must complete with a boolean value as its result.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the `iteratee` functions have finished.
     * Result will be the first item in the array that passes the truth test
     * (iteratee) or the value `undefined` if none passed. Invoked with
     * (err, result).
     * @returns {Promise} a promise, if a callback is omitted
     */ function detectLimit(coll, limit, iteratee, callback) {
        return _createTester((bool)=>bool, (res, item)=>item)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var detectLimit$1 = awaitify(detectLimit, 4);
    /**
     * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.
     *
     * @name detectSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.detect]{@link module:Collections.detect}
     * @alias findSeries
     * @category Collections
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
     * The iteratee must complete with a boolean value as its result.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the `iteratee` functions have finished.
     * Result will be the first item in the array that passes the truth test
     * (iteratee) or the value `undefined` if none passed. Invoked with
     * (err, result).
     * @returns {Promise} a promise, if a callback is omitted
     */ function detectSeries(coll, iteratee, callback) {
        return _createTester((bool)=>bool, (res, item)=>item)(eachOfLimit$2(1), coll, iteratee, callback);
    }
    var detectSeries$1 = awaitify(detectSeries, 3);
    function consoleFunc(name) {
        return (fn, ...args)=>wrapAsync(fn)(...args, (err, ...resultArgs)=>{
                /* istanbul ignore else */ if (typeof console === "object") {
                    /* istanbul ignore else */ if (err) {
                        /* istanbul ignore else */ if (console.error) {
                            console.error(err);
                        }
                    } else if (console[name]) {
                        resultArgs.forEach((x)=>console[name](x));
                    }
                }
            });
    }
    /**
     * Logs the result of an [`async` function]{@link AsyncFunction} to the
     * `console` using `console.dir` to display the properties of the resulting object.
     * Only works in Node.js or in browsers that support `console.dir` and
     * `console.error` (such as FF and Chrome).
     * If multiple arguments are returned from the async function,
     * `console.dir` is called on each argument in order.
     *
     * @name dir
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} function - The function you want to eventually apply
     * all arguments to.
     * @param {...*} arguments... - Any number of arguments to apply to the function.
     * @example
     *
     * // in a module
     * var hello = function(name, callback) {
     *     setTimeout(function() {
     *         callback(null, {hello: name});
     *     }, 1000);
     * };
     *
     * // in the node repl
     * node> async.dir(hello, 'world');
     * {hello: 'world'}
     */ var dir = consoleFunc("dir");
    /**
     * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in
     * the order of operations, the arguments `test` and `iteratee` are switched.
     *
     * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.
     *
     * @name doWhilst
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.whilst]{@link module:ControlFlow.whilst}
     * @category Control Flow
     * @param {AsyncFunction} iteratee - A function which is called each time `test`
     * passes. Invoked with (callback).
     * @param {AsyncFunction} test - asynchronous truth test to perform after each
     * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the
     * non-error args from the previous callback of `iteratee`.
     * @param {Function} [callback] - A callback which is called after the test
     * function has failed and repeated execution of `iteratee` has stopped.
     * `callback` will be passed an error and any arguments passed to the final
     * `iteratee`'s callback. Invoked with (err, [results]);
     * @returns {Promise} a promise, if no callback is passed
     */ function doWhilst(iteratee, test, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results;
        function next(err, ...args) {
            if (err) return callback(err);
            if (err === false) return;
            results = args;
            _test(...args, check);
        }
        function check(err, truth) {
            if (err) return callback(err);
            if (err === false) return;
            if (!truth) return callback(null, ...results);
            _fn(next);
        }
        return check(null, true);
    }
    var doWhilst$1 = awaitify(doWhilst, 3);
    /**
     * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the
     * argument ordering differs from `until`.
     *
     * @name doUntil
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}
     * @category Control Flow
     * @param {AsyncFunction} iteratee - An async function which is called each time
     * `test` fails. Invoked with (callback).
     * @param {AsyncFunction} test - asynchronous truth test to perform after each
     * execution of `iteratee`. Invoked with (...args, callback), where `...args` are the
     * non-error args from the previous callback of `iteratee`
     * @param {Function} [callback] - A callback which is called after the test
     * function has passed and repeated execution of `iteratee` has stopped. `callback`
     * will be passed an error and any arguments passed to the final `iteratee`'s
     * callback. Invoked with (err, [results]);
     * @returns {Promise} a promise, if no callback is passed
     */ function doUntil(iteratee, test, callback) {
        const _test = wrapAsync(test);
        return doWhilst$1(iteratee, (...args)=>{
            const cb = args.pop();
            _test(...args, (err, truth)=>cb(err, !truth));
        }, callback);
    }
    function _withoutIndex(iteratee) {
        return (value, index, callback)=>iteratee(value, callback);
    }
    /**
     * Applies the function `iteratee` to each item in `coll`, in parallel.
     * The `iteratee` is called with an item from the list, and a callback for when
     * it has finished. If the `iteratee` passes an error to its `callback`, the
     * main `callback` (for the `each` function) is immediately called with the
     * error.
     *
     * Note, that since this function applies `iteratee` to each item in parallel,
     * there is no guarantee that the iteratee functions will complete in order.
     *
     * @name each
     * @static
     * @memberOf module:Collections
     * @method
     * @alias forEach
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to
     * each item in `coll`. Invoked with (item, callback).
     * The array index is not passed to the iteratee.
     * If you need the index, use `eachOf`.
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     * // dir4 does not exist
     *
     * const fileList = [ 'dir1/file2.txt', 'dir2/file3.txt', 'dir/file5.txt'];
     * const withMissingFileList = ['dir1/file1.txt', 'dir4/file2.txt'];
     *
     * // asynchronous function that deletes a file
     * const deleteFile = function(file, callback) {
     *     fs.unlink(file, callback);
     * };
     *
     * // Using callbacks
     * async.each(fileList, deleteFile, function(err) {
     *     if( err ) {
     *         console.log(err);
     *     } else {
     *         console.log('All files have been deleted successfully');
     *     }
     * });
     *
     * // Error Handling
     * async.each(withMissingFileList, deleteFile, function(err){
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     *     // since dir4/file2.txt does not exist
     *     // dir1/file1.txt could have been deleted
     * });
     *
     * // Using Promises
     * async.each(fileList, deleteFile)
     * .then( () => {
     *     console.log('All files have been deleted successfully');
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Error Handling
     * async.each(fileList, deleteFile)
     * .then( () => {
     *     console.log('All files have been deleted successfully');
     * }).catch( err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     *     // since dir4/file2.txt does not exist
     *     // dir1/file1.txt could have been deleted
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         await async.each(files, deleteFile);
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // Error Handling
     * async () => {
     *     try {
     *         await async.each(withMissingFileList, deleteFile);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *         // since dir4/file2.txt does not exist
     *         // dir1/file1.txt could have been deleted
     *     }
     * }
     *
     */ function eachLimit$2(coll, iteratee, callback) {
        return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var each = awaitify(eachLimit$2, 3);
    /**
     * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.
     *
     * @name eachLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.each]{@link module:Collections.each}
     * @alias forEachLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The array index is not passed to the iteratee.
     * If you need the index, use `eachOfLimit`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     */ function eachLimit(coll, limit, iteratee, callback) {
        return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var eachLimit$1 = awaitify(eachLimit, 4);
    /**
     * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
     *
     * Note, that unlike [`each`]{@link module:Collections.each}, this function applies iteratee to each item
     * in series and therefore the iteratee functions will complete in order.

     * @name eachSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.each]{@link module:Collections.each}
     * @alias forEachSeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each
     * item in `coll`.
     * The array index is not passed to the iteratee.
     * If you need the index, use `eachOfSeries`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called when all
     * `iteratee` functions have finished, or an error occurs. Invoked with (err).
     * @returns {Promise} a promise, if a callback is omitted
     */ function eachSeries(coll, iteratee, callback) {
        return eachLimit$1(coll, 1, iteratee, callback);
    }
    var eachSeries$1 = awaitify(eachSeries, 3);
    /**
     * Wrap an async function and ensure it calls its callback on a later tick of
     * the event loop.  If the function already calls its callback on a next tick,
     * no extra deferral is added. This is useful for preventing stack overflows
     * (`RangeError: Maximum call stack size exceeded`) and generally keeping
     * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)
     * contained. ES2017 `async` functions are returned as-is -- they are immune
     * to Zalgo's corrupting influences, as they always resolve on a later tick.
     *
     * @name ensureAsync
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} fn - an async function, one that expects a node-style
     * callback as its last argument.
     * @returns {AsyncFunction} Returns a wrapped function with the exact same call
     * signature as the function passed in.
     * @example
     *
     * function sometimesAsync(arg, callback) {
     *     if (cache[arg]) {
     *         return callback(null, cache[arg]); // this would be synchronous!!
     *     } else {
     *         doSomeIO(arg, callback); // this IO would be asynchronous
     *     }
     * }
     *
     * // this has a risk of stack overflows if many results are cached in a row
     * async.mapSeries(args, sometimesAsync, done);
     *
     * // this will defer sometimesAsync's callback if necessary,
     * // preventing stack overflows
     * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
     */ function ensureAsync(fn) {
        if (isAsync(fn)) return fn;
        return function(...args /*, callback*/ ) {
            var callback = args.pop();
            var sync = true;
            args.push((...innerArgs)=>{
                if (sync) {
                    setImmediate$1(()=>callback(...innerArgs));
                } else {
                    callback(...innerArgs);
                }
            });
            fn.apply(this, args);
            sync = false;
        };
    }
    /**
     * Returns `true` if every element in `coll` satisfies an async test. If any
     * iteratee call returns `false`, the main `callback` is immediately called.
     *
     * @name every
     * @static
     * @memberOf module:Collections
     * @method
     * @alias all
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collection in parallel.
     * The iteratee must complete with a boolean result value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result will be either `true` or `false`
     * depending on the values of the async tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     * // dir4 does not exist
     *
     * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file5.txt'];
     * const withMissingFileList = ['file1.txt','file2.txt','file4.txt'];
     *
     * // asynchronous function that checks if a file exists
     * function fileExists(file, callback) {
     *    fs.access(file, fs.constants.F_OK, (err) => {
     *        callback(null, !err);
     *    });
     * }
     *
     * // Using callbacks
     * async.every(fileList, fileExists, function(err, result) {
     *     console.log(result);
     *     // true
     *     // result is true since every file exists
     * });
     *
     * async.every(withMissingFileList, fileExists, function(err, result) {
     *     console.log(result);
     *     // false
     *     // result is false since NOT every file exists
     * });
     *
     * // Using Promises
     * async.every(fileList, fileExists)
     * .then( result => {
     *     console.log(result);
     *     // true
     *     // result is true since every file exists
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * async.every(withMissingFileList, fileExists)
     * .then( result => {
     *     console.log(result);
     *     // false
     *     // result is false since NOT every file exists
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.every(fileList, fileExists);
     *         console.log(result);
     *         // true
     *         // result is true since every file exists
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * async () => {
     *     try {
     *         let result = await async.every(withMissingFileList, fileExists);
     *         console.log(result);
     *         // false
     *         // result is false since NOT every file exists
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */ function every(coll, iteratee, callback) {
        return _createTester((bool)=>!bool, (res)=>!res)(eachOf$1, coll, iteratee, callback);
    }
    var every$1 = awaitify(every, 3);
    /**
     * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.
     *
     * @name everyLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.every]{@link module:Collections.every}
     * @alias allLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collection in parallel.
     * The iteratee must complete with a boolean result value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result will be either `true` or `false`
     * depending on the values of the async tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     */ function everyLimit(coll, limit, iteratee, callback) {
        return _createTester((bool)=>!bool, (res)=>!res)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var everyLimit$1 = awaitify(everyLimit, 4);
    /**
     * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.
     *
     * @name everySeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.every]{@link module:Collections.every}
     * @alias allSeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collection in series.
     * The iteratee must complete with a boolean result value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result will be either `true` or `false`
     * depending on the values of the async tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     */ function everySeries(coll, iteratee, callback) {
        return _createTester((bool)=>!bool, (res)=>!res)(eachOfSeries$1, coll, iteratee, callback);
    }
    var everySeries$1 = awaitify(everySeries, 3);
    function filterArray(eachfn, arr, iteratee, callback) {
        var truthValues = new Array(arr.length);
        eachfn(arr, (x, index, iterCb)=>{
            iteratee(x, (err, v)=>{
                truthValues[index] = !!v;
                iterCb(err);
            });
        }, (err)=>{
            if (err) return callback(err);
            var results = [];
            for(var i = 0; i < arr.length; i++){
                if (truthValues[i]) results.push(arr[i]);
            }
            callback(null, results);
        });
    }
    function filterGeneric(eachfn, coll, iteratee, callback) {
        var results = [];
        eachfn(coll, (x, index, iterCb)=>{
            iteratee(x, (err, v)=>{
                if (err) return iterCb(err);
                if (v) {
                    results.push({
                        index,
                        value: x
                    });
                }
                iterCb(err);
            });
        }, (err)=>{
            if (err) return callback(err);
            callback(null, results.sort((a, b)=>a.index - b.index).map((v)=>v.value));
        });
    }
    function _filter(eachfn, coll, iteratee, callback) {
        var filter = isArrayLike(coll) ? filterArray : filterGeneric;
        return filter(eachfn, coll, wrapAsync(iteratee), callback);
    }
    /**
     * Returns a new array of all the values in `coll` which pass an async truth
     * test. This operation is performed in parallel, but the results array will be
     * in the same order as the original.
     *
     * @name filter
     * @static
     * @memberOf module:Collections
     * @method
     * @alias select
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {Function} iteratee - A truth test to apply to each item in `coll`.
     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
     * with a boolean argument once it has completed. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback provided
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     *
     * const files = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];
     *
     * // asynchronous function that checks if a file exists
     * function fileExists(file, callback) {
     *    fs.access(file, fs.constants.F_OK, (err) => {
     *        callback(null, !err);
     *    });
     * }
     *
     * // Using callbacks
     * async.filter(files, fileExists, function(err, results) {
     *    if(err) {
     *        console.log(err);
     *    } else {
     *        console.log(results);
     *        // [ 'dir1/file1.txt', 'dir2/file3.txt' ]
     *        // results is now an array of the existing files
     *    }
     * });
     *
     * // Using Promises
     * async.filter(files, fileExists)
     * .then(results => {
     *     console.log(results);
     *     // [ 'dir1/file1.txt', 'dir2/file3.txt' ]
     *     // results is now an array of the existing files
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let results = await async.filter(files, fileExists);
     *         console.log(results);
     *         // [ 'dir1/file1.txt', 'dir2/file3.txt' ]
     *         // results is now an array of the existing files
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */ function filter(coll, iteratee, callback) {
        return _filter(eachOf$1, coll, iteratee, callback);
    }
    var filter$1 = awaitify(filter, 3);
    /**
     * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name filterLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.filter]{@link module:Collections.filter}
     * @alias selectLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {Function} iteratee - A truth test to apply to each item in `coll`.
     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
     * with a boolean argument once it has completed. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback provided
     */ function filterLimit(coll, limit, iteratee, callback) {
        return _filter(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var filterLimit$1 = awaitify(filterLimit, 4);
    /**
     * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.
     *
     * @name filterSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.filter]{@link module:Collections.filter}
     * @alias selectSeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {Function} iteratee - A truth test to apply to each item in `coll`.
     * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
     * with a boolean argument once it has completed. Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results)
     * @returns {Promise} a promise, if no callback provided
     */ function filterSeries(coll, iteratee, callback) {
        return _filter(eachOfSeries$1, coll, iteratee, callback);
    }
    var filterSeries$1 = awaitify(filterSeries, 3);
    /**
     * Calls the asynchronous function `fn` with a callback parameter that allows it
     * to call itself again, in series, indefinitely.

     * If an error is passed to the callback then `errback` is called with the
     * error, and execution stops, otherwise it will never be called.
     *
     * @name forever
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {AsyncFunction} fn - an async function to call repeatedly.
     * Invoked with (next).
     * @param {Function} [errback] - when `fn` passes an error to it's callback,
     * this function will be called, and execution stops. Invoked with (err).
     * @returns {Promise} a promise that rejects if an error occurs and an errback
     * is not passed
     * @example
     *
     * async.forever(
     *     function(next) {
     *         // next is suitable for passing to things that need a callback(err [, whatever]);
     *         // it will result in this function being called again.
     *     },
     *     function(err) {
     *         // if next is called with a value in its first parameter, it will appear
     *         // in here as 'err', and execution will stop.
     *     }
     * );
     */ function forever(fn, errback) {
        var done = onlyOnce(errback);
        var task = wrapAsync(ensureAsync(fn));
        function next(err) {
            if (err) return done(err);
            if (err === false) return;
            task(next);
        }
        return next();
    }
    var forever$1 = awaitify(forever, 2);
    /**
     * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.
     *
     * @name groupByLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.groupBy]{@link module:Collections.groupBy}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with a `key` to group the value under.
     * Invoked with (value, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Result is an `Object` whoses
     * properties are arrays of values which returned the corresponding key.
     * @returns {Promise} a promise, if no callback is passed
     */ function groupByLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb)=>{
            _iteratee(val, (err, key)=>{
                if (err) return iterCb(err);
                return iterCb(err, {
                    key,
                    val
                });
            });
        }, (err, mapResults)=>{
            var result = {};
            // from MDN, handle object having an `hasOwnProperty` prop
            var { hasOwnProperty } = Object.prototype;
            for(var i = 0; i < mapResults.length; i++){
                if (mapResults[i]) {
                    var { key } = mapResults[i];
                    var { val } = mapResults[i];
                    if (hasOwnProperty.call(result, key)) {
                        result[key].push(val);
                    } else {
                        result[key] = [
                            val
                        ];
                    }
                }
            }
            return callback(err, result);
        });
    }
    var groupByLimit$1 = awaitify(groupByLimit, 4);
    /**
     * Returns a new object, where each value corresponds to an array of items, from
     * `coll`, that returned the corresponding key. That is, the keys of the object
     * correspond to the values passed to the `iteratee` callback.
     *
     * Note: Since this function applies the `iteratee` to each item in parallel,
     * there is no guarantee that the `iteratee` functions will complete in order.
     * However, the values for each key in the `result` will be in the same order as
     * the original `coll`. For Objects, the values will roughly be in the order of
     * the original Objects' keys (but this can vary across JavaScript engines).
     *
     * @name groupBy
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with a `key` to group the value under.
     * Invoked with (value, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Result is an `Object` whoses
     * properties are arrays of values which returned the corresponding key.
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     * // dir4 does not exist
     *
     * const files = ['dir1/file1.txt','dir2','dir4']
     *
     * // asynchronous function that detects file type as none, file, or directory
     * function detectFile(file, callback) {
     *     fs.stat(file, function(err, stat) {
     *         if (err) {
     *             return callback(null, 'none');
     *         }
     *         callback(null, stat.isDirectory() ? 'directory' : 'file');
     *     });
     * }
     *
     * //Using callbacks
     * async.groupBy(files, detectFile, function(err, result) {
     *     if(err) {
     *         console.log(err);
     *     } else {
     *	       console.log(result);
     *         // {
     *         //     file: [ 'dir1/file1.txt' ],
     *         //     none: [ 'dir4' ],
     *         //     directory: [ 'dir2']
     *         // }
     *         // result is object containing the files grouped by type
     *     }
     * });
     *
     * // Using Promises
     * async.groupBy(files, detectFile)
     * .then( result => {
     *     console.log(result);
     *     // {
     *     //     file: [ 'dir1/file1.txt' ],
     *     //     none: [ 'dir4' ],
     *     //     directory: [ 'dir2']
     *     // }
     *     // result is object containing the files grouped by type
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.groupBy(files, detectFile);
     *         console.log(result);
     *         // {
     *         //     file: [ 'dir1/file1.txt' ],
     *         //     none: [ 'dir4' ],
     *         //     directory: [ 'dir2']
     *         // }
     *         // result is object containing the files grouped by type
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */ function groupBy(coll, iteratee, callback) {
        return groupByLimit$1(coll, Infinity, iteratee, callback);
    }
    /**
     * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.
     *
     * @name groupBySeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.groupBy]{@link module:Collections.groupBy}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with a `key` to group the value under.
     * Invoked with (value, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. Result is an `Object` whose
     * properties are arrays of values which returned the corresponding key.
     * @returns {Promise} a promise, if no callback is passed
     */ function groupBySeries(coll, iteratee, callback) {
        return groupByLimit$1(coll, 1, iteratee, callback);
    }
    /**
     * Logs the result of an `async` function to the `console`. Only works in
     * Node.js or in browsers that support `console.log` and `console.error` (such
     * as FF and Chrome). If multiple arguments are returned from the async
     * function, `console.log` is called on each argument in order.
     *
     * @name log
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} function - The function you want to eventually apply
     * all arguments to.
     * @param {...*} arguments... - Any number of arguments to apply to the function.
     * @example
     *
     * // in a module
     * var hello = function(name, callback) {
     *     setTimeout(function() {
     *         callback(null, 'hello ' + name);
     *     }, 1000);
     * };
     *
     * // in the node repl
     * node> async.log(hello, 'world');
     * 'hello world'
     */ var log = consoleFunc("log");
    /**
     * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name mapValuesLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.mapValues]{@link module:Collections.mapValues}
     * @category Collection
     * @param {Object} obj - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - A function to apply to each value and key
     * in `coll`.
     * The iteratee should complete with the transformed value as its result.
     * Invoked with (value, key, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. `result` is a new object consisting
     * of each key from `obj`, with each transformed value on the right-hand side.
     * Invoked with (err, result).
     * @returns {Promise} a promise, if no callback is passed
     */ function mapValuesLimit(obj, limit, iteratee, callback) {
        callback = once(callback);
        var newObj = {};
        var _iteratee = wrapAsync(iteratee);
        return eachOfLimit$2(limit)(obj, (val, key, next)=>{
            _iteratee(val, key, (err, result)=>{
                if (err) return next(err);
                newObj[key] = result;
                next(err);
            });
        }, (err)=>callback(err, newObj));
    }
    var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
    /**
     * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.
     *
     * Produces a new Object by mapping each value of `obj` through the `iteratee`
     * function. The `iteratee` is called each `value` and `key` from `obj` and a
     * callback for when it has finished processing. Each of these callbacks takes
     * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`
     * passes an error to its callback, the main `callback` (for the `mapValues`
     * function) is immediately called with the error.
     *
     * Note, the order of the keys in the result is not guaranteed.  The keys will
     * be roughly in the order they complete, (but this is very engine-specific)
     *
     * @name mapValues
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Object} obj - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each value and key
     * in `coll`.
     * The iteratee should complete with the transformed value as its result.
     * Invoked with (value, key, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. `result` is a new object consisting
     * of each key from `obj`, with each transformed value on the right-hand side.
     * Invoked with (err, result).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * // file1.txt is a file that is 1000 bytes in size
     * // file2.txt is a file that is 2000 bytes in size
     * // file3.txt is a file that is 3000 bytes in size
     * // file4.txt does not exist
     *
     * const fileMap = {
     *     f1: 'file1.txt',
     *     f2: 'file2.txt',
     *     f3: 'file3.txt'
     * };
     *
     * const withMissingFileMap = {
     *     f1: 'file1.txt',
     *     f2: 'file2.txt',
     *     f3: 'file4.txt'
     * };
     *
     * // asynchronous function that returns the file size in bytes
     * function getFileSizeInBytes(file, key, callback) {
     *     fs.stat(file, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         callback(null, stat.size);
     *     });
     * }
     *
     * // Using callbacks
     * async.mapValues(fileMap, getFileSizeInBytes, function(err, result) {
     *     if (err) {
     *         console.log(err);
     *     } else {
     *         console.log(result);
     *         // result is now a map of file size in bytes for each file, e.g.
     *         // {
     *         //     f1: 1000,
     *         //     f2: 2000,
     *         //     f3: 3000
     *         // }
     *     }
     * });
     *
     * // Error handling
     * async.mapValues(withMissingFileMap, getFileSizeInBytes, function(err, result) {
     *     if (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     } else {
     *         console.log(result);
     *     }
     * });
     *
     * // Using Promises
     * async.mapValues(fileMap, getFileSizeInBytes)
     * .then( result => {
     *     console.log(result);
     *     // result is now a map of file size in bytes for each file, e.g.
     *     // {
     *     //     f1: 1000,
     *     //     f2: 2000,
     *     //     f3: 3000
     *     // }
     * }).catch (err => {
     *     console.log(err);
     * });
     *
     * // Error Handling
     * async.mapValues(withMissingFileMap, getFileSizeInBytes)
     * .then( result => {
     *     console.log(result);
     * }).catch (err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.mapValues(fileMap, getFileSizeInBytes);
     *         console.log(result);
     *         // result is now a map of file size in bytes for each file, e.g.
     *         // {
     *         //     f1: 1000,
     *         //     f2: 2000,
     *         //     f3: 3000
     *         // }
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // Error Handling
     * async () => {
     *     try {
     *         let result = await async.mapValues(withMissingFileMap, getFileSizeInBytes);
     *         console.log(result);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     }
     * }
     *
     */ function mapValues(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, Infinity, iteratee, callback);
    }
    /**
     * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.
     *
     * @name mapValuesSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.mapValues]{@link module:Collections.mapValues}
     * @category Collection
     * @param {Object} obj - A collection to iterate over.
     * @param {AsyncFunction} iteratee - A function to apply to each value and key
     * in `coll`.
     * The iteratee should complete with the transformed value as its result.
     * Invoked with (value, key, callback).
     * @param {Function} [callback] - A callback which is called when all `iteratee`
     * functions have finished, or an error occurs. `result` is a new object consisting
     * of each key from `obj`, with each transformed value on the right-hand side.
     * Invoked with (err, result).
     * @returns {Promise} a promise, if no callback is passed
     */ function mapValuesSeries(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, 1, iteratee, callback);
    }
    /**
     * Caches the results of an async function. When creating a hash to store
     * function results against, the callback is omitted from the hash and an
     * optional hash function can be used.
     *
     * **Note: if the async function errs, the result will not be cached and
     * subsequent calls will call the wrapped function.**
     *
     * If no hash function is specified, the first argument is used as a hash key,
     * which may work reasonably if it is a string or a data type that converts to a
     * distinct string. Note that objects and arrays will not behave reasonably.
     * Neither will cases where the other arguments are significant. In such cases,
     * specify your own hash function.
     *
     * The cache of results is exposed as the `memo` property of the function
     * returned by `memoize`.
     *
     * @name memoize
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} fn - The async function to proxy and cache results from.
     * @param {Function} hasher - An optional function for generating a custom hash
     * for storing results. It has all the arguments applied to it apart from the
     * callback, and must be synchronous.
     * @returns {AsyncFunction} a memoized version of `fn`
     * @example
     *
     * var slow_fn = function(name, callback) {
     *     // do something
     *     callback(null, result);
     * };
     * var fn = async.memoize(slow_fn);
     *
     * // fn can now be used as if it were slow_fn
     * fn('some name', function() {
     *     // callback
     * });
     */ function memoize(fn, hasher = (v)=>v) {
        var memo = Object.create(null);
        var queues = Object.create(null);
        var _fn = wrapAsync(fn);
        var memoized = initialParams((args, callback)=>{
            var key = hasher(...args);
            if (key in memo) {
                setImmediate$1(()=>callback(null, ...memo[key]));
            } else if (key in queues) {
                queues[key].push(callback);
            } else {
                queues[key] = [
                    callback
                ];
                _fn(...args, (err, ...resultArgs)=>{
                    // #1465 don't memoize if an error occurred
                    if (!err) {
                        memo[key] = resultArgs;
                    }
                    var q = queues[key];
                    delete queues[key];
                    for(var i = 0, l = q.length; i < l; i++){
                        q[i](err, ...resultArgs);
                    }
                });
            }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    }
    /* istanbul ignore file */ /**
     * Calls `callback` on a later loop around the event loop. In Node.js this just
     * calls `process.nextTick`.  In the browser it will use `setImmediate` if
     * available, otherwise `setTimeout(callback, 0)`, which means other higher
     * priority events may precede the execution of `callback`.
     *
     * This is used internally for browser-compatibility purposes.
     *
     * @name nextTick
     * @static
     * @memberOf module:Utils
     * @method
     * @see [async.setImmediate]{@link module:Utils.setImmediate}
     * @category Util
     * @param {Function} callback - The function to call on a later loop around
     * the event loop. Invoked with (args...).
     * @param {...*} args... - any number of additional arguments to pass to the
     * callback on the next tick.
     * @example
     *
     * var call_order = [];
     * async.nextTick(function() {
     *     call_order.push('two');
     *     // call_order now equals ['one','two']
     * });
     * call_order.push('one');
     *
     * async.setImmediate(function (a, b, c) {
     *     // a, b, and c equal 1, 2, and 3
     * }, 1, 2, 3);
     */ var _defer;
    if (hasNextTick) {
        _defer = process.nextTick;
    } else if (hasSetImmediate) {
        _defer = setImmediate;
    } else {
        _defer = fallback;
    }
    var nextTick = wrap(_defer);
    var _parallel = awaitify((eachfn, tasks, callback)=>{
        var results = isArrayLike(tasks) ? [] : {};
        eachfn(tasks, (task, key, taskCb)=>{
            wrapAsync(task)((err, ...result)=>{
                if (result.length < 2) {
                    [result] = result;
                }
                results[key] = result;
                taskCb(err);
            });
        }, (err)=>callback(err, results));
    }, 3);
    /**
     * Run the `tasks` collection of functions in parallel, without waiting until
     * the previous function has completed. If any of the functions pass an error to
     * its callback, the main `callback` is immediately called with the value of the
     * error. Once the `tasks` have completed, the results are passed to the final
     * `callback` as an array.
     *
     * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
     * parallel execution of code.  If your tasks do not use any timers or perform
     * any I/O, they will actually be executed in series.  Any synchronous setup
     * sections for each task will happen one after the other.  JavaScript remains
     * single-threaded.
     *
     * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the
     * execution of other tasks when a task fails.
     *
     * It is also possible to use an object instead of an array. Each property will
     * be run as a function and the results will be passed to the final `callback`
     * as an object instead of an array. This can be a more readable way of handling
     * results from {@link async.parallel}.
     *
     * @name parallel
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of
     * [async functions]{@link AsyncFunction} to run.
     * Each async function can complete with any number of optional `result` values.
     * @param {Function} [callback] - An optional callback to run once all the
     * functions have completed successfully. This function gets a results array
     * (or object) containing all the result arguments passed to the task callbacks.
     * Invoked with (err, results).
     * @returns {Promise} a promise, if a callback is not passed
     *
     * @example
     *
     * //Using Callbacks
     * async.parallel([
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ], function(err, results) {
     *     console.log(results);
     *     // results is equal to ['one','two'] even though
     *     // the second function had a shorter timeout.
     * });
     *
     * // an example using an object instead of an array
     * async.parallel({
     *     one: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 1);
     *         }, 200);
     *     },
     *     two: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 2);
     *         }, 100);
     *     }
     * }, function(err, results) {
     *     console.log(results);
     *     // results is equal to: { one: 1, two: 2 }
     * });
     *
     * //Using Promises
     * async.parallel([
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ]).then(results => {
     *     console.log(results);
     *     // results is equal to ['one','two'] even though
     *     // the second function had a shorter timeout.
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // an example using an object instead of an array
     * async.parallel({
     *     one: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 1);
     *         }, 200);
     *     },
     *     two: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 2);
     *         }, 100);
     *     }
     * }).then(results => {
     *     console.log(results);
     *     // results is equal to: { one: 1, two: 2 }
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * //Using async/await
     * async () => {
     *     try {
     *         let results = await async.parallel([
     *             function(callback) {
     *                 setTimeout(function() {
     *                     callback(null, 'one');
     *                 }, 200);
     *             },
     *             function(callback) {
     *                 setTimeout(function() {
     *                     callback(null, 'two');
     *                 }, 100);
     *             }
     *         ]);
     *         console.log(results);
     *         // results is equal to ['one','two'] even though
     *         // the second function had a shorter timeout.
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // an example using an object instead of an array
     * async () => {
     *     try {
     *         let results = await async.parallel({
     *             one: function(callback) {
     *                 setTimeout(function() {
     *                     callback(null, 1);
     *                 }, 200);
     *             },
     *            two: function(callback) {
     *                 setTimeout(function() {
     *                     callback(null, 2);
     *                 }, 100);
     *            }
     *         });
     *         console.log(results);
     *         // results is equal to: { one: 1, two: 2 }
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */ function parallel(tasks, callback) {
        return _parallel(eachOf$1, tasks, callback);
    }
    /**
     * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name parallelLimit
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.parallel]{@link module:ControlFlow.parallel}
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of
     * [async functions]{@link AsyncFunction} to run.
     * Each async function can complete with any number of optional `result` values.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {Function} [callback] - An optional callback to run once all the
     * functions have completed successfully. This function gets a results array
     * (or object) containing all the result arguments passed to the task callbacks.
     * Invoked with (err, results).
     * @returns {Promise} a promise, if a callback is not passed
     */ function parallelLimit(tasks, limit, callback) {
        return _parallel(eachOfLimit$2(limit), tasks, callback);
    }
    /**
     * A queue of tasks for the worker function to complete.
     * @typedef {Iterable} QueueObject
     * @memberOf module:ControlFlow
     * @property {Function} length - a function returning the number of items
     * waiting to be processed. Invoke with `queue.length()`.
     * @property {boolean} started - a boolean indicating whether or not any
     * items have been pushed and processed by the queue.
     * @property {Function} running - a function returning the number of items
     * currently being processed. Invoke with `queue.running()`.
     * @property {Function} workersList - a function returning the array of items
     * currently being processed. Invoke with `queue.workersList()`.
     * @property {Function} idle - a function returning false if there are items
     * waiting or being processed, or true if not. Invoke with `queue.idle()`.
     * @property {number} concurrency - an integer for determining how many `worker`
     * functions should be run in parallel. This property can be changed after a
     * `queue` is created to alter the concurrency on-the-fly.
     * @property {number} payload - an integer that specifies how many items are
     * passed to the worker function at a time. only applies if this is a
     * [cargo]{@link module:ControlFlow.cargo} object
     * @property {AsyncFunction} push - add a new task to the `queue`. Calls `callback`
     * once the `worker` has finished processing the task. Instead of a single task,
     * a `tasks` array can be submitted. The respective callback is used for every
     * task in the list. Invoke with `queue.push(task, [callback])`,
     * @property {AsyncFunction} unshift - add a new task to the front of the `queue`.
     * Invoke with `queue.unshift(task, [callback])`.
     * @property {AsyncFunction} pushAsync - the same as `q.push`, except this returns
     * a promise that rejects if an error occurs.
     * @property {AsyncFunction} unshiftAsync - the same as `q.unshift`, except this returns
     * a promise that rejects if an error occurs.
     * @property {Function} remove - remove items from the queue that match a test
     * function.  The test function will be passed an object with a `data` property,
     * and a `priority` property, if this is a
     * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.
     * Invoked with `queue.remove(testFn)`, where `testFn` is of the form
     * `function ({data, priority}) {}` and returns a Boolean.
     * @property {Function} saturated - a function that sets a callback that is
     * called when the number of running workers hits the `concurrency` limit, and
     * further tasks will be queued.  If the callback is omitted, `q.saturated()`
     * returns a promise for the next occurrence.
     * @property {Function} unsaturated - a function that sets a callback that is
     * called when the number of running workers is less than the `concurrency` &
     * `buffer` limits, and further tasks will not be queued. If the callback is
     * omitted, `q.unsaturated()` returns a promise for the next occurrence.
     * @property {number} buffer - A minimum threshold buffer in order to say that
     * the `queue` is `unsaturated`.
     * @property {Function} empty - a function that sets a callback that is called
     * when the last item from the `queue` is given to a `worker`. If the callback
     * is omitted, `q.empty()` returns a promise for the next occurrence.
     * @property {Function} drain - a function that sets a callback that is called
     * when the last item from the `queue` has returned from the `worker`. If the
     * callback is omitted, `q.drain()` returns a promise for the next occurrence.
     * @property {Function} error - a function that sets a callback that is called
     * when a task errors. Has the signature `function(error, task)`. If the
     * callback is omitted, `error()` returns a promise that rejects on the next
     * error.
     * @property {boolean} paused - a boolean for determining whether the queue is
     * in a paused state.
     * @property {Function} pause - a function that pauses the processing of tasks
     * until `resume()` is called. Invoke with `queue.pause()`.
     * @property {Function} resume - a function that resumes the processing of
     * queued tasks when the queue is paused. Invoke with `queue.resume()`.
     * @property {Function} kill - a function that removes the `drain` callback and
     * empties remaining tasks from the queue forcing it to go idle. No more tasks
     * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.
     *
     * @example
     * const q = async.queue(worker, 2)
     * q.push(item1)
     * q.push(item2)
     * q.push(item3)
     * // queues are iterable, spread into an array to inspect
     * const items = [...q] // [item1, item2, item3]
     * // or use for of
     * for (let item of q) {
     *     console.log(item)
     * }
     *
     * q.drain(() => {
     *     console.log('all done')
     * })
     * // or
     * await q.drain()
     */ /**
     * Creates a `queue` object with the specified `concurrency`. Tasks added to the
     * `queue` are processed in parallel (up to the `concurrency` limit). If all
     * `worker`s are in progress, the task is queued until one becomes available.
     * Once a `worker` completes a `task`, that `task`'s callback is called.
     *
     * @name queue
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {AsyncFunction} worker - An async function for processing a queued task.
     * If you want to handle errors from an individual task, pass a callback to
     * `q.push()`. Invoked with (task, callback).
     * @param {number} [concurrency=1] - An `integer` for determining how many
     * `worker` functions should be run in parallel.  If omitted, the concurrency
     * defaults to `1`.  If the concurrency is `0`, an error is thrown.
     * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can be
     * attached as certain properties to listen for specific events during the
     * lifecycle of the queue.
     * @example
     *
     * // create a queue object with concurrency 2
     * var q = async.queue(function(task, callback) {
     *     console.log('hello ' + task.name);
     *     callback();
     * }, 2);
     *
     * // assign a callback
     * q.drain(function() {
     *     console.log('all items have been processed');
     * });
     * // or await the end
     * await q.drain()
     *
     * // assign an error callback
     * q.error(function(err, task) {
     *     console.error('task experienced an error');
     * });
     *
     * // add some items to the queue
     * q.push({name: 'foo'}, function(err) {
     *     console.log('finished processing foo');
     * });
     * // callback is optional
     * q.push({name: 'bar'});
     *
     * // add some items to the queue (batch-wise)
     * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
     *     console.log('finished processing item');
     * });
     *
     * // add some items to the front of the queue
     * q.unshift({name: 'bar'}, function (err) {
     *     console.log('finished processing bar');
     * });
     */ function queue(worker, concurrency) {
        var _worker = wrapAsync(worker);
        return queue$1((items, cb)=>{
            _worker(items[0], cb);
        }, concurrency, 1);
    }
    // Binary min-heap implementation used for priority queue.
    // Implementation is stable, i.e. push time is considered for equal priorities
    class Heap {
        constructor(){
            this.heap = [];
            this.pushCount = Number.MIN_SAFE_INTEGER;
        }
        get length() {
            return this.heap.length;
        }
        empty() {
            this.heap = [];
            return this;
        }
        percUp(index) {
            let p;
            while(index > 0 && smaller(this.heap[index], this.heap[p = parent(index)])){
                let t = this.heap[index];
                this.heap[index] = this.heap[p];
                this.heap[p] = t;
                index = p;
            }
        }
        percDown(index) {
            let l;
            while((l = leftChi(index)) < this.heap.length){
                if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
                    l = l + 1;
                }
                if (smaller(this.heap[index], this.heap[l])) {
                    break;
                }
                let t = this.heap[index];
                this.heap[index] = this.heap[l];
                this.heap[l] = t;
                index = l;
            }
        }
        push(node) {
            node.pushCount = ++this.pushCount;
            this.heap.push(node);
            this.percUp(this.heap.length - 1);
        }
        unshift(node) {
            return this.heap.push(node);
        }
        shift() {
            let [top] = this.heap;
            this.heap[0] = this.heap[this.heap.length - 1];
            this.heap.pop();
            this.percDown(0);
            return top;
        }
        toArray() {
            return [
                ...this
            ];
        }
        *[Symbol.iterator]() {
            for(let i = 0; i < this.heap.length; i++){
                yield this.heap[i].data;
            }
        }
        remove(testFn) {
            let j = 0;
            for(let i = 0; i < this.heap.length; i++){
                if (!testFn(this.heap[i])) {
                    this.heap[j] = this.heap[i];
                    j++;
                }
            }
            this.heap.splice(j);
            for(let i = parent(this.heap.length - 1); i >= 0; i--){
                this.percDown(i);
            }
            return this;
        }
    }
    function leftChi(i) {
        return (i << 1) + 1;
    }
    function parent(i) {
        return (i + 1 >> 1) - 1;
    }
    function smaller(x, y) {
        if (x.priority !== y.priority) {
            return x.priority < y.priority;
        } else {
            return x.pushCount < y.pushCount;
        }
    }
    /**
     * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and
     * completed in ascending priority order.
     *
     * @name priorityQueue
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.queue]{@link module:ControlFlow.queue}
     * @category Control Flow
     * @param {AsyncFunction} worker - An async function for processing a queued task.
     * If you want to handle errors from an individual task, pass a callback to
     * `q.push()`.
     * Invoked with (task, callback).
     * @param {number} concurrency - An `integer` for determining how many `worker`
     * functions should be run in parallel.  If omitted, the concurrency defaults to
     * `1`.  If the concurrency is `0`, an error is thrown.
     * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are three
     * differences between `queue` and `priorityQueue` objects:
     * * `push(task, priority, [callback])` - `priority` should be a number. If an
     *   array of `tasks` is given, all tasks will be assigned the same priority.
     * * `pushAsync(task, priority, [callback])` - the same as `priorityQueue.push`,
     *   except this returns a promise that rejects if an error occurs.
     * * The `unshift` and `unshiftAsync` methods were removed.
     */ function priorityQueue(worker, concurrency) {
        // Start with a normal queue
        var q = queue(worker, concurrency);
        var { push, pushAsync } = q;
        q._tasks = new Heap();
        q._createTaskItem = ({ data, priority }, callback)=>{
            return {
                data,
                priority,
                callback
            };
        };
        function createDataItems(tasks, priority) {
            if (!Array.isArray(tasks)) {
                return {
                    data: tasks,
                    priority
                };
            }
            return tasks.map((data)=>{
                return {
                    data,
                    priority
                };
            });
        }
        // Override push to accept second parameter representing priority
        q.push = function(data, priority = 0, callback) {
            return push(createDataItems(data, priority), callback);
        };
        q.pushAsync = function(data, priority = 0, callback) {
            return pushAsync(createDataItems(data, priority), callback);
        };
        // Remove unshift functions
        delete q.unshift;
        delete q.unshiftAsync;
        return q;
    }
    /**
     * Runs the `tasks` array of functions in parallel, without waiting until the
     * previous function has completed. Once any of the `tasks` complete or pass an
     * error to its callback, the main `callback` is immediately called. It's
     * equivalent to `Promise.race()`.
     *
     * @name race
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}
     * to run. Each function can complete with an optional `result` value.
     * @param {Function} callback - A callback to run once any of the functions have
     * completed. This function gets an error or result from the first function that
     * completed. Invoked with (err, result).
     * @returns {Promise} a promise, if a callback is omitted
     * @example
     *
     * async.race([
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ],
     * // main callback
     * function(err, result) {
     *     // the result will be equal to 'two' as it finishes earlier
     * });
     */ function race(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks)) return callback(new TypeError("First argument to race must be an array of functions"));
        if (!tasks.length) return callback();
        for(var i = 0, l = tasks.length; i < l; i++){
            wrapAsync(tasks[i])(callback);
        }
    }
    var race$1 = awaitify(race, 2);
    /**
     * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.
     *
     * @name reduceRight
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.reduce]{@link module:Collections.reduce}
     * @alias foldr
     * @category Collection
     * @param {Array} array - A collection to iterate over.
     * @param {*} memo - The initial state of the reduction.
     * @param {AsyncFunction} iteratee - A function applied to each item in the
     * array to produce the next step in the reduction.
     * The `iteratee` should complete with the next state of the reduction.
     * If the iteratee completes with an error, the reduction is stopped and the
     * main `callback` is immediately called with the error.
     * Invoked with (memo, item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result is the reduced value. Invoked with
     * (err, result).
     * @returns {Promise} a promise, if no callback is passed
     */ function reduceRight(array, memo, iteratee, callback) {
        var reversed = [
            ...array
        ].reverse();
        return reduce$1(reversed, memo, iteratee, callback);
    }
    /**
     * Wraps the async function in another function that always completes with a
     * result object, even when it errors.
     *
     * The result object has either the property `error` or `value`.
     *
     * @name reflect
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} fn - The async function you want to wrap
     * @returns {Function} - A function that always passes null to it's callback as
     * the error. The second argument to the callback will be an `object` with
     * either an `error` or a `value` property.
     * @example
     *
     * async.parallel([
     *     async.reflect(function(callback) {
     *         // do some stuff ...
     *         callback(null, 'one');
     *     }),
     *     async.reflect(function(callback) {
     *         // do some more stuff but error ...
     *         callback('bad stuff happened');
     *     }),
     *     async.reflect(function(callback) {
     *         // do some more stuff ...
     *         callback(null, 'two');
     *     })
     * ],
     * // optional callback
     * function(err, results) {
     *     // values
     *     // results[0].value = 'one'
     *     // results[1].error = 'bad stuff happened'
     *     // results[2].value = 'two'
     * });
     */ function reflect(fn) {
        var _fn = wrapAsync(fn);
        return initialParams(function reflectOn(args, reflectCallback) {
            args.push((error, ...cbArgs)=>{
                let retVal = {};
                if (error) {
                    retVal.error = error;
                }
                if (cbArgs.length > 0) {
                    var value = cbArgs;
                    if (cbArgs.length <= 1) {
                        [value] = cbArgs;
                    }
                    retVal.value = value;
                }
                reflectCallback(null, retVal);
            });
            return _fn.apply(this, args);
        });
    }
    /**
     * A helper function that wraps an array or an object of functions with `reflect`.
     *
     * @name reflectAll
     * @static
     * @memberOf module:Utils
     * @method
     * @see [async.reflect]{@link module:Utils.reflect}
     * @category Util
     * @param {Array|Object|Iterable} tasks - The collection of
     * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.
     * @returns {Array} Returns an array of async functions, each wrapped in
     * `async.reflect`
     * @example
     *
     * let tasks = [
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         // do some more stuff but error ...
     *         callback(new Error('bad stuff happened'));
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ];
     *
     * async.parallel(async.reflectAll(tasks),
     * // optional callback
     * function(err, results) {
     *     // values
     *     // results[0].value = 'one'
     *     // results[1].error = Error('bad stuff happened')
     *     // results[2].value = 'two'
     * });
     *
     * // an example using an object instead of an array
     * let tasks = {
     *     one: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     two: function(callback) {
     *         callback('two');
     *     },
     *     three: function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'three');
     *         }, 100);
     *     }
     * };
     *
     * async.parallel(async.reflectAll(tasks),
     * // optional callback
     * function(err, results) {
     *     // values
     *     // results.one.value = 'one'
     *     // results.two.error = 'two'
     *     // results.three.value = 'three'
     * });
     */ function reflectAll(tasks) {
        var results;
        if (Array.isArray(tasks)) {
            results = tasks.map(reflect);
        } else {
            results = {};
            Object.keys(tasks).forEach((key)=>{
                results[key] = reflect.call(this, tasks[key]);
            });
        }
        return results;
    }
    function reject$2(eachfn, arr, _iteratee, callback) {
        const iteratee = wrapAsync(_iteratee);
        return _filter(eachfn, arr, (value, cb)=>{
            iteratee(value, (err, v)=>{
                cb(err, !v);
            });
        }, callback);
    }
    /**
     * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.
     *
     * @name reject
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.filter]{@link module:Collections.filter}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {Function} iteratee - An async truth test to apply to each item in
     * `coll`.
     * The should complete with a boolean value as its `result`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     *
     * const fileList = ['dir1/file1.txt','dir2/file3.txt','dir3/file6.txt'];
     *
     * // asynchronous function that checks if a file exists
     * function fileExists(file, callback) {
     *    fs.access(file, fs.constants.F_OK, (err) => {
     *        callback(null, !err);
     *    });
     * }
     *
     * // Using callbacks
     * async.reject(fileList, fileExists, function(err, results) {
     *    // [ 'dir3/file6.txt' ]
     *    // results now equals an array of the non-existing files
     * });
     *
     * // Using Promises
     * async.reject(fileList, fileExists)
     * .then( results => {
     *     console.log(results);
     *     // [ 'dir3/file6.txt' ]
     *     // results now equals an array of the non-existing files
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let results = await async.reject(fileList, fileExists);
     *         console.log(results);
     *         // [ 'dir3/file6.txt' ]
     *         // results now equals an array of the non-existing files
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */ function reject(coll, iteratee, callback) {
        return reject$2(eachOf$1, coll, iteratee, callback);
    }
    var reject$1 = awaitify(reject, 3);
    /**
     * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name rejectLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.reject]{@link module:Collections.reject}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {Function} iteratee - An async truth test to apply to each item in
     * `coll`.
     * The should complete with a boolean value as its `result`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     */ function rejectLimit(coll, limit, iteratee, callback) {
        return reject$2(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var rejectLimit$1 = awaitify(rejectLimit, 4);
    /**
     * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.
     *
     * @name rejectSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.reject]{@link module:Collections.reject}
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {Function} iteratee - An async truth test to apply to each item in
     * `coll`.
     * The should complete with a boolean value as its `result`.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback is passed
     */ function rejectSeries(coll, iteratee, callback) {
        return reject$2(eachOfSeries$1, coll, iteratee, callback);
    }
    var rejectSeries$1 = awaitify(rejectSeries, 3);
    function constant(value) {
        return function() {
            return value;
        };
    }
    /**
     * Attempts to get a successful response from `task` no more than `times` times
     * before returning an error. If the task is successful, the `callback` will be
     * passed the result of the successful task. If all attempts fail, the callback
     * will be passed the error and result (if any) of the final attempt.
     *
     * @name retry
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @see [async.retryable]{@link module:ControlFlow.retryable}
     * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an
     * object with `times` and `interval` or a number.
     * * `times` - The number of attempts to make before giving up.  The default
     *   is `5`.
     * * `interval` - The time to wait between retries, in milliseconds.  The
     *   default is `0`. The interval may also be specified as a function of the
     *   retry count (see example).
     * * `errorFilter` - An optional synchronous function that is invoked on
     *   erroneous result. If it returns `true` the retry attempts will continue;
     *   if the function returns `false` the retry flow is aborted with the current
     *   attempt's error and result being returned to the final callback.
     *   Invoked with (err).
     * * If `opts` is a number, the number specifies the number of times to retry,
     *   with the default interval of `0`.
     * @param {AsyncFunction} task - An async function to retry.
     * Invoked with (callback).
     * @param {Function} [callback] - An optional callback which is called when the
     * task has succeeded, or after the final failed attempt. It receives the `err`
     * and `result` arguments of the last attempt at completing the `task`. Invoked
     * with (err, results).
     * @returns {Promise} a promise if no callback provided
     *
     * @example
     *
     * // The `retry` function can be used as a stand-alone control flow by passing
     * // a callback, as shown below:
     *
     * // try calling apiMethod 3 times
     * async.retry(3, apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // try calling apiMethod 3 times, waiting 200 ms between each retry
     * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // try calling apiMethod 10 times with exponential backoff
     * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
     * async.retry({
     *   times: 10,
     *   interval: function(retryCount) {
     *     return 50 * Math.pow(2, retryCount);
     *   }
     * }, apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // try calling apiMethod the default 5 times no delay between each retry
     * async.retry(apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // try calling apiMethod only when error condition satisfies, all other
     * // errors will abort the retry control flow and return to final callback
     * async.retry({
     *   errorFilter: function(err) {
     *     return err.message === 'Temporary error'; // only retry on a specific error
     *   }
     * }, apiMethod, function(err, result) {
     *     // do something with the result
     * });
     *
     * // to retry individual methods that are not as reliable within other
     * // control flow functions, use the `retryable` wrapper:
     * async.auto({
     *     users: api.getUsers.bind(api),
     *     payments: async.retryable(3, api.getPayments.bind(api))
     * }, function(err, results) {
     *     // do something with the results
     * });
     *
     */ const DEFAULT_TIMES = 5;
    const DEFAULT_INTERVAL = 0;
    function retry(opts, task, callback) {
        var options = {
            times: DEFAULT_TIMES,
            intervalFunc: constant(DEFAULT_INTERVAL)
        };
        if (arguments.length < 3 && typeof opts === "function") {
            callback = task || promiseCallback();
            task = opts;
        } else {
            parseTimes(options, opts);
            callback = callback || promiseCallback();
        }
        if (typeof task !== "function") {
            throw new Error("Invalid arguments for async.retry");
        }
        var _task = wrapAsync(task);
        var attempt = 1;
        function retryAttempt() {
            _task((err, ...args)=>{
                if (err === false) return;
                if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
                    setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
                } else {
                    callback(err, ...args);
                }
            });
        }
        retryAttempt();
        return callback[PROMISE_SYMBOL];
    }
    function parseTimes(acc, t) {
        if (typeof t === "object") {
            acc.times = +t.times || DEFAULT_TIMES;
            acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);
            acc.errorFilter = t.errorFilter;
        } else if (typeof t === "number" || typeof t === "string") {
            acc.times = +t || DEFAULT_TIMES;
        } else {
            throw new Error("Invalid arguments for async.retry");
        }
    }
    /**
     * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method
     * wraps a task and makes it retryable, rather than immediately calling it
     * with retries.
     *
     * @name retryable
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.retry]{@link module:ControlFlow.retry}
     * @category Control Flow
     * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional
     * options, exactly the same as from `retry`, except for a `opts.arity` that
     * is the arity of the `task` function, defaulting to `task.length`
     * @param {AsyncFunction} task - the asynchronous function to wrap.
     * This function will be passed any arguments passed to the returned wrapper.
     * Invoked with (...args, callback).
     * @returns {AsyncFunction} The wrapped function, which when invoked, will
     * retry on an error, based on the parameters specified in `opts`.
     * This function will accept the same parameters as `task`.
     * @example
     *
     * async.auto({
     *     dep1: async.retryable(3, getFromFlakyService),
     *     process: ["dep1", async.retryable(3, function (results, cb) {
     *         maybeProcessData(results.dep1, cb);
     *     })]
     * }, callback);
     */ function retryable(opts, task) {
        if (!task) {
            task = opts;
            opts = null;
        }
        let arity = opts && opts.arity || task.length;
        if (isAsync(task)) {
            arity += 1;
        }
        var _task = wrapAsync(task);
        return initialParams((args, callback)=>{
            if (args.length < arity - 1 || callback == null) {
                args.push(callback);
                callback = promiseCallback();
            }
            function taskFn(cb) {
                _task(...args, cb);
            }
            if (opts) retry(opts, taskFn, callback);
            else retry(taskFn, callback);
            return callback[PROMISE_SYMBOL];
        });
    }
    /**
     * Run the functions in the `tasks` collection in series, each one running once
     * the previous function has completed. If any functions in the series pass an
     * error to its callback, no more functions are run, and `callback` is
     * immediately called with the value of the error. Otherwise, `callback`
     * receives an array of results when `tasks` have completed.
     *
     * It is also possible to use an object instead of an array. Each property will
     * be run as a function, and the results will be passed to the final `callback`
     * as an object instead of an array. This can be a more readable way of handling
     *  results from {@link async.series}.
     *
     * **Note** that while many implementations preserve the order of object
     * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
     * explicitly states that
     *
     * > The mechanics and order of enumerating the properties is not specified.
     *
     * So if you rely on the order in which your series of functions are executed,
     * and want this to work on all platforms, consider using an array.
     *
     * @name series
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing
     * [async functions]{@link AsyncFunction} to run in series.
     * Each function can complete with any number of optional `result` values.
     * @param {Function} [callback] - An optional callback to run once all the
     * functions have completed. This function gets a results array (or object)
     * containing all the result arguments passed to the `task` callbacks. Invoked
     * with (err, result).
     * @return {Promise} a promise, if no callback is passed
     * @example
     *
     * //Using Callbacks
     * async.series([
     *     function(callback) {
     *         setTimeout(function() {
     *             // do some async task
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             // then do another async task
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ], function(err, results) {
     *     console.log(results);
     *     // results is equal to ['one','two']
     * });
     *
     * // an example using objects instead of arrays
     * async.series({
     *     one: function(callback) {
     *         setTimeout(function() {
     *             // do some async task
     *             callback(null, 1);
     *         }, 200);
     *     },
     *     two: function(callback) {
     *         setTimeout(function() {
     *             // then do another async task
     *             callback(null, 2);
     *         }, 100);
     *     }
     * }, function(err, results) {
     *     console.log(results);
     *     // results is equal to: { one: 1, two: 2 }
     * });
     *
     * //Using Promises
     * async.series([
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'one');
     *         }, 200);
     *     },
     *     function(callback) {
     *         setTimeout(function() {
     *             callback(null, 'two');
     *         }, 100);
     *     }
     * ]).then(results => {
     *     console.log(results);
     *     // results is equal to ['one','two']
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // an example using an object instead of an array
     * async.series({
     *     one: function(callback) {
     *         setTimeout(function() {
     *             // do some async task
     *             callback(null, 1);
     *         }, 200);
     *     },
     *     two: function(callback) {
     *         setTimeout(function() {
     *             // then do another async task
     *             callback(null, 2);
     *         }, 100);
     *     }
     * }).then(results => {
     *     console.log(results);
     *     // results is equal to: { one: 1, two: 2 }
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * //Using async/await
     * async () => {
     *     try {
     *         let results = await async.series([
     *             function(callback) {
     *                 setTimeout(function() {
     *                     // do some async task
     *                     callback(null, 'one');
     *                 }, 200);
     *             },
     *             function(callback) {
     *                 setTimeout(function() {
     *                     // then do another async task
     *                     callback(null, 'two');
     *                 }, 100);
     *             }
     *         ]);
     *         console.log(results);
     *         // results is equal to ['one','two']
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * // an example using an object instead of an array
     * async () => {
     *     try {
     *         let results = await async.parallel({
     *             one: function(callback) {
     *                 setTimeout(function() {
     *                     // do some async task
     *                     callback(null, 1);
     *                 }, 200);
     *             },
     *            two: function(callback) {
     *                 setTimeout(function() {
     *                     // then do another async task
     *                     callback(null, 2);
     *                 }, 100);
     *            }
     *         });
     *         console.log(results);
     *         // results is equal to: { one: 1, two: 2 }
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */ function series(tasks, callback) {
        return _parallel(eachOfSeries$1, tasks, callback);
    }
    /**
     * Returns `true` if at least one element in the `coll` satisfies an async test.
     * If any iteratee call returns `true`, the main `callback` is immediately
     * called.
     *
     * @name some
     * @static
     * @memberOf module:Collections
     * @method
     * @alias any
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collections in parallel.
     * The iteratee should complete with a boolean `result` value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the iteratee functions have finished.
     * Result will be either `true` or `false` depending on the values of the async
     * tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     * @example
     *
     * // dir1 is a directory that contains file1.txt, file2.txt
     * // dir2 is a directory that contains file3.txt, file4.txt
     * // dir3 is a directory that contains file5.txt
     * // dir4 does not exist
     *
     * // asynchronous function that checks if a file exists
     * function fileExists(file, callback) {
     *    fs.access(file, fs.constants.F_OK, (err) => {
     *        callback(null, !err);
     *    });
     * }
     *
     * // Using callbacks
     * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists,
     *    function(err, result) {
     *        console.log(result);
     *        // true
     *        // result is true since some file in the list exists
     *    }
     *);
     *
     * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists,
     *    function(err, result) {
     *        console.log(result);
     *        // false
     *        // result is false since none of the files exists
     *    }
     *);
     *
     * // Using Promises
     * async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists)
     * .then( result => {
     *     console.log(result);
     *     // true
     *     // result is true since some file in the list exists
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists)
     * .then( result => {
     *     console.log(result);
     *     // false
     *     // result is false since none of the files exists
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir3/file5.txt'], fileExists);
     *         console.log(result);
     *         // true
     *         // result is true since some file in the list exists
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     * async () => {
     *     try {
     *         let result = await async.some(['dir1/missing.txt','dir2/missing.txt','dir4/missing.txt'], fileExists);
     *         console.log(result);
     *         // false
     *         // result is false since none of the files exists
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */ function some(coll, iteratee, callback) {
        return _createTester(Boolean, (res)=>res)(eachOf$1, coll, iteratee, callback);
    }
    var some$1 = awaitify(some, 3);
    /**
     * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.
     *
     * @name someLimit
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.some]{@link module:Collections.some}
     * @alias anyLimit
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collections in parallel.
     * The iteratee should complete with a boolean `result` value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the iteratee functions have finished.
     * Result will be either `true` or `false` depending on the values of the async
     * tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     */ function someLimit(coll, limit, iteratee, callback) {
        return _createTester(Boolean, (res)=>res)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var someLimit$1 = awaitify(someLimit, 4);
    /**
     * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.
     *
     * @name someSeries
     * @static
     * @memberOf module:Collections
     * @method
     * @see [async.some]{@link module:Collections.some}
     * @alias anySeries
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async truth test to apply to each item
     * in the collections in series.
     * The iteratee should complete with a boolean `result` value.
     * Invoked with (item, callback).
     * @param {Function} [callback] - A callback which is called as soon as any
     * iteratee returns `true`, or after all the iteratee functions have finished.
     * Result will be either `true` or `false` depending on the values of the async
     * tests. Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     */ function someSeries(coll, iteratee, callback) {
        return _createTester(Boolean, (res)=>res)(eachOfSeries$1, coll, iteratee, callback);
    }
    var someSeries$1 = awaitify(someSeries, 3);
    /**
     * Sorts a list by the results of running each `coll` value through an async
     * `iteratee`.
     *
     * @name sortBy
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {AsyncFunction} iteratee - An async function to apply to each item in
     * `coll`.
     * The iteratee should complete with a value to use as the sort criteria as
     * its `result`.
     * Invoked with (item, callback).
     * @param {Function} callback - A callback which is called after all the
     * `iteratee` functions have finished, or an error occurs. Results is the items
     * from the original `coll` sorted by the values returned by the `iteratee`
     * calls. Invoked with (err, results).
     * @returns {Promise} a promise, if no callback passed
     * @example
     *
     * // bigfile.txt is a file that is 251100 bytes in size
     * // mediumfile.txt is a file that is 11000 bytes in size
     * // smallfile.txt is a file that is 121 bytes in size
     *
     * // asynchronous function that returns the file size in bytes
     * function getFileSizeInBytes(file, callback) {
     *     fs.stat(file, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         callback(null, stat.size);
     *     });
     * }
     *
     * // Using callbacks
     * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes,
     *     function(err, results) {
     *         if (err) {
     *             console.log(err);
     *         } else {
     *             console.log(results);
     *             // results is now the original array of files sorted by
     *             // file size (ascending by default), e.g.
     *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
     *         }
     *     }
     * );
     *
     * // By modifying the callback parameter the
     * // sorting order can be influenced:
     *
     * // ascending order
     * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], function(file, callback) {
     *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {
     *         if (getFileSizeErr) return callback(getFileSizeErr);
     *         callback(null, fileSize);
     *     });
     * }, function(err, results) {
     *         if (err) {
     *             console.log(err);
     *         } else {
     *             console.log(results);
     *             // results is now the original array of files sorted by
     *             // file size (ascending by default), e.g.
     *             // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
     *         }
     *     }
     * );
     *
     * // descending order
     * async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], function(file, callback) {
     *     getFileSizeInBytes(file, function(getFileSizeErr, fileSize) {
     *         if (getFileSizeErr) {
     *             return callback(getFileSizeErr);
     *         }
     *         callback(null, fileSize * -1);
     *     });
     * }, function(err, results) {
     *         if (err) {
     *             console.log(err);
     *         } else {
     *             console.log(results);
     *             // results is now the original array of files sorted by
     *             // file size (ascending by default), e.g.
     *             // [ 'bigfile.txt', 'mediumfile.txt', 'smallfile.txt']
     *         }
     *     }
     * );
     *
     * // Error handling
     * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes,
     *     function(err, results) {
     *         if (err) {
     *             console.log(err);
     *             // [ Error: ENOENT: no such file or directory ]
     *         } else {
     *             console.log(results);
     *         }
     *     }
     * );
     *
     * // Using Promises
     * async.sortBy(['mediumfile.txt','smallfile.txt','bigfile.txt'], getFileSizeInBytes)
     * .then( results => {
     *     console.log(results);
     *     // results is now the original array of files sorted by
     *     // file size (ascending by default), e.g.
     *     // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
     * }).catch( err => {
     *     console.log(err);
     * });
     *
     * // Error handling
     * async.sortBy(['mediumfile.txt','smallfile.txt','missingfile.txt'], getFileSizeInBytes)
     * .then( results => {
     *     console.log(results);
     * }).catch( err => {
     *     console.log(err);
     *     // [ Error: ENOENT: no such file or directory ]
     * });
     *
     * // Using async/await
     * (async () => {
     *     try {
     *         let results = await async.sortBy(['bigfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);
     *         console.log(results);
     *         // results is now the original array of files sorted by
     *         // file size (ascending by default), e.g.
     *         // [ 'smallfile.txt', 'mediumfile.txt', 'bigfile.txt']
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * })();
     *
     * // Error handling
     * async () => {
     *     try {
     *         let results = await async.sortBy(['missingfile.txt','mediumfile.txt','smallfile.txt'], getFileSizeInBytes);
     *         console.log(results);
     *     }
     *     catch (err) {
     *         console.log(err);
     *         // [ Error: ENOENT: no such file or directory ]
     *     }
     * }
     *
     */ function sortBy(coll, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return map$1(coll, (x, iterCb)=>{
            _iteratee(x, (err, criteria)=>{
                if (err) return iterCb(err);
                iterCb(err, {
                    value: x,
                    criteria
                });
            });
        }, (err, results)=>{
            if (err) return callback(err);
            callback(null, results.sort(comparator).map((v)=>v.value));
        });
        function comparator(left, right) {
            var a = left.criteria, b = right.criteria;
            return a < b ? -1 : a > b ? 1 : 0;
        }
    }
    var sortBy$1 = awaitify(sortBy, 3);
    /**
     * Sets a time limit on an asynchronous function. If the function does not call
     * its callback within the specified milliseconds, it will be called with a
     * timeout error. The code property for the error object will be `'ETIMEDOUT'`.
     *
     * @name timeout
     * @static
     * @memberOf module:Utils
     * @method
     * @category Util
     * @param {AsyncFunction} asyncFn - The async function to limit in time.
     * @param {number} milliseconds - The specified time limit.
     * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)
     * to timeout Error for more information..
     * @returns {AsyncFunction} Returns a wrapped function that can be used with any
     * of the control flow functions.
     * Invoke this function with the same parameters as you would `asyncFunc`.
     * @example
     *
     * function myFunction(foo, callback) {
     *     doAsyncTask(foo, function(err, data) {
     *         // handle errors
     *         if (err) return callback(err);
     *
     *         // do some stuff ...
     *
     *         // return processed data
     *         return callback(null, data);
     *     });
     * }
     *
     * var wrapped = async.timeout(myFunction, 1000);
     *
     * // call `wrapped` as you would `myFunction`
     * wrapped({ bar: 'bar' }, function(err, data) {
     *     // if `myFunction` takes < 1000 ms to execute, `err`
     *     // and `data` will have their expected values
     *
     *     // else `err` will be an Error with the code 'ETIMEDOUT'
     * });
     */ function timeout(asyncFn, milliseconds, info) {
        var fn = wrapAsync(asyncFn);
        return initialParams((args, callback)=>{
            var timedOut = false;
            var timer;
            function timeoutCallback() {
                var name = asyncFn.name || "anonymous";
                var error = new Error('Callback function "' + name + '" timed out.');
                error.code = "ETIMEDOUT";
                if (info) {
                    error.info = info;
                }
                timedOut = true;
                callback(error);
            }
            args.push((...cbArgs)=>{
                if (!timedOut) {
                    callback(...cbArgs);
                    clearTimeout(timer);
                }
            });
            // setup timer and call original function
            timer = setTimeout(timeoutCallback, milliseconds);
            fn(...args);
        });
    }
    function range(size) {
        var result = Array(size);
        while(size--){
            result[size] = size;
        }
        return result;
    }
    /**
     * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a
     * time.
     *
     * @name timesLimit
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.times]{@link module:ControlFlow.times}
     * @category Control Flow
     * @param {number} count - The number of times to run the function.
     * @param {number} limit - The maximum number of async operations at a time.
     * @param {AsyncFunction} iteratee - The async function to call `n` times.
     * Invoked with the iteration index and a callback: (n, next).
     * @param {Function} callback - see [async.map]{@link module:Collections.map}.
     * @returns {Promise} a promise, if no callback is provided
     */ function timesLimit(count, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(range(count), limit, _iteratee, callback);
    }
    /**
     * Calls the `iteratee` function `n` times, and accumulates results in the same
     * manner you would use with [map]{@link module:Collections.map}.
     *
     * @name times
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.map]{@link module:Collections.map}
     * @category Control Flow
     * @param {number} n - The number of times to run the function.
     * @param {AsyncFunction} iteratee - The async function to call `n` times.
     * Invoked with the iteration index and a callback: (n, next).
     * @param {Function} callback - see {@link module:Collections.map}.
     * @returns {Promise} a promise, if no callback is provided
     * @example
     *
     * // Pretend this is some complicated async factory
     * var createUser = function(id, callback) {
     *     callback(null, {
     *         id: 'user' + id
     *     });
     * };
     *
     * // generate 5 users
     * async.times(5, function(n, next) {
     *     createUser(n, function(err, user) {
     *         next(err, user);
     *     });
     * }, function(err, users) {
     *     // we should now have 5 users
     * });
     */ function times(n, iteratee, callback) {
        return timesLimit(n, Infinity, iteratee, callback);
    }
    /**
     * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.
     *
     * @name timesSeries
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.times]{@link module:ControlFlow.times}
     * @category Control Flow
     * @param {number} n - The number of times to run the function.
     * @param {AsyncFunction} iteratee - The async function to call `n` times.
     * Invoked with the iteration index and a callback: (n, next).
     * @param {Function} callback - see {@link module:Collections.map}.
     * @returns {Promise} a promise, if no callback is provided
     */ function timesSeries(n, iteratee, callback) {
        return timesLimit(n, 1, iteratee, callback);
    }
    /**
     * A relative of `reduce`.  Takes an Object or Array, and iterates over each
     * element in parallel, each step potentially mutating an `accumulator` value.
     * The type of the accumulator defaults to the type of collection passed in.
     *
     * @name transform
     * @static
     * @memberOf module:Collections
     * @method
     * @category Collection
     * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
     * @param {*} [accumulator] - The initial state of the transform.  If omitted,
     * it will default to an empty Object or Array, depending on the type of `coll`
     * @param {AsyncFunction} iteratee - A function applied to each item in the
     * collection that potentially modifies the accumulator.
     * Invoked with (accumulator, item, key, callback).
     * @param {Function} [callback] - A callback which is called after all the
     * `iteratee` functions have finished. Result is the transformed accumulator.
     * Invoked with (err, result).
     * @returns {Promise} a promise, if no callback provided
     * @example
     *
     * // file1.txt is a file that is 1000 bytes in size
     * // file2.txt is a file that is 2000 bytes in size
     * // file3.txt is a file that is 3000 bytes in size
     *
     * // helper function that returns human-readable size format from bytes
     * function formatBytes(bytes, decimals = 2) {
     *   // implementation not included for brevity
     *   return humanReadbleFilesize;
     * }
     *
     * const fileList = ['file1.txt','file2.txt','file3.txt'];
     *
     * // asynchronous function that returns the file size, transformed to human-readable format
     * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.
     * function transformFileSize(acc, value, key, callback) {
     *     fs.stat(value, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         acc[key] = formatBytes(stat.size);
     *         callback(null);
     *     });
     * }
     *
     * // Using callbacks
     * async.transform(fileList, transformFileSize, function(err, result) {
     *     if(err) {
     *         console.log(err);
     *     } else {
     *         console.log(result);
     *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]
     *     }
     * });
     *
     * // Using Promises
     * async.transform(fileList, transformFileSize)
     * .then(result => {
     *     console.log(result);
     *     // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * (async () => {
     *     try {
     *         let result = await async.transform(fileList, transformFileSize);
     *         console.log(result);
     *         // [ '1000 Bytes', '1.95 KB', '2.93 KB' ]
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * })();
     *
     * @example
     *
     * // file1.txt is a file that is 1000 bytes in size
     * // file2.txt is a file that is 2000 bytes in size
     * // file3.txt is a file that is 3000 bytes in size
     *
     * // helper function that returns human-readable size format from bytes
     * function formatBytes(bytes, decimals = 2) {
     *   // implementation not included for brevity
     *   return humanReadbleFilesize;
     * }
     *
     * const fileMap = { f1: 'file1.txt', f2: 'file2.txt', f3: 'file3.txt' };
     *
     * // asynchronous function that returns the file size, transformed to human-readable format
     * // e.g. 1024 bytes = 1KB, 1234 bytes = 1.21 KB, 1048576 bytes = 1MB, etc.
     * function transformFileSize(acc, value, key, callback) {
     *     fs.stat(value, function(err, stat) {
     *         if (err) {
     *             return callback(err);
     *         }
     *         acc[key] = formatBytes(stat.size);
     *         callback(null);
     *     });
     * }
     *
     * // Using callbacks
     * async.transform(fileMap, transformFileSize, function(err, result) {
     *     if(err) {
     *         console.log(err);
     *     } else {
     *         console.log(result);
     *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }
     *     }
     * });
     *
     * // Using Promises
     * async.transform(fileMap, transformFileSize)
     * .then(result => {
     *     console.log(result);
     *     // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }
     * }).catch(err => {
     *     console.log(err);
     * });
     *
     * // Using async/await
     * async () => {
     *     try {
     *         let result = await async.transform(fileMap, transformFileSize);
     *         console.log(result);
     *         // { f1: '1000 Bytes', f2: '1.95 KB', f3: '2.93 KB' }
     *     }
     *     catch (err) {
     *         console.log(err);
     *     }
     * }
     *
     */ function transform(coll, accumulator, iteratee, callback) {
        if (arguments.length <= 3 && typeof accumulator === "function") {
            callback = iteratee;
            iteratee = accumulator;
            accumulator = Array.isArray(coll) ? [] : {};
        }
        callback = once(callback || promiseCallback());
        var _iteratee = wrapAsync(iteratee);
        eachOf$1(coll, (v, k, cb)=>{
            _iteratee(accumulator, v, k, cb);
        }, (err)=>callback(err, accumulator));
        return callback[PROMISE_SYMBOL];
    }
    /**
     * It runs each task in series but stops whenever any of the functions were
     * successful. If one of the tasks were successful, the `callback` will be
     * passed the result of the successful task. If all tasks fail, the callback
     * will be passed the error and result (if any) of the final attempt.
     *
     * @name tryEach
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection containing functions to
     * run, each function is passed a `callback(err, result)` it must call on
     * completion with an error `err` (which can be `null`) and an optional `result`
     * value.
     * @param {Function} [callback] - An optional callback which is called when one
     * of the tasks has succeeded, or all have failed. It receives the `err` and
     * `result` arguments of the last attempt at completing the `task`. Invoked with
     * (err, results).
     * @returns {Promise} a promise, if no callback is passed
     * @example
     * async.tryEach([
     *     function getDataFromFirstWebsite(callback) {
     *         // Try getting the data from the first website
     *         callback(err, data);
     *     },
     *     function getDataFromSecondWebsite(callback) {
     *         // First website failed,
     *         // Try getting the data from the backup website
     *         callback(err, data);
     *     }
     * ],
     * // optional callback
     * function(err, results) {
     *     Now do something with the data.
     * });
     *
     */ function tryEach(tasks, callback) {
        var error = null;
        var result;
        return eachSeries$1(tasks, (task, taskCb)=>{
            wrapAsync(task)((err, ...args)=>{
                if (err === false) return taskCb(err);
                if (args.length < 2) {
                    [result] = args;
                } else {
                    result = args;
                }
                error = err;
                taskCb(err ? null : {});
            });
        }, ()=>callback(error, result));
    }
    var tryEach$1 = awaitify(tryEach);
    /**
     * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,
     * unmemoized form. Handy for testing.
     *
     * @name unmemoize
     * @static
     * @memberOf module:Utils
     * @method
     * @see [async.memoize]{@link module:Utils.memoize}
     * @category Util
     * @param {AsyncFunction} fn - the memoized function
     * @returns {AsyncFunction} a function that calls the original unmemoized function
     */ function unmemoize(fn) {
        return (...args)=>{
            return (fn.unmemoized || fn)(...args);
        };
    }
    /**
     * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when
     * stopped, or an error occurs.
     *
     * @name whilst
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {AsyncFunction} test - asynchronous truth test to perform before each
     * execution of `iteratee`. Invoked with (callback).
     * @param {AsyncFunction} iteratee - An async function which is called each time
     * `test` passes. Invoked with (callback).
     * @param {Function} [callback] - A callback which is called after the test
     * function has failed and repeated execution of `iteratee` has stopped. `callback`
     * will be passed an error and any arguments passed to the final `iteratee`'s
     * callback. Invoked with (err, [results]);
     * @returns {Promise} a promise, if no callback is passed
     * @example
     *
     * var count = 0;
     * async.whilst(
     *     function test(cb) { cb(null, count < 5); },
     *     function iter(callback) {
     *         count++;
     *         setTimeout(function() {
     *             callback(null, count);
     *         }, 1000);
     *     },
     *     function (err, n) {
     *         // 5 seconds have passed, n = 5
     *     }
     * );
     */ function whilst(test, iteratee, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results = [];
        function next(err, ...rest) {
            if (err) return callback(err);
            results = rest;
            if (err === false) return;
            _test(check);
        }
        function check(err, truth) {
            if (err) return callback(err);
            if (err === false) return;
            if (!truth) return callback(null, ...results);
            _fn(next);
        }
        return _test(check);
    }
    var whilst$1 = awaitify(whilst, 3);
    /**
     * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when
     * stopped, or an error occurs. `callback` will be passed an error and any
     * arguments passed to the final `iteratee`'s callback.
     *
     * The inverse of [whilst]{@link module:ControlFlow.whilst}.
     *
     * @name until
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @see [async.whilst]{@link module:ControlFlow.whilst}
     * @category Control Flow
     * @param {AsyncFunction} test - asynchronous truth test to perform before each
     * execution of `iteratee`. Invoked with (callback).
     * @param {AsyncFunction} iteratee - An async function which is called each time
     * `test` fails. Invoked with (callback).
     * @param {Function} [callback] - A callback which is called after the test
     * function has passed and repeated execution of `iteratee` has stopped. `callback`
     * will be passed an error and any arguments passed to the final `iteratee`'s
     * callback. Invoked with (err, [results]);
     * @returns {Promise} a promise, if a callback is not passed
     *
     * @example
     * const results = []
     * let finished = false
     * async.until(function test(cb) {
     *     cb(null, finished)
     * }, function iter(next) {
     *     fetchPage(url, (err, body) => {
     *         if (err) return next(err)
     *         results = results.concat(body.objects)
     *         finished = !!body.next
     *         next(err)
     *     })
     * }, function done (err) {
     *     // all pages have been fetched
     * })
     */ function until(test, iteratee, callback) {
        const _test = wrapAsync(test);
        return whilst$1((cb)=>_test((err, truth)=>cb(err, !truth)), iteratee, callback);
    }
    /**
     * Runs the `tasks` array of functions in series, each passing their results to
     * the next in the array. However, if any of the `tasks` pass an error to their
     * own callback, the next function is not executed, and the main `callback` is
     * immediately called with the error.
     *
     * @name waterfall
     * @static
     * @memberOf module:ControlFlow
     * @method
     * @category Control Flow
     * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}
     * to run.
     * Each function should complete with any number of `result` values.
     * The `result` values will be passed as arguments, in order, to the next task.
     * @param {Function} [callback] - An optional callback to run once all the
     * functions have completed. This will be passed the results of the last task's
     * callback. Invoked with (err, [results]).
     * @returns {Promise} a promise, if a callback is omitted
     * @example
     *
     * async.waterfall([
     *     function(callback) {
     *         callback(null, 'one', 'two');
     *     },
     *     function(arg1, arg2, callback) {
     *         // arg1 now equals 'one' and arg2 now equals 'two'
     *         callback(null, 'three');
     *     },
     *     function(arg1, callback) {
     *         // arg1 now equals 'three'
     *         callback(null, 'done');
     *     }
     * ], function (err, result) {
     *     // result now equals 'done'
     * });
     *
     * // Or, with named functions:
     * async.waterfall([
     *     myFirstFunction,
     *     mySecondFunction,
     *     myLastFunction,
     * ], function (err, result) {
     *     // result now equals 'done'
     * });
     * function myFirstFunction(callback) {
     *     callback(null, 'one', 'two');
     * }
     * function mySecondFunction(arg1, arg2, callback) {
     *     // arg1 now equals 'one' and arg2 now equals 'two'
     *     callback(null, 'three');
     * }
     * function myLastFunction(arg1, callback) {
     *     // arg1 now equals 'three'
     *     callback(null, 'done');
     * }
     */ function waterfall(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks)) return callback(new Error("First argument to waterfall must be an array of functions"));
        if (!tasks.length) return callback();
        var taskIndex = 0;
        function nextTask(args) {
            var task = wrapAsync(tasks[taskIndex++]);
            task(...args, onlyOnce(next));
        }
        function next(err, ...args) {
            if (err === false) return;
            if (err || taskIndex === tasks.length) {
                return callback(err, ...args);
            }
            nextTask(args);
        }
        nextTask([]);
    }
    var waterfall$1 = awaitify(waterfall);
    /**
     * An "async function" in the context of Async is an asynchronous function with
     * a variable number of parameters, with the final parameter being a callback.
     * (`function (arg1, arg2, ..., callback) {}`)
     * The final callback is of the form `callback(err, results...)`, which must be
     * called once the function is completed.  The callback should be called with a
     * Error as its first argument to signal that an error occurred.
     * Otherwise, if no error occurred, it should be called with `null` as the first
     * argument, and any additional `result` arguments that may apply, to signal
     * successful completion.
     * The callback must be called exactly once, ideally on a later tick of the
     * JavaScript event loop.
     *
     * This type of function is also referred to as a "Node-style async function",
     * or a "continuation passing-style function" (CPS). Most of the methods of this
     * library are themselves CPS/Node-style async functions, or functions that
     * return CPS/Node-style async functions.
     *
     * Wherever we accept a Node-style async function, we also directly accept an
     * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.
     * In this case, the `async` function will not be passed a final callback
     * argument, and any thrown error will be used as the `err` argument of the
     * implicit callback, and the return value will be used as the `result` value.
     * (i.e. a `rejected` of the returned Promise becomes the `err` callback
     * argument, and a `resolved` value becomes the `result`.)
     *
     * Note, due to JavaScript limitations, we can only detect native `async`
     * functions and not transpilied implementations.
     * Your environment must have `async`/`await` support for this to work.
     * (e.g. Node > v7.6, or a recent version of a modern browser).
     * If you are using `async` functions through a transpiler (e.g. Babel), you
     * must still wrap the function with [asyncify]{@link module:Utils.asyncify},
     * because the `async function` will be compiled to an ordinary function that
     * returns a promise.
     *
     * @typedef {Function} AsyncFunction
     * @static
     */ var index = {
        apply,
        applyEach,
        applyEachSeries,
        asyncify,
        auto,
        autoInject,
        cargo: cargo$1,
        cargoQueue: cargo,
        compose,
        concat: concat$1,
        concatLimit: concatLimit$1,
        concatSeries: concatSeries$1,
        constant: constant$1,
        detect: detect$1,
        detectLimit: detectLimit$1,
        detectSeries: detectSeries$1,
        dir,
        doUntil,
        doWhilst: doWhilst$1,
        each,
        eachLimit: eachLimit$1,
        eachOf: eachOf$1,
        eachOfLimit: eachOfLimit$1,
        eachOfSeries: eachOfSeries$1,
        eachSeries: eachSeries$1,
        ensureAsync,
        every: every$1,
        everyLimit: everyLimit$1,
        everySeries: everySeries$1,
        filter: filter$1,
        filterLimit: filterLimit$1,
        filterSeries: filterSeries$1,
        forever: forever$1,
        groupBy,
        groupByLimit: groupByLimit$1,
        groupBySeries,
        log,
        map: map$1,
        mapLimit: mapLimit$1,
        mapSeries: mapSeries$1,
        mapValues,
        mapValuesLimit: mapValuesLimit$1,
        mapValuesSeries,
        memoize,
        nextTick,
        parallel,
        parallelLimit,
        priorityQueue,
        queue,
        race: race$1,
        reduce: reduce$1,
        reduceRight,
        reflect,
        reflectAll,
        reject: reject$1,
        rejectLimit: rejectLimit$1,
        rejectSeries: rejectSeries$1,
        retry,
        retryable,
        seq,
        series,
        setImmediate: setImmediate$1,
        some: some$1,
        someLimit: someLimit$1,
        someSeries: someSeries$1,
        sortBy: sortBy$1,
        timeout,
        times,
        timesLimit,
        timesSeries,
        transform,
        tryEach: tryEach$1,
        unmemoize,
        until,
        waterfall: waterfall$1,
        whilst: whilst$1,
        // aliases
        all: every$1,
        allLimit: everyLimit$1,
        allSeries: everySeries$1,
        any: some$1,
        anyLimit: someLimit$1,
        anySeries: someSeries$1,
        find: detect$1,
        findLimit: detectLimit$1,
        findSeries: detectSeries$1,
        flatMap: concat$1,
        flatMapLimit: concatLimit$1,
        flatMapSeries: concatSeries$1,
        forEach: each,
        forEachSeries: eachSeries$1,
        forEachLimit: eachLimit$1,
        forEachOf: eachOf$1,
        forEachOfSeries: eachOfSeries$1,
        forEachOfLimit: eachOfLimit$1,
        inject: reduce$1,
        foldl: reduce$1,
        foldr: reduceRight,
        select: filter$1,
        selectLimit: filterLimit$1,
        selectSeries: filterSeries$1,
        wrapSync: asyncify,
        during: whilst$1,
        doDuring: doWhilst$1
    };
    exports1.all = every$1;
    exports1.allLimit = everyLimit$1;
    exports1.allSeries = everySeries$1;
    exports1.any = some$1;
    exports1.anyLimit = someLimit$1;
    exports1.anySeries = someSeries$1;
    exports1.apply = apply;
    exports1.applyEach = applyEach;
    exports1.applyEachSeries = applyEachSeries;
    exports1.asyncify = asyncify;
    exports1.auto = auto;
    exports1.autoInject = autoInject;
    exports1.cargo = cargo$1;
    exports1.cargoQueue = cargo;
    exports1.compose = compose;
    exports1.concat = concat$1;
    exports1.concatLimit = concatLimit$1;
    exports1.concatSeries = concatSeries$1;
    exports1.constant = constant$1;
    exports1.default = index;
    exports1.detect = detect$1;
    exports1.detectLimit = detectLimit$1;
    exports1.detectSeries = detectSeries$1;
    exports1.dir = dir;
    exports1.doDuring = doWhilst$1;
    exports1.doUntil = doUntil;
    exports1.doWhilst = doWhilst$1;
    exports1.during = whilst$1;
    exports1.each = each;
    exports1.eachLimit = eachLimit$1;
    exports1.eachOf = eachOf$1;
    exports1.eachOfLimit = eachOfLimit$1;
    exports1.eachOfSeries = eachOfSeries$1;
    exports1.eachSeries = eachSeries$1;
    exports1.ensureAsync = ensureAsync;
    exports1.every = every$1;
    exports1.everyLimit = everyLimit$1;
    exports1.everySeries = everySeries$1;
    exports1.filter = filter$1;
    exports1.filterLimit = filterLimit$1;
    exports1.filterSeries = filterSeries$1;
    exports1.find = detect$1;
    exports1.findLimit = detectLimit$1;
    exports1.findSeries = detectSeries$1;
    exports1.flatMap = concat$1;
    exports1.flatMapLimit = concatLimit$1;
    exports1.flatMapSeries = concatSeries$1;
    exports1.foldl = reduce$1;
    exports1.foldr = reduceRight;
    exports1.forEach = each;
    exports1.forEachLimit = eachLimit$1;
    exports1.forEachOf = eachOf$1;
    exports1.forEachOfLimit = eachOfLimit$1;
    exports1.forEachOfSeries = eachOfSeries$1;
    exports1.forEachSeries = eachSeries$1;
    exports1.forever = forever$1;
    exports1.groupBy = groupBy;
    exports1.groupByLimit = groupByLimit$1;
    exports1.groupBySeries = groupBySeries;
    exports1.inject = reduce$1;
    exports1.log = log;
    exports1.map = map$1;
    exports1.mapLimit = mapLimit$1;
    exports1.mapSeries = mapSeries$1;
    exports1.mapValues = mapValues;
    exports1.mapValuesLimit = mapValuesLimit$1;
    exports1.mapValuesSeries = mapValuesSeries;
    exports1.memoize = memoize;
    exports1.nextTick = nextTick;
    exports1.parallel = parallel;
    exports1.parallelLimit = parallelLimit;
    exports1.priorityQueue = priorityQueue;
    exports1.queue = queue;
    exports1.race = race$1;
    exports1.reduce = reduce$1;
    exports1.reduceRight = reduceRight;
    exports1.reflect = reflect;
    exports1.reflectAll = reflectAll;
    exports1.reject = reject$1;
    exports1.rejectLimit = rejectLimit$1;
    exports1.rejectSeries = rejectSeries$1;
    exports1.retry = retry;
    exports1.retryable = retryable;
    exports1.select = filter$1;
    exports1.selectLimit = filterLimit$1;
    exports1.selectSeries = filterSeries$1;
    exports1.seq = seq;
    exports1.series = series;
    exports1.setImmediate = setImmediate$1;
    exports1.some = some$1;
    exports1.someLimit = someLimit$1;
    exports1.someSeries = someSeries$1;
    exports1.sortBy = sortBy$1;
    exports1.timeout = timeout;
    exports1.times = times;
    exports1.timesLimit = timesLimit;
    exports1.timesSeries = timesSeries;
    exports1.transform = transform;
    exports1.tryEach = tryEach$1;
    exports1.unmemoize = unmemoize;
    exports1.until = until;
    exports1.waterfall = waterfall$1;
    exports1.whilst = whilst$1;
    exports1.wrapSync = asyncify;
    Object.defineProperty(exports1, "__esModule", {
        value: true
    });
});


/***/ }),

/***/ 2165:
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
    if (a instanceof RegExp) a = maybeMatch(a, str);
    if (b instanceof RegExp) b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
    };
}
function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
}
balanced.range = range;
function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
        if (a === b) {
            return [
                ai,
                bi
            ];
        }
        begs = [];
        left = str.length;
        while(i >= 0 && !result){
            if (i == ai) {
                begs.push(i);
                ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
                result = [
                    begs.pop(),
                    bi
                ];
            } else {
                beg = begs.pop();
                if (beg < left) {
                    left = beg;
                    right = bi;
                }
                bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
            result = [
                left,
                right
            ];
        }
    }
    return result;
}


/***/ }),

/***/ 29037:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;
var bigInt = function(undefined) {
    "use strict";
    var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
    var supportsNativeBigInt = typeof BigInt === "function";
    function Integer(v, radix, alphabet, caseSensitive) {
        if (typeof v === "undefined") return Integer[0];
        if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
        return parseValue(v);
    }
    function BigInteger(value, sign) {
        this.value = value;
        this.sign = sign;
        this.isSmall = false;
    }
    BigInteger.prototype = Object.create(Integer.prototype);
    function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
    }
    SmallInteger.prototype = Object.create(Integer.prototype);
    function NativeBigInt(value) {
        this.value = value;
    }
    NativeBigInt.prototype = Object.create(Integer.prototype);
    function isPrecise(n) {
        return -MAX_INT < n && n < MAX_INT;
    }
    function smallToArray(n) {
        if (n < 1e7) return [
            n
        ];
        if (n < 1e14) return [
            n % 1e7,
            Math.floor(n / 1e7)
        ];
        return [
            n % 1e7,
            Math.floor(n / 1e7) % 1e7,
            Math.floor(n / 1e14)
        ];
    }
    function arrayToSmall(arr) {
        trim(arr);
        var length = arr.length;
        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
            switch(length){
                case 0:
                    return 0;
                case 1:
                    return arr[0];
                case 2:
                    return arr[0] + arr[1] * BASE;
                default:
                    return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
            }
        }
        return arr;
    }
    function trim(v) {
        var i = v.length;
        while(v[--i] === 0);
        v.length = i + 1;
    }
    function createArray(length) {
        var x = new Array(length);
        var i = -1;
        while(++i < length){
            x[i] = 0;
        }
        return x;
    }
    function truncate(n) {
        if (n > 0) return Math.floor(n);
        return Math.ceil(n);
    }
    function add(a, b) {
        var l_a = a.length, l_b = b.length, r = new Array(l_a), carry = 0, base = BASE, sum, i;
        for(i = 0; i < l_b; i++){
            sum = a[i] + b[i] + carry;
            carry = sum >= base ? 1 : 0;
            r[i] = sum - carry * base;
        }
        while(i < l_a){
            sum = a[i] + carry;
            carry = sum === base ? 1 : 0;
            r[i++] = sum - carry * base;
        }
        if (carry > 0) r.push(carry);
        return r;
    }
    function addAny(a, b) {
        if (a.length >= b.length) return add(a, b);
        return add(b, a);
    }
    function addSmall(a, carry) {
        var l = a.length, r = new Array(l), base = BASE, sum, i;
        for(i = 0; i < l; i++){
            sum = a[i] - base + carry;
            carry = Math.floor(sum / base);
            r[i] = sum - carry * base;
            carry += 1;
        }
        while(carry > 0){
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }
    BigInteger.prototype.add = function(v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.subtract(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall) {
            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
        }
        return new BigInteger(addAny(a, b), this.sign);
    };
    BigInteger.prototype.plus = BigInteger.prototype.add;
    SmallInteger.prototype.add = function(v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.subtract(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            if (isPrecise(a + b)) return new SmallInteger(a + b);
            b = smallToArray(Math.abs(b));
        }
        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
    };
    SmallInteger.prototype.plus = SmallInteger.prototype.add;
    NativeBigInt.prototype.add = function(v) {
        return new NativeBigInt(this.value + parseValue(v).value);
    };
    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
    function subtract(a, b) {
        var a_l = a.length, b_l = b.length, r = new Array(a_l), borrow = 0, base = BASE, i, difference;
        for(i = 0; i < b_l; i++){
            difference = a[i] - borrow - b[i];
            if (difference < 0) {
                difference += base;
                borrow = 1;
            } else borrow = 0;
            r[i] = difference;
        }
        for(i = b_l; i < a_l; i++){
            difference = a[i] - borrow;
            if (difference < 0) difference += base;
            else {
                r[i++] = difference;
                break;
            }
            r[i] = difference;
        }
        for(; i < a_l; i++){
            r[i] = a[i];
        }
        trim(r);
        return r;
    }
    function subtractAny(a, b, sign) {
        var value;
        if (compareAbs(a, b) >= 0) {
            value = subtract(a, b);
        } else {
            value = subtract(b, a);
            sign = !sign;
        }
        value = arrayToSmall(value);
        if (typeof value === "number") {
            if (sign) value = -value;
            return new SmallInteger(value);
        }
        return new BigInteger(value, sign);
    }
    function subtractSmall(a, b, sign) {
        var l = a.length, r = new Array(l), carry = -b, base = BASE, i, difference;
        for(i = 0; i < l; i++){
            difference = a[i] + carry;
            carry = Math.floor(difference / base);
            difference %= base;
            r[i] = difference < 0 ? difference + base : difference;
        }
        r = arrayToSmall(r);
        if (typeof r === "number") {
            if (sign) r = -r;
            return new SmallInteger(r);
        }
        return new BigInteger(r, sign);
    }
    BigInteger.prototype.subtract = function(v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.add(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall) return subtractSmall(a, Math.abs(b), this.sign);
        return subtractAny(a, b, this.sign);
    };
    BigInteger.prototype.minus = BigInteger.prototype.subtract;
    SmallInteger.prototype.subtract = function(v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.add(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            return new SmallInteger(a - b);
        }
        return subtractSmall(b, Math.abs(a), a >= 0);
    };
    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
    NativeBigInt.prototype.subtract = function(v) {
        return new NativeBigInt(this.value - parseValue(v).value);
    };
    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
    BigInteger.prototype.negate = function() {
        return new BigInteger(this.value, !this.sign);
    };
    SmallInteger.prototype.negate = function() {
        var sign = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign;
        return small;
    };
    NativeBigInt.prototype.negate = function() {
        return new NativeBigInt(-this.value);
    };
    BigInteger.prototype.abs = function() {
        return new BigInteger(this.value, false);
    };
    SmallInteger.prototype.abs = function() {
        return new SmallInteger(Math.abs(this.value));
    };
    NativeBigInt.prototype.abs = function() {
        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
    };
    function multiplyLong(a, b) {
        var a_l = a.length, b_l = b.length, l = a_l + b_l, r = createArray(l), base = BASE, product, carry, i, a_i, b_j;
        for(i = 0; i < a_l; ++i){
            a_i = a[i];
            for(var j = 0; j < b_l; ++j){
                b_j = b[j];
                product = a_i * b_j + r[i + j];
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
                r[i + j + 1] += carry;
            }
        }
        trim(r);
        return r;
    }
    function multiplySmall(a, b) {
        var l = a.length, r = new Array(l), base = BASE, carry = 0, product, i;
        for(i = 0; i < l; i++){
            product = a[i] * b + carry;
            carry = Math.floor(product / base);
            r[i] = product - carry * base;
        }
        while(carry > 0){
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }
    function shiftLeft(x, n) {
        var r = [];
        while(n-- > 0)r.push(0);
        return r.concat(x);
    }
    function multiplyKaratsuba(x, y) {
        var n = Math.max(x.length, y.length);
        if (n <= 30) return multiplyLong(x, y);
        n = Math.ceil(n / 2);
        var b = x.slice(n), a = x.slice(0, n), d = y.slice(n), c = y.slice(0, n);
        var ac = multiplyKaratsuba(a, c), bd = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
        trim(product);
        return product;
    }
    // The following function is derived from a surface fit of a graph plotting the performance difference
    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
    function useKaratsuba(l1, l2) {
        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
    }
    BigInteger.prototype.multiply = function(v) {
        var n = parseValue(v), a = this.value, b = n.value, sign = this.sign !== n.sign, abs;
        if (n.isSmall) {
            if (b === 0) return Integer[0];
            if (b === 1) return this;
            if (b === -1) return this.negate();
            abs = Math.abs(b);
            if (abs < BASE) {
                return new BigInteger(multiplySmall(a, abs), sign);
            }
            b = smallToArray(abs);
        }
        if (useKaratsuba(a.length, b.length)) return new BigInteger(multiplyKaratsuba(a, b), sign);
        return new BigInteger(multiplyLong(a, b), sign);
    };
    BigInteger.prototype.times = BigInteger.prototype.multiply;
    function multiplySmallAndArray(a, b, sign) {
        if (a < BASE) {
            return new BigInteger(multiplySmall(b, a), sign);
        }
        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
    }
    SmallInteger.prototype._multiplyBySmall = function(a) {
        if (isPrecise(a.value * this.value)) {
            return new SmallInteger(a.value * this.value);
        }
        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
    };
    BigInteger.prototype._multiplyBySmall = function(a) {
        if (a.value === 0) return Integer[0];
        if (a.value === 1) return this;
        if (a.value === -1) return this.negate();
        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
    };
    SmallInteger.prototype.multiply = function(v) {
        return parseValue(v)._multiplyBySmall(this);
    };
    SmallInteger.prototype.times = SmallInteger.prototype.multiply;
    NativeBigInt.prototype.multiply = function(v) {
        return new NativeBigInt(this.value * parseValue(v).value);
    };
    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
    function square(a) {
        //console.assert(2 * BASE * BASE < MAX_INT);
        var l = a.length, r = createArray(l + l), base = BASE, product, carry, i, a_i, a_j;
        for(i = 0; i < l; i++){
            a_i = a[i];
            carry = 0 - a_i * a_i;
            for(var j = i; j < l; j++){
                a_j = a[j];
                product = 2 * (a_i * a_j) + r[i + j] + carry;
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
            }
            r[i + l] = carry;
        }
        trim(r);
        return r;
    }
    BigInteger.prototype.square = function() {
        return new BigInteger(square(this.value), false);
    };
    SmallInteger.prototype.square = function() {
        var value = this.value * this.value;
        if (isPrecise(value)) return new SmallInteger(value);
        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
    };
    NativeBigInt.prototype.square = function(v) {
        return new NativeBigInt(this.value * this.value);
    };
    function divMod1(a, b) {
        var a_l = a.length, b_l = b.length, base = BASE, result = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], // normalization
        lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift, carry, borrow, i, l, q;
        if (remainder.length <= a_l) remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];
        for(shift = a_l - b_l; shift >= 0; shift--){
            quotientDigit = base - 1;
            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
            }
            // quotientDigit <= base - 1
            carry = 0;
            borrow = 0;
            l = divisor.length;
            for(i = 0; i < l; i++){
                carry += quotientDigit * divisor[i];
                q = Math.floor(carry / base);
                borrow += remainder[shift + i] - (carry - q * base);
                carry = q;
                if (borrow < 0) {
                    remainder[shift + i] = borrow + base;
                    borrow = -1;
                } else {
                    remainder[shift + i] = borrow;
                    borrow = 0;
                }
            }
            while(borrow !== 0){
                quotientDigit -= 1;
                carry = 0;
                for(i = 0; i < l; i++){
                    carry += remainder[shift + i] - base + divisor[i];
                    if (carry < 0) {
                        remainder[shift + i] = carry + base;
                        carry = 0;
                    } else {
                        remainder[shift + i] = carry;
                        carry = 1;
                    }
                }
                borrow += carry;
            }
            result[shift] = quotientDigit;
        }
        // denormalization
        remainder = divModSmall(remainder, lambda)[0];
        return [
            arrayToSmall(result),
            arrayToSmall(remainder)
        ];
    }
    function divMod2(a, b) {
        // Performs faster than divMod1 on larger input sizes.
        var a_l = a.length, b_l = b.length, result = [], part = [], base = BASE, guess, xlen, highx, highy, check;
        while(a_l){
            part.unshift(a[--a_l]);
            trim(part);
            if (compareAbs(part, b) < 0) {
                result.push(0);
                continue;
            }
            xlen = part.length;
            highx = part[xlen - 1] * base + part[xlen - 2];
            highy = b[b_l - 1] * base + b[b_l - 2];
            if (xlen > b_l) {
                highx = (highx + 1) * base;
            }
            guess = Math.ceil(highx / highy);
            do {
                check = multiplySmall(b, guess);
                if (compareAbs(check, part) <= 0) break;
                guess--;
            }while (guess);
            result.push(guess);
            part = subtract(part, check);
        }
        result.reverse();
        return [
            arrayToSmall(result),
            arrayToSmall(part)
        ];
    }
    function divModSmall(value, lambda) {
        var length = value.length, quotient = createArray(length), base = BASE, i, q, remainder, divisor;
        remainder = 0;
        for(i = length - 1; i >= 0; --i){
            divisor = remainder * base + value[i];
            q = truncate(divisor / lambda);
            remainder = divisor - q * lambda;
            quotient[i] = q | 0;
        }
        return [
            quotient,
            remainder | 0
        ];
    }
    function divModAny(self, v) {
        var value, n = parseValue(v);
        if (supportsNativeBigInt) {
            return [
                new NativeBigInt(self.value / n.value),
                new NativeBigInt(self.value % n.value)
            ];
        }
        var a = self.value, b = n.value;
        var quotient;
        if (b === 0) throw new Error("Cannot divide by zero");
        if (self.isSmall) {
            if (n.isSmall) {
                return [
                    new SmallInteger(truncate(a / b)),
                    new SmallInteger(a % b)
                ];
            }
            return [
                Integer[0],
                self
            ];
        }
        if (n.isSmall) {
            if (b === 1) return [
                self,
                Integer[0]
            ];
            if (b == -1) return [
                self.negate(),
                Integer[0]
            ];
            var abs = Math.abs(b);
            if (abs < BASE) {
                value = divModSmall(a, abs);
                quotient = arrayToSmall(value[0]);
                var remainder = value[1];
                if (self.sign) remainder = -remainder;
                if (typeof quotient === "number") {
                    if (self.sign !== n.sign) quotient = -quotient;
                    return [
                        new SmallInteger(quotient),
                        new SmallInteger(remainder)
                    ];
                }
                return [
                    new BigInteger(quotient, self.sign !== n.sign),
                    new SmallInteger(remainder)
                ];
            }
            b = smallToArray(abs);
        }
        var comparison = compareAbs(a, b);
        if (comparison === -1) return [
            Integer[0],
            self
        ];
        if (comparison === 0) return [
            Integer[self.sign === n.sign ? 1 : -1],
            Integer[0]
        ];
        // divMod1 is faster on smaller input sizes
        if (a.length + b.length <= 200) value = divMod1(a, b);
        else value = divMod2(a, b);
        quotient = value[0];
        var qSign = self.sign !== n.sign, mod = value[1], mSign = self.sign;
        if (typeof quotient === "number") {
            if (qSign) quotient = -quotient;
            quotient = new SmallInteger(quotient);
        } else quotient = new BigInteger(quotient, qSign);
        if (typeof mod === "number") {
            if (mSign) mod = -mod;
            mod = new SmallInteger(mod);
        } else mod = new BigInteger(mod, mSign);
        return [
            quotient,
            mod
        ];
    }
    BigInteger.prototype.divmod = function(v) {
        var result = divModAny(this, v);
        return {
            quotient: result[0],
            remainder: result[1]
        };
    };
    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;
    BigInteger.prototype.divide = function(v) {
        return divModAny(this, v)[0];
    };
    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {
        return new NativeBigInt(this.value / parseValue(v).value);
    };
    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;
    BigInteger.prototype.mod = function(v) {
        return divModAny(this, v)[1];
    };
    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {
        return new NativeBigInt(this.value % parseValue(v).value);
    };
    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;
    BigInteger.prototype.pow = function(v) {
        var n = parseValue(v), a = this.value, b = n.value, value, x, y;
        if (b === 0) return Integer[1];
        if (a === 0) return Integer[0];
        if (a === 1) return Integer[1];
        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.sign) {
            return Integer[0];
        }
        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
        if (this.isSmall) {
            if (isPrecise(value = Math.pow(a, b))) return new SmallInteger(truncate(value));
        }
        x = this;
        y = Integer[1];
        while(true){
            if (b & 1 === 1) {
                y = y.times(x);
                --b;
            }
            if (b === 0) break;
            b /= 2;
            x = x.square();
        }
        return y;
    };
    SmallInteger.prototype.pow = BigInteger.prototype.pow;
    NativeBigInt.prototype.pow = function(v) {
        var n = parseValue(v);
        var a = this.value, b = n.value;
        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
        if (b === _0) return Integer[1];
        if (a === _0) return Integer[0];
        if (a === _1) return Integer[1];
        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.isNegative()) return new NativeBigInt(_0);
        var x = this;
        var y = Integer[1];
        while(true){
            if ((b & _1) === _1) {
                y = y.times(x);
                --b;
            }
            if (b === _0) break;
            b /= _2;
            x = x.square();
        }
        return y;
    };
    BigInteger.prototype.modPow = function(exp, mod) {
        exp = parseValue(exp);
        mod = parseValue(mod);
        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
        var r = Integer[1], base = this.mod(mod);
        if (exp.isNegative()) {
            exp = exp.multiply(Integer[-1]);
            base = base.modInv(mod);
        }
        while(exp.isPositive()){
            if (base.isZero()) return Integer[0];
            if (exp.isOdd()) r = r.multiply(base).mod(mod);
            exp = exp.divide(2);
            base = base.square().mod(mod);
        }
        return r;
    };
    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;
    function compareAbs(a, b) {
        if (a.length !== b.length) {
            return a.length > b.length ? 1 : -1;
        }
        for(var i = a.length - 1; i >= 0; i--){
            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
        }
        return 0;
    }
    BigInteger.prototype.compareAbs = function(v) {
        var n = parseValue(v), a = this.value, b = n.value;
        if (n.isSmall) return 1;
        return compareAbs(a, b);
    };
    SmallInteger.prototype.compareAbs = function(v) {
        var n = parseValue(v), a = Math.abs(this.value), b = n.value;
        if (n.isSmall) {
            b = Math.abs(b);
            return a === b ? 0 : a > b ? 1 : -1;
        }
        return -1;
    };
    NativeBigInt.prototype.compareAbs = function(v) {
        var a = this.value;
        var b = parseValue(v).value;
        a = a >= 0 ? a : -a;
        b = b >= 0 ? b : -b;
        return a === b ? 0 : a > b ? 1 : -1;
    };
    BigInteger.prototype.compare = function(v) {
        // See discussion about comparison with Infinity:
        // https://github.com/peterolson/BigInteger.js/issues/61
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }
        var n = parseValue(v), a = this.value, b = n.value;
        if (this.sign !== n.sign) {
            return n.sign ? 1 : -1;
        }
        if (n.isSmall) {
            return this.sign ? -1 : 1;
        }
        return compareAbs(a, b) * (this.sign ? -1 : 1);
    };
    BigInteger.prototype.compareTo = BigInteger.prototype.compare;
    SmallInteger.prototype.compare = function(v) {
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }
        var n = parseValue(v), a = this.value, b = n.value;
        if (n.isSmall) {
            return a == b ? 0 : a > b ? 1 : -1;
        }
        if (a < 0 !== n.sign) {
            return a < 0 ? -1 : 1;
        }
        return a < 0 ? 1 : -1;
    };
    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
    NativeBigInt.prototype.compare = function(v) {
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }
        var a = this.value;
        var b = parseValue(v).value;
        return a === b ? 0 : a > b ? 1 : -1;
    };
    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
    BigInteger.prototype.equals = function(v) {
        return this.compare(v) === 0;
    };
    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;
    BigInteger.prototype.notEquals = function(v) {
        return this.compare(v) !== 0;
    };
    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;
    BigInteger.prototype.greater = function(v) {
        return this.compare(v) > 0;
    };
    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;
    BigInteger.prototype.lesser = function(v) {
        return this.compare(v) < 0;
    };
    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;
    BigInteger.prototype.greaterOrEquals = function(v) {
        return this.compare(v) >= 0;
    };
    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;
    BigInteger.prototype.lesserOrEquals = function(v) {
        return this.compare(v) <= 0;
    };
    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;
    BigInteger.prototype.isEven = function() {
        return (this.value[0] & 1) === 0;
    };
    SmallInteger.prototype.isEven = function() {
        return (this.value & 1) === 0;
    };
    NativeBigInt.prototype.isEven = function() {
        return (this.value & BigInt(1)) === BigInt(0);
    };
    BigInteger.prototype.isOdd = function() {
        return (this.value[0] & 1) === 1;
    };
    SmallInteger.prototype.isOdd = function() {
        return (this.value & 1) === 1;
    };
    NativeBigInt.prototype.isOdd = function() {
        return (this.value & BigInt(1)) === BigInt(1);
    };
    BigInteger.prototype.isPositive = function() {
        return !this.sign;
    };
    SmallInteger.prototype.isPositive = function() {
        return this.value > 0;
    };
    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
    BigInteger.prototype.isNegative = function() {
        return this.sign;
    };
    SmallInteger.prototype.isNegative = function() {
        return this.value < 0;
    };
    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
    BigInteger.prototype.isUnit = function() {
        return false;
    };
    SmallInteger.prototype.isUnit = function() {
        return Math.abs(this.value) === 1;
    };
    NativeBigInt.prototype.isUnit = function() {
        return this.abs().value === BigInt(1);
    };
    BigInteger.prototype.isZero = function() {
        return false;
    };
    SmallInteger.prototype.isZero = function() {
        return this.value === 0;
    };
    NativeBigInt.prototype.isZero = function() {
        return this.value === BigInt(0);
    };
    BigInteger.prototype.isDivisibleBy = function(v) {
        var n = parseValue(v);
        if (n.isZero()) return false;
        if (n.isUnit()) return true;
        if (n.compareAbs(2) === 0) return this.isEven();
        return this.mod(n).isZero();
    };
    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;
    function isBasicPrime(v) {
        var n = v.abs();
        if (n.isUnit()) return false;
        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
        if (n.lesser(49)) return true;
    // we don't know if it's prime: let the other functions figure it out
    }
    function millerRabinTest(n, a) {
        var nPrev = n.prev(), b = nPrev, r = 0, d, t, i, x;
        while(b.isEven())b = b.divide(2), r++;
        next: for(i = 0; i < a.length; i++){
            if (n.lesser(a[i])) continue;
            x = bigInt(a[i]).modPow(b, n);
            if (x.isUnit() || x.equals(nPrev)) continue;
            for(d = r - 1; d != 0; d--){
                x = x.square().mod(n);
                if (x.isUnit()) return false;
                if (x.equals(nPrev)) continue next;
            }
            return false;
        }
        return true;
    }
    // Set "strict" to true to force GRH-supported lower bound of 2*log(N)^2
    BigInteger.prototype.isPrime = function(strict) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined) return isPrime;
        var n = this.abs();
        var bits = n.bitLength();
        if (bits <= 64) return millerRabinTest(n, [
            2,
            3,
            5,
            7,
            11,
            13,
            17,
            19,
            23,
            29,
            31,
            37
        ]);
        var logN = Math.log(2) * bits.toJSNumber();
        var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
        for(var a = [], i = 0; i < t; i++){
            a.push(bigInt(i + 2));
        }
        return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;
    BigInteger.prototype.isProbablePrime = function(iterations, rng) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined) return isPrime;
        var n = this.abs();
        var t = iterations === undefined ? 5 : iterations;
        for(var a = [], i = 0; i < t; i++){
            a.push(bigInt.randBetween(2, n.minus(2), rng));
        }
        return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;
    BigInteger.prototype.modInv = function(n) {
        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
        while(!newR.isZero()){
            q = r.divide(newR);
            lastT = t;
            lastR = r;
            t = newT;
            r = newR;
            newT = lastT.subtract(q.multiply(newT));
            newR = lastR.subtract(q.multiply(newR));
        }
        if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
        if (t.compare(0) === -1) {
            t = t.add(n);
        }
        if (this.isNegative()) {
            return t.negate();
        }
        return t;
    };
    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;
    BigInteger.prototype.next = function() {
        var value = this.value;
        if (this.sign) {
            return subtractSmall(value, 1, this.sign);
        }
        return new BigInteger(addSmall(value, 1), this.sign);
    };
    SmallInteger.prototype.next = function() {
        var value = this.value;
        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
        return new BigInteger(MAX_INT_ARR, false);
    };
    NativeBigInt.prototype.next = function() {
        return new NativeBigInt(this.value + BigInt(1));
    };
    BigInteger.prototype.prev = function() {
        var value = this.value;
        if (this.sign) {
            return new BigInteger(addSmall(value, 1), true);
        }
        return subtractSmall(value, 1, this.sign);
    };
    SmallInteger.prototype.prev = function() {
        var value = this.value;
        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
        return new BigInteger(MAX_INT_ARR, true);
    };
    NativeBigInt.prototype.prev = function() {
        return new NativeBigInt(this.value - BigInt(1));
    };
    var powersOfTwo = [
        1
    ];
    while(2 * powersOfTwo[powersOfTwo.length - 1] <= BASE)powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];
    function shift_isSmall(n) {
        return Math.abs(n) <= BASE;
    }
    BigInteger.prototype.shiftLeft = function(v) {
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftRight(-n);
        var result = this;
        if (result.isZero()) return result;
        while(n >= powers2Length){
            result = result.multiply(highestPower2);
            n -= powers2Length - 1;
        }
        return result.multiply(powersOfTwo[n]);
    };
    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;
    BigInteger.prototype.shiftRight = function(v) {
        var remQuo;
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftLeft(-n);
        var result = this;
        while(n >= powers2Length){
            if (result.isZero() || result.isNegative() && result.isUnit()) return result;
            remQuo = divModAny(result, highestPower2);
            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
            n -= powers2Length - 1;
        }
        remQuo = divModAny(result, powersOfTwo[n]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
    };
    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;
    function bitwise(x, y, fn) {
        y = parseValue(y);
        var xSign = x.isNegative(), ySign = y.isNegative();
        var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;
        var xDigit = 0, yDigit = 0;
        var xDivMod = null, yDivMod = null;
        var result = [];
        while(!xRem.isZero() || !yRem.isZero()){
            xDivMod = divModAny(xRem, highestPower2);
            xDigit = xDivMod[1].toJSNumber();
            if (xSign) {
                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
            }
            yDivMod = divModAny(yRem, highestPower2);
            yDigit = yDivMod[1].toJSNumber();
            if (ySign) {
                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
            }
            xRem = xDivMod[0];
            yRem = yDivMod[0];
            result.push(fn(xDigit, yDigit));
        }
        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
        for(var i = result.length - 1; i >= 0; i -= 1){
            sum = sum.multiply(highestPower2).add(bigInt(result[i]));
        }
        return sum;
    }
    BigInteger.prototype.not = function() {
        return this.negate().prev();
    };
    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;
    BigInteger.prototype.and = function(n) {
        return bitwise(this, n, function(a, b) {
            return a & b;
        });
    };
    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;
    BigInteger.prototype.or = function(n) {
        return bitwise(this, n, function(a, b) {
            return a | b;
        });
    };
    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;
    BigInteger.prototype.xor = function(n) {
        return bitwise(this, n, function(a, b) {
            return a ^ b;
        });
    };
    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;
    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
    function roughLOB(n) {
        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
        var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;
        return x & -x;
    }
    function integerLogarithm(value, base) {
        if (base.compareTo(value) <= 0) {
            var tmp = integerLogarithm(value, base.square(base));
            var p = tmp.p;
            var e = tmp.e;
            var t = p.multiply(base);
            return t.compareTo(value) <= 0 ? {
                p: t,
                e: e * 2 + 1
            } : {
                p: p,
                e: e * 2
            };
        }
        return {
            p: bigInt(1),
            e: 0
        };
    }
    BigInteger.prototype.bitLength = function() {
        var n = this;
        if (n.compareTo(bigInt(0)) < 0) {
            n = n.negate().subtract(bigInt(1));
        }
        if (n.compareTo(bigInt(0)) === 0) {
            return bigInt(0);
        }
        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
    };
    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;
    function max(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.greater(b) ? a : b;
    }
    function min(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.lesser(b) ? a : b;
    }
    function gcd(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        if (a.equals(b)) return a;
        if (a.isZero()) return b;
        if (b.isZero()) return a;
        var c = Integer[1], d, t;
        while(a.isEven() && b.isEven()){
            d = min(roughLOB(a), roughLOB(b));
            a = a.divide(d);
            b = b.divide(d);
            c = c.multiply(d);
        }
        while(a.isEven()){
            a = a.divide(roughLOB(a));
        }
        do {
            while(b.isEven()){
                b = b.divide(roughLOB(b));
            }
            if (a.greater(b)) {
                t = b;
                b = a;
                a = t;
            }
            b = b.subtract(a);
        }while (!b.isZero());
        return c.isUnit() ? a : a.multiply(c);
    }
    function lcm(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        return a.divide(gcd(a, b)).multiply(b);
    }
    function randBetween(a, b, rng) {
        a = parseValue(a);
        b = parseValue(b);
        var usedRNG = rng || Math.random;
        var low = min(a, b), high = max(a, b);
        var range = high.subtract(low).add(1);
        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
        var digits = toBase(range, BASE).value;
        var result = [], restricted = true;
        for(var i = 0; i < digits.length; i++){
            var top = restricted ? digits[i] + (i + 1 < digits.length ? digits[i + 1] / BASE : 0) : BASE;
            var digit = truncate(usedRNG() * top);
            result.push(digit);
            if (digit < digits[i]) restricted = false;
        }
        return low.add(Integer.fromArray(result, BASE, false));
    }
    var parseBase = function(text, base, alphabet, caseSensitive) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        text = String(text);
        if (!caseSensitive) {
            text = text.toLowerCase();
            alphabet = alphabet.toLowerCase();
        }
        var length = text.length;
        var i;
        var absBase = Math.abs(base);
        var alphabetValues = {};
        for(i = 0; i < alphabet.length; i++){
            alphabetValues[alphabet[i]] = i;
        }
        for(i = 0; i < length; i++){
            var c = text[i];
            if (c === "-") continue;
            if (c in alphabetValues) {
                if (alphabetValues[c] >= absBase) {
                    if (c === "1" && absBase === 1) continue;
                    throw new Error(c + " is not a valid digit in base " + base + ".");
                }
            }
        }
        base = parseValue(base);
        var digits = [];
        var isNegative = text[0] === "-";
        for(i = isNegative ? 1 : 0; i < text.length; i++){
            var c = text[i];
            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));
            else if (c === "<") {
                var start = i;
                do {
                    i++;
                }while (text[i] !== ">" && i < text.length);
                digits.push(parseValue(text.slice(start + 1, i)));
            } else throw new Error(c + " is not a valid character");
        }
        return parseBaseFromArray(digits, base, isNegative);
    };
    function parseBaseFromArray(digits, base, isNegative) {
        var val = Integer[0], pow = Integer[1], i;
        for(i = digits.length - 1; i >= 0; i--){
            val = val.add(digits[i].times(pow));
            pow = pow.times(base);
        }
        return isNegative ? val.negate() : val;
    }
    function stringify(digit, alphabet) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        if (digit < alphabet.length) {
            return alphabet[digit];
        }
        return "<" + digit + ">";
    }
    function toBase(n, base) {
        base = bigInt(base);
        if (base.isZero()) {
            if (n.isZero()) return {
                value: [
                    0
                ],
                isNegative: false
            };
            throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (base.equals(-1)) {
            if (n.isZero()) return {
                value: [
                    0
                ],
                isNegative: false
            };
            if (n.isNegative()) return {
                value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [
                    1,
                    0
                ])),
                isNegative: false
            };
            var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [
                0,
                1
            ]);
            arr.unshift([
                1
            ]);
            return {
                value: [].concat.apply([], arr),
                isNegative: false
            };
        }
        var neg = false;
        if (n.isNegative() && base.isPositive()) {
            neg = true;
            n = n.abs();
        }
        if (base.isUnit()) {
            if (n.isZero()) return {
                value: [
                    0
                ],
                isNegative: false
            };
            return {
                value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
                isNegative: neg
            };
        }
        var out = [];
        var left = n, divmod;
        while(left.isNegative() || left.compareAbs(base) >= 0){
            divmod = left.divmod(base);
            left = divmod.quotient;
            var digit = divmod.remainder;
            if (digit.isNegative()) {
                digit = base.minus(digit).abs();
                left = left.next();
            }
            out.push(digit.toJSNumber());
        }
        out.push(left.toJSNumber());
        return {
            value: out.reverse(),
            isNegative: neg
        };
    }
    function toBaseString(n, base, alphabet) {
        var arr = toBase(n, base);
        return (arr.isNegative ? "-" : "") + arr.value.map(function(x) {
            return stringify(x, alphabet);
        }).join("");
    }
    BigInteger.prototype.toArray = function(radix) {
        return toBase(this, radix);
    };
    SmallInteger.prototype.toArray = function(radix) {
        return toBase(this, radix);
    };
    NativeBigInt.prototype.toArray = function(radix) {
        return toBase(this, radix);
    };
    BigInteger.prototype.toString = function(radix, alphabet) {
        if (radix === undefined) radix = 10;
        if (radix !== 10 || alphabet) return toBaseString(this, radix, alphabet);
        var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
        while(--l >= 0){
            digit = String(v[l]);
            str += zeros.slice(digit.length) + digit;
        }
        var sign = this.sign ? "-" : "";
        return sign + str;
    };
    SmallInteger.prototype.toString = function(radix, alphabet) {
        if (radix === undefined) radix = 10;
        if (radix != 10 || alphabet) return toBaseString(this, radix, alphabet);
        return String(this.value);
    };
    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() {
        return this.toString();
    };
    BigInteger.prototype.valueOf = function() {
        return parseInt(this.toString(), 10);
    };
    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
    SmallInteger.prototype.valueOf = function() {
        return this.value;
    };
    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {
        return parseInt(this.toString(), 10);
    };
    function parseStringValue(v) {
        if (isPrecise(+v)) {
            var x = +v;
            if (x === truncate(x)) return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
            throw new Error("Invalid integer: " + v);
        }
        var sign = v[0] === "-";
        if (sign) v = v.slice(1);
        var split = v.split(/e/i);
        if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
        if (split.length === 2) {
            var exp = split[1];
            if (exp[0] === "+") exp = exp.slice(1);
            exp = +exp;
            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
            var text = split[0];
            var decimalPlace = text.indexOf(".");
            if (decimalPlace >= 0) {
                exp -= text.length - decimalPlace - 1;
                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
            }
            if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
            text += new Array(exp + 1).join("0");
            v = text;
        }
        var isValid = /^([0-9][0-9]*)$/.test(v);
        if (!isValid) throw new Error("Invalid integer: " + v);
        if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(sign ? "-" + v : v));
        }
        var r = [], max = v.length, l = LOG_BASE, min = max - l;
        while(max > 0){
            r.push(+v.slice(min, max));
            min -= l;
            if (min < 0) min = 0;
            max -= l;
        }
        trim(r);
        return new BigInteger(r, sign);
    }
    function parseNumberValue(v) {
        if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(v));
        }
        if (isPrecise(v)) {
            if (v !== truncate(v)) throw new Error(v + " is not an integer.");
            return new SmallInteger(v);
        }
        return parseStringValue(v.toString());
    }
    function parseValue(v) {
        if (typeof v === "number") {
            return parseNumberValue(v);
        }
        if (typeof v === "string") {
            return parseStringValue(v);
        }
        if (typeof v === "bigint") {
            return new NativeBigInt(v);
        }
        return v;
    }
    // Pre-define numbers in range [-999,999]
    for(var i = 0; i < 1000; i++){
        Integer[i] = parseValue(i);
        if (i > 0) Integer[-i] = parseValue(-i);
    }
    // Backwards compatibility
    Integer.one = Integer[1];
    Integer.zero = Integer[0];
    Integer.minusOne = Integer[-1];
    Integer.max = max;
    Integer.min = min;
    Integer.gcd = gcd;
    Integer.lcm = lcm;
    Integer.isInstance = function(x) {
        return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt;
    };
    Integer.randBetween = randBetween;
    Integer.fromArray = function(digits, base, isNegative) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
    };
    return Integer;
}();
// Node.js check
if ( true && module.hasOwnProperty("exports")) {
    module.exports = bigInt;
}
//amd check
if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
        return bigInt;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}


/***/ }),

/***/ 2361:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

var Chainsaw = __webpack_require__(55074);
var EventEmitter = (__webpack_require__(82361).EventEmitter);
var Buffers = __webpack_require__(67406);
var Vars = __webpack_require__(18705);
var Stream = (__webpack_require__(12781).Stream);
exports = module.exports = function(bufOrEm, eventName) {
    if (Buffer.isBuffer(bufOrEm)) {
        return exports.parse(bufOrEm);
    }
    var s = exports.stream();
    if (bufOrEm && bufOrEm.pipe) {
        bufOrEm.pipe(s);
    } else if (bufOrEm) {
        bufOrEm.on(eventName || "data", function(buf) {
            s.write(buf);
        });
        bufOrEm.on("end", function() {
            s.end();
        });
    }
    return s;
};
exports.stream = function(input) {
    if (input) return exports.apply(null, arguments);
    var pending = null;
    function getBytes(bytes, cb, skip) {
        pending = {
            bytes: bytes,
            skip: skip,
            cb: function(buf) {
                pending = null;
                cb(buf);
            }
        };
        dispatch();
    }
    var offset = null;
    function dispatch() {
        if (!pending) {
            if (caughtEnd) done = true;
            return;
        }
        if (typeof pending === "function") {
            pending();
        } else {
            var bytes = offset + pending.bytes;
            if (buffers.length >= bytes) {
                var buf;
                if (offset == null) {
                    buf = buffers.splice(0, bytes);
                    if (!pending.skip) {
                        buf = buf.slice();
                    }
                } else {
                    if (!pending.skip) {
                        buf = buffers.slice(offset, bytes);
                    }
                    offset = bytes;
                }
                if (pending.skip) {
                    pending.cb();
                } else {
                    pending.cb(buf);
                }
            }
        }
    }
    function builder(saw) {
        function next() {
            if (!done) saw.next();
        }
        var self = words(function(bytes, cb) {
            return function(name) {
                getBytes(bytes, function(buf) {
                    vars.set(name, cb(buf));
                    next();
                });
            };
        });
        self.tap = function(cb) {
            saw.nest(cb, vars.store);
        };
        self.into = function(key, cb) {
            if (!vars.get(key)) vars.set(key, {});
            var parent = vars;
            vars = Vars(parent.get(key));
            saw.nest(function() {
                cb.apply(this, arguments);
                this.tap(function() {
                    vars = parent;
                });
            }, vars.store);
        };
        self.flush = function() {
            vars.store = {};
            next();
        };
        self.loop = function(cb) {
            var end = false;
            saw.nest(false, function loop() {
                this.vars = vars.store;
                cb.call(this, function() {
                    end = true;
                    next();
                }, vars.store);
                this.tap((function() {
                    if (end) saw.next();
                    else loop.call(this);
                }).bind(this));
            }, vars.store);
        };
        self.buffer = function(name, bytes) {
            if (typeof bytes === "string") {
                bytes = vars.get(bytes);
            }
            getBytes(bytes, function(buf) {
                vars.set(name, buf);
                next();
            });
        };
        self.skip = function(bytes) {
            if (typeof bytes === "string") {
                bytes = vars.get(bytes);
            }
            getBytes(bytes, function() {
                next();
            });
        };
        self.scan = function find(name, search) {
            if (typeof search === "string") {
                search = new Buffer(search);
            } else if (!Buffer.isBuffer(search)) {
                throw new Error("search must be a Buffer or a string");
            }
            var taken = 0;
            pending = function() {
                var pos = buffers.indexOf(search, offset + taken);
                var i = pos - offset - taken;
                if (pos !== -1) {
                    pending = null;
                    if (offset != null) {
                        vars.set(name, buffers.slice(offset, offset + taken + i));
                        offset += taken + i + search.length;
                    } else {
                        vars.set(name, buffers.slice(0, taken + i));
                        buffers.splice(0, taken + i + search.length);
                    }
                    next();
                    dispatch();
                } else {
                    i = Math.max(buffers.length - search.length - offset - taken, 0);
                }
                taken += i;
            };
            dispatch();
        };
        self.peek = function(cb) {
            offset = 0;
            saw.nest(function() {
                cb.call(this, vars.store);
                this.tap(function() {
                    offset = null;
                });
            });
        };
        return self;
    }
    ;
    var stream = Chainsaw.light(builder);
    stream.writable = true;
    var buffers = Buffers();
    stream.write = function(buf) {
        buffers.push(buf);
        dispatch();
    };
    var vars = Vars();
    var done = false, caughtEnd = false;
    stream.end = function() {
        caughtEnd = true;
    };
    stream.pipe = Stream.prototype.pipe;
    Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function(name) {
        stream[name] = EventEmitter.prototype[name];
    });
    return stream;
};
exports.parse = function parse(buffer) {
    var self = words(function(bytes, cb) {
        return function(name) {
            if (offset + bytes <= buffer.length) {
                var buf = buffer.slice(offset, offset + bytes);
                offset += bytes;
                vars.set(name, cb(buf));
            } else {
                vars.set(name, null);
            }
            return self;
        };
    });
    var offset = 0;
    var vars = Vars();
    self.vars = vars.store;
    self.tap = function(cb) {
        cb.call(self, vars.store);
        return self;
    };
    self.into = function(key, cb) {
        if (!vars.get(key)) {
            vars.set(key, {});
        }
        var parent = vars;
        vars = Vars(parent.get(key));
        cb.call(self, vars.store);
        vars = parent;
        return self;
    };
    self.loop = function(cb) {
        var end = false;
        var ender = function() {
            end = true;
        };
        while(end === false){
            cb.call(self, ender, vars.store);
        }
        return self;
    };
    self.buffer = function(name, size) {
        if (typeof size === "string") {
            size = vars.get(size);
        }
        var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));
        offset += size;
        vars.set(name, buf);
        return self;
    };
    self.skip = function(bytes) {
        if (typeof bytes === "string") {
            bytes = vars.get(bytes);
        }
        offset += bytes;
        return self;
    };
    self.scan = function(name, search) {
        if (typeof search === "string") {
            search = new Buffer(search);
        } else if (!Buffer.isBuffer(search)) {
            throw new Error("search must be a Buffer or a string");
        }
        vars.set(name, null);
        // simple but slow string search
        for(var i = 0; i + offset <= buffer.length - search.length + 1; i++){
            for(var j = 0; j < search.length && buffer[offset + i + j] === search[j]; j++);
            if (j === search.length) break;
        }
        vars.set(name, buffer.slice(offset, offset + i));
        offset += i + search.length;
        return self;
    };
    self.peek = function(cb) {
        var was = offset;
        cb.call(self, vars.store);
        offset = was;
        return self;
    };
    self.flush = function() {
        vars.store = {};
        return self;
    };
    self.eof = function() {
        return offset >= buffer.length;
    };
    return self;
};
// convert byte strings to unsigned little endian numbers
function decodeLEu(bytes) {
    var acc = 0;
    for(var i = 0; i < bytes.length; i++){
        acc += Math.pow(256, i) * bytes[i];
    }
    return acc;
}
// convert byte strings to unsigned big endian numbers
function decodeBEu(bytes) {
    var acc = 0;
    for(var i = 0; i < bytes.length; i++){
        acc += Math.pow(256, bytes.length - i - 1) * bytes[i];
    }
    return acc;
}
// convert byte strings to signed big endian numbers
function decodeBEs(bytes) {
    var val = decodeBEu(bytes);
    if ((bytes[0] & 0x80) == 0x80) {
        val -= Math.pow(256, bytes.length);
    }
    return val;
}
// convert byte strings to signed little endian numbers
function decodeLEs(bytes) {
    var val = decodeLEu(bytes);
    if ((bytes[bytes.length - 1] & 0x80) == 0x80) {
        val -= Math.pow(256, bytes.length);
    }
    return val;
}
function words(decode) {
    var self = {};
    [
        1,
        2,
        4,
        8
    ].forEach(function(bytes) {
        var bits = bytes * 8;
        self["word" + bits + "le"] = self["word" + bits + "lu"] = decode(bytes, decodeLEu);
        self["word" + bits + "ls"] = decode(bytes, decodeLEs);
        self["word" + bits + "be"] = self["word" + bits + "bu"] = decode(bytes, decodeBEu);
        self["word" + bits + "bs"] = decode(bytes, decodeBEs);
    });
    // word8be(n) == word8le(n) for all n
    self.word8 = self.word8u = self.word8be;
    self.word8s = self.word8bs;
    return self;
}


/***/ }),

/***/ 18705:
/***/ ((module) => {

"use strict";

module.exports = function(store) {
    function getset(name, value) {
        var node = vars.store;
        var keys = name.split(".");
        keys.slice(0, -1).forEach(function(k) {
            if (node[k] === undefined) node[k] = {};
            node = node[k];
        });
        var key = keys[keys.length - 1];
        if (arguments.length == 1) {
            return node[key];
        } else {
            return node[key] = value;
        }
    }
    var vars = {
        get: function(name) {
            return getset(name);
        },
        set: function(name, value) {
            return getset(name, value);
        },
        store: store || {}
    };
    return vars;
};


/***/ }),

/***/ 77810:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { Buffer } = __webpack_require__(14300);
const symbol = Symbol.for("BufferList");
function BufferList(buf) {
    if (!(this instanceof BufferList)) {
        return new BufferList(buf);
    }
    BufferList._init.call(this, buf);
}
BufferList._init = function _init(buf) {
    Object.defineProperty(this, symbol, {
        value: true
    });
    this._bufs = [];
    this.length = 0;
    if (buf) {
        this.append(buf);
    }
};
BufferList.prototype._new = function _new(buf) {
    return new BufferList(buf);
};
BufferList.prototype._offset = function _offset(offset) {
    if (offset === 0) {
        return [
            0,
            0
        ];
    }
    let tot = 0;
    for(let i = 0; i < this._bufs.length; i++){
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
            return [
                i,
                offset - tot
            ];
        }
        tot = _t;
    }
};
BufferList.prototype._reverseOffset = function(blOffset) {
    const bufferId = blOffset[0];
    let offset = blOffset[1];
    for(let i = 0; i < bufferId; i++){
        offset += this._bufs[i].length;
    }
    return offset;
};
BufferList.prototype.get = function get(index) {
    if (index > this.length || index < 0) {
        return undefined;
    }
    const offset = this._offset(index);
    return this._bufs[offset[0]][offset[1]];
};
BufferList.prototype.slice = function slice(start, end) {
    if (typeof start === "number" && start < 0) {
        start += this.length;
    }
    if (typeof end === "number" && end < 0) {
        end += this.length;
    }
    return this.copy(null, 0, start, end);
};
BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
    if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
    }
    if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
    }
    if (srcStart >= this.length) {
        return dst || Buffer.alloc(0);
    }
    if (srcEnd <= 0) {
        return dst || Buffer.alloc(0);
    }
    const copy = !!dst;
    const off = this._offset(srcStart);
    const len = srcEnd - srcStart;
    let bytes = len;
    let bufoff = copy && dstStart || 0;
    let start = off[1];
    // copy/slice everything
    if (srcStart === 0 && srcEnd === this.length) {
        if (!copy) {
            // slice, but full concat if multiple buffers
            return this._bufs.length === 1 ? this._bufs[0] : Buffer.concat(this._bufs, this.length);
        }
        // copy, need to copy individual buffers
        for(let i = 0; i < this._bufs.length; i++){
            this._bufs[i].copy(dst, bufoff);
            bufoff += this._bufs[i].length;
        }
        return dst;
    }
    // easy, cheap case where it's a subset of one of the buffers
    if (bytes <= this._bufs[off[0]].length - start) {
        return copy ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
    }
    if (!copy) {
        // a slice, we need something to copy in to
        dst = Buffer.allocUnsafe(len);
    }
    for(let i = off[0]; i < this._bufs.length; i++){
        const l = this._bufs[i].length - start;
        if (bytes > l) {
            this._bufs[i].copy(dst, bufoff, start);
            bufoff += l;
        } else {
            this._bufs[i].copy(dst, bufoff, start, start + bytes);
            bufoff += l;
            break;
        }
        bytes -= l;
        if (start) {
            start = 0;
        }
    }
    // safeguard so that we don't return uninitialized memory
    if (dst.length > bufoff) return dst.slice(0, bufoff);
    return dst;
};
BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
    start = start || 0;
    end = typeof end !== "number" ? this.length : end;
    if (start < 0) {
        start += this.length;
    }
    if (end < 0) {
        end += this.length;
    }
    if (start === end) {
        return this._new();
    }
    const startOffset = this._offset(start);
    const endOffset = this._offset(end);
    const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
    if (endOffset[1] === 0) {
        buffers.pop();
    } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
    }
    if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
    }
    return this._new(buffers);
};
BufferList.prototype.toString = function toString(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
};
BufferList.prototype.consume = function consume(bytes) {
    // first, normalize the argument, in accordance with how Buffer does it
    bytes = Math.trunc(bytes);
    // do nothing if not a positive number
    if (Number.isNaN(bytes) || bytes <= 0) return this;
    while(this._bufs.length){
        if (bytes >= this._bufs[0].length) {
            bytes -= this._bufs[0].length;
            this.length -= this._bufs[0].length;
            this._bufs.shift();
        } else {
            this._bufs[0] = this._bufs[0].slice(bytes);
            this.length -= bytes;
            break;
        }
    }
    return this;
};
BufferList.prototype.duplicate = function duplicate() {
    const copy = this._new();
    for(let i = 0; i < this._bufs.length; i++){
        copy.append(this._bufs[i]);
    }
    return copy;
};
BufferList.prototype.append = function append(buf) {
    if (buf == null) {
        return this;
    }
    if (buf.buffer) {
        // append a view of the underlying ArrayBuffer
        this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength));
    } else if (Array.isArray(buf)) {
        for(let i = 0; i < buf.length; i++){
            this.append(buf[i]);
        }
    } else if (this._isBufferList(buf)) {
        // unwrap argument into individual BufferLists
        for(let i = 0; i < buf._bufs.length; i++){
            this.append(buf._bufs[i]);
        }
    } else {
        // coerce number arguments to strings, since Buffer(number) does
        // uninitialized memory allocation
        if (typeof buf === "number") {
            buf = buf.toString();
        }
        this._appendBuffer(Buffer.from(buf));
    }
    return this;
};
BufferList.prototype._appendBuffer = function appendBuffer(buf) {
    this._bufs.push(buf);
    this.length += buf.length;
};
BufferList.prototype.indexOf = function(search, offset, encoding) {
    if (encoding === undefined && typeof offset === "string") {
        encoding = offset;
        offset = undefined;
    }
    if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
    } else if (typeof search === "number") {
        search = Buffer.from([
            search
        ]);
    } else if (typeof search === "string") {
        search = Buffer.from(search, encoding);
    } else if (this._isBufferList(search)) {
        search = search.slice();
    } else if (Array.isArray(search.buffer)) {
        search = Buffer.from(search.buffer, search.byteOffset, search.byteLength);
    } else if (!Buffer.isBuffer(search)) {
        search = Buffer.from(search);
    }
    offset = Number(offset || 0);
    if (isNaN(offset)) {
        offset = 0;
    }
    if (offset < 0) {
        offset = this.length + offset;
    }
    if (offset < 0) {
        offset = 0;
    }
    if (search.length === 0) {
        return offset > this.length ? this.length : offset;
    }
    const blOffset = this._offset(offset);
    let blIndex = blOffset[0] // index of which internal buffer we're working on
    ;
    let buffOffset = blOffset[1] // offset of the internal buffer we're working on
    ;
    // scan over each buffer
    for(; blIndex < this._bufs.length; blIndex++){
        const buff = this._bufs[blIndex];
        while(buffOffset < buff.length){
            const availableWindow = buff.length - buffOffset;
            if (availableWindow >= search.length) {
                const nativeSearchResult = buff.indexOf(search, buffOffset);
                if (nativeSearchResult !== -1) {
                    return this._reverseOffset([
                        blIndex,
                        nativeSearchResult
                    ]);
                }
                buffOffset = buff.length - search.length + 1 // end of native search window
                ;
            } else {
                const revOffset = this._reverseOffset([
                    blIndex,
                    buffOffset
                ]);
                if (this._match(revOffset, search)) {
                    return revOffset;
                }
                buffOffset++;
            }
        }
        buffOffset = 0;
    }
    return -1;
};
BufferList.prototype._match = function(offset, search) {
    if (this.length - offset < search.length) {
        return false;
    }
    for(let searchOffset = 0; searchOffset < search.length; searchOffset++){
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
            return false;
        }
    }
    return true;
};
(function() {
    const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
    };
    for(const m in methods){
        (function(m) {
            if (methods[m] === null) {
                BufferList.prototype[m] = function(offset, byteLength) {
                    return this.slice(offset, offset + byteLength)[m](0, byteLength);
                };
            } else {
                BufferList.prototype[m] = function(offset = 0) {
                    return this.slice(offset, offset + methods[m])[m](0);
                };
            }
        })(m);
    }
})();
// Used internally by the class and also as an indicator of this object being
// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser
// environment because there could be multiple different copies of the
// BufferList class and some `BufferList`s might be `BufferList`s.
BufferList.prototype._isBufferList = function _isBufferList(b) {
    return b instanceof BufferList || BufferList.isBufferList(b);
};
BufferList.isBufferList = function isBufferList(b) {
    return b != null && b[symbol];
};
module.exports = BufferList;


/***/ }),

/***/ 89011:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const DuplexStream = (__webpack_require__(98323).Duplex);
const inherits = __webpack_require__(33834);
const BufferList = __webpack_require__(77810);
function BufferListStream(callback) {
    if (!(this instanceof BufferListStream)) {
        return new BufferListStream(callback);
    }
    if (typeof callback === "function") {
        this._callback = callback;
        const piper = (function piper(err) {
            if (this._callback) {
                this._callback(err);
                this._callback = null;
            }
        }).bind(this);
        this.on("pipe", function onPipe(src) {
            src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
            src.removeListener("error", piper);
        });
        callback = null;
    }
    BufferList._init.call(this, callback);
    DuplexStream.call(this);
}
inherits(BufferListStream, DuplexStream);
Object.assign(BufferListStream.prototype, BufferList.prototype);
BufferListStream.prototype._new = function _new(callback) {
    return new BufferListStream(callback);
};
BufferListStream.prototype._write = function _write(buf, encoding, callback) {
    this._appendBuffer(buf);
    if (typeof callback === "function") {
        callback();
    }
};
BufferListStream.prototype._read = function _read(size) {
    if (!this.length) {
        return this.push(null);
    }
    size = Math.min(size, this.length);
    this.push(this.slice(0, size));
    this.consume(size);
};
BufferListStream.prototype.end = function end(chunk) {
    DuplexStream.prototype.end.call(this, chunk);
    if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
    }
};
BufferListStream.prototype._destroy = function _destroy(err, cb) {
    this._bufs.length = 0;
    this.length = 0;
    cb(err);
};
BufferListStream.prototype._isBufferList = function _isBufferList(b) {
    return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
};
BufferListStream.isBufferList = BufferList.isBufferList;
module.exports = BufferListStream;
module.exports.BufferListStream = BufferListStream;
module.exports.BufferList = BufferList;


/***/ }),

/***/ 26779:
/***/ ((module) => {

"use strict";

module.exports = function(Promise) {
    var SomePromiseArray = Promise._SomePromiseArray;
    function any(promises) {
        var ret = new SomePromiseArray(promises);
        var promise = ret.promise();
        ret.setHowMany(1);
        ret.setUnwrap();
        ret.init();
        return promise;
    }
    Promise.any = function(promises) {
        return any(promises);
    };
    Promise.prototype.any = function() {
        return any(this);
    };
};


/***/ }),

/***/ 27439:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var firstLineError;
try {
    throw new Error();
} catch (e) {
    firstLineError = e;
}
var schedule = __webpack_require__(5425);
var Queue = __webpack_require__(73815);
var util = __webpack_require__(64935);
function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self = this;
    this.drainQueues = function() {
        self._drainQueues();
    };
    this._schedule = schedule;
}
Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
};
Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
};
Async.prototype.enableTrampoline = function() {
    this._trampolineEnabled = true;
};
Async.prototype.disableTrampolineIfNecessary = function() {
    if (util.hasDevTools) {
        this._trampolineEnabled = false;
    }
};
Async.prototype.haveItemsQueued = function() {
    return this._isTickUsed || this._haveDrainedQueues;
};
Async.prototype.fatalError = function(e, isNode) {
    if (isNode) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
        process.exit(2);
    } else {
        this.throwLater(e);
    }
};
Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
        arg = fn;
        fn = function() {
            throw arg;
        };
    }
    if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
            fn(arg);
        }, 0);
    } else try {
        this._schedule(function() {
            fn(arg);
        });
    } catch (e) {
        throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
    }
};
function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
}
function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
}
function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
}
if (!util.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
} else {
    Async.prototype.invokeLater = function(fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                setTimeout(function() {
                    fn.call(receiver, arg);
                }, 100);
            });
        }
    };
    Async.prototype.invoke = function(fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvoke.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                fn.call(receiver, arg);
            });
        }
    };
    Async.prototype.settlePromises = function(promise) {
        if (this._trampolineEnabled) {
            AsyncSettlePromises.call(this, promise);
        } else {
            this._schedule(function() {
                promise._settlePromises();
            });
        }
    };
}
Async.prototype._drainQueue = function(queue) {
    while(queue.length() > 0){
        var fn = queue.shift();
        if (typeof fn !== "function") {
            fn._settlePromises();
            continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
    }
};
Async.prototype._drainQueues = function() {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
};
Async.prototype._queueTick = function() {
    if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
    }
};
Async.prototype._reset = function() {
    this._isTickUsed = false;
};
module.exports = Async;
module.exports.firstLineError = firstLineError;


/***/ }),

/***/ 4988:
/***/ ((module) => {

"use strict";

module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
    var calledBind = false;
    var rejectThis = function(_, e) {
        this._reject(e);
    };
    var targetRejected = function(e, context) {
        context.promiseRejectionQueued = true;
        context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };
    var bindingResolved = function(thisArg, context) {
        if ((this._bitField & 50397184) === 0) {
            this._resolveCallback(context.target);
        }
    };
    var bindingRejected = function(e, context) {
        if (!context.promiseRejectionQueued) this._reject(e);
    };
    Promise.prototype.bind = function(thisArg) {
        if (!calledBind) {
            calledBind = true;
            Promise.prototype._propagateFrom = debug.propagateFromFunction();
            Promise.prototype._boundValue = debug.boundValueFunction();
        }
        var maybePromise = tryConvertToPromise(thisArg);
        var ret = new Promise(INTERNAL);
        ret._propagateFrom(this, 1);
        var target = this._target();
        ret._setBoundTo(maybePromise);
        if (maybePromise instanceof Promise) {
            var context = {
                promiseRejectionQueued: false,
                promise: ret,
                target: target,
                bindingPromise: maybePromise
            };
            target._then(INTERNAL, targetRejected, undefined, ret, context);
            maybePromise._then(bindingResolved, bindingRejected, undefined, ret, context);
            ret._setOnCancel(maybePromise);
        } else {
            ret._resolveCallback(target);
        }
        return ret;
    };
    Promise.prototype._setBoundTo = function(obj) {
        if (obj !== undefined) {
            this._bitField = this._bitField | 2097152;
            this._boundTo = obj;
        } else {
            this._bitField = this._bitField & ~2097152;
        }
    };
    Promise.prototype._isBound = function() {
        return (this._bitField & 2097152) === 2097152;
    };
    Promise.bind = function(thisArg, value) {
        return Promise.resolve(value).bind(thisArg);
    };
};


/***/ }),

/***/ 72468:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var old;
if (typeof Promise !== "undefined") old = Promise;
function noConflict() {
    try {
        if (Promise === bluebird) Promise = old;
    } catch (e) {}
    return bluebird;
}
var bluebird = __webpack_require__(91865)();
bluebird.noConflict = noConflict;
module.exports = bluebird;


/***/ }),

/***/ 27929:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var cr = Object.create;
if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
}
module.exports = function(Promise) {
    var util = __webpack_require__(64935);
    var canEvaluate = util.canEvaluate;
    var isIdentifier = util.isIdentifier;
    var getMethodCaller;
    var getGetter;
    if (true) {
        var makeMethodCaller = function(methodName) {
            return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
        };
        var makeGetter = function(propertyName) {
            return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
        };
        var getCompiled = function(name, compiler, cache) {
            var ret = cache[name];
            if (typeof ret !== "function") {
                if (!isIdentifier(name)) {
                    return null;
                }
                ret = compiler(name);
                cache[name] = ret;
                cache[" size"]++;
                if (cache[" size"] > 512) {
                    var keys = Object.keys(cache);
                    for(var i = 0; i < 256; ++i)delete cache[keys[i]];
                    cache[" size"] = keys.length - 256;
                }
            }
            return ret;
        };
        getMethodCaller = function(name) {
            return getCompiled(name, makeMethodCaller, callerCache);
        };
        getGetter = function(name) {
            return getCompiled(name, makeGetter, getterCache);
        };
    }
    function ensureMethod(obj, methodName) {
        var fn;
        if (obj != null) fn = obj[methodName];
        if (typeof fn !== "function") {
            var message = "Object " + util.classString(obj) + " has no method '" + util.toString(methodName) + "'";
            throw new Promise.TypeError(message);
        }
        return fn;
    }
    function caller(obj) {
        var methodName = this.pop();
        var fn = ensureMethod(obj, methodName);
        return fn.apply(obj, this);
    }
    Promise.prototype.call = function(methodName) {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for(var $_i = 1; $_i < $_len; ++$_i){
            args[$_i - 1] = arguments[$_i];
        }
        ;
        if (true) {
            if (canEvaluate) {
                var maybeCaller = getMethodCaller(methodName);
                if (maybeCaller !== null) {
                    return this._then(maybeCaller, undefined, undefined, args, undefined);
                }
            }
        }
        args.push(methodName);
        return this._then(caller, undefined, undefined, args, undefined);
    };
    function namedGetter(obj) {
        return obj[this];
    }
    function indexedGetter(obj) {
        var index = +this;
        if (index < 0) index = Math.max(0, index + obj.length);
        return obj[index];
    }
    Promise.prototype.get = function(propertyName) {
        var isIndex = typeof propertyName === "number";
        var getter;
        if (!isIndex) {
            if (canEvaluate) {
                var maybeGetter = getGetter(propertyName);
                getter = maybeGetter !== null ? maybeGetter : namedGetter;
            } else {
                getter = namedGetter;
            }
        } else {
            getter = indexedGetter;
        }
        return this._then(getter, undefined, undefined, propertyName, undefined);
    };
};


/***/ }),

/***/ 23558:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise, PromiseArray, apiRejection, debug) {
    var util = __webpack_require__(64935);
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var async = Promise._async;
    Promise.prototype["break"] = Promise.prototype.cancel = function() {
        if (!debug.cancellation()) return this._warn("cancellation is disabled");
        var promise = this;
        var child = promise;
        while(promise._isCancellable()){
            if (!promise._cancelBy(child)) {
                if (child._isFollowing()) {
                    child._followee().cancel();
                } else {
                    child._cancelBranched();
                }
                break;
            }
            var parent = promise._cancellationParent;
            if (parent == null || !parent._isCancellable()) {
                if (promise._isFollowing()) {
                    promise._followee().cancel();
                } else {
                    promise._cancelBranched();
                }
                break;
            } else {
                if (promise._isFollowing()) promise._followee().cancel();
                promise._setWillBeCancelled();
                child = promise;
                promise = parent;
            }
        }
    };
    Promise.prototype._branchHasCancelled = function() {
        this._branchesRemainingToCancel--;
    };
    Promise.prototype._enoughBranchesHaveCancelled = function() {
        return this._branchesRemainingToCancel === undefined || this._branchesRemainingToCancel <= 0;
    };
    Promise.prototype._cancelBy = function(canceller) {
        if (canceller === this) {
            this._branchesRemainingToCancel = 0;
            this._invokeOnCancel();
            return true;
        } else {
            this._branchHasCancelled();
            if (this._enoughBranchesHaveCancelled()) {
                this._invokeOnCancel();
                return true;
            }
        }
        return false;
    };
    Promise.prototype._cancelBranched = function() {
        if (this._enoughBranchesHaveCancelled()) {
            this._cancel();
        }
    };
    Promise.prototype._cancel = function() {
        if (!this._isCancellable()) return;
        this._setCancelled();
        async.invoke(this._cancelPromises, this, undefined);
    };
    Promise.prototype._cancelPromises = function() {
        if (this._length() > 0) this._settlePromises();
    };
    Promise.prototype._unsetOnCancel = function() {
        this._onCancelField = undefined;
    };
    Promise.prototype._isCancellable = function() {
        return this.isPending() && !this._isCancelled();
    };
    Promise.prototype.isCancellable = function() {
        return this.isPending() && !this.isCancelled();
    };
    Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
        if (util.isArray(onCancelCallback)) {
            for(var i = 0; i < onCancelCallback.length; ++i){
                this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
            }
        } else if (onCancelCallback !== undefined) {
            if (typeof onCancelCallback === "function") {
                if (!internalOnly) {
                    var e = tryCatch(onCancelCallback).call(this._boundValue());
                    if (e === errorObj) {
                        this._attachExtraTrace(e.e);
                        async.throwLater(e.e);
                    }
                }
            } else {
                onCancelCallback._resultCancelled(this);
            }
        }
    };
    Promise.prototype._invokeOnCancel = function() {
        var onCancelCallback = this._onCancel();
        this._unsetOnCancel();
        async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
    };
    Promise.prototype._invokeInternalOnCancel = function() {
        if (this._isCancellable()) {
            this._doInvokeOnCancel(this._onCancel(), true);
            this._unsetOnCancel();
        }
    };
    Promise.prototype._resultCancelled = function() {
        this.cancel();
    };
};


/***/ }),

/***/ 22308:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(NEXT_FILTER) {
    var util = __webpack_require__(64935);
    var getKeys = (__webpack_require__(12032).keys);
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    function catchFilter(instances, cb, promise) {
        return function(e) {
            var boundTo = promise._boundValue();
            predicateLoop: for(var i = 0; i < instances.length; ++i){
                var item = instances[i];
                if (item === Error || item != null && item.prototype instanceof Error) {
                    if (e instanceof item) {
                        return tryCatch(cb).call(boundTo, e);
                    }
                } else if (typeof item === "function") {
                    var matchesPredicate = tryCatch(item).call(boundTo, e);
                    if (matchesPredicate === errorObj) {
                        return matchesPredicate;
                    } else if (matchesPredicate) {
                        return tryCatch(cb).call(boundTo, e);
                    }
                } else if (util.isObject(e)) {
                    var keys = getKeys(item);
                    for(var j = 0; j < keys.length; ++j){
                        var key = keys[j];
                        if (item[key] != e[key]) {
                            continue predicateLoop;
                        }
                    }
                    return tryCatch(cb).call(boundTo, e);
                }
            }
            return NEXT_FILTER;
        };
    }
    return catchFilter;
};


/***/ }),

/***/ 8254:
/***/ ((module) => {

"use strict";

module.exports = function(Promise) {
    var longStackTraces = false;
    var contextStack = [];
    Promise.prototype._promiseCreated = function() {};
    Promise.prototype._pushContext = function() {};
    Promise.prototype._popContext = function() {
        return null;
    };
    Promise._peekContext = Promise.prototype._peekContext = function() {};
    function Context() {
        this._trace = new Context.CapturedTrace(peekContext());
    }
    Context.prototype._pushContext = function() {
        if (this._trace !== undefined) {
            this._trace._promiseCreated = null;
            contextStack.push(this._trace);
        }
    };
    Context.prototype._popContext = function() {
        if (this._trace !== undefined) {
            var trace = contextStack.pop();
            var ret = trace._promiseCreated;
            trace._promiseCreated = null;
            return ret;
        }
        return null;
    };
    function createContext() {
        if (longStackTraces) return new Context();
    }
    function peekContext() {
        var lastIndex = contextStack.length - 1;
        if (lastIndex >= 0) {
            return contextStack[lastIndex];
        }
        return undefined;
    }
    Context.CapturedTrace = null;
    Context.create = createContext;
    Context.deactivateLongStackTraces = function() {};
    Context.activateLongStackTraces = function() {
        var Promise_pushContext = Promise.prototype._pushContext;
        var Promise_popContext = Promise.prototype._popContext;
        var Promise_PeekContext = Promise._peekContext;
        var Promise_peekContext = Promise.prototype._peekContext;
        var Promise_promiseCreated = Promise.prototype._promiseCreated;
        Context.deactivateLongStackTraces = function() {
            Promise.prototype._pushContext = Promise_pushContext;
            Promise.prototype._popContext = Promise_popContext;
            Promise._peekContext = Promise_PeekContext;
            Promise.prototype._peekContext = Promise_peekContext;
            Promise.prototype._promiseCreated = Promise_promiseCreated;
            longStackTraces = false;
        };
        longStackTraces = true;
        Promise.prototype._pushContext = Context.prototype._pushContext;
        Promise.prototype._popContext = Context.prototype._popContext;
        Promise._peekContext = Promise.prototype._peekContext = peekContext;
        Promise.prototype._promiseCreated = function() {
            var ctx = this._peekContext();
            if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
        };
    };
    return Context;
};


/***/ }),

/***/ 20928:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise, Context) {
    var getDomain = Promise._getDomain;
    var async = Promise._async;
    var Warning = (__webpack_require__(91710).Warning);
    var util = __webpack_require__(64935);
    var canAttachTrace = util.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
    var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
    var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var printWarning;
    var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && ( false || util.env("BLUEBIRD_DEBUG") || util.env("NODE_ENV") === "development"));
    var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));
    var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
    var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
    Promise.prototype.suppressUnhandledRejections = function() {
        var target = this._target();
        target._bitField = target._bitField & ~1048576 | 524288;
    };
    Promise.prototype._ensurePossibleRejectionHandled = function() {
        if ((this._bitField & 524288) !== 0) return;
        this._setRejectionIsUnhandled();
        async.invokeLater(this._notifyUnhandledRejection, this, undefined);
    };
    Promise.prototype._notifyUnhandledRejectionIsHandled = function() {
        fireRejectionEvent("rejectionHandled", unhandledRejectionHandled, undefined, this);
    };
    Promise.prototype._setReturnedNonUndefined = function() {
        this._bitField = this._bitField | 268435456;
    };
    Promise.prototype._returnedNonUndefined = function() {
        return (this._bitField & 268435456) !== 0;
    };
    Promise.prototype._notifyUnhandledRejection = function() {
        if (this._isRejectionUnhandled()) {
            var reason = this._settledValue();
            this._setUnhandledRejectionIsNotified();
            fireRejectionEvent("unhandledRejection", possiblyUnhandledRejection, reason, this);
        }
    };
    Promise.prototype._setUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField | 262144;
    };
    Promise.prototype._unsetUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField & ~262144;
    };
    Promise.prototype._isUnhandledRejectionNotified = function() {
        return (this._bitField & 262144) > 0;
    };
    Promise.prototype._setRejectionIsUnhandled = function() {
        this._bitField = this._bitField | 1048576;
    };
    Promise.prototype._unsetRejectionIsUnhandled = function() {
        this._bitField = this._bitField & ~1048576;
        if (this._isUnhandledRejectionNotified()) {
            this._unsetUnhandledRejectionIsNotified();
            this._notifyUnhandledRejectionIsHandled();
        }
    };
    Promise.prototype._isRejectionUnhandled = function() {
        return (this._bitField & 1048576) > 0;
    };
    Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
        return warn(message, shouldUseOwnTrace, promise || this);
    };
    Promise.onPossiblyUnhandledRejection = function(fn) {
        var domain = getDomain();
        possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;
    };
    Promise.onUnhandledRejectionHandled = function(fn) {
        var domain = getDomain();
        unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : undefined;
    };
    var disableLongStackTraces = function() {};
    Promise.longStackTraces = function() {
        if (async.haveItemsQueued() && !config.longStackTraces) {
            throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
        }
        if (!config.longStackTraces && longStackTracesIsSupported()) {
            var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
            var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
            config.longStackTraces = true;
            disableLongStackTraces = function() {
                if (async.haveItemsQueued() && !config.longStackTraces) {
                    throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
                }
                Promise.prototype._captureStackTrace = Promise_captureStackTrace;
                Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
                Context.deactivateLongStackTraces();
                async.enableTrampoline();
                config.longStackTraces = false;
            };
            Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
            Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
            Context.activateLongStackTraces();
            async.disableTrampolineIfNecessary();
        }
    };
    Promise.hasLongStackTraces = function() {
        return config.longStackTraces && longStackTracesIsSupported();
    };
    var fireDomEvent = function() {
        try {
            if (typeof CustomEvent === "function") {
                var event = new CustomEvent("CustomEvent");
                util.global.dispatchEvent(event);
                return function(name, event) {
                    var domEvent = new CustomEvent(name.toLowerCase(), {
                        detail: event,
                        cancelable: true
                    });
                    return !util.global.dispatchEvent(domEvent);
                };
            } else if (typeof Event === "function") {
                var event = new Event("CustomEvent");
                util.global.dispatchEvent(event);
                return function(name, event) {
                    var domEvent = new Event(name.toLowerCase(), {
                        cancelable: true
                    });
                    domEvent.detail = event;
                    return !util.global.dispatchEvent(domEvent);
                };
            } else {
                var event = document.createEvent("CustomEvent");
                event.initCustomEvent("testingtheevent", false, true, {});
                util.global.dispatchEvent(event);
                return function(name, event) {
                    var domEvent = document.createEvent("CustomEvent");
                    domEvent.initCustomEvent(name.toLowerCase(), false, true, event);
                    return !util.global.dispatchEvent(domEvent);
                };
            }
        } catch (e) {}
        return function() {
            return false;
        };
    }();
    var fireGlobalEvent = function() {
        if (util.isNode) {
            return function() {
                return process.emit.apply(process, arguments);
            };
        } else {
            if (!util.global) {
                return function() {
                    return false;
                };
            }
            return function(name) {
                var methodName = "on" + name.toLowerCase();
                var method = util.global[methodName];
                if (!method) return false;
                method.apply(util.global, [].slice.call(arguments, 1));
                return true;
            };
        }
    }();
    function generatePromiseLifecycleEventObject(name, promise) {
        return {
            promise: promise
        };
    }
    var eventToObjectGenerator = {
        promiseCreated: generatePromiseLifecycleEventObject,
        promiseFulfilled: generatePromiseLifecycleEventObject,
        promiseRejected: generatePromiseLifecycleEventObject,
        promiseResolved: generatePromiseLifecycleEventObject,
        promiseCancelled: generatePromiseLifecycleEventObject,
        promiseChained: function(name, promise, child) {
            return {
                promise: promise,
                child: child
            };
        },
        warning: function(name, warning) {
            return {
                warning: warning
            };
        },
        unhandledRejection: function(name, reason, promise) {
            return {
                reason: reason,
                promise: promise
            };
        },
        rejectionHandled: generatePromiseLifecycleEventObject
    };
    var activeFireEvent = function(name) {
        var globalEventFired = false;
        try {
            globalEventFired = fireGlobalEvent.apply(null, arguments);
        } catch (e) {
            async.throwLater(e);
            globalEventFired = true;
        }
        var domEventFired = false;
        try {
            domEventFired = fireDomEvent(name, eventToObjectGenerator[name].apply(null, arguments));
        } catch (e) {
            async.throwLater(e);
            domEventFired = true;
        }
        return domEventFired || globalEventFired;
    };
    Promise.config = function(opts) {
        opts = Object(opts);
        if ("longStackTraces" in opts) {
            if (opts.longStackTraces) {
                Promise.longStackTraces();
            } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
                disableLongStackTraces();
            }
        }
        if ("warnings" in opts) {
            var warningsOption = opts.warnings;
            config.warnings = !!warningsOption;
            wForgottenReturn = config.warnings;
            if (util.isObject(warningsOption)) {
                if ("wForgottenReturn" in warningsOption) {
                    wForgottenReturn = !!warningsOption.wForgottenReturn;
                }
            }
        }
        if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
            if (async.haveItemsQueued()) {
                throw new Error("cannot enable cancellation after promises are in use");
            }
            Promise.prototype._clearCancellationData = cancellationClearCancellationData;
            Promise.prototype._propagateFrom = cancellationPropagateFrom;
            Promise.prototype._onCancel = cancellationOnCancel;
            Promise.prototype._setOnCancel = cancellationSetOnCancel;
            Promise.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
            Promise.prototype._execute = cancellationExecute;
            propagateFromFunction = cancellationPropagateFrom;
            config.cancellation = true;
        }
        if ("monitoring" in opts) {
            if (opts.monitoring && !config.monitoring) {
                config.monitoring = true;
                Promise.prototype._fireEvent = activeFireEvent;
            } else if (!opts.monitoring && config.monitoring) {
                config.monitoring = false;
                Promise.prototype._fireEvent = defaultFireEvent;
            }
        }
        return Promise;
    };
    function defaultFireEvent() {
        return false;
    }
    Promise.prototype._fireEvent = defaultFireEvent;
    Promise.prototype._execute = function(executor, resolve, reject) {
        try {
            executor(resolve, reject);
        } catch (e) {
            return e;
        }
    };
    Promise.prototype._onCancel = function() {};
    Promise.prototype._setOnCancel = function(handler) {
        ;
    };
    Promise.prototype._attachCancellationCallback = function(onCancel) {
        ;
    };
    Promise.prototype._captureStackTrace = function() {};
    Promise.prototype._attachExtraTrace = function() {};
    Promise.prototype._clearCancellationData = function() {};
    Promise.prototype._propagateFrom = function(parent, flags) {
        ;
        ;
    };
    function cancellationExecute(executor, resolve, reject) {
        var promise = this;
        try {
            executor(resolve, reject, function(onCancel) {
                if (typeof onCancel !== "function") {
                    throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
                }
                promise._attachCancellationCallback(onCancel);
            });
        } catch (e) {
            return e;
        }
    }
    function cancellationAttachCancellationCallback(onCancel) {
        if (!this._isCancellable()) return this;
        var previousOnCancel = this._onCancel();
        if (previousOnCancel !== undefined) {
            if (util.isArray(previousOnCancel)) {
                previousOnCancel.push(onCancel);
            } else {
                this._setOnCancel([
                    previousOnCancel,
                    onCancel
                ]);
            }
        } else {
            this._setOnCancel(onCancel);
        }
    }
    function cancellationOnCancel() {
        return this._onCancelField;
    }
    function cancellationSetOnCancel(onCancel) {
        this._onCancelField = onCancel;
    }
    function cancellationClearCancellationData() {
        this._cancellationParent = undefined;
        this._onCancelField = undefined;
    }
    function cancellationPropagateFrom(parent, flags) {
        if ((flags & 1) !== 0) {
            this._cancellationParent = parent;
            var branchesRemainingToCancel = parent._branchesRemainingToCancel;
            if (branchesRemainingToCancel === undefined) {
                branchesRemainingToCancel = 0;
            }
            parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
        }
        if ((flags & 2) !== 0 && parent._isBound()) {
            this._setBoundTo(parent._boundTo);
        }
    }
    function bindingPropagateFrom(parent, flags) {
        if ((flags & 2) !== 0 && parent._isBound()) {
            this._setBoundTo(parent._boundTo);
        }
    }
    var propagateFromFunction = bindingPropagateFrom;
    function boundValueFunction() {
        var ret = this._boundTo;
        if (ret !== undefined) {
            if (ret instanceof Promise) {
                if (ret.isFulfilled()) {
                    return ret.value();
                } else {
                    return undefined;
                }
            }
        }
        return ret;
    }
    function longStackTracesCaptureStackTrace() {
        this._trace = new CapturedTrace(this._peekContext());
    }
    function longStackTracesAttachExtraTrace(error, ignoreSelf) {
        if (canAttachTrace(error)) {
            var trace = this._trace;
            if (trace !== undefined) {
                if (ignoreSelf) trace = trace._parent;
            }
            if (trace !== undefined) {
                trace.attachExtraTrace(error);
            } else if (!error.__stackCleaned__) {
                var parsed = parseStackAndMessage(error);
                util.notEnumerableProp(error, "stack", parsed.message + "\n" + parsed.stack.join("\n"));
                util.notEnumerableProp(error, "__stackCleaned__", true);
            }
        }
    }
    function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
        if (returnValue === undefined && promiseCreated !== null && wForgottenReturn) {
            if (parent !== undefined && parent._returnedNonUndefined()) return;
            if ((promise._bitField & 65535) === 0) return;
            if (name) name = name + " ";
            var handlerLine = "";
            var creatorLine = "";
            if (promiseCreated._trace) {
                var traceLines = promiseCreated._trace.stack.split("\n");
                var stack = cleanStack(traceLines);
                for(var i = stack.length - 1; i >= 0; --i){
                    var line = stack[i];
                    if (!nodeFramePattern.test(line)) {
                        var lineMatches = line.match(parseLinePattern);
                        if (lineMatches) {
                            handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                        }
                        break;
                    }
                }
                if (stack.length > 0) {
                    var firstUserLine = stack[0];
                    for(var i = 0; i < traceLines.length; ++i){
                        if (traceLines[i] === firstUserLine) {
                            if (i > 0) {
                                creatorLine = "\n" + traceLines[i - 1];
                            }
                            break;
                        }
                    }
                }
            }
            var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, " + "see http://goo.gl/rRqMUw" + creatorLine;
            promise._warn(msg, true, promiseCreated);
        }
    }
    function deprecated(name, replacement) {
        var message = name + " is deprecated and will be removed in a future version.";
        if (replacement) message += " Use " + replacement + " instead.";
        return warn(message);
    }
    function warn(message, shouldUseOwnTrace, promise) {
        if (!config.warnings) return;
        var warning = new Warning(message);
        var ctx;
        if (shouldUseOwnTrace) {
            promise._attachExtraTrace(warning);
        } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
            ctx.attachExtraTrace(warning);
        } else {
            var parsed = parseStackAndMessage(warning);
            warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
        }
        if (!activeFireEvent("warning", warning)) {
            formatAndLogError(warning, "", true);
        }
    }
    function reconstructStack(message, stacks) {
        for(var i = 0; i < stacks.length - 1; ++i){
            stacks[i].push("From previous event:");
            stacks[i] = stacks[i].join("\n");
        }
        if (i < stacks.length) {
            stacks[i] = stacks[i].join("\n");
        }
        return message + "\n" + stacks.join("\n");
    }
    function removeDuplicateOrEmptyJumps(stacks) {
        for(var i = 0; i < stacks.length; ++i){
            if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
                stacks.splice(i, 1);
                i--;
            }
        }
    }
    function removeCommonRoots(stacks) {
        var current = stacks[0];
        for(var i = 1; i < stacks.length; ++i){
            var prev = stacks[i];
            var currentLastIndex = current.length - 1;
            var currentLastLine = current[currentLastIndex];
            var commonRootMeetPoint = -1;
            for(var j = prev.length - 1; j >= 0; --j){
                if (prev[j] === currentLastLine) {
                    commonRootMeetPoint = j;
                    break;
                }
            }
            for(var j = commonRootMeetPoint; j >= 0; --j){
                var line = prev[j];
                if (current[currentLastIndex] === line) {
                    current.pop();
                    currentLastIndex--;
                } else {
                    break;
                }
            }
            current = prev;
        }
    }
    function cleanStack(stack) {
        var ret = [];
        for(var i = 0; i < stack.length; ++i){
            var line = stack[i];
            var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
            var isInternalFrame = isTraceLine && shouldIgnore(line);
            if (isTraceLine && !isInternalFrame) {
                if (indentStackFrames && line.charAt(0) !== " ") {
                    line = "    " + line;
                }
                ret.push(line);
            }
        }
        return ret;
    }
    function stackFramesAsArray(error) {
        var stack = error.stack.replace(/\s+$/g, "").split("\n");
        for(var i = 0; i < stack.length; ++i){
            var line = stack[i];
            if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
                break;
            }
        }
        if (i > 0 && error.name != "SyntaxError") {
            stack = stack.slice(i);
        }
        return stack;
    }
    function parseStackAndMessage(error) {
        var stack = error.stack;
        var message = error.toString();
        stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : [
            "    (No stack trace)"
        ];
        return {
            message: message,
            stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
        };
    }
    function formatAndLogError(error, title, isSoft) {
        if (typeof console !== "undefined") {
            var message;
            if (util.isObject(error)) {
                var stack = error.stack;
                message = title + formatStack(stack, error);
            } else {
                message = title + String(error);
            }
            if (typeof printWarning === "function") {
                printWarning(message, isSoft);
            } else if (typeof console.log === "function" || typeof console.log === "object") {
                console.log(message);
            }
        }
    }
    function fireRejectionEvent(name, localHandler, reason, promise) {
        var localEventFired = false;
        try {
            if (typeof localHandler === "function") {
                localEventFired = true;
                if (name === "rejectionHandled") {
                    localHandler(promise);
                } else {
                    localHandler(reason, promise);
                }
            }
        } catch (e) {
            async.throwLater(e);
        }
        if (name === "unhandledRejection") {
            if (!activeFireEvent(name, reason, promise) && !localEventFired) {
                formatAndLogError(reason, "Unhandled rejection ");
            }
        } else {
            activeFireEvent(name, promise);
        }
    }
    function formatNonError(obj) {
        var str;
        if (typeof obj === "function") {
            str = "[function " + (obj.name || "anonymous") + "]";
        } else {
            str = obj && typeof obj.toString === "function" ? obj.toString() : util.toString(obj);
            var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
            if (ruselessToString.test(str)) {
                try {
                    var newStr = JSON.stringify(obj);
                    str = newStr;
                } catch (e) {}
            }
            if (str.length === 0) {
                str = "(empty array)";
            }
        }
        return "(<" + snip(str) + ">, no stack trace)";
    }
    function snip(str) {
        var maxChars = 41;
        if (str.length < maxChars) {
            return str;
        }
        return str.substr(0, maxChars - 3) + "...";
    }
    function longStackTracesIsSupported() {
        return typeof captureStackTrace === "function";
    }
    var shouldIgnore = function() {
        return false;
    };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
        var matches = line.match(parseLineInfoRegex);
        if (matches) {
            return {
                fileName: matches[1],
                line: parseInt(matches[2], 10)
            };
        }
    }
    function setBounds(firstLineError, lastLineError) {
        if (!longStackTracesIsSupported()) return;
        var firstStackLines = firstLineError.stack.split("\n");
        var lastStackLines = lastLineError.stack.split("\n");
        var firstIndex = -1;
        var lastIndex = -1;
        var firstFileName;
        var lastFileName;
        for(var i = 0; i < firstStackLines.length; ++i){
            var result = parseLineInfo(firstStackLines[i]);
            if (result) {
                firstFileName = result.fileName;
                firstIndex = result.line;
                break;
            }
        }
        for(var i = 0; i < lastStackLines.length; ++i){
            var result = parseLineInfo(lastStackLines[i]);
            if (result) {
                lastFileName = result.fileName;
                lastIndex = result.line;
                break;
            }
        }
        if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
            return;
        }
        shouldIgnore = function(line) {
            if (bluebirdFramePattern.test(line)) return true;
            var info = parseLineInfo(line);
            if (info) {
                if (info.fileName === firstFileName && firstIndex <= info.line && info.line <= lastIndex) {
                    return true;
                }
            }
            return false;
        };
    }
    function CapturedTrace(parent) {
        this._parent = parent;
        this._promisesCreated = 0;
        var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
        captureStackTrace(this, CapturedTrace);
        if (length > 32) this.uncycle();
    }
    util.inherits(CapturedTrace, Error);
    Context.CapturedTrace = CapturedTrace;
    CapturedTrace.prototype.uncycle = function() {
        var length = this._length;
        if (length < 2) return;
        var nodes = [];
        var stackToIndex = {};
        for(var i = 0, node = this; node !== undefined; ++i){
            nodes.push(node);
            node = node._parent;
        }
        length = this._length = i;
        for(var i = length - 1; i >= 0; --i){
            var stack = nodes[i].stack;
            if (stackToIndex[stack] === undefined) {
                stackToIndex[stack] = i;
            }
        }
        for(var i = 0; i < length; ++i){
            var currentStack = nodes[i].stack;
            var index = stackToIndex[currentStack];
            if (index !== undefined && index !== i) {
                if (index > 0) {
                    nodes[index - 1]._parent = undefined;
                    nodes[index - 1]._length = 1;
                }
                nodes[i]._parent = undefined;
                nodes[i]._length = 1;
                var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
                if (index < length - 1) {
                    cycleEdgeNode._parent = nodes[index + 1];
                    cycleEdgeNode._parent.uncycle();
                    cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
                } else {
                    cycleEdgeNode._parent = undefined;
                    cycleEdgeNode._length = 1;
                }
                var currentChildLength = cycleEdgeNode._length + 1;
                for(var j = i - 2; j >= 0; --j){
                    nodes[j]._length = currentChildLength;
                    currentChildLength++;
                }
                return;
            }
        }
    };
    CapturedTrace.prototype.attachExtraTrace = function(error) {
        if (error.__stackCleaned__) return;
        this.uncycle();
        var parsed = parseStackAndMessage(error);
        var message = parsed.message;
        var stacks = [
            parsed.stack
        ];
        var trace = this;
        while(trace !== undefined){
            stacks.push(cleanStack(trace.stack.split("\n")));
            trace = trace._parent;
        }
        removeCommonRoots(stacks);
        removeDuplicateOrEmptyJumps(stacks);
        util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
        util.notEnumerableProp(error, "__stackCleaned__", true);
    };
    var captureStackTrace = function stackDetection() {
        var v8stackFramePattern = /^\s*at\s*/;
        var v8stackFormatter = function(stack, error) {
            if (typeof stack === "string") return stack;
            if (error.name !== undefined && error.message !== undefined) {
                return error.toString();
            }
            return formatNonError(error);
        };
        if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
            Error.stackTraceLimit += 6;
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            var captureStackTrace = Error.captureStackTrace;
            shouldIgnore = function(line) {
                return bluebirdFramePattern.test(line);
            };
            return function(receiver, ignoreUntil) {
                Error.stackTraceLimit += 6;
                captureStackTrace(receiver, ignoreUntil);
                Error.stackTraceLimit -= 6;
            };
        }
        var err = new Error();
        if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
            stackFramePattern = /@/;
            formatStack = v8stackFormatter;
            indentStackFrames = true;
            return function captureStackTrace(o) {
                o.stack = new Error().stack;
            };
        }
        var hasStackAfterThrow;
        try {
            throw new Error();
        } catch (e) {
            hasStackAfterThrow = "stack" in e;
        }
        if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
            stackFramePattern = v8stackFramePattern;
            formatStack = v8stackFormatter;
            return function captureStackTrace(o) {
                Error.stackTraceLimit += 6;
                try {
                    throw new Error();
                } catch (e) {
                    o.stack = e.stack;
                }
                Error.stackTraceLimit -= 6;
            };
        }
        formatStack = function(stack, error) {
            if (typeof stack === "string") return stack;
            if ((typeof error === "object" || typeof error === "function") && error.name !== undefined && error.message !== undefined) {
                return error.toString();
            }
            return formatNonError(error);
        };
        return null;
    }([]);
    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
        printWarning = function(message) {
            console.warn(message);
        };
        if (util.isNode && process.stderr.isTTY) {
            printWarning = function(message, isSoft) {
                var color = isSoft ? "\x1b[33m" : "\x1b[31m";
                console.warn(color + message + "\x1b[0m\n");
            };
        } else if (!util.isNode && typeof new Error().stack === "string") {
            printWarning = function(message, isSoft) {
                console.warn("%c" + message, isSoft ? "color: darkorange" : "color: red");
            };
        }
    }
    var config = {
        warnings: warnings,
        longStackTraces: false,
        cancellation: false,
        monitoring: false
    };
    if (longStackTraces) Promise.longStackTraces();
    return {
        longStackTraces: function() {
            return config.longStackTraces;
        },
        warnings: function() {
            return config.warnings;
        },
        cancellation: function() {
            return config.cancellation;
        },
        monitoring: function() {
            return config.monitoring;
        },
        propagateFromFunction: function() {
            return propagateFromFunction;
        },
        boundValueFunction: function() {
            return boundValueFunction;
        },
        checkForgottenReturns: checkForgottenReturns,
        setBounds: setBounds,
        warn: warn,
        deprecated: deprecated,
        CapturedTrace: CapturedTrace,
        fireDomEvent: fireDomEvent,
        fireGlobalEvent: fireGlobalEvent
    };
};


/***/ }),

/***/ 80537:
/***/ ((module) => {

"use strict";

module.exports = function(Promise) {
    function returner() {
        return this.value;
    }
    function thrower() {
        throw this.reason;
    }
    Promise.prototype["return"] = Promise.prototype.thenReturn = function(value) {
        if (value instanceof Promise) value.suppressUnhandledRejections();
        return this._then(returner, undefined, undefined, {
            value: value
        }, undefined);
    };
    Promise.prototype["throw"] = Promise.prototype.thenThrow = function(reason) {
        return this._then(thrower, undefined, undefined, {
            reason: reason
        }, undefined);
    };
    Promise.prototype.catchThrow = function(reason) {
        if (arguments.length <= 1) {
            return this._then(undefined, thrower, undefined, {
                reason: reason
            }, undefined);
        } else {
            var _reason = arguments[1];
            var handler = function() {
                throw _reason;
            };
            return this.caught(reason, handler);
        }
    };
    Promise.prototype.catchReturn = function(value) {
        if (arguments.length <= 1) {
            if (value instanceof Promise) value.suppressUnhandledRejections();
            return this._then(undefined, returner, undefined, {
                value: value
            }, undefined);
        } else {
            var _value = arguments[1];
            if (_value instanceof Promise) _value.suppressUnhandledRejections();
            var handler = function() {
                return _value;
            };
            return this.caught(value, handler);
        }
    };
};


/***/ }),

/***/ 64872:
/***/ ((module) => {

"use strict";

module.exports = function(Promise, INTERNAL) {
    var PromiseReduce = Promise.reduce;
    var PromiseAll = Promise.all;
    function promiseAllThis() {
        return PromiseAll(this);
    }
    function PromiseMapSeries(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
    }
    Promise.prototype.each = function(fn) {
        return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, this, undefined);
    };
    Promise.prototype.mapSeries = function(fn) {
        return PromiseReduce(this, fn, INTERNAL, INTERNAL);
    };
    Promise.each = function(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, undefined, undefined, promises, undefined);
    };
    Promise.mapSeries = PromiseMapSeries;
};


/***/ }),

/***/ 91710:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var es5 = __webpack_require__(12032);
var Objectfreeze = es5.freeze;
var util = __webpack_require__(64935);
var inherits = util.inherits;
var notEnumerableProp = util.notEnumerableProp;
function subError(nameProperty, defaultMessage) {
    function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        notEnumerableProp(this, "message", typeof message === "string" ? message : defaultMessage);
        notEnumerableProp(this, "name", nameProperty);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        } else {
            Error.call(this);
        }
    }
    inherits(SubError, Error);
    return SubError;
}
var _TypeError, _RangeError;
var Warning = subError("Warning", "warning");
var CancellationError = subError("CancellationError", "cancellation error");
var TimeoutError = subError("TimeoutError", "timeout error");
var AggregateError = subError("AggregateError", "aggregate error");
try {
    _TypeError = TypeError;
    _RangeError = RangeError;
} catch (e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
}
var methods = ("join pop push shift unshift slice filter forEach some " + "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
for(var i = 0; i < methods.length; ++i){
    if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
}
es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
});
AggregateError.prototype["isOperational"] = true;
var level = 0;
AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:" + "\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for(var i = 0; i < this.length; ++i){
        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
        var lines = str.split("\n");
        for(var j = 0; j < lines.length; ++j){
            lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret += str + "\n";
    }
    level--;
    return ret;
};
function OperationalError(message) {
    if (!(this instanceof OperationalError)) return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;
    if (message instanceof Error) {
        notEnumerableProp(this, "message", message.message);
        notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }
}
inherits(OperationalError, Error);
var errorTypes = Error["__BluebirdErrorTypes__"];
if (!errorTypes) {
    errorTypes = Objectfreeze({
        CancellationError: CancellationError,
        TimeoutError: TimeoutError,
        OperationalError: OperationalError,
        RejectionError: OperationalError,
        AggregateError: AggregateError
    });
    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
    });
}
module.exports = {
    Error: Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning: Warning
};


/***/ }),

/***/ 12032:
/***/ ((module) => {

"use strict";

var isES5 = function() {
    "use strict";
    return this === undefined;
}();
if (isES5) {
    module.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: isES5,
        propertyIsWritable: function(obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
        }
    };
} else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;
    var ObjectKeys = function(o) {
        var ret = [];
        for(var key in o){
            if (has.call(o, key)) {
                ret.push(key);
            }
        }
        return ret;
    };
    var ObjectGetDescriptor = function(o, key) {
        return {
            value: o[key]
        };
    };
    var ObjectDefineProperty = function(o, key, desc) {
        o[key] = desc.value;
        return o;
    };
    var ObjectFreeze = function(obj) {
        return obj;
    };
    var ObjectGetPrototypeOf = function(obj) {
        try {
            return Object(obj).constructor.prototype;
        } catch (e) {
            return proto;
        }
    };
    var ArrayIsArray = function(obj) {
        try {
            return str.call(obj) === "[object Array]";
        } catch (e) {
            return false;
        }
    };
    module.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5: isES5,
        propertyIsWritable: function() {
            return true;
        }
    };
}


/***/ }),

/***/ 76944:
/***/ ((module) => {

"use strict";

module.exports = function(Promise, INTERNAL) {
    var PromiseMap = Promise.map;
    Promise.prototype.filter = function(fn, options) {
        return PromiseMap(this, fn, options, INTERNAL);
    };
    Promise.filter = function(promises, fn, options) {
        return PromiseMap(promises, fn, options, INTERNAL);
    };
};


/***/ }),

/***/ 73678:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise, tryConvertToPromise) {
    var util = __webpack_require__(64935);
    var CancellationError = Promise.CancellationError;
    var errorObj = util.errorObj;
    function PassThroughHandlerContext(promise, type, handler) {
        this.promise = promise;
        this.type = type;
        this.handler = handler;
        this.called = false;
        this.cancelPromise = null;
    }
    PassThroughHandlerContext.prototype.isFinallyHandler = function() {
        return this.type === 0;
    };
    function FinallyHandlerCancelReaction(finallyHandler) {
        this.finallyHandler = finallyHandler;
    }
    FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
        checkCancel(this.finallyHandler);
    };
    function checkCancel(ctx, reason) {
        if (ctx.cancelPromise != null) {
            if (arguments.length > 1) {
                ctx.cancelPromise._reject(reason);
            } else {
                ctx.cancelPromise._cancel();
            }
            ctx.cancelPromise = null;
            return true;
        }
        return false;
    }
    function succeed() {
        return finallyHandler.call(this, this.promise._target()._settledValue());
    }
    function fail(reason) {
        if (checkCancel(this, reason)) return;
        errorObj.e = reason;
        return errorObj;
    }
    function finallyHandler(reasonOrValue) {
        var promise = this.promise;
        var handler = this.handler;
        if (!this.called) {
            this.called = true;
            var ret = this.isFinallyHandler() ? handler.call(promise._boundValue()) : handler.call(promise._boundValue(), reasonOrValue);
            if (ret !== undefined) {
                promise._setReturnedNonUndefined();
                var maybePromise = tryConvertToPromise(ret, promise);
                if (maybePromise instanceof Promise) {
                    if (this.cancelPromise != null) {
                        if (maybePromise._isCancelled()) {
                            var reason = new CancellationError("late cancellation observer");
                            promise._attachExtraTrace(reason);
                            errorObj.e = reason;
                            return errorObj;
                        } else if (maybePromise.isPending()) {
                            maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));
                        }
                    }
                    return maybePromise._then(succeed, fail, undefined, this, undefined);
                }
            }
        }
        if (promise.isRejected()) {
            checkCancel(this);
            errorObj.e = reasonOrValue;
            return errorObj;
        } else {
            checkCancel(this);
            return reasonOrValue;
        }
    }
    Promise.prototype._passThrough = function(handler, type, success, fail) {
        if (typeof handler !== "function") return this.then();
        return this._then(success, fail, undefined, new PassThroughHandlerContext(this, type, handler), undefined);
    };
    Promise.prototype.lastly = Promise.prototype["finally"] = function(handler) {
        return this._passThrough(handler, 0, finallyHandler, finallyHandler);
    };
    Promise.prototype.tap = function(handler) {
        return this._passThrough(handler, 1, finallyHandler);
    };
    return PassThroughHandlerContext;
};


/***/ }),

/***/ 68727:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
    var errors = __webpack_require__(91710);
    var TypeError = errors.TypeError;
    var util = __webpack_require__(64935);
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var yieldHandlers = [];
    function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
        for(var i = 0; i < yieldHandlers.length; ++i){
            traceParent._pushContext();
            var result = tryCatch(yieldHandlers[i])(value);
            traceParent._popContext();
            if (result === errorObj) {
                traceParent._pushContext();
                var ret = Promise.reject(errorObj.e);
                traceParent._popContext();
                return ret;
            }
            var maybePromise = tryConvertToPromise(result, traceParent);
            if (maybePromise instanceof Promise) return maybePromise;
        }
        return null;
    }
    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
        if (debug.cancellation()) {
            var internal = new Promise(INTERNAL);
            var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
            this._promise = internal.lastly(function() {
                return _finallyPromise;
            });
            internal._captureStackTrace();
            internal._setOnCancel(this);
        } else {
            var promise = this._promise = new Promise(INTERNAL);
            promise._captureStackTrace();
        }
        this._stack = stack;
        this._generatorFunction = generatorFunction;
        this._receiver = receiver;
        this._generator = undefined;
        this._yieldHandlers = typeof yieldHandler === "function" ? [
            yieldHandler
        ].concat(yieldHandlers) : yieldHandlers;
        this._yieldedPromise = null;
        this._cancellationPhase = false;
    }
    util.inherits(PromiseSpawn, Proxyable);
    PromiseSpawn.prototype._isResolved = function() {
        return this._promise === null;
    };
    PromiseSpawn.prototype._cleanup = function() {
        this._promise = this._generator = null;
        if (debug.cancellation() && this._finallyPromise !== null) {
            this._finallyPromise._fulfill();
            this._finallyPromise = null;
        }
    };
    PromiseSpawn.prototype._promiseCancelled = function() {
        if (this._isResolved()) return;
        var implementsReturn = typeof this._generator["return"] !== "undefined";
        var result;
        if (!implementsReturn) {
            var reason = new Promise.CancellationError("generator .return() sentinel");
            Promise.coroutine.returnSentinel = reason;
            this._promise._attachExtraTrace(reason);
            this._promise._pushContext();
            result = tryCatch(this._generator["throw"]).call(this._generator, reason);
            this._promise._popContext();
        } else {
            this._promise._pushContext();
            result = tryCatch(this._generator["return"]).call(this._generator, undefined);
            this._promise._popContext();
        }
        this._cancellationPhase = true;
        this._yieldedPromise = null;
        this._continue(result);
    };
    PromiseSpawn.prototype._promiseFulfilled = function(value) {
        this._yieldedPromise = null;
        this._promise._pushContext();
        var result = tryCatch(this._generator.next).call(this._generator, value);
        this._promise._popContext();
        this._continue(result);
    };
    PromiseSpawn.prototype._promiseRejected = function(reason) {
        this._yieldedPromise = null;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        var result = tryCatch(this._generator["throw"]).call(this._generator, reason);
        this._promise._popContext();
        this._continue(result);
    };
    PromiseSpawn.prototype._resultCancelled = function() {
        if (this._yieldedPromise instanceof Promise) {
            var promise = this._yieldedPromise;
            this._yieldedPromise = null;
            promise.cancel();
        }
    };
    PromiseSpawn.prototype.promise = function() {
        return this._promise;
    };
    PromiseSpawn.prototype._run = function() {
        this._generator = this._generatorFunction.call(this._receiver);
        this._receiver = this._generatorFunction = undefined;
        this._promiseFulfilled(undefined);
    };
    PromiseSpawn.prototype._continue = function(result) {
        var promise = this._promise;
        if (result === errorObj) {
            this._cleanup();
            if (this._cancellationPhase) {
                return promise.cancel();
            } else {
                return promise._rejectCallback(result.e, false);
            }
        }
        var value = result.value;
        if (result.done === true) {
            this._cleanup();
            if (this._cancellationPhase) {
                return promise.cancel();
            } else {
                return promise._resolveCallback(value);
            }
        } else {
            var maybePromise = tryConvertToPromise(value, this._promise);
            if (!(maybePromise instanceof Promise)) {
                maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);
                if (maybePromise === null) {
                    this._promiseRejected(new TypeError("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", value) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")));
                    return;
                }
            }
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;
            if ((bitField & 50397184) === 0) {
                this._yieldedPromise = maybePromise;
                maybePromise._proxy(this, null);
            } else if ((bitField & 33554432) !== 0) {
                Promise._async.invoke(this._promiseFulfilled, this, maybePromise._value());
            } else if ((bitField & 16777216) !== 0) {
                Promise._async.invoke(this._promiseRejected, this, maybePromise._reason());
            } else {
                this._promiseCancelled();
            }
        }
    };
    Promise.coroutine = function(generatorFunction, options) {
        if (typeof generatorFunction !== "function") {
            throw new TypeError("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var yieldHandler = Object(options).yieldHandler;
        var PromiseSpawn$ = PromiseSpawn;
        var stack = new Error().stack;
        return function() {
            var generator = generatorFunction.apply(this, arguments);
            var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);
            var ret = spawn.promise();
            spawn._generator = generator;
            spawn._promiseFulfilled(undefined);
            return ret;
        };
    };
    Promise.coroutine.addYieldHandler = function(fn) {
        if (typeof fn !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(fn));
        }
        yieldHandlers.push(fn);
    };
    Promise.spawn = function(generatorFunction) {
        debug.deprecated("Promise.spawn()", "Promise.coroutine()");
        if (typeof generatorFunction !== "function") {
            return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var spawn = new PromiseSpawn(generatorFunction, this);
        var ret = spawn.promise();
        spawn._run(Promise.spawn);
        return ret;
    };
};


/***/ }),

/***/ 50149:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain) {
    var util = __webpack_require__(64935);
    var canEvaluate = util.canEvaluate;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var reject;
    if (true) {
        if (canEvaluate) {
            var thenCallback = function(i) {
                return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i));
            };
            var promiseSetter = function(i) {
                return new Function("promise", "holder", "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ".replace(/Index/g, i));
            };
            var generateHolderClass = function(total) {
                var props = new Array(total);
                for(var i = 0; i < props.length; ++i){
                    props[i] = "this.p" + (i + 1);
                }
                var assignment = props.join(" = ") + " = null;";
                var cancellationCode = "var promise;\n" + props.map(function(prop) {
                    return "                                                         \n                promise = " + prop + ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ";
                }).join("\n");
                var passedArguments = props.join(", ");
                var name = "Holder$" + total;
                var code = "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ";
                code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
                return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch, errorObj, Promise, async);
            };
            var holderClasses = [];
            var thenCallbacks = [];
            var promiseSetters = [];
            for(var i = 0; i < 8; ++i){
                holderClasses.push(generateHolderClass(i + 1));
                thenCallbacks.push(thenCallback(i + 1));
                promiseSetters.push(promiseSetter(i + 1));
            }
            reject = function(reason) {
                this._reject(reason);
            };
        }
    }
    Promise.join = function() {
        var last = arguments.length - 1;
        var fn;
        if (last > 0 && typeof arguments[last] === "function") {
            fn = arguments[last];
            if (true) {
                if (last <= 8 && canEvaluate) {
                    var ret = new Promise(INTERNAL);
                    ret._captureStackTrace();
                    var HolderClass = holderClasses[last - 1];
                    var holder = new HolderClass(fn);
                    var callbacks = thenCallbacks;
                    for(var i = 0; i < last; ++i){
                        var maybePromise = tryConvertToPromise(arguments[i], ret);
                        if (maybePromise instanceof Promise) {
                            maybePromise = maybePromise._target();
                            var bitField = maybePromise._bitField;
                            ;
                            if ((bitField & 50397184) === 0) {
                                maybePromise._then(callbacks[i], reject, undefined, ret, holder);
                                promiseSetters[i](maybePromise, holder);
                                holder.asyncNeeded = false;
                            } else if ((bitField & 33554432) !== 0) {
                                callbacks[i].call(ret, maybePromise._value(), holder);
                            } else if ((bitField & 16777216) !== 0) {
                                ret._reject(maybePromise._reason());
                            } else {
                                ret._cancel();
                            }
                        } else {
                            callbacks[i].call(ret, maybePromise, holder);
                        }
                    }
                    if (!ret._isFateSealed()) {
                        if (holder.asyncNeeded) {
                            var domain = getDomain();
                            if (domain !== null) {
                                holder.fn = util.domainBind(domain, holder.fn);
                            }
                        }
                        ret._setAsyncGuaranteed();
                        ret._setOnCancel(holder);
                    }
                    return ret;
                }
            }
        }
        var $_len = arguments.length;
        var args = new Array($_len);
        for(var $_i = 0; $_i < $_len; ++$_i){
            args[$_i] = arguments[$_i];
        }
        ;
        if (fn) args.pop();
        var ret = new PromiseArray(args).promise();
        return fn !== undefined ? ret.spread(fn) : ret;
    };
};


/***/ }),

/***/ 3240:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var getDomain = Promise._getDomain;
    var util = __webpack_require__(64935);
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    var async = Promise._async;
    function MappingPromiseArray(promises, fn, limit, _filter) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        var domain = getDomain();
        this._callback = domain === null ? fn : util.domainBind(domain, fn);
        this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
        this._limit = limit;
        this._inFlight = 0;
        this._queue = [];
        async.invoke(this._asyncInit, this, undefined);
    }
    util.inherits(MappingPromiseArray, PromiseArray);
    MappingPromiseArray.prototype._asyncInit = function() {
        this._init$(undefined, -2);
    };
    MappingPromiseArray.prototype._init = function() {};
    MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
        var values = this._values;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var limit = this._limit;
        if (index < 0) {
            index = index * -1 - 1;
            values[index] = value;
            if (limit >= 1) {
                this._inFlight--;
                this._drainQueue();
                if (this._isResolved()) return true;
            }
        } else {
            if (limit >= 1 && this._inFlight >= limit) {
                values[index] = value;
                this._queue.push(index);
                return false;
            }
            if (preservedValues !== null) preservedValues[index] = value;
            var promise = this._promise;
            var callback = this._callback;
            var receiver = promise._boundValue();
            promise._pushContext();
            var ret = tryCatch(callback).call(receiver, value, index, length);
            var promiseCreated = promise._popContext();
            debug.checkForgottenReturns(ret, promiseCreated, preservedValues !== null ? "Promise.filter" : "Promise.map", promise);
            if (ret === errorObj) {
                this._reject(ret.e);
                return true;
            }
            var maybePromise = tryConvertToPromise(ret, this._promise);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                ;
                if ((bitField & 50397184) === 0) {
                    if (limit >= 1) this._inFlight++;
                    values[index] = maybePromise;
                    maybePromise._proxy(this, (index + 1) * -1);
                    return false;
                } else if ((bitField & 33554432) !== 0) {
                    ret = maybePromise._value();
                } else if ((bitField & 16777216) !== 0) {
                    this._reject(maybePromise._reason());
                    return true;
                } else {
                    this._cancel();
                    return true;
                }
            }
            values[index] = ret;
        }
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= length) {
            if (preservedValues !== null) {
                this._filter(values, preservedValues);
            } else {
                this._resolve(values);
            }
            return true;
        }
        return false;
    };
    MappingPromiseArray.prototype._drainQueue = function() {
        var queue = this._queue;
        var limit = this._limit;
        var values = this._values;
        while(queue.length > 0 && this._inFlight < limit){
            if (this._isResolved()) return;
            var index = queue.pop();
            this._promiseFulfilled(values[index], index);
        }
    };
    MappingPromiseArray.prototype._filter = function(booleans, values) {
        var len = values.length;
        var ret = new Array(len);
        var j = 0;
        for(var i = 0; i < len; ++i){
            if (booleans[i]) ret[j++] = values[i];
        }
        ret.length = j;
        this._resolve(ret);
    };
    MappingPromiseArray.prototype.preservedValues = function() {
        return this._preservedValues;
    };
    function map(promises, fn, options, _filter) {
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var limit = 0;
        if (options !== undefined) {
            if (typeof options === "object" && options !== null) {
                if (typeof options.concurrency !== "number") {
                    return Promise.reject(new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency)));
                }
                limit = options.concurrency;
            } else {
                return Promise.reject(new TypeError("options argument must be an object but it is " + util.classString(options)));
            }
        }
        limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
        return new MappingPromiseArray(promises, fn, limit, _filter).promise();
    }
    Promise.prototype.map = function(fn, options) {
        return map(this, fn, options, null);
    };
    Promise.map = function(promises, fn, options, _filter) {
        return map(promises, fn, options, _filter);
    };
};


/***/ }),

/***/ 31090:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
    var util = __webpack_require__(64935);
    var tryCatch = util.tryCatch;
    Promise.method = function(fn) {
        if (typeof fn !== "function") {
            throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
        }
        return function() {
            var ret = new Promise(INTERNAL);
            ret._captureStackTrace();
            ret._pushContext();
            var value = tryCatch(fn).apply(this, arguments);
            var promiseCreated = ret._popContext();
            debug.checkForgottenReturns(value, promiseCreated, "Promise.method", ret);
            ret._resolveFromSyncValue(value);
            return ret;
        };
    };
    Promise.attempt = Promise["try"] = function(fn) {
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value;
        if (arguments.length > 1) {
            debug.deprecated("calling Promise.try with more than 1 argument");
            var arg = arguments[1];
            var ctx = arguments[2];
            value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
        } else {
            value = tryCatch(fn)();
        }
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(value, promiseCreated, "Promise.try", ret);
        ret._resolveFromSyncValue(value);
        return ret;
    };
    Promise.prototype._resolveFromSyncValue = function(value) {
        if (value === util.errorObj) {
            this._rejectCallback(value.e, false);
        } else {
            this._resolveCallback(value, true);
        }
    };
};


/***/ }),

/***/ 28688:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var util = __webpack_require__(64935);
var maybeWrapAsError = util.maybeWrapAsError;
var errors = __webpack_require__(91710);
var OperationalError = errors.OperationalError;
var es5 = __webpack_require__(12032);
function isUntypedError(obj) {
    return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;
}
var rErrorKey = /^(?:name|message|stack|cause)$/;
function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
        ret = new OperationalError(obj);
        ret.name = obj.name;
        ret.message = obj.message;
        ret.stack = obj.stack;
        var keys = es5.keys(obj);
        for(var i = 0; i < keys.length; ++i){
            var key = keys[i];
            if (!rErrorKey.test(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    util.markAsOriginatingFromRejection(obj);
    return obj;
}
function nodebackForPromise(promise, multiArgs) {
    return function(err, value) {
        if (promise === null) return;
        if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        } else if (!multiArgs) {
            promise._fulfill(value);
        } else {
            var $_len = arguments.length;
            var args = new Array(Math.max($_len - 1, 0));
            for(var $_i = 1; $_i < $_len; ++$_i){
                args[$_i - 1] = arguments[$_i];
            }
            ;
            promise._fulfill(args);
        }
        promise = null;
    };
}
module.exports = nodebackForPromise;


/***/ }),

/***/ 50139:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise) {
    var util = __webpack_require__(64935);
    var async = Promise._async;
    var tryCatch = util.tryCatch;
    var errorObj = util.errorObj;
    function spreadAdapter(val, nodeback) {
        var promise = this;
        if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
        var ret = tryCatch(nodeback).apply(promise._boundValue(), [
            null
        ].concat(val));
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    function successAdapter(val, nodeback) {
        var promise = this;
        var receiver = promise._boundValue();
        var ret = val === undefined ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    function errorAdapter(reason, nodeback) {
        var promise = this;
        if (!reason) {
            var newReason = new Error(reason + "");
            newReason.cause = reason;
            reason = newReason;
        }
        var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
        if (ret === errorObj) {
            async.throwLater(ret.e);
        }
    }
    Promise.prototype.asCallback = Promise.prototype.nodeify = function(nodeback, options) {
        if (typeof nodeback == "function") {
            var adapter = successAdapter;
            if (options !== undefined && Object(options).spread) {
                adapter = spreadAdapter;
            }
            this._then(adapter, errorAdapter, undefined, this, nodeback);
        }
        return this;
    };
};


/***/ }),

/***/ 91865:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function() {
    var makeSelfResolutionError = function() {
        return new TypeError("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
    };
    var reflectHandler = function() {
        return new Promise.PromiseInspection(this._target());
    };
    var apiRejection = function(msg) {
        return Promise.reject(new TypeError(msg));
    };
    function Proxyable() {}
    var UNDEFINED_BINDING = {};
    var util = __webpack_require__(64935);
    var getDomain;
    if (util.isNode) {
        getDomain = function() {
            var ret = process.domain;
            if (ret === undefined) ret = null;
            return ret;
        };
    } else {
        getDomain = function() {
            return null;
        };
    }
    util.notEnumerableProp(Promise, "_getDomain", getDomain);
    var es5 = __webpack_require__(12032);
    var Async = __webpack_require__(27439);
    var async = new Async();
    es5.defineProperty(Promise, "_async", {
        value: async
    });
    var errors = __webpack_require__(91710);
    var TypeError = Promise.TypeError = errors.TypeError;
    Promise.RangeError = errors.RangeError;
    var CancellationError = Promise.CancellationError = errors.CancellationError;
    Promise.TimeoutError = errors.TimeoutError;
    Promise.OperationalError = errors.OperationalError;
    Promise.RejectionError = errors.OperationalError;
    Promise.AggregateError = errors.AggregateError;
    var INTERNAL = function() {};
    var APPLY = {};
    var NEXT_FILTER = {};
    var tryConvertToPromise = __webpack_require__(94436)(Promise, INTERNAL);
    var PromiseArray = __webpack_require__(72699)(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable);
    var Context = __webpack_require__(8254)(Promise);
    /*jshint unused:false*/ var createContext = Context.create;
    var debug = __webpack_require__(20928)(Promise, Context);
    var CapturedTrace = debug.CapturedTrace;
    var PassThroughHandlerContext = __webpack_require__(73678)(Promise, tryConvertToPromise);
    var catchFilter = __webpack_require__(22308)(NEXT_FILTER);
    var nodebackForPromise = __webpack_require__(28688);
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    function check(self, executor) {
        if (typeof executor !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(executor));
        }
        if (self.constructor !== Promise) {
            throw new TypeError("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
        }
    }
    function Promise(executor) {
        this._bitField = 0;
        this._fulfillmentHandler0 = undefined;
        this._rejectionHandler0 = undefined;
        this._promise0 = undefined;
        this._receiver0 = undefined;
        if (executor !== INTERNAL) {
            check(this, executor);
            this._resolveFromExecutor(executor);
        }
        this._promiseCreated();
        this._fireEvent("promiseCreated", this);
    }
    Promise.prototype.toString = function() {
        return "[object Promise]";
    };
    Promise.prototype.caught = Promise.prototype["catch"] = function(fn) {
        var len = arguments.length;
        if (len > 1) {
            var catchInstances = new Array(len - 1), j = 0, i;
            for(i = 0; i < len - 1; ++i){
                var item = arguments[i];
                if (util.isObject(item)) {
                    catchInstances[j++] = item;
                } else {
                    return apiRejection("expecting an object but got " + "A catch statement predicate " + util.classString(item));
                }
            }
            catchInstances.length = j;
            fn = arguments[i];
            return this.then(undefined, catchFilter(catchInstances, fn, this));
        }
        return this.then(undefined, fn);
    };
    Promise.prototype.reflect = function() {
        return this._then(reflectHandler, reflectHandler, undefined, this, undefined);
    };
    Promise.prototype.then = function(didFulfill, didReject) {
        if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
            var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
            if (arguments.length > 1) {
                msg += ", " + util.classString(didReject);
            }
            this._warn(msg);
        }
        return this._then(didFulfill, didReject, undefined, undefined, undefined);
    };
    Promise.prototype.done = function(didFulfill, didReject) {
        var promise = this._then(didFulfill, didReject, undefined, undefined, undefined);
        promise._setIsFinal();
    };
    Promise.prototype.spread = function(fn) {
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        return this.all()._then(fn, undefined, undefined, APPLY, undefined);
    };
    Promise.prototype.toJSON = function() {
        var ret = {
            isFulfilled: false,
            isRejected: false,
            fulfillmentValue: undefined,
            rejectionReason: undefined
        };
        if (this.isFulfilled()) {
            ret.fulfillmentValue = this.value();
            ret.isFulfilled = true;
        } else if (this.isRejected()) {
            ret.rejectionReason = this.reason();
            ret.isRejected = true;
        }
        return ret;
    };
    Promise.prototype.all = function() {
        if (arguments.length > 0) {
            this._warn(".all() was passed arguments but it does not take any");
        }
        return new PromiseArray(this).promise();
    };
    Promise.prototype.error = function(fn) {
        return this.caught(util.originatesFromRejection, fn);
    };
    Promise.getNewLibraryCopy = module.exports;
    Promise.is = function(val) {
        return val instanceof Promise;
    };
    Promise.fromNode = Promise.fromCallback = function(fn) {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
        var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
        if (result === errorObj) {
            ret._rejectCallback(result.e, true);
        }
        if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
        return ret;
    };
    Promise.all = function(promises) {
        return new PromiseArray(promises).promise();
    };
    Promise.cast = function(obj) {
        var ret = tryConvertToPromise(obj);
        if (!(ret instanceof Promise)) {
            ret = new Promise(INTERNAL);
            ret._captureStackTrace();
            ret._setFulfilled();
            ret._rejectionHandler0 = obj;
        }
        return ret;
    };
    Promise.resolve = Promise.fulfilled = Promise.cast;
    Promise.reject = Promise.rejected = function(reason) {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._rejectCallback(reason, true);
        return ret;
    };
    Promise.setScheduler = function(fn) {
        if (typeof fn !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(fn));
        }
        return async.setScheduler(fn);
    };
    Promise.prototype._then = function(didFulfill, didReject, _, receiver, internalData) {
        var haveInternalData = internalData !== undefined;
        var promise = haveInternalData ? internalData : new Promise(INTERNAL);
        var target = this._target();
        var bitField = target._bitField;
        if (!haveInternalData) {
            promise._propagateFrom(this, 3);
            promise._captureStackTrace();
            if (receiver === undefined && (this._bitField & 2097152) !== 0) {
                if (!((bitField & 50397184) === 0)) {
                    receiver = this._boundValue();
                } else {
                    receiver = target === this ? undefined : this._boundTo;
                }
            }
            this._fireEvent("promiseChained", this, promise);
        }
        var domain = getDomain();
        if (!((bitField & 50397184) === 0)) {
            var handler, value, settler = target._settlePromiseCtx;
            if ((bitField & 33554432) !== 0) {
                value = target._rejectionHandler0;
                handler = didFulfill;
            } else if ((bitField & 16777216) !== 0) {
                value = target._fulfillmentHandler0;
                handler = didReject;
                target._unsetRejectionIsUnhandled();
            } else {
                settler = target._settlePromiseLateCancellationObserver;
                value = new CancellationError("late cancellation observer");
                target._attachExtraTrace(value);
                handler = didReject;
            }
            async.invoke(settler, target, {
                handler: domain === null ? handler : typeof handler === "function" && util.domainBind(domain, handler),
                promise: promise,
                receiver: receiver,
                value: value
            });
        } else {
            target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
        }
        return promise;
    };
    Promise.prototype._length = function() {
        return this._bitField & 65535;
    };
    Promise.prototype._isFateSealed = function() {
        return (this._bitField & 117506048) !== 0;
    };
    Promise.prototype._isFollowing = function() {
        return (this._bitField & 67108864) === 67108864;
    };
    Promise.prototype._setLength = function(len) {
        this._bitField = this._bitField & -65536 | len & 65535;
    };
    Promise.prototype._setFulfilled = function() {
        this._bitField = this._bitField | 33554432;
        this._fireEvent("promiseFulfilled", this);
    };
    Promise.prototype._setRejected = function() {
        this._bitField = this._bitField | 16777216;
        this._fireEvent("promiseRejected", this);
    };
    Promise.prototype._setFollowing = function() {
        this._bitField = this._bitField | 67108864;
        this._fireEvent("promiseResolved", this);
    };
    Promise.prototype._setIsFinal = function() {
        this._bitField = this._bitField | 4194304;
    };
    Promise.prototype._isFinal = function() {
        return (this._bitField & 4194304) > 0;
    };
    Promise.prototype._unsetCancelled = function() {
        this._bitField = this._bitField & ~65536;
    };
    Promise.prototype._setCancelled = function() {
        this._bitField = this._bitField | 65536;
        this._fireEvent("promiseCancelled", this);
    };
    Promise.prototype._setWillBeCancelled = function() {
        this._bitField = this._bitField | 8388608;
    };
    Promise.prototype._setAsyncGuaranteed = function() {
        if (async.hasCustomScheduler()) return;
        this._bitField = this._bitField | 134217728;
    };
    Promise.prototype._receiverAt = function(index) {
        var ret = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
        if (ret === UNDEFINED_BINDING) {
            return undefined;
        } else if (ret === undefined && this._isBound()) {
            return this._boundValue();
        }
        return ret;
    };
    Promise.prototype._promiseAt = function(index) {
        return this[index * 4 - 4 + 2];
    };
    Promise.prototype._fulfillmentHandlerAt = function(index) {
        return this[index * 4 - 4 + 0];
    };
    Promise.prototype._rejectionHandlerAt = function(index) {
        return this[index * 4 - 4 + 1];
    };
    Promise.prototype._boundValue = function() {};
    Promise.prototype._migrateCallback0 = function(follower) {
        var bitField = follower._bitField;
        var fulfill = follower._fulfillmentHandler0;
        var reject = follower._rejectionHandler0;
        var promise = follower._promise0;
        var receiver = follower._receiverAt(0);
        if (receiver === undefined) receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
    };
    Promise.prototype._migrateCallbackAt = function(follower, index) {
        var fulfill = follower._fulfillmentHandlerAt(index);
        var reject = follower._rejectionHandlerAt(index);
        var promise = follower._promiseAt(index);
        var receiver = follower._receiverAt(index);
        if (receiver === undefined) receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject, promise, receiver, null);
    };
    Promise.prototype._addCallbacks = function(fulfill, reject, promise, receiver, domain) {
        var index = this._length();
        if (index >= 65535 - 4) {
            index = 0;
            this._setLength(0);
        }
        if (index === 0) {
            this._promise0 = promise;
            this._receiver0 = receiver;
            if (typeof fulfill === "function") {
                this._fulfillmentHandler0 = domain === null ? fulfill : util.domainBind(domain, fulfill);
            }
            if (typeof reject === "function") {
                this._rejectionHandler0 = domain === null ? reject : util.domainBind(domain, reject);
            }
        } else {
            var base = index * 4 - 4;
            this[base + 2] = promise;
            this[base + 3] = receiver;
            if (typeof fulfill === "function") {
                this[base + 0] = domain === null ? fulfill : util.domainBind(domain, fulfill);
            }
            if (typeof reject === "function") {
                this[base + 1] = domain === null ? reject : util.domainBind(domain, reject);
            }
        }
        this._setLength(index + 1);
        return index;
    };
    Promise.prototype._proxy = function(proxyable, arg) {
        this._addCallbacks(undefined, undefined, arg, proxyable, null);
    };
    Promise.prototype._resolveCallback = function(value, shouldBind) {
        if ((this._bitField & 117506048) !== 0) return;
        if (value === this) return this._rejectCallback(makeSelfResolutionError(), false);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise)) return this._fulfill(value);
        if (shouldBind) this._propagateFrom(maybePromise, 2);
        var promise = maybePromise._target();
        if (promise === this) {
            this._reject(makeSelfResolutionError());
            return;
        }
        var bitField = promise._bitField;
        if ((bitField & 50397184) === 0) {
            var len = this._length();
            if (len > 0) promise._migrateCallback0(this);
            for(var i = 1; i < len; ++i){
                promise._migrateCallbackAt(this, i);
            }
            this._setFollowing();
            this._setLength(0);
            this._setFollowee(promise);
        } else if ((bitField & 33554432) !== 0) {
            this._fulfill(promise._value());
        } else if ((bitField & 16777216) !== 0) {
            this._reject(promise._reason());
        } else {
            var reason = new CancellationError("late cancellation observer");
            promise._attachExtraTrace(reason);
            this._reject(reason);
        }
    };
    Promise.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
        var trace = util.ensureErrorObject(reason);
        var hasStack = trace === reason;
        if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
            var message = "a promise was rejected with a non-error: " + util.classString(reason);
            this._warn(message, true);
        }
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason);
    };
    Promise.prototype._resolveFromExecutor = function(executor) {
        var promise = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = this._execute(executor, function(value) {
            promise._resolveCallback(value);
        }, function(reason) {
            promise._rejectCallback(reason, synchronous);
        });
        synchronous = false;
        this._popContext();
        if (r !== undefined) {
            promise._rejectCallback(r, true);
        }
    };
    Promise.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise) {
        var bitField = promise._bitField;
        if ((bitField & 65536) !== 0) return;
        promise._pushContext();
        var x;
        if (receiver === APPLY) {
            if (!value || typeof value.length !== "number") {
                x = errorObj;
                x.e = new TypeError("cannot .spread() a non-array: " + util.classString(value));
            } else {
                x = tryCatch(handler).apply(this._boundValue(), value);
            }
        } else {
            x = tryCatch(handler).call(receiver, value);
        }
        var promiseCreated = promise._popContext();
        bitField = promise._bitField;
        if ((bitField & 65536) !== 0) return;
        if (x === NEXT_FILTER) {
            promise._reject(value);
        } else if (x === errorObj) {
            promise._rejectCallback(x.e, false);
        } else {
            debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
            promise._resolveCallback(x);
        }
    };
    Promise.prototype._target = function() {
        var ret = this;
        while(ret._isFollowing())ret = ret._followee();
        return ret;
    };
    Promise.prototype._followee = function() {
        return this._rejectionHandler0;
    };
    Promise.prototype._setFollowee = function(promise) {
        this._rejectionHandler0 = promise;
    };
    Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
        var isPromise = promise instanceof Promise;
        var bitField = this._bitField;
        var asyncGuaranteed = (bitField & 134217728) !== 0;
        if ((bitField & 65536) !== 0) {
            if (isPromise) promise._invokeInternalOnCancel();
            if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
                receiver.cancelPromise = promise;
                if (tryCatch(handler).call(receiver, value) === errorObj) {
                    promise._reject(errorObj.e);
                }
            } else if (handler === reflectHandler) {
                promise._fulfill(reflectHandler.call(receiver));
            } else if (receiver instanceof Proxyable) {
                receiver._promiseCancelled(promise);
            } else if (isPromise || promise instanceof PromiseArray) {
                promise._cancel();
            } else {
                receiver.cancel();
            }
        } else if (typeof handler === "function") {
            if (!isPromise) {
                handler.call(receiver, value, promise);
            } else {
                if (asyncGuaranteed) promise._setAsyncGuaranteed();
                this._settlePromiseFromHandler(handler, receiver, value, promise);
            }
        } else if (receiver instanceof Proxyable) {
            if (!receiver._isResolved()) {
                if ((bitField & 33554432) !== 0) {
                    receiver._promiseFulfilled(value, promise);
                } else {
                    receiver._promiseRejected(value, promise);
                }
            }
        } else if (isPromise) {
            if (asyncGuaranteed) promise._setAsyncGuaranteed();
            if ((bitField & 33554432) !== 0) {
                promise._fulfill(value);
            } else {
                promise._reject(value);
            }
        }
    };
    Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
        var handler = ctx.handler;
        var promise = ctx.promise;
        var receiver = ctx.receiver;
        var value = ctx.value;
        if (typeof handler === "function") {
            if (!(promise instanceof Promise)) {
                handler.call(receiver, value, promise);
            } else {
                this._settlePromiseFromHandler(handler, receiver, value, promise);
            }
        } else if (promise instanceof Promise) {
            promise._reject(value);
        }
    };
    Promise.prototype._settlePromiseCtx = function(ctx) {
        this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
    };
    Promise.prototype._settlePromise0 = function(handler, value, bitField) {
        var promise = this._promise0;
        var receiver = this._receiverAt(0);
        this._promise0 = undefined;
        this._receiver0 = undefined;
        this._settlePromise(promise, handler, receiver, value);
    };
    Promise.prototype._clearCallbackDataAtIndex = function(index) {
        var base = index * 4 - 4;
        this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = undefined;
    };
    Promise.prototype._fulfill = function(value) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16) return;
        if (value === this) {
            var err = makeSelfResolutionError();
            this._attachExtraTrace(err);
            return this._reject(err);
        }
        this._setFulfilled();
        this._rejectionHandler0 = value;
        if ((bitField & 65535) > 0) {
            if ((bitField & 134217728) !== 0) {
                this._settlePromises();
            } else {
                async.settlePromises(this);
            }
        }
    };
    Promise.prototype._reject = function(reason) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16) return;
        this._setRejected();
        this._fulfillmentHandler0 = reason;
        if (this._isFinal()) {
            return async.fatalError(reason, util.isNode);
        }
        if ((bitField & 65535) > 0) {
            async.settlePromises(this);
        } else {
            this._ensurePossibleRejectionHandled();
        }
    };
    Promise.prototype._fulfillPromises = function(len, value) {
        for(var i = 1; i < len; i++){
            var handler = this._fulfillmentHandlerAt(i);
            var promise = this._promiseAt(i);
            var receiver = this._receiverAt(i);
            this._clearCallbackDataAtIndex(i);
            this._settlePromise(promise, handler, receiver, value);
        }
    };
    Promise.prototype._rejectPromises = function(len, reason) {
        for(var i = 1; i < len; i++){
            var handler = this._rejectionHandlerAt(i);
            var promise = this._promiseAt(i);
            var receiver = this._receiverAt(i);
            this._clearCallbackDataAtIndex(i);
            this._settlePromise(promise, handler, receiver, reason);
        }
    };
    Promise.prototype._settlePromises = function() {
        var bitField = this._bitField;
        var len = bitField & 65535;
        if (len > 0) {
            if ((bitField & 16842752) !== 0) {
                var reason = this._fulfillmentHandler0;
                this._settlePromise0(this._rejectionHandler0, reason, bitField);
                this._rejectPromises(len, reason);
            } else {
                var value = this._rejectionHandler0;
                this._settlePromise0(this._fulfillmentHandler0, value, bitField);
                this._fulfillPromises(len, value);
            }
            this._setLength(0);
        }
        this._clearCancellationData();
    };
    Promise.prototype._settledValue = function() {
        var bitField = this._bitField;
        if ((bitField & 33554432) !== 0) {
            return this._rejectionHandler0;
        } else if ((bitField & 16777216) !== 0) {
            return this._fulfillmentHandler0;
        }
    };
    function deferResolve(v) {
        this.promise._resolveCallback(v);
    }
    function deferReject(v) {
        this.promise._rejectCallback(v, false);
    }
    Promise.defer = Promise.pending = function() {
        debug.deprecated("Promise.defer", "new Promise");
        var promise = new Promise(INTERNAL);
        return {
            promise: promise,
            resolve: deferResolve,
            reject: deferReject
        };
    };
    util.notEnumerableProp(Promise, "_makeSelfResolutionError", makeSelfResolutionError);
    __webpack_require__(31090)(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug);
    __webpack_require__(4988)(Promise, INTERNAL, tryConvertToPromise, debug);
    __webpack_require__(23558)(Promise, PromiseArray, apiRejection, debug);
    __webpack_require__(80537)(Promise);
    __webpack_require__(68971)(Promise);
    __webpack_require__(50149)(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
    Promise.Promise = Promise;
    Promise.version = "3.4.7";
    __webpack_require__(3240)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
    __webpack_require__(27929)(Promise);
    __webpack_require__(53556)(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
    __webpack_require__(94878)(Promise, INTERNAL, debug);
    __webpack_require__(68727)(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
    __webpack_require__(50139)(Promise);
    __webpack_require__(66066)(Promise, INTERNAL);
    __webpack_require__(4196)(Promise, PromiseArray, tryConvertToPromise, apiRejection);
    __webpack_require__(39959)(Promise, INTERNAL, tryConvertToPromise, apiRejection);
    __webpack_require__(73614)(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
    __webpack_require__(36880)(Promise, PromiseArray, debug);
    __webpack_require__(65562)(Promise, PromiseArray, apiRejection);
    __webpack_require__(76944)(Promise, INTERNAL);
    __webpack_require__(64872)(Promise, INTERNAL);
    __webpack_require__(26779)(Promise);
    util.toFastProperties(Promise);
    util.toFastProperties(Promise.prototype);
    function fillTypes(value) {
        var p = new Promise(INTERNAL);
        p._fulfillmentHandler0 = value;
        p._rejectionHandler0 = value;
        p._promise0 = value;
        p._receiver0 = value;
    }
    // Complete slack tracking, opt out of field-type tracking and           
    // stabilize map                                                         
    fillTypes({
        a: 1
    });
    fillTypes({
        b: 2
    });
    fillTypes({
        c: 3
    });
    fillTypes(1);
    fillTypes(function() {});
    fillTypes(undefined);
    fillTypes(false);
    fillTypes(new Promise(INTERNAL));
    debug.setBounds(Async.firstLineError, util.lastLineError);
    return Promise;
};


/***/ }),

/***/ 72699:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
    var util = __webpack_require__(64935);
    var isArray = util.isArray;
    function toResolutionValue(val) {
        switch(val){
            case -2:
                return [];
            case -3:
                return {};
        }
    }
    function PromiseArray(values) {
        var promise = this._promise = new Promise(INTERNAL);
        if (values instanceof Promise) {
            promise._propagateFrom(values, 3);
        }
        promise._setOnCancel(this);
        this._values = values;
        this._length = 0;
        this._totalResolved = 0;
        this._init(undefined, -2);
    }
    util.inherits(PromiseArray, Proxyable);
    PromiseArray.prototype.length = function() {
        return this._length;
    };
    PromiseArray.prototype.promise = function() {
        return this._promise;
    };
    PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
        var values = tryConvertToPromise(this._values, this._promise);
        if (values instanceof Promise) {
            values = values._target();
            var bitField = values._bitField;
            ;
            this._values = values;
            if ((bitField & 50397184) === 0) {
                this._promise._setAsyncGuaranteed();
                return values._then(init, this._reject, undefined, this, resolveValueIfEmpty);
            } else if ((bitField & 33554432) !== 0) {
                values = values._value();
            } else if ((bitField & 16777216) !== 0) {
                return this._reject(values._reason());
            } else {
                return this._cancel();
            }
        }
        values = util.asArray(values);
        if (values === null) {
            var err = apiRejection("expecting an array or an iterable object but got " + util.classString(values)).reason();
            this._promise._rejectCallback(err, false);
            return;
        }
        if (values.length === 0) {
            if (resolveValueIfEmpty === -5) {
                this._resolveEmptyArray();
            } else {
                this._resolve(toResolutionValue(resolveValueIfEmpty));
            }
            return;
        }
        this._iterate(values);
    };
    PromiseArray.prototype._iterate = function(values) {
        var len = this.getActualLength(values.length);
        this._length = len;
        this._values = this.shouldCopyValues() ? new Array(len) : this._values;
        var result = this._promise;
        var isResolved = false;
        var bitField = null;
        for(var i = 0; i < len; ++i){
            var maybePromise = tryConvertToPromise(values[i], result);
            if (maybePromise instanceof Promise) {
                maybePromise = maybePromise._target();
                bitField = maybePromise._bitField;
            } else {
                bitField = null;
            }
            if (isResolved) {
                if (bitField !== null) {
                    maybePromise.suppressUnhandledRejections();
                }
            } else if (bitField !== null) {
                if ((bitField & 50397184) === 0) {
                    maybePromise._proxy(this, i);
                    this._values[i] = maybePromise;
                } else if ((bitField & 33554432) !== 0) {
                    isResolved = this._promiseFulfilled(maybePromise._value(), i);
                } else if ((bitField & 16777216) !== 0) {
                    isResolved = this._promiseRejected(maybePromise._reason(), i);
                } else {
                    isResolved = this._promiseCancelled(i);
                }
            } else {
                isResolved = this._promiseFulfilled(maybePromise, i);
            }
        }
        if (!isResolved) result._setAsyncGuaranteed();
    };
    PromiseArray.prototype._isResolved = function() {
        return this._values === null;
    };
    PromiseArray.prototype._resolve = function(value) {
        this._values = null;
        this._promise._fulfill(value);
    };
    PromiseArray.prototype._cancel = function() {
        if (this._isResolved() || !this._promise._isCancellable()) return;
        this._values = null;
        this._promise._cancel();
    };
    PromiseArray.prototype._reject = function(reason) {
        this._values = null;
        this._promise._rejectCallback(reason, false);
    };
    PromiseArray.prototype._promiseFulfilled = function(value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            this._resolve(this._values);
            return true;
        }
        return false;
    };
    PromiseArray.prototype._promiseCancelled = function() {
        this._cancel();
        return true;
    };
    PromiseArray.prototype._promiseRejected = function(reason) {
        this._totalResolved++;
        this._reject(reason);
        return true;
    };
    PromiseArray.prototype._resultCancelled = function() {
        if (this._isResolved()) return;
        var values = this._values;
        this._cancel();
        if (values instanceof Promise) {
            values.cancel();
        } else {
            for(var i = 0; i < values.length; ++i){
                if (values[i] instanceof Promise) {
                    values[i].cancel();
                }
            }
        }
    };
    PromiseArray.prototype.shouldCopyValues = function() {
        return true;
    };
    PromiseArray.prototype.getActualLength = function(len) {
        return len;
    };
    return PromiseArray;
};


/***/ }),

/***/ 66066:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise, INTERNAL) {
    var THIS = {};
    var util = __webpack_require__(64935);
    var nodebackForPromise = __webpack_require__(28688);
    var withAppended = util.withAppended;
    var maybeWrapAsError = util.maybeWrapAsError;
    var canEvaluate = util.canEvaluate;
    var TypeError = (__webpack_require__(91710).TypeError);
    var defaultSuffix = "Async";
    var defaultPromisified = {
        __isPromisified__: true
    };
    var noCopyProps = [
        "arity",
        "length",
        "name",
        "arguments",
        "caller",
        "callee",
        "prototype",
        "__isPromisified__"
    ];
    var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
    var defaultFilter = function(name) {
        return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
    };
    function propsFilter(key) {
        return !noCopyPropsPattern.test(key);
    }
    function isPromisified(fn) {
        try {
            return fn.__isPromisified__ === true;
        } catch (e) {
            return false;
        }
    }
    function hasPromisified(obj, key, suffix) {
        var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);
        return val ? isPromisified(val) : false;
    }
    function checkValid(ret, suffix, suffixRegexp) {
        for(var i = 0; i < ret.length; i += 2){
            var key = ret[i];
            if (suffixRegexp.test(key)) {
                var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
                for(var j = 0; j < ret.length; j += 2){
                    if (ret[j] === keyWithoutAsyncSuffix) {
                        throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
                    }
                }
            }
        }
    }
    function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
        var keys = util.inheritedDataKeys(obj);
        var ret = [];
        for(var i = 0; i < keys.length; ++i){
            var key = keys[i];
            var value = obj[key];
            var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);
            if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {
                ret.push(key, value);
            }
        }
        checkValid(ret, suffix, suffixRegexp);
        return ret;
    }
    var escapeIdentRegex = function(str) {
        return str.replace(/([$])/, "\\$");
    };
    var makeNodePromisifiedEval;
    if (true) {
        var switchCaseArgumentOrder = function(likelyArgumentCount) {
            var ret = [
                likelyArgumentCount
            ];
            var min = Math.max(0, likelyArgumentCount - 1 - 3);
            for(var i = likelyArgumentCount - 1; i >= min; --i){
                ret.push(i);
            }
            for(var i = likelyArgumentCount + 1; i <= 3; ++i){
                ret.push(i);
            }
            return ret;
        };
        var argumentSequence = function(argumentCount) {
            return util.filledRange(argumentCount, "_arg", "");
        };
        var parameterDeclaration = function(parameterCount) {
            return util.filledRange(Math.max(parameterCount, 3), "_arg", "");
        };
        var parameterCount = function(fn) {
            if (typeof fn.length === "number") {
                return Math.max(Math.min(fn.length, 1023 + 1), 0);
            }
            return 0;
        };
        makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _, multiArgs) {
            var newParameterCount = Math.max(0, parameterCount(fn) - 1);
            var argumentOrder = switchCaseArgumentOrder(newParameterCount);
            var shouldProxyThis = typeof callback === "string" || receiver === THIS;
            function generateCallForArgumentCount(count) {
                var args = argumentSequence(count).join(", ");
                var comma = count > 0 ? ", " : "";
                var ret;
                if (shouldProxyThis) {
                    ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
                } else {
                    ret = receiver === undefined ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
                }
                return ret.replace("{{args}}", args).replace(", ", comma);
            }
            function generateArgumentSwitchCase() {
                var ret = "";
                for(var i = 0; i < argumentOrder.length; ++i){
                    ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
                }
                ret += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
                return ret;
            }
            var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
            var body = "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
            body = body.replace("Parameters", parameterDeclaration(newParameterCount));
            return new Function("Promise", "fn", "receiver", "withAppended", "maybeWrapAsError", "nodebackForPromise", "tryCatch", "errorObj", "notEnumerableProp", "INTERNAL", body)(Promise, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);
        };
    }
    function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
        var defaultThis = function() {
            return this;
        }();
        var method = callback;
        if (typeof method === "string") {
            callback = fn;
        }
        function promisified() {
            var _receiver = receiver;
            if (receiver === THIS) _receiver = this;
            var promise = new Promise(INTERNAL);
            promise._captureStackTrace();
            var cb = typeof method === "string" && this !== defaultThis ? this[method] : callback;
            var fn = nodebackForPromise(promise, multiArgs);
            try {
                cb.apply(_receiver, withAppended(arguments, fn));
            } catch (e) {
                promise._rejectCallback(maybeWrapAsError(e), true, true);
            }
            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
            return promise;
        }
        util.notEnumerableProp(promisified, "__isPromisified__", true);
        return promisified;
    }
    var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
    function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
        var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
        var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);
        for(var i = 0, len = methods.length; i < len; i += 2){
            var key = methods[i];
            var fn = methods[i + 1];
            var promisifiedKey = key + suffix;
            if (promisifier === makeNodePromisified) {
                obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
            } else {
                var promisified = promisifier(fn, function() {
                    return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
                });
                util.notEnumerableProp(promisified, "__isPromisified__", true);
                obj[promisifiedKey] = promisified;
            }
        }
        util.toFastProperties(obj);
        return obj;
    }
    function promisify(callback, receiver, multiArgs) {
        return makeNodePromisified(callback, receiver, undefined, callback, null, multiArgs);
    }
    Promise.promisify = function(fn, options) {
        if (typeof fn !== "function") {
            throw new TypeError("expecting a function but got " + util.classString(fn));
        }
        if (isPromisified(fn)) {
            return fn;
        }
        options = Object(options);
        var receiver = options.context === undefined ? THIS : options.context;
        var multiArgs = !!options.multiArgs;
        var ret = promisify(fn, receiver, multiArgs);
        util.copyDescriptors(fn, ret, propsFilter);
        return ret;
    };
    Promise.promisifyAll = function(target, options) {
        if (typeof target !== "function" && typeof target !== "object") {
            throw new TypeError("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        options = Object(options);
        var multiArgs = !!options.multiArgs;
        var suffix = options.suffix;
        if (typeof suffix !== "string") suffix = defaultSuffix;
        var filter = options.filter;
        if (typeof filter !== "function") filter = defaultFilter;
        var promisifier = options.promisifier;
        if (typeof promisifier !== "function") promisifier = makeNodePromisified;
        if (!util.isIdentifier(suffix)) {
            throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
        }
        var keys = util.inheritedDataKeys(target);
        for(var i = 0; i < keys.length; ++i){
            var value = target[keys[i]];
            if (keys[i] !== "constructor" && util.isClass(value)) {
                promisifyAll(value.prototype, suffix, filter, promisifier, multiArgs);
                promisifyAll(value, suffix, filter, promisifier, multiArgs);
            }
        }
        return promisifyAll(target, suffix, filter, promisifier, multiArgs);
    };
};


/***/ }),

/***/ 4196:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise, PromiseArray, tryConvertToPromise, apiRejection) {
    var util = __webpack_require__(64935);
    var isObject = util.isObject;
    var es5 = __webpack_require__(12032);
    var Es6Map;
    if (typeof Map === "function") Es6Map = Map;
    var mapToEntries = function() {
        var index = 0;
        var size = 0;
        function extractEntry(value, key) {
            this[index] = value;
            this[index + size] = key;
            index++;
        }
        return function mapToEntries(map) {
            size = map.size;
            index = 0;
            var ret = new Array(map.size * 2);
            map.forEach(extractEntry, ret);
            return ret;
        };
    }();
    var entriesToMap = function(entries) {
        var ret = new Es6Map();
        var length = entries.length / 2 | 0;
        for(var i = 0; i < length; ++i){
            var key = entries[length + i];
            var value = entries[i];
            ret.set(key, value);
        }
        return ret;
    };
    function PropertiesPromiseArray(obj) {
        var isMap = false;
        var entries;
        if (Es6Map !== undefined && obj instanceof Es6Map) {
            entries = mapToEntries(obj);
            isMap = true;
        } else {
            var keys = es5.keys(obj);
            var len = keys.length;
            entries = new Array(len * 2);
            for(var i = 0; i < len; ++i){
                var key = keys[i];
                entries[i] = obj[key];
                entries[i + len] = key;
            }
        }
        this.constructor$(entries);
        this._isMap = isMap;
        this._init$(undefined, -3);
    }
    util.inherits(PropertiesPromiseArray, PromiseArray);
    PropertiesPromiseArray.prototype._init = function() {};
    PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            var val;
            if (this._isMap) {
                val = entriesToMap(this._values);
            } else {
                val = {};
                var keyOffset = this.length();
                for(var i = 0, len = this.length(); i < len; ++i){
                    val[this._values[i + keyOffset]] = this._values[i];
                }
            }
            this._resolve(val);
            return true;
        }
        return false;
    };
    PropertiesPromiseArray.prototype.shouldCopyValues = function() {
        return false;
    };
    PropertiesPromiseArray.prototype.getActualLength = function(len) {
        return len >> 1;
    };
    function props(promises) {
        var ret;
        var castValue = tryConvertToPromise(promises);
        if (!isObject(castValue)) {
            return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
        } else if (castValue instanceof Promise) {
            ret = castValue._then(Promise.props, undefined, undefined, undefined, undefined);
        } else {
            ret = new PropertiesPromiseArray(castValue).promise();
        }
        if (castValue instanceof Promise) {
            ret._propagateFrom(castValue, 2);
        }
        return ret;
    }
    Promise.prototype.props = function() {
        return props(this);
    };
    Promise.props = function(promises) {
        return props(promises);
    };
};


/***/ }),

/***/ 73815:
/***/ ((module) => {

"use strict";

function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for(var j = 0; j < len; ++j){
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}
function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
}
Queue.prototype._willBeOverCapacity = function(size) {
    return this._capacity < size;
};
Queue.prototype._pushOne = function(arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = this._front + length & this._capacity - 1;
    this[i] = arg;
    this._length = length + 1;
};
Queue.prototype.push = function(fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[j + 0 & wrapMask] = fn;
    this[j + 1 & wrapMask] = receiver;
    this[j + 2 & wrapMask] = arg;
    this._length = length;
};
Queue.prototype.shift = function() {
    var front = this._front, ret = this[front];
    this[front] = undefined;
    this._front = front + 1 & this._capacity - 1;
    this._length--;
    return ret;
};
Queue.prototype.length = function() {
    return this._length;
};
Queue.prototype._checkCapacity = function(size) {
    if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
    }
};
Queue.prototype._resizeTo = function(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = front + length & oldCapacity - 1;
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
};
module.exports = Queue;


/***/ }),

/***/ 39959:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
    var util = __webpack_require__(64935);
    var raceLater = function(promise) {
        return promise.then(function(array) {
            return race(array, promise);
        });
    };
    function race(promises, parent) {
        var maybePromise = tryConvertToPromise(promises);
        if (maybePromise instanceof Promise) {
            return raceLater(maybePromise);
        } else {
            promises = util.asArray(promises);
            if (promises === null) return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
        }
        var ret = new Promise(INTERNAL);
        if (parent !== undefined) {
            ret._propagateFrom(parent, 3);
        }
        var fulfill = ret._fulfill;
        var reject = ret._reject;
        for(var i = 0, len = promises.length; i < len; ++i){
            var val = promises[i];
            if (val === undefined && !(i in promises)) {
                continue;
            }
            Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
        }
        return ret;
    }
    Promise.race = function(promises) {
        return race(promises, undefined);
    };
    Promise.prototype.race = function() {
        return race(this, undefined);
    };
};


/***/ }),

/***/ 73614:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var getDomain = Promise._getDomain;
    var util = __webpack_require__(64935);
    var tryCatch = util.tryCatch;
    function ReductionPromiseArray(promises, fn, initialValue, _each) {
        this.constructor$(promises);
        var domain = getDomain();
        this._fn = domain === null ? fn : util.domainBind(domain, fn);
        if (initialValue !== undefined) {
            initialValue = Promise.resolve(initialValue);
            initialValue._attachCancellationCallback(this);
        }
        this._initialValue = initialValue;
        this._currentCancellable = null;
        if (_each === INTERNAL) {
            this._eachValues = Array(this._length);
        } else if (_each === 0) {
            this._eachValues = null;
        } else {
            this._eachValues = undefined;
        }
        this._promise._captureStackTrace();
        this._init$(undefined, -5);
    }
    util.inherits(ReductionPromiseArray, PromiseArray);
    ReductionPromiseArray.prototype._gotAccum = function(accum) {
        if (this._eachValues !== undefined && this._eachValues !== null && accum !== INTERNAL) {
            this._eachValues.push(accum);
        }
    };
    ReductionPromiseArray.prototype._eachComplete = function(value) {
        if (this._eachValues !== null) {
            this._eachValues.push(value);
        }
        return this._eachValues;
    };
    ReductionPromiseArray.prototype._init = function() {};
    ReductionPromiseArray.prototype._resolveEmptyArray = function() {
        this._resolve(this._eachValues !== undefined ? this._eachValues : this._initialValue);
    };
    ReductionPromiseArray.prototype.shouldCopyValues = function() {
        return false;
    };
    ReductionPromiseArray.prototype._resolve = function(value) {
        this._promise._resolveCallback(value);
        this._values = null;
    };
    ReductionPromiseArray.prototype._resultCancelled = function(sender) {
        if (sender === this._initialValue) return this._cancel();
        if (this._isResolved()) return;
        this._resultCancelled$();
        if (this._currentCancellable instanceof Promise) {
            this._currentCancellable.cancel();
        }
        if (this._initialValue instanceof Promise) {
            this._initialValue.cancel();
        }
    };
    ReductionPromiseArray.prototype._iterate = function(values) {
        this._values = values;
        var value;
        var i;
        var length = values.length;
        if (this._initialValue !== undefined) {
            value = this._initialValue;
            i = 0;
        } else {
            value = Promise.resolve(values[0]);
            i = 1;
        }
        this._currentCancellable = value;
        if (!value.isRejected()) {
            for(; i < length; ++i){
                var ctx = {
                    accum: null,
                    value: values[i],
                    index: i,
                    length: length,
                    array: this
                };
                value = value._then(gotAccum, undefined, undefined, ctx, undefined);
            }
        }
        if (this._eachValues !== undefined) {
            value = value._then(this._eachComplete, undefined, undefined, this, undefined);
        }
        value._then(completed, completed, undefined, value, this);
    };
    Promise.prototype.reduce = function(fn, initialValue) {
        return reduce(this, fn, initialValue, null);
    };
    Promise.reduce = function(promises, fn, initialValue, _each) {
        return reduce(promises, fn, initialValue, _each);
    };
    function completed(valueOrReason, array) {
        if (this.isFulfilled()) {
            array._resolve(valueOrReason);
        } else {
            array._reject(valueOrReason);
        }
    }
    function reduce(promises, fn, initialValue, _each) {
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
        return array.promise();
    }
    function gotAccum(accum) {
        this.accum = accum;
        this.array._gotAccum(accum);
        var value = tryConvertToPromise(this.value, this.array._promise);
        if (value instanceof Promise) {
            this.array._currentCancellable = value;
            return value._then(gotValue, undefined, undefined, this, undefined);
        } else {
            return gotValue.call(this, value);
        }
    }
    function gotValue(value) {
        var array = this.array;
        var promise = array._promise;
        var fn = tryCatch(array._fn);
        promise._pushContext();
        var ret;
        if (array._eachValues !== undefined) {
            ret = fn.call(promise._boundValue(), value, this.index, this.length);
        } else {
            ret = fn.call(promise._boundValue(), this.accum, value, this.index, this.length);
        }
        if (ret instanceof Promise) {
            array._currentCancellable = ret;
        }
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(ret, promiseCreated, array._eachValues !== undefined ? "Promise.each" : "Promise.reduce", promise);
        return ret;
    }
};


/***/ }),

/***/ 5425:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var util = __webpack_require__(64935);
var schedule;
var noAsyncScheduler = function() {
    throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
};
var NativePromise = util.getNativePromise();
if (util.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = global.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode ? function(fn) {
        GlobalSetImmediate.call(global, fn);
    } : function(fn) {
        ProcessNextTick.call(process, fn);
    };
} else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
    var nativePromise = NativePromise.resolve();
    schedule = function(fn) {
        nativePromise.then(fn);
    };
} else if (typeof MutationObserver !== "undefined" && !( false && (0))) {
    schedule = function() {
        var div = document.createElement("div");
        var opts = {
            attributes: true
        };
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function() {
            div.classList.toggle("foo");
            toggleScheduled = false;
        });
        o2.observe(div2, opts);
        var scheduleToggle = function() {
            if (toggleScheduled) return;
            toggleScheduled = true;
            div2.classList.toggle("foo");
        };
        return function schedule(fn) {
            var o = new MutationObserver(function() {
                o.disconnect();
                fn();
            });
            o.observe(div, opts);
            scheduleToggle();
        };
    }();
} else if (typeof setImmediate !== "undefined") {
    schedule = function(fn) {
        setImmediate(fn);
    };
} else if (typeof setTimeout !== "undefined") {
    schedule = function(fn) {
        setTimeout(fn, 0);
    };
} else {
    schedule = noAsyncScheduler;
}
module.exports = schedule;


/***/ }),

/***/ 36880:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise, PromiseArray, debug) {
    var PromiseInspection = Promise.PromiseInspection;
    var util = __webpack_require__(64935);
    function SettledPromiseArray(values) {
        this.constructor$(values);
    }
    util.inherits(SettledPromiseArray, PromiseArray);
    SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
        this._values[index] = inspection;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
            this._resolve(this._values);
            return true;
        }
        return false;
    };
    SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
        var ret = new PromiseInspection();
        ret._bitField = 33554432;
        ret._settledValueField = value;
        return this._promiseResolved(index, ret);
    };
    SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
        var ret = new PromiseInspection();
        ret._bitField = 16777216;
        ret._settledValueField = reason;
        return this._promiseResolved(index, ret);
    };
    Promise.settle = function(promises) {
        debug.deprecated(".settle()", ".reflect()");
        return new SettledPromiseArray(promises).promise();
    };
    Promise.prototype.settle = function() {
        return Promise.settle(this);
    };
};


/***/ }),

/***/ 65562:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise, PromiseArray, apiRejection) {
    var util = __webpack_require__(64935);
    var RangeError = (__webpack_require__(91710).RangeError);
    var AggregateError = (__webpack_require__(91710).AggregateError);
    var isArray = util.isArray;
    var CANCELLATION = {};
    function SomePromiseArray(values) {
        this.constructor$(values);
        this._howMany = 0;
        this._unwrap = false;
        this._initialized = false;
    }
    util.inherits(SomePromiseArray, PromiseArray);
    SomePromiseArray.prototype._init = function() {
        if (!this._initialized) {
            return;
        }
        if (this._howMany === 0) {
            this._resolve([]);
            return;
        }
        this._init$(undefined, -5);
        var isArrayResolved = isArray(this._values);
        if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
            this._reject(this._getRangeError(this.length()));
        }
    };
    SomePromiseArray.prototype.init = function() {
        this._initialized = true;
        this._init();
    };
    SomePromiseArray.prototype.setUnwrap = function() {
        this._unwrap = true;
    };
    SomePromiseArray.prototype.howMany = function() {
        return this._howMany;
    };
    SomePromiseArray.prototype.setHowMany = function(count) {
        this._howMany = count;
    };
    SomePromiseArray.prototype._promiseFulfilled = function(value) {
        this._addFulfilled(value);
        if (this._fulfilled() === this.howMany()) {
            this._values.length = this.howMany();
            if (this.howMany() === 1 && this._unwrap) {
                this._resolve(this._values[0]);
            } else {
                this._resolve(this._values);
            }
            return true;
        }
        return false;
    };
    SomePromiseArray.prototype._promiseRejected = function(reason) {
        this._addRejected(reason);
        return this._checkOutcome();
    };
    SomePromiseArray.prototype._promiseCancelled = function() {
        if (this._values instanceof Promise || this._values == null) {
            return this._cancel();
        }
        this._addRejected(CANCELLATION);
        return this._checkOutcome();
    };
    SomePromiseArray.prototype._checkOutcome = function() {
        if (this.howMany() > this._canPossiblyFulfill()) {
            var e = new AggregateError();
            for(var i = this.length(); i < this._values.length; ++i){
                if (this._values[i] !== CANCELLATION) {
                    e.push(this._values[i]);
                }
            }
            if (e.length > 0) {
                this._reject(e);
            } else {
                this._cancel();
            }
            return true;
        }
        return false;
    };
    SomePromiseArray.prototype._fulfilled = function() {
        return this._totalResolved;
    };
    SomePromiseArray.prototype._rejected = function() {
        return this._values.length - this.length();
    };
    SomePromiseArray.prototype._addRejected = function(reason) {
        this._values.push(reason);
    };
    SomePromiseArray.prototype._addFulfilled = function(value) {
        this._values[this._totalResolved++] = value;
    };
    SomePromiseArray.prototype._canPossiblyFulfill = function() {
        return this.length() - this._rejected();
    };
    SomePromiseArray.prototype._getRangeError = function(count) {
        var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
        return new RangeError(message);
    };
    SomePromiseArray.prototype._resolveEmptyArray = function() {
        this._reject(this._getRangeError(0));
    };
    function some(promises, howMany) {
        if ((howMany | 0) !== howMany || howMany < 0) {
            return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
        }
        var ret = new SomePromiseArray(promises);
        var promise = ret.promise();
        ret.setHowMany(howMany);
        ret.init();
        return promise;
    }
    Promise.some = function(promises, howMany) {
        return some(promises, howMany);
    };
    Promise.prototype.some = function(howMany) {
        return some(this, howMany);
    };
    Promise._SomePromiseArray = SomePromiseArray;
};


/***/ }),

/***/ 68971:
/***/ ((module) => {

"use strict";

module.exports = function(Promise) {
    function PromiseInspection(promise) {
        if (promise !== undefined) {
            promise = promise._target();
            this._bitField = promise._bitField;
            this._settledValueField = promise._isFateSealed() ? promise._settledValue() : undefined;
        } else {
            this._bitField = 0;
            this._settledValueField = undefined;
        }
    }
    PromiseInspection.prototype._settledValue = function() {
        return this._settledValueField;
    };
    var value = PromiseInspection.prototype.value = function() {
        if (!this.isFulfilled()) {
            throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
    };
    var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
        if (!this.isRejected()) {
            throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
    };
    var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
        return (this._bitField & 33554432) !== 0;
    };
    var isRejected = PromiseInspection.prototype.isRejected = function() {
        return (this._bitField & 16777216) !== 0;
    };
    var isPending = PromiseInspection.prototype.isPending = function() {
        return (this._bitField & 50397184) === 0;
    };
    var isResolved = PromiseInspection.prototype.isResolved = function() {
        return (this._bitField & 50331648) !== 0;
    };
    PromiseInspection.prototype.isCancelled = function() {
        return (this._bitField & 8454144) !== 0;
    };
    Promise.prototype.__isCancelled = function() {
        return (this._bitField & 65536) === 65536;
    };
    Promise.prototype._isCancelled = function() {
        return this._target().__isCancelled();
    };
    Promise.prototype.isCancelled = function() {
        return (this._target()._bitField & 8454144) !== 0;
    };
    Promise.prototype.isPending = function() {
        return isPending.call(this._target());
    };
    Promise.prototype.isRejected = function() {
        return isRejected.call(this._target());
    };
    Promise.prototype.isFulfilled = function() {
        return isFulfilled.call(this._target());
    };
    Promise.prototype.isResolved = function() {
        return isResolved.call(this._target());
    };
    Promise.prototype.value = function() {
        return value.call(this._target());
    };
    Promise.prototype.reason = function() {
        var target = this._target();
        target._unsetRejectionIsUnhandled();
        return reason.call(target);
    };
    Promise.prototype._value = function() {
        return this._settledValue();
    };
    Promise.prototype._reason = function() {
        this._unsetRejectionIsUnhandled();
        return this._settledValue();
    };
    Promise.PromiseInspection = PromiseInspection;
};


/***/ }),

/***/ 94436:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise, INTERNAL) {
    var util = __webpack_require__(64935);
    var errorObj = util.errorObj;
    var isObject = util.isObject;
    function tryConvertToPromise(obj, context) {
        if (isObject(obj)) {
            if (obj instanceof Promise) return obj;
            var then = getThen(obj);
            if (then === errorObj) {
                if (context) context._pushContext();
                var ret = Promise.reject(then.e);
                if (context) context._popContext();
                return ret;
            } else if (typeof then === "function") {
                if (isAnyBluebirdPromise(obj)) {
                    var ret = new Promise(INTERNAL);
                    obj._then(ret._fulfill, ret._reject, undefined, ret, null);
                    return ret;
                }
                return doThenable(obj, then, context);
            }
        }
        return obj;
    }
    function doGetThen(obj) {
        return obj.then;
    }
    function getThen(obj) {
        try {
            return doGetThen(obj);
        } catch (e) {
            errorObj.e = e;
            return errorObj;
        }
    }
    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj) {
        try {
            return hasProp.call(obj, "_promise0");
        } catch (e) {
            return false;
        }
    }
    function doThenable(x, then, context) {
        var promise = new Promise(INTERNAL);
        var ret = promise;
        if (context) context._pushContext();
        promise._captureStackTrace();
        if (context) context._popContext();
        var synchronous = true;
        var result = util.tryCatch(then).call(x, resolve, reject);
        synchronous = false;
        if (promise && result === errorObj) {
            promise._rejectCallback(result.e, true, true);
            promise = null;
        }
        function resolve(value) {
            if (!promise) return;
            promise._resolveCallback(value);
            promise = null;
        }
        function reject(reason) {
            if (!promise) return;
            promise._rejectCallback(reason, synchronous, true);
            promise = null;
        }
        return ret;
    }
    return tryConvertToPromise;
};


/***/ }),

/***/ 94878:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise, INTERNAL, debug) {
    var util = __webpack_require__(64935);
    var TimeoutError = Promise.TimeoutError;
    function HandleWrapper(handle) {
        this.handle = handle;
    }
    HandleWrapper.prototype._resultCancelled = function() {
        clearTimeout(this.handle);
    };
    var afterValue = function(value) {
        return delay(+this).thenReturn(value);
    };
    var delay = Promise.delay = function(ms, value) {
        var ret;
        var handle;
        if (value !== undefined) {
            ret = Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
            if (debug.cancellation() && value instanceof Promise) {
                ret._setOnCancel(value);
            }
        } else {
            ret = new Promise(INTERNAL);
            handle = setTimeout(function() {
                ret._fulfill();
            }, +ms);
            if (debug.cancellation()) {
                ret._setOnCancel(new HandleWrapper(handle));
            }
            ret._captureStackTrace();
        }
        ret._setAsyncGuaranteed();
        return ret;
    };
    Promise.prototype.delay = function(ms) {
        return delay(ms, this);
    };
    var afterTimeout = function(promise, message, parent) {
        var err;
        if (typeof message !== "string") {
            if (message instanceof Error) {
                err = message;
            } else {
                err = new TimeoutError("operation timed out");
            }
        } else {
            err = new TimeoutError(message);
        }
        util.markAsOriginatingFromRejection(err);
        promise._attachExtraTrace(err);
        promise._reject(err);
        if (parent != null) {
            parent.cancel();
        }
    };
    function successClear(value) {
        clearTimeout(this.handle);
        return value;
    }
    function failureClear(reason) {
        clearTimeout(this.handle);
        throw reason;
    }
    Promise.prototype.timeout = function(ms, message) {
        ms = +ms;
        var ret, parent;
        var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
            if (ret.isPending()) {
                afterTimeout(ret, message, parent);
            }
        }, ms));
        if (debug.cancellation()) {
            parent = this.then();
            ret = parent._then(successClear, failureClear, undefined, handleWrapper, undefined);
            ret._setOnCancel(handleWrapper);
        } else {
            ret = this._then(successClear, failureClear, undefined, handleWrapper, undefined);
        }
        return ret;
    };
};


/***/ }),

/***/ 53556:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = function(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
    var util = __webpack_require__(64935);
    var TypeError = (__webpack_require__(91710).TypeError);
    var inherits = (__webpack_require__(64935).inherits);
    var errorObj = util.errorObj;
    var tryCatch = util.tryCatch;
    var NULL = {};
    function thrower(e) {
        setTimeout(function() {
            throw e;
        }, 0);
    }
    function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
            maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
    }
    function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret = new Promise(INTERNAL);
        function iterator() {
            if (i >= len) return ret._fulfill();
            var maybePromise = castPreservingDisposable(resources[i++]);
            if (maybePromise instanceof Promise && maybePromise._isDisposable()) {
                try {
                    maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);
                } catch (e) {
                    return thrower(e);
                }
                if (maybePromise instanceof Promise) {
                    return maybePromise._then(iterator, thrower, null, null, null);
                }
            }
            iterator();
        }
        iterator();
        return ret;
    }
    function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
    }
    Disposer.prototype.data = function() {
        return this._data;
    };
    Disposer.prototype.promise = function() {
        return this._promise;
    };
    Disposer.prototype.resource = function() {
        if (this.promise().isFulfilled()) {
            return this.promise().value();
        }
        return NULL;
    };
    Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== undefined) context._pushContext();
        var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
        if (context !== undefined) context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret;
    };
    Disposer.isDisposer = function(d) {
        return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
    };
    function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
    }
    inherits(FunctionDisposer, Disposer);
    FunctionDisposer.prototype.doDispose = function(resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
    };
    function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
            this.resources[this.index]._setDisposable(value);
            return value.promise();
        }
        return value;
    }
    function ResourceList(length) {
        this.length = length;
        this.promise = null;
        this[length - 1] = null;
    }
    ResourceList.prototype._resultCancelled = function() {
        var len = this.length;
        for(var i = 0; i < len; ++i){
            var item = this[i];
            if (item instanceof Promise) {
                item.cancel();
            }
        }
    };
    Promise.using = function() {
        var len = arguments.length;
        if (len < 2) return apiRejection("you must pass at least 2 arguments to Promise.using");
        var fn = arguments[len - 1];
        if (typeof fn !== "function") {
            return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var input;
        var spreadArgs = true;
        if (len === 2 && Array.isArray(arguments[0])) {
            input = arguments[0];
            len = input.length;
            spreadArgs = false;
        } else {
            input = arguments;
            len--;
        }
        var resources = new ResourceList(len);
        for(var i = 0; i < len; ++i){
            var resource = input[i];
            if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
            } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise) {
                    resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                        resources: resources,
                        index: i
                    }, undefined);
                }
            }
            resources[i] = resource;
        }
        var reflectedResources = new Array(resources.length);
        for(var i = 0; i < reflectedResources.length; ++i){
            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
        }
        var resultPromise = Promise.all(reflectedResources).then(function(inspections) {
            for(var i = 0; i < inspections.length; ++i){
                var inspection = inspections[i];
                if (inspection.isRejected()) {
                    errorObj.e = inspection.error();
                    return errorObj;
                } else if (!inspection.isFulfilled()) {
                    resultPromise.cancel();
                    return;
                }
                inspections[i] = inspection.value();
            }
            promise._pushContext();
            fn = tryCatch(fn);
            var ret = spreadArgs ? fn.apply(undefined, inspections) : fn(inspections);
            var promiseCreated = promise._popContext();
            debug.checkForgottenReturns(ret, promiseCreated, "Promise.using", promise);
            return ret;
        });
        var promise = resultPromise.lastly(function() {
            var inspection = new Promise.PromiseInspection(resultPromise);
            return dispose(resources, inspection);
        });
        resources.promise = promise;
        promise._setOnCancel(resources);
        return promise;
    };
    Promise.prototype._setDisposable = function(disposer) {
        this._bitField = this._bitField | 131072;
        this._disposer = disposer;
    };
    Promise.prototype._isDisposable = function() {
        return (this._bitField & 131072) > 0;
    };
    Promise.prototype._getDisposer = function() {
        return this._disposer;
    };
    Promise.prototype._unsetDisposable = function() {
        this._bitField = this._bitField & ~131072;
        this._disposer = undefined;
    };
    Promise.prototype.disposer = function(fn) {
        if (typeof fn === "function") {
            return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError();
    };
};


/***/ }),

/***/ 64935:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var es5 = __webpack_require__(12032);
var canEvaluate = typeof navigator == "undefined";
var errorObj = {
    e: {}
};
var tryCatchTarget;
var globalObject = typeof self !== "undefined" ? self :  false ? 0 : typeof global !== "undefined" ? global : void 0 !== undefined ? void 0 : null;
function tryCatcher() {
    try {
        var target1 = tryCatchTarget;
        tryCatchTarget = null;
        return target1.apply(this, arguments);
    } catch (e1) {
        errorObj.e = e1;
        return errorObj;
    }
}
function tryCatch(fn1) {
    tryCatchTarget = fn1;
    return tryCatcher;
}
var inherits = function(Child1, Parent1) {
    var hasProp1 = {}.hasOwnProperty;
    function T1() {
        this.constructor = Child1;
        this.constructor$ = Parent1;
        for(var propertyName1 in Parent1.prototype){
            if (hasProp1.call(Parent1.prototype, propertyName1) && propertyName1.charAt(propertyName1.length - 1) !== "$") {
                this[propertyName1 + "$"] = Parent1.prototype[propertyName1];
            }
        }
    }
    T1.prototype = Parent1.prototype;
    Child1.prototype = new T1();
    return Child1.prototype;
};
function isPrimitive(val1) {
    return val1 == null || val1 === true || val1 === false || typeof val1 === "string" || typeof val1 === "number";
}
function isObject(value1) {
    return typeof value1 === "function" || typeof value1 === "object" && value1 !== null;
}
function maybeWrapAsError(maybeError1) {
    if (!isPrimitive(maybeError1)) return maybeError1;
    return new Error(safeToString(maybeError1));
}
function withAppended(target1, appendee1) {
    var len1 = target1.length;
    var ret1 = new Array(len1 + 1);
    var i1;
    for(i1 = 0; i1 < len1; ++i1){
        ret1[i1] = target1[i1];
    }
    ret1[i1] = appendee1;
    return ret1;
}
function getDataPropertyOrDefault(obj1, key1, defaultValue1) {
    if (es5.isES5) {
        var desc1 = Object.getOwnPropertyDescriptor(obj1, key1);
        if (desc1 != null) {
            return desc1.get == null && desc1.set == null ? desc1.value : defaultValue1;
        }
    } else {
        return ({}).hasOwnProperty.call(obj1, key1) ? obj1[key1] : undefined;
    }
}
function notEnumerableProp(obj1, name1, value1) {
    if (isPrimitive(obj1)) return obj1;
    var descriptor1 = {
        value: value1,
        configurable: true,
        enumerable: false,
        writable: true
    };
    es5.defineProperty(obj1, name1, descriptor1);
    return obj1;
}
function thrower(r1) {
    throw r1;
}
var inheritedDataKeys = function() {
    var excludedPrototypes1 = [
        Array.prototype,
        Object.prototype,
        Function.prototype
    ];
    var isExcludedProto1 = function(val1) {
        for(var i1 = 0; i1 < excludedPrototypes1.length; ++i1){
            if (excludedPrototypes1[i1] === val1) {
                return true;
            }
        }
        return false;
    };
    if (es5.isES5) {
        var getKeys1 = Object.getOwnPropertyNames;
        return function(obj1) {
            var ret1 = [];
            var visitedKeys1 = Object.create(null);
            while(obj1 != null && !isExcludedProto1(obj1)){
                var keys1;
                try {
                    keys1 = getKeys1(obj1);
                } catch (e1) {
                    return ret1;
                }
                for(var i1 = 0; i1 < keys1.length; ++i1){
                    var key1 = keys1[i1];
                    if (visitedKeys1[key1]) continue;
                    visitedKeys1[key1] = true;
                    var desc1 = Object.getOwnPropertyDescriptor(obj1, key1);
                    if (desc1 != null && desc1.get == null && desc1.set == null) {
                        ret1.push(key1);
                    }
                }
                obj1 = es5.getPrototypeOf(obj1);
            }
            return ret1;
        };
    } else {
        var hasProp1 = {}.hasOwnProperty;
        return function(obj1) {
            if (isExcludedProto1(obj1)) return [];
            var ret1 = [];
            /*jshint forin:false */ enumeration: for(var key1 in obj1){
                if (hasProp1.call(obj1, key1)) {
                    ret1.push(key1);
                } else {
                    for(var i1 = 0; i1 < excludedPrototypes1.length; ++i1){
                        if (hasProp1.call(excludedPrototypes1[i1], key1)) {
                            continue enumeration;
                        }
                    }
                    ret1.push(key1);
                }
            }
            return ret1;
        };
    }
}();
var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
function isClass(fn1) {
    try {
        if (typeof fn1 === "function") {
            var keys1 = es5.names(fn1.prototype);
            var hasMethods1 = es5.isES5 && keys1.length > 1;
            var hasMethodsOtherThanConstructor1 = keys1.length > 0 && !(keys1.length === 1 && keys1[0] === "constructor");
            var hasThisAssignmentAndStaticMethods1 = thisAssignmentPattern.test(fn1 + "") && es5.names(fn1).length > 0;
            if (hasMethods1 || hasMethodsOtherThanConstructor1 || hasThisAssignmentAndStaticMethods1) {
                return true;
            }
        }
        return false;
    } catch (e1) {
        return false;
    }
}
function toFastProperties(obj) {
    /*jshint -W027,-W055,-W031*/ function FakeConstructor() {}
    FakeConstructor.prototype = obj;
    var l = 8;
    while(l--)new FakeConstructor();
    return obj;
    eval(obj);
}
var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str1) {
    return rident.test(str1);
}
function filledRange(count1, prefix1, suffix1) {
    var ret1 = new Array(count1);
    for(var i1 = 0; i1 < count1; ++i1){
        ret1[i1] = prefix1 + i1 + suffix1;
    }
    return ret1;
}
function safeToString(obj1) {
    try {
        return obj1 + "";
    } catch (e1) {
        return "[no string representation]";
    }
}
function isError(obj1) {
    return obj1 !== null && typeof obj1 === "object" && typeof obj1.message === "string" && typeof obj1.name === "string";
}
function markAsOriginatingFromRejection(e1) {
    try {
        notEnumerableProp(e1, "isOperational", true);
    } catch (ignore1) {}
}
function originatesFromRejection(e1) {
    if (e1 == null) return false;
    return e1 instanceof Error["__BluebirdErrorTypes__"].OperationalError || e1["isOperational"] === true;
}
function canAttachTrace(obj1) {
    return isError(obj1) && es5.propertyIsWritable(obj1, "stack");
}
var ensureErrorObject = function() {
    if (!("stack" in new Error())) {
        return function(value1) {
            if (canAttachTrace(value1)) return value1;
            try {
                throw new Error(safeToString(value1));
            } catch (err1) {
                return err1;
            }
        };
    } else {
        return function(value1) {
            if (canAttachTrace(value1)) return value1;
            return new Error(safeToString(value1));
        };
    }
}();
function classString(obj1) {
    return ({}).toString.call(obj1);
}
function copyDescriptors(from1, to1, filter1) {
    var keys1 = es5.names(from1);
    for(var i1 = 0; i1 < keys1.length; ++i1){
        var key1 = keys1[i1];
        if (filter1(key1)) {
            try {
                es5.defineProperty(to1, key1, es5.getDescriptor(from1, key1));
            } catch (ignore1) {}
        }
    }
}
var asArray = function(v1) {
    if (es5.isArray(v1)) {
        return v1;
    }
    return null;
};
if (typeof Symbol !== "undefined" && Symbol.iterator) {
    var ArrayFrom = typeof Array.from === "function" ? function(v1) {
        return Array.from(v1);
    } : function(v1) {
        var ret1 = [];
        var it1 = v1[Symbol.iterator]();
        var itResult1;
        while(!(itResult1 = it1.next()).done){
            ret1.push(itResult1.value);
        }
        return ret1;
    };
    asArray = function(v1) {
        if (es5.isArray(v1)) {
            return v1;
        } else if (v1 != null && typeof v1[Symbol.iterator] === "function") {
            return ArrayFrom(v1);
        }
        return null;
    };
}
var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
function env(key1) {
    return hasEnvVariables ? process.env[key1] : undefined;
}
function getNativePromise() {
    if (typeof Promise === "function") {
        try {
            var promise1 = new Promise(function() {});
            if (({}).toString.call(promise1) === "[object Promise]") {
                return Promise;
            }
        } catch (e1) {}
    }
}
function domainBind(self1, cb1) {
    return self1.bind(cb1);
}
var ret = {
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    asArray: asArray,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    isError: isError,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch: tryCatch,
    inherits: inherits,
    withAppended: withAppended,
    maybeWrapAsError: maybeWrapAsError,
    toFastProperties: toFastProperties,
    filledRange: filledRange,
    toString: safeToString,
    canAttachTrace: canAttachTrace,
    ensureErrorObject: ensureErrorObject,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    classString: classString,
    copyDescriptors: copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
    isNode: isNode,
    hasEnvVariables: hasEnvVariables,
    env: env,
    global: globalObject,
    getNativePromise: getNativePromise,
    domainBind: domainBind
};
ret.isRecentNode = ret.isNode && function() {
    var version1 = process.versions.node.split(".").map(Number);
    return version1[0] === 0 && version1[1] > 10 || version1[0] > 0;
}();
if (ret.isNode) ret.toFastProperties(process);
try {
    throw new Error();
} catch (e) {
    ret.lastLineError = e;
}
module.exports = ret;


/***/ }),

/***/ 14152:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var concatMap = __webpack_require__(23630);
var balanced = __webpack_require__(2165);
module.exports = expandTop;
var escSlash = "\x00SLASH" + Math.random() + "\x00";
var escOpen = "\x00OPEN" + Math.random() + "\x00";
var escClose = "\x00CLOSE" + Math.random() + "\x00";
var escComma = "\x00COMMA" + Math.random() + "\x00";
var escPeriod = "\x00PERIOD" + Math.random() + "\x00";
function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
}
function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
}
// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
    if (!str) return [
        ""
    ];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m) return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
}
function expandTop(str) {
    if (!str) return [];
    // I don't know why Bash 4.3 does this, but it does.
    // Anything starting with {} will have the first two bytes preserved
    // but *only* at the top level, so {},a}b will not expand to anything,
    // but a{},b}c will be expanded to [a}c,abc].
    // One could argue that this is a bug in Bash, but since the goal of
    // this module is to match Bash's rules, we escape a leading {}
    if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
}
function identity(e) {
    return e;
}
function embrace(str) {
    return "{" + str + "}";
}
function isPadded(el) {
    return /^-?0\d/.test(el);
}
function lte(i, y) {
    return i <= y;
}
function gte(i, y) {
    return i >= y;
}
function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m || /\$$/.test(m.pre)) return [
        str
    ];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
        // {a},b}
        if (m.post.match(/,(?!,).*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
        }
        return [
            str
        ];
    }
    var n;
    if (isSequence) {
        n = m.body.split(/\.\./);
    } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
            // x{{a,b}}y ==> x{a}y x{b}y
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
                var post = m.post.length ? expand(m.post, false) : [
                    ""
                ];
                return post.map(function(p) {
                    return m.pre + n[0] + p;
                });
            }
        }
    }
    // at this point, n is the parts, and we know it's not a comma set
    // with a single entry.
    // no need to expand pre, since it is guaranteed to be free of brace-sets
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [
        ""
    ];
    var N;
    if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
            incr *= -1;
            test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for(var i = x; test(i, y); i += incr){
            var c;
            if (isAlphaSequence) {
                c = String.fromCharCode(i);
                if (c === "\\") c = "";
            } else {
                c = String(i);
                if (pad) {
                    var need = width - c.length;
                    if (need > 0) {
                        var z = new Array(need + 1).join("0");
                        if (i < 0) c = "-" + z + c.slice(1);
                        else c = z + c;
                    }
                }
            }
            N.push(c);
        }
    } else {
        N = concatMap(n, function(el) {
            return expand(el, false);
        });
    }
    for(var j = 0; j < N.length; j++){
        for(var k = 0; k < post.length; k++){
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion) expansions.push(expansion);
        }
    }
    return expansions;
}


/***/ }),

/***/ 78177:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(14300).Buffer);
var CRC_TABLE = [
    0x00000000,
    0x77073096,
    0xee0e612c,
    0x990951ba,
    0x076dc419,
    0x706af48f,
    0xe963a535,
    0x9e6495a3,
    0x0edb8832,
    0x79dcb8a4,
    0xe0d5e91e,
    0x97d2d988,
    0x09b64c2b,
    0x7eb17cbd,
    0xe7b82d07,
    0x90bf1d91,
    0x1db71064,
    0x6ab020f2,
    0xf3b97148,
    0x84be41de,
    0x1adad47d,
    0x6ddde4eb,
    0xf4d4b551,
    0x83d385c7,
    0x136c9856,
    0x646ba8c0,
    0xfd62f97a,
    0x8a65c9ec,
    0x14015c4f,
    0x63066cd9,
    0xfa0f3d63,
    0x8d080df5,
    0x3b6e20c8,
    0x4c69105e,
    0xd56041e4,
    0xa2677172,
    0x3c03e4d1,
    0x4b04d447,
    0xd20d85fd,
    0xa50ab56b,
    0x35b5a8fa,
    0x42b2986c,
    0xdbbbc9d6,
    0xacbcf940,
    0x32d86ce3,
    0x45df5c75,
    0xdcd60dcf,
    0xabd13d59,
    0x26d930ac,
    0x51de003a,
    0xc8d75180,
    0xbfd06116,
    0x21b4f4b5,
    0x56b3c423,
    0xcfba9599,
    0xb8bda50f,
    0x2802b89e,
    0x5f058808,
    0xc60cd9b2,
    0xb10be924,
    0x2f6f7c87,
    0x58684c11,
    0xc1611dab,
    0xb6662d3d,
    0x76dc4190,
    0x01db7106,
    0x98d220bc,
    0xefd5102a,
    0x71b18589,
    0x06b6b51f,
    0x9fbfe4a5,
    0xe8b8d433,
    0x7807c9a2,
    0x0f00f934,
    0x9609a88e,
    0xe10e9818,
    0x7f6a0dbb,
    0x086d3d2d,
    0x91646c97,
    0xe6635c01,
    0x6b6b51f4,
    0x1c6c6162,
    0x856530d8,
    0xf262004e,
    0x6c0695ed,
    0x1b01a57b,
    0x8208f4c1,
    0xf50fc457,
    0x65b0d9c6,
    0x12b7e950,
    0x8bbeb8ea,
    0xfcb9887c,
    0x62dd1ddf,
    0x15da2d49,
    0x8cd37cf3,
    0xfbd44c65,
    0x4db26158,
    0x3ab551ce,
    0xa3bc0074,
    0xd4bb30e2,
    0x4adfa541,
    0x3dd895d7,
    0xa4d1c46d,
    0xd3d6f4fb,
    0x4369e96a,
    0x346ed9fc,
    0xad678846,
    0xda60b8d0,
    0x44042d73,
    0x33031de5,
    0xaa0a4c5f,
    0xdd0d7cc9,
    0x5005713c,
    0x270241aa,
    0xbe0b1010,
    0xc90c2086,
    0x5768b525,
    0x206f85b3,
    0xb966d409,
    0xce61e49f,
    0x5edef90e,
    0x29d9c998,
    0xb0d09822,
    0xc7d7a8b4,
    0x59b33d17,
    0x2eb40d81,
    0xb7bd5c3b,
    0xc0ba6cad,
    0xedb88320,
    0x9abfb3b6,
    0x03b6e20c,
    0x74b1d29a,
    0xead54739,
    0x9dd277af,
    0x04db2615,
    0x73dc1683,
    0xe3630b12,
    0x94643b84,
    0x0d6d6a3e,
    0x7a6a5aa8,
    0xe40ecf0b,
    0x9309ff9d,
    0x0a00ae27,
    0x7d079eb1,
    0xf00f9344,
    0x8708a3d2,
    0x1e01f268,
    0x6906c2fe,
    0xf762575d,
    0x806567cb,
    0x196c3671,
    0x6e6b06e7,
    0xfed41b76,
    0x89d32be0,
    0x10da7a5a,
    0x67dd4acc,
    0xf9b9df6f,
    0x8ebeeff9,
    0x17b7be43,
    0x60b08ed5,
    0xd6d6a3e8,
    0xa1d1937e,
    0x38d8c2c4,
    0x4fdff252,
    0xd1bb67f1,
    0xa6bc5767,
    0x3fb506dd,
    0x48b2364b,
    0xd80d2bda,
    0xaf0a1b4c,
    0x36034af6,
    0x41047a60,
    0xdf60efc3,
    0xa867df55,
    0x316e8eef,
    0x4669be79,
    0xcb61b38c,
    0xbc66831a,
    0x256fd2a0,
    0x5268e236,
    0xcc0c7795,
    0xbb0b4703,
    0x220216b9,
    0x5505262f,
    0xc5ba3bbe,
    0xb2bd0b28,
    0x2bb45a92,
    0x5cb36a04,
    0xc2d7ffa7,
    0xb5d0cf31,
    0x2cd99e8b,
    0x5bdeae1d,
    0x9b64c2b0,
    0xec63f226,
    0x756aa39c,
    0x026d930a,
    0x9c0906a9,
    0xeb0e363f,
    0x72076785,
    0x05005713,
    0x95bf4a82,
    0xe2b87a14,
    0x7bb12bae,
    0x0cb61b38,
    0x92d28e9b,
    0xe5d5be0d,
    0x7cdcefb7,
    0x0bdbdf21,
    0x86d3d2d4,
    0xf1d4e242,
    0x68ddb3f8,
    0x1fda836e,
    0x81be16cd,
    0xf6b9265b,
    0x6fb077e1,
    0x18b74777,
    0x88085ae6,
    0xff0f6a70,
    0x66063bca,
    0x11010b5c,
    0x8f659eff,
    0xf862ae69,
    0x616bffd3,
    0x166ccf45,
    0xa00ae278,
    0xd70dd2ee,
    0x4e048354,
    0x3903b3c2,
    0xa7672661,
    0xd06016f7,
    0x4969474d,
    0x3e6e77db,
    0xaed16a4a,
    0xd9d65adc,
    0x40df0b66,
    0x37d83bf0,
    0xa9bcae53,
    0xdebb9ec5,
    0x47b2cf7f,
    0x30b5ffe9,
    0xbdbdf21c,
    0xcabac28a,
    0x53b39330,
    0x24b4a3a6,
    0xbad03605,
    0xcdd70693,
    0x54de5729,
    0x23d967bf,
    0xb3667a2e,
    0xc4614ab8,
    0x5d681b02,
    0x2a6f2b94,
    0xb40bbe37,
    0xc30c8ea1,
    0x5a05df1b,
    0x2d02ef8d
];
if (typeof Int32Array !== "undefined") {
    CRC_TABLE = new Int32Array(CRC_TABLE);
}
function ensureBuffer(input) {
    if (Buffer.isBuffer(input)) {
        return input;
    }
    var hasNewBufferAPI = typeof Buffer.alloc === "function" && typeof Buffer.from === "function";
    if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer.alloc(input) : new Buffer(input);
    } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer.from(input) : new Buffer(input);
    } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
    }
}
function bufferizeInt(num) {
    var tmp = ensureBuffer(4);
    tmp.writeInt32BE(num, 0);
    return tmp;
}
function _crc32(buf, previous) {
    buf = ensureBuffer(buf);
    if (Buffer.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
    }
    var crc = ~~previous ^ -1;
    for(var n = 0; n < buf.length; n++){
        crc = CRC_TABLE[(crc ^ buf[n]) & 0xff] ^ crc >>> 8;
    }
    return crc ^ -1;
}
function crc32() {
    return bufferizeInt(_crc32.apply(null, arguments));
}
crc32.signed = function() {
    return _crc32.apply(null, arguments);
};
crc32.unsigned = function() {
    return _crc32.apply(null, arguments) >>> 0;
};
module.exports = crc32;


/***/ }),

/***/ 89622:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var initBuffer = __webpack_require__(41865);
if (!Buffer.prototype.indexOf) {
    Buffer.prototype.indexOf = function(value, offset) {
        offset = offset || 0;
        // Always wrap the input as a Buffer so that this method will support any
        // data type such as array octet, string or buffer.
        if (typeof value === "string" || value instanceof String) {
            value = initBuffer(value);
        } else if (typeof value === "number" || value instanceof Number) {
            value = initBuffer([
                value
            ]);
        }
        var len = value.length;
        for(var i = offset; i <= this.length - len; i++){
            var mismatch = false;
            for(var j = 0; j < len; j++){
                if (this[i + j] != value[j]) {
                    mismatch = true;
                    break;
                }
            }
            if (!mismatch) {
                return i;
            }
        }
        return -1;
    };
}
function bufferLastIndexOf(value, offset) {
    // Always wrap the input as a Buffer so that this method will support any
    // data type such as array octet, string or buffer.
    if (typeof value === "string" || value instanceof String) {
        value = initBuffer(value);
    } else if (typeof value === "number" || value instanceof Number) {
        value = initBuffer([
            value
        ]);
    }
    var len = value.length;
    offset = offset || this.length - len;
    for(var i = offset; i >= 0; i--){
        var mismatch = false;
        for(var j = 0; j < len; j++){
            if (this[i + j] != value[j]) {
                mismatch = true;
                break;
            }
        }
        if (!mismatch) {
            return i;
        }
    }
    return -1;
}
if (Buffer.prototype.lastIndexOf) {
    // check Buffer#lastIndexOf is usable: https://github.com/nodejs/node/issues/4604
    if (initBuffer("ABC").lastIndexOf("ABC") === -1) Buffer.prototype.lastIndexOf = bufferLastIndexOf;
} else {
    Buffer.prototype.lastIndexOf = bufferLastIndexOf;
}


/***/ }),

/***/ 41865:
/***/ ((module) => {

"use strict";

module.exports = function initBuffer(val) {
    // assume old version
    var nodeVersion = process && process.version ? process.version : "v5.0.0";
    var major = nodeVersion.split(".")[0].replace("v", "");
    return major < 6 ? new Buffer(val) : Buffer.from(val);
};


/***/ }),

/***/ 67406:
/***/ ((module) => {

"use strict";

module.exports = Buffers;
function Buffers(bufs) {
    if (!(this instanceof Buffers)) return new Buffers(bufs);
    this.buffers = bufs || [];
    this.length = this.buffers.reduce(function(size, buf) {
        return size + buf.length;
    }, 0);
}
Buffers.prototype.push = function() {
    for(var i = 0; i < arguments.length; i++){
        if (!Buffer.isBuffer(arguments[i])) {
            throw new TypeError("Tried to push a non-buffer");
        }
    }
    for(var i = 0; i < arguments.length; i++){
        var buf = arguments[i];
        this.buffers.push(buf);
        this.length += buf.length;
    }
    return this.length;
};
Buffers.prototype.unshift = function() {
    for(var i = 0; i < arguments.length; i++){
        if (!Buffer.isBuffer(arguments[i])) {
            throw new TypeError("Tried to unshift a non-buffer");
        }
    }
    for(var i = 0; i < arguments.length; i++){
        var buf = arguments[i];
        this.buffers.unshift(buf);
        this.length += buf.length;
    }
    return this.length;
};
Buffers.prototype.copy = function(dst, dStart, start, end) {
    return this.slice(start, end).copy(dst, dStart, 0, end - start);
};
Buffers.prototype.splice = function(i, howMany) {
    var buffers = this.buffers;
    var index = i >= 0 ? i : this.length - i;
    var reps = [].slice.call(arguments, 2);
    if (howMany === undefined) {
        howMany = this.length - index;
    } else if (howMany > this.length - index) {
        howMany = this.length - index;
    }
    for(var i = 0; i < reps.length; i++){
        this.length += reps[i].length;
    }
    var removed = new Buffers();
    var bytes = 0;
    var startBytes = 0;
    for(var ii = 0; ii < buffers.length && startBytes + buffers[ii].length < index; ii++){
        startBytes += buffers[ii].length;
    }
    if (index - startBytes > 0) {
        var start = index - startBytes;
        if (start + howMany < buffers[ii].length) {
            removed.push(buffers[ii].slice(start, start + howMany));
            var orig = buffers[ii];
            //var buf = new Buffer(orig.length - howMany);
            var buf0 = new Buffer(start);
            for(var i = 0; i < start; i++){
                buf0[i] = orig[i];
            }
            var buf1 = new Buffer(orig.length - start - howMany);
            for(var i = start + howMany; i < orig.length; i++){
                buf1[i - howMany - start] = orig[i];
            }
            if (reps.length > 0) {
                var reps_ = reps.slice();
                reps_.unshift(buf0);
                reps_.push(buf1);
                buffers.splice.apply(buffers, [
                    ii,
                    1
                ].concat(reps_));
                ii += reps_.length;
                reps = [];
            } else {
                buffers.splice(ii, 1, buf0, buf1);
                //buffers[ii] = buf;
                ii += 2;
            }
        } else {
            removed.push(buffers[ii].slice(start));
            buffers[ii] = buffers[ii].slice(0, start);
            ii++;
        }
    }
    if (reps.length > 0) {
        buffers.splice.apply(buffers, [
            ii,
            0
        ].concat(reps));
        ii += reps.length;
    }
    while(removed.length < howMany){
        var buf = buffers[ii];
        var len = buf.length;
        var take = Math.min(len, howMany - removed.length);
        if (take === len) {
            removed.push(buf);
            buffers.splice(ii, 1);
        } else {
            removed.push(buf.slice(0, take));
            buffers[ii] = buffers[ii].slice(take);
        }
    }
    this.length -= removed.length;
    return removed;
};
Buffers.prototype.slice = function(i, j) {
    var buffers = this.buffers;
    if (j === undefined) j = this.length;
    if (i === undefined) i = 0;
    if (j > this.length) j = this.length;
    var startBytes = 0;
    for(var si = 0; si < buffers.length && startBytes + buffers[si].length <= i; si++){
        startBytes += buffers[si].length;
    }
    var target = new Buffer(j - i);
    var ti = 0;
    for(var ii = si; ti < j - i && ii < buffers.length; ii++){
        var len = buffers[ii].length;
        var start = ti === 0 ? i - startBytes : 0;
        var end = ti + len >= j - i ? Math.min(start + (j - i) - ti, len) : len;
        buffers[ii].copy(target, ti, start, end);
        ti += end - start;
    }
    return target;
};
Buffers.prototype.pos = function(i) {
    if (i < 0 || i >= this.length) throw new Error("oob");
    var l = i, bi = 0, bu = null;
    for(;;){
        bu = this.buffers[bi];
        if (l < bu.length) {
            return {
                buf: bi,
                offset: l
            };
        } else {
            l -= bu.length;
        }
        bi++;
    }
};
Buffers.prototype.get = function get(i) {
    var pos = this.pos(i);
    return this.buffers[pos.buf].get(pos.offset);
};
Buffers.prototype.set = function set(i, b) {
    var pos = this.pos(i);
    return this.buffers[pos.buf].set(pos.offset, b);
};
Buffers.prototype.indexOf = function(needle, offset) {
    if ("string" === typeof needle) {
        needle = new Buffer(needle);
    } else if (needle instanceof Buffer) {
    // already a buffer
    } else {
        throw new Error("Invalid type for a search string");
    }
    if (!needle.length) {
        return 0;
    }
    if (!this.length) {
        return -1;
    }
    var i = 0, j = 0, match = 0, mstart, pos = 0;
    // start search from a particular point in the virtual buffer
    if (offset) {
        var p = this.pos(offset);
        i = p.buf;
        j = p.offset;
        pos = offset;
    }
    // for each character in virtual buffer
    for(;;){
        while(j >= this.buffers[i].length){
            j = 0;
            i++;
            if (i >= this.buffers.length) {
                // search string not found
                return -1;
            }
        }
        var char = this.buffers[i][j];
        if (char == needle[match]) {
            // keep track where match started
            if (match == 0) {
                mstart = {
                    i: i,
                    j: j,
                    pos: pos
                };
            }
            match++;
            if (match == needle.length) {
                // full match
                return mstart.pos;
            }
        } else if (match != 0) {
            // a partial match ended, go back to match starting position
            // this will continue the search at the next character
            i = mstart.i;
            j = mstart.j;
            pos = mstart.pos;
            match = 0;
        }
        j++;
        pos++;
    }
};
Buffers.prototype.toBuffer = function() {
    return this.slice();
};
Buffers.prototype.toString = function(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
};


/***/ }),

/***/ 55074:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Traverse = __webpack_require__(61695);
var EventEmitter = (__webpack_require__(82361).EventEmitter);
module.exports = Chainsaw;
function Chainsaw(builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== undefined) saw.handlers = r;
    saw.record();
    return saw.chain();
}
;
Chainsaw.light = function ChainsawLight(builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== undefined) saw.handlers = r;
    return saw.chain();
};
Chainsaw.saw = function(builder, handlers) {
    var saw = new EventEmitter;
    saw.handlers = handlers;
    saw.actions = [];
    saw.chain = function() {
        var ch = Traverse(saw.handlers).map(function(node) {
            if (this.isRoot) return node;
            var ps = this.path;
            if (typeof node === "function") {
                this.update(function() {
                    saw.actions.push({
                        path: ps,
                        args: [].slice.call(arguments)
                    });
                    return ch;
                });
            }
        });
        process.nextTick(function() {
            saw.emit("begin");
            saw.next();
        });
        return ch;
    };
    saw.pop = function() {
        return saw.actions.shift();
    };
    saw.next = function() {
        var action = saw.pop();
        if (!action) {
            saw.emit("end");
        } else if (!action.trap) {
            var node = saw.handlers;
            action.path.forEach(function(key) {
                node = node[key];
            });
            node.apply(saw.handlers, action.args);
        }
    };
    saw.nest = function(cb) {
        var args = [].slice.call(arguments, 1);
        var autonext = true;
        if (typeof cb === "boolean") {
            var autonext = cb;
            cb = args.shift();
        }
        var s = Chainsaw.saw(builder, {});
        var r = builder.call(s.handlers, s);
        if (r !== undefined) s.handlers = r;
        // If we are recording...
        if ("undefined" !== typeof saw.step) {
            // ... our children should, too
            s.record();
        }
        cb.apply(s.chain(), args);
        if (autonext !== false) s.on("end", saw.next);
    };
    saw.record = function() {
        upgradeChainsaw(saw);
    };
    [
        "trap",
        "down",
        "jump"
    ].forEach(function(method) {
        saw[method] = function() {
            throw new Error("To use the trap, down and jump features, please " + "call record() first to start recording actions.");
        };
    });
    return saw;
};
function upgradeChainsaw(saw) {
    saw.step = 0;
    // override pop
    saw.pop = function() {
        return saw.actions[saw.step++];
    };
    saw.trap = function(name, cb) {
        var ps = Array.isArray(name) ? name : [
            name
        ];
        saw.actions.push({
            path: ps,
            step: saw.step,
            cb: cb,
            trap: true
        });
    };
    saw.down = function(name) {
        var ps = (Array.isArray(name) ? name : [
            name
        ]).join("/");
        var i = saw.actions.slice(saw.step).map(function(x) {
            if (x.trap && x.step <= saw.step) return false;
            return x.path.join("/") == ps;
        }).indexOf(true);
        if (i >= 0) saw.step += i;
        else saw.step = saw.actions.length;
        var act = saw.actions[saw.step - 1];
        if (act && act.trap) {
            // It's a trap!
            saw.step = act.step;
            act.cb();
        } else saw.next();
    };
    saw.jump = function(step) {
        saw.step = step;
        saw.next();
    };
}
;


/***/ }),

/***/ 59108:
/***/ ((module) => {

"use strict";
/**
 * node-compress-commons
 *
 * Copyright (c) 2014 Chris Talkington, contributors.
 * Licensed under the MIT license.
 * https://github.com/archiverjs/node-compress-commons/blob/master/LICENSE-MIT
 */ 
var ArchiveEntry = module.exports = function() {};
ArchiveEntry.prototype.getName = function() {};
ArchiveEntry.prototype.getSize = function() {};
ArchiveEntry.prototype.getLastModifiedDate = function() {};
ArchiveEntry.prototype.isDirectory = function() {};


/***/ }),

/***/ 71131:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * node-compress-commons
 *
 * Copyright (c) 2014 Chris Talkington, contributors.
 * Licensed under the MIT license.
 * https://github.com/archiverjs/node-compress-commons/blob/master/LICENSE-MIT
 */ 
var inherits = (__webpack_require__(73837).inherits);
var Transform = (__webpack_require__(98323).Transform);
var ArchiveEntry = __webpack_require__(59108);
var util = __webpack_require__(21248);
var ArchiveOutputStream = module.exports = function(options) {
    if (!(this instanceof ArchiveOutputStream)) {
        return new ArchiveOutputStream(options);
    }
    Transform.call(this, options);
    this.offset = 0;
    this._archive = {
        finish: false,
        finished: false,
        processing: false
    };
};
inherits(ArchiveOutputStream, Transform);
ArchiveOutputStream.prototype._appendBuffer = function(zae, source, callback) {
// scaffold only
};
ArchiveOutputStream.prototype._appendStream = function(zae, source, callback) {
// scaffold only
};
ArchiveOutputStream.prototype._emitErrorCallback = function(err) {
    if (err) {
        this.emit("error", err);
    }
};
ArchiveOutputStream.prototype._finish = function(ae) {
// scaffold only
};
ArchiveOutputStream.prototype._normalizeEntry = function(ae) {
// scaffold only
};
ArchiveOutputStream.prototype._transform = function(chunk, encoding, callback) {
    callback(null, chunk);
};
ArchiveOutputStream.prototype.entry = function(ae, source, callback) {
    source = source || null;
    if (typeof callback !== "function") {
        callback = this._emitErrorCallback.bind(this);
    }
    if (!(ae instanceof ArchiveEntry)) {
        callback(new Error("not a valid instance of ArchiveEntry"));
        return;
    }
    if (this._archive.finish || this._archive.finished) {
        callback(new Error("unacceptable entry after finish"));
        return;
    }
    if (this._archive.processing) {
        callback(new Error("already processing an entry"));
        return;
    }
    this._archive.processing = true;
    this._normalizeEntry(ae);
    this._entry = ae;
    source = util.normalizeInputSource(source);
    if (Buffer.isBuffer(source)) {
        this._appendBuffer(ae, source, callback);
    } else if (util.isStream(source)) {
        this._appendStream(ae, source, callback);
    } else {
        this._archive.processing = false;
        callback(new Error("input source must be valid Stream or Buffer instance"));
        return;
    }
    return this;
};
ArchiveOutputStream.prototype.finish = function() {
    if (this._archive.processing) {
        this._archive.finish = true;
        return;
    }
    this._finish();
};
ArchiveOutputStream.prototype.getBytesWritten = function() {
    return this.offset;
};
ArchiveOutputStream.prototype.write = function(chunk, cb) {
    if (chunk) {
        this.offset += chunk.length;
    }
    return Transform.prototype.write.call(this, chunk, cb);
};


/***/ }),

/***/ 30111:
/***/ ((module) => {

"use strict";
/**
 * node-compress-commons
 *
 * Copyright (c) 2014 Chris Talkington, contributors.
 * Licensed under the MIT license.
 * https://github.com/archiverjs/node-compress-commons/blob/master/LICENSE-MIT
 */ 
module.exports = {
    WORD: 4,
    DWORD: 8,
    EMPTY: Buffer.alloc(0),
    SHORT: 2,
    SHORT_MASK: 0xffff,
    SHORT_SHIFT: 16,
    SHORT_ZERO: Buffer.from(Array(2)),
    LONG: 4,
    LONG_ZERO: Buffer.from(Array(4)),
    MIN_VERSION_INITIAL: 10,
    MIN_VERSION_DATA_DESCRIPTOR: 20,
    MIN_VERSION_ZIP64: 45,
    VERSION_MADEBY: 45,
    METHOD_STORED: 0,
    METHOD_DEFLATED: 8,
    PLATFORM_UNIX: 3,
    PLATFORM_FAT: 0,
    SIG_LFH: 0x04034b50,
    SIG_DD: 0x08074b50,
    SIG_CFH: 0x02014b50,
    SIG_EOCD: 0x06054b50,
    SIG_ZIP64_EOCD: 0x06064B50,
    SIG_ZIP64_EOCD_LOC: 0x07064B50,
    ZIP64_MAGIC_SHORT: 0xffff,
    ZIP64_MAGIC: 0xffffffff,
    ZIP64_EXTRA_ID: 0x0001,
    ZLIB_NO_COMPRESSION: 0,
    ZLIB_BEST_SPEED: 1,
    ZLIB_BEST_COMPRESSION: 9,
    ZLIB_DEFAULT_COMPRESSION: -1,
    MODE_MASK: 0xFFF,
    DEFAULT_FILE_MODE: 33188,
    DEFAULT_DIR_MODE: 16877,
    EXT_FILE_ATTR_DIR: 1106051088,
    EXT_FILE_ATTR_FILE: 2175008800,
    // Unix file types
    S_IFMT: 61440,
    S_IFIFO: 4096,
    S_IFCHR: 8192,
    S_IFDIR: 16384,
    S_IFBLK: 24576,
    S_IFREG: 32768,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    // DOS file type flags
    S_DOS_A: 32,
    S_DOS_D: 16,
    S_DOS_V: 8,
    S_DOS_S: 4,
    S_DOS_H: 2,
    S_DOS_R: 1 // 01 Read Only
};


/***/ }),

/***/ 94990:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * node-compress-commons
 *
 * Copyright (c) 2014 Chris Talkington, contributors.
 * Licensed under the MIT license.
 * https://github.com/archiverjs/node-compress-commons/blob/master/LICENSE-MIT
 */ 
var zipUtil = __webpack_require__(46183);
var DATA_DESCRIPTOR_FLAG = 1 << 3;
var ENCRYPTION_FLAG = 1 << 0;
var NUMBER_OF_SHANNON_FANO_TREES_FLAG = 1 << 2;
var SLIDING_DICTIONARY_SIZE_FLAG = 1 << 1;
var STRONG_ENCRYPTION_FLAG = 1 << 6;
var UFT8_NAMES_FLAG = 1 << 11;
var GeneralPurposeBit = module.exports = function() {
    if (!(this instanceof GeneralPurposeBit)) {
        return new GeneralPurposeBit();
    }
    this.descriptor = false;
    this.encryption = false;
    this.utf8 = false;
    this.numberOfShannonFanoTrees = 0;
    this.strongEncryption = false;
    this.slidingDictionarySize = 0;
    return this;
};
GeneralPurposeBit.prototype.encode = function() {
    return zipUtil.getShortBytes((this.descriptor ? DATA_DESCRIPTOR_FLAG : 0) | (this.utf8 ? UFT8_NAMES_FLAG : 0) | (this.encryption ? ENCRYPTION_FLAG : 0) | (this.strongEncryption ? STRONG_ENCRYPTION_FLAG : 0));
};
GeneralPurposeBit.prototype.parse = function(buf, offset) {
    var flag = zipUtil.getShortBytesValue(buf, offset);
    var gbp = new GeneralPurposeBit();
    gbp.useDataDescriptor((flag & DATA_DESCRIPTOR_FLAG) !== 0);
    gbp.useUTF8ForNames((flag & UFT8_NAMES_FLAG) !== 0);
    gbp.useStrongEncryption((flag & STRONG_ENCRYPTION_FLAG) !== 0);
    gbp.useEncryption((flag & ENCRYPTION_FLAG) !== 0);
    gbp.setSlidingDictionarySize((flag & SLIDING_DICTIONARY_SIZE_FLAG) !== 0 ? 8192 : 4096);
    gbp.setNumberOfShannonFanoTrees((flag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) !== 0 ? 3 : 2);
    return gbp;
};
GeneralPurposeBit.prototype.setNumberOfShannonFanoTrees = function(n) {
    this.numberOfShannonFanoTrees = n;
};
GeneralPurposeBit.prototype.getNumberOfShannonFanoTrees = function() {
    return this.numberOfShannonFanoTrees;
};
GeneralPurposeBit.prototype.setSlidingDictionarySize = function(n) {
    this.slidingDictionarySize = n;
};
GeneralPurposeBit.prototype.getSlidingDictionarySize = function() {
    return this.slidingDictionarySize;
};
GeneralPurposeBit.prototype.useDataDescriptor = function(b) {
    this.descriptor = b;
};
GeneralPurposeBit.prototype.usesDataDescriptor = function() {
    return this.descriptor;
};
GeneralPurposeBit.prototype.useEncryption = function(b) {
    this.encryption = b;
};
GeneralPurposeBit.prototype.usesEncryption = function() {
    return this.encryption;
};
GeneralPurposeBit.prototype.useStrongEncryption = function(b) {
    this.strongEncryption = b;
};
GeneralPurposeBit.prototype.usesStrongEncryption = function() {
    return this.strongEncryption;
};
GeneralPurposeBit.prototype.useUTF8ForNames = function(b) {
    this.utf8 = b;
};
GeneralPurposeBit.prototype.usesUTF8ForNames = function() {
    return this.utf8;
};


/***/ }),

/***/ 95528:
/***/ ((module) => {

"use strict";
/**
 * node-compress-commons
 *
 * Copyright (c) 2014 Chris Talkington, contributors.
 * Licensed under the MIT license.
 * https://github.com/archiverjs/node-compress-commons/blob/master/LICENSE-MIT
 */ 
module.exports = {
    /**
     * Bits used for permissions (and sticky bit)
     */ PERM_MASK: 4095,
    /**
     * Bits used to indicate the filesystem object type.
     */ FILE_TYPE_FLAG: 61440,
    /**
     * Indicates symbolic links.
     */ LINK_FLAG: 40960,
    /**
     * Indicates plain files.
     */ FILE_FLAG: 32768,
    /**
     * Indicates directories.
     */ DIR_FLAG: 16384,
    // ----------------------------------------------------------
    // somewhat arbitrary choices that are quite common for shared
    // installations
    // -----------------------------------------------------------
    /**
     * Default permissions for symbolic links.
     */ DEFAULT_LINK_PERM: 511,
    /**
     * Default permissions for directories.
     */ DEFAULT_DIR_PERM: 493,
    /**
     * Default permissions for plain files.
     */ DEFAULT_FILE_PERM: 420 // 0644
};


/***/ }),

/***/ 46183:
/***/ ((module) => {

"use strict";
/**
 * node-compress-commons
 *
 * Copyright (c) 2014 Chris Talkington, contributors.
 * Licensed under the MIT license.
 * https://github.com/archiverjs/node-compress-commons/blob/master/LICENSE-MIT
 */ 
var util = module.exports = {};
util.dateToDos = function(d, forceLocalTime) {
    forceLocalTime = forceLocalTime || false;
    var year = forceLocalTime ? d.getFullYear() : d.getUTCFullYear();
    if (year < 1980) {
        return 2162688; // 1980-1-1 00:00:00
    } else if (year >= 2044) {
        return 2141175677; // 2043-12-31 23:59:58
    }
    var val = {
        year: year,
        month: forceLocalTime ? d.getMonth() : d.getUTCMonth(),
        date: forceLocalTime ? d.getDate() : d.getUTCDate(),
        hours: forceLocalTime ? d.getHours() : d.getUTCHours(),
        minutes: forceLocalTime ? d.getMinutes() : d.getUTCMinutes(),
        seconds: forceLocalTime ? d.getSeconds() : d.getUTCSeconds()
    };
    return val.year - 1980 << 25 | val.month + 1 << 21 | val.date << 16 | val.hours << 11 | val.minutes << 5 | val.seconds / 2;
};
util.dosToDate = function(dos) {
    return new Date((dos >> 25 & 0x7f) + 1980, (dos >> 21 & 0x0f) - 1, dos >> 16 & 0x1f, dos >> 11 & 0x1f, dos >> 5 & 0x3f, (dos & 0x1f) << 1);
};
util.fromDosTime = function(buf) {
    return util.dosToDate(buf.readUInt32LE(0));
};
util.getEightBytes = function(v) {
    var buf = Buffer.alloc(8);
    buf.writeUInt32LE(v % 0x0100000000, 0);
    buf.writeUInt32LE(v / 0x0100000000 | 0, 4);
    return buf;
};
util.getShortBytes = function(v) {
    var buf = Buffer.alloc(2);
    buf.writeUInt16LE((v & 0xFFFF) >>> 0, 0);
    return buf;
};
util.getShortBytesValue = function(buf, offset) {
    return buf.readUInt16LE(offset);
};
util.getLongBytes = function(v) {
    var buf = Buffer.alloc(4);
    buf.writeUInt32LE((v & 0xFFFFFFFF) >>> 0, 0);
    return buf;
};
util.getLongBytesValue = function(buf, offset) {
    return buf.readUInt32LE(offset);
};
util.toDosTime = function(d) {
    return util.getLongBytes(util.dateToDos(d));
};


/***/ }),

/***/ 82454:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * node-compress-commons
 *
 * Copyright (c) 2014 Chris Talkington, contributors.
 * Licensed under the MIT license.
 * https://github.com/archiverjs/node-compress-commons/blob/master/LICENSE-MIT
 */ 
var inherits = (__webpack_require__(73837).inherits);
var normalizePath = __webpack_require__(26218);
var ArchiveEntry = __webpack_require__(59108);
var GeneralPurposeBit = __webpack_require__(94990);
var UnixStat = __webpack_require__(95528);
var constants = __webpack_require__(30111);
var zipUtil = __webpack_require__(46183);
var ZipArchiveEntry = module.exports = function(name) {
    if (!(this instanceof ZipArchiveEntry)) {
        return new ZipArchiveEntry(name);
    }
    ArchiveEntry.call(this);
    this.platform = constants.PLATFORM_FAT;
    this.method = -1;
    this.name = null;
    this.size = 0;
    this.csize = 0;
    this.gpb = new GeneralPurposeBit();
    this.crc = 0;
    this.time = -1;
    this.minver = constants.MIN_VERSION_INITIAL;
    this.mode = -1;
    this.extra = null;
    this.exattr = 0;
    this.inattr = 0;
    this.comment = null;
    if (name) {
        this.setName(name);
    }
};
inherits(ZipArchiveEntry, ArchiveEntry);
/**
 * Returns the extra fields related to the entry.
 *
 * @returns {Buffer}
 */ ZipArchiveEntry.prototype.getCentralDirectoryExtra = function() {
    return this.getExtra();
};
/**
 * Returns the comment set for the entry.
 *
 * @returns {string}
 */ ZipArchiveEntry.prototype.getComment = function() {
    return this.comment !== null ? this.comment : "";
};
/**
 * Returns the compressed size of the entry.
 *
 * @returns {number}
 */ ZipArchiveEntry.prototype.getCompressedSize = function() {
    return this.csize;
};
/**
 * Returns the CRC32 digest for the entry.
 *
 * @returns {number}
 */ ZipArchiveEntry.prototype.getCrc = function() {
    return this.crc;
};
/**
 * Returns the external file attributes for the entry.
 *
 * @returns {number}
 */ ZipArchiveEntry.prototype.getExternalAttributes = function() {
    return this.exattr;
};
/**
 * Returns the extra fields related to the entry.
 *
 * @returns {Buffer}
 */ ZipArchiveEntry.prototype.getExtra = function() {
    return this.extra !== null ? this.extra : constants.EMPTY;
};
/**
 * Returns the general purpose bits related to the entry.
 *
 * @returns {GeneralPurposeBit}
 */ ZipArchiveEntry.prototype.getGeneralPurposeBit = function() {
    return this.gpb;
};
/**
 * Returns the internal file attributes for the entry.
 *
 * @returns {number}
 */ ZipArchiveEntry.prototype.getInternalAttributes = function() {
    return this.inattr;
};
/**
 * Returns the last modified date of the entry.
 *
 * @returns {number}
 */ ZipArchiveEntry.prototype.getLastModifiedDate = function() {
    return this.getTime();
};
/**
 * Returns the extra fields related to the entry.
 *
 * @returns {Buffer}
 */ ZipArchiveEntry.prototype.getLocalFileDataExtra = function() {
    return this.getExtra();
};
/**
 * Returns the compression method used on the entry.
 *
 * @returns {number}
 */ ZipArchiveEntry.prototype.getMethod = function() {
    return this.method;
};
/**
 * Returns the filename of the entry.
 *
 * @returns {string}
 */ ZipArchiveEntry.prototype.getName = function() {
    return this.name;
};
/**
 * Returns the platform on which the entry was made.
 *
 * @returns {number}
 */ ZipArchiveEntry.prototype.getPlatform = function() {
    return this.platform;
};
/**
 * Returns the size of the entry.
 *
 * @returns {number}
 */ ZipArchiveEntry.prototype.getSize = function() {
    return this.size;
};
/**
 * Returns a date object representing the last modified date of the entry.
 *
 * @returns {number|Date}
 */ ZipArchiveEntry.prototype.getTime = function() {
    return this.time !== -1 ? zipUtil.dosToDate(this.time) : -1;
};
/**
 * Returns the DOS timestamp for the entry.
 *
 * @returns {number}
 */ ZipArchiveEntry.prototype.getTimeDos = function() {
    return this.time !== -1 ? this.time : 0;
};
/**
 * Returns the UNIX file permissions for the entry.
 *
 * @returns {number}
 */ ZipArchiveEntry.prototype.getUnixMode = function() {
    return this.platform !== constants.PLATFORM_UNIX ? 0 : this.getExternalAttributes() >> constants.SHORT_SHIFT & constants.SHORT_MASK;
};
/**
 * Returns the version of ZIP needed to extract the entry.
 *
 * @returns {number}
 */ ZipArchiveEntry.prototype.getVersionNeededToExtract = function() {
    return this.minver;
};
/**
 * Sets the comment of the entry.
 *
 * @param comment
 */ ZipArchiveEntry.prototype.setComment = function(comment) {
    if (Buffer.byteLength(comment) !== comment.length) {
        this.getGeneralPurposeBit().useUTF8ForNames(true);
    }
    this.comment = comment;
};
/**
 * Sets the compressed size of the entry.
 *
 * @param size
 */ ZipArchiveEntry.prototype.setCompressedSize = function(size) {
    if (size < 0) {
        throw new Error("invalid entry compressed size");
    }
    this.csize = size;
};
/**
 * Sets the checksum of the entry.
 *
 * @param crc
 */ ZipArchiveEntry.prototype.setCrc = function(crc) {
    if (crc < 0) {
        throw new Error("invalid entry crc32");
    }
    this.crc = crc;
};
/**
 * Sets the external file attributes of the entry.
 *
 * @param attr
 */ ZipArchiveEntry.prototype.setExternalAttributes = function(attr) {
    this.exattr = attr >>> 0;
};
/**
 * Sets the extra fields related to the entry.
 *
 * @param extra
 */ ZipArchiveEntry.prototype.setExtra = function(extra) {
    this.extra = extra;
};
/**
 * Sets the general purpose bits related to the entry.
 *
 * @param gpb
 */ ZipArchiveEntry.prototype.setGeneralPurposeBit = function(gpb) {
    if (!(gpb instanceof GeneralPurposeBit)) {
        throw new Error("invalid entry GeneralPurposeBit");
    }
    this.gpb = gpb;
};
/**
 * Sets the internal file attributes of the entry.
 *
 * @param attr
 */ ZipArchiveEntry.prototype.setInternalAttributes = function(attr) {
    this.inattr = attr;
};
/**
 * Sets the compression method of the entry.
 *
 * @param method
 */ ZipArchiveEntry.prototype.setMethod = function(method) {
    if (method < 0) {
        throw new Error("invalid entry compression method");
    }
    this.method = method;
};
/**
 * Sets the name of the entry.
 *
 * @param name
 * @param prependSlash
 */ ZipArchiveEntry.prototype.setName = function(name, prependSlash = false) {
    name = normalizePath(name, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
    if (prependSlash) {
        name = `/${name}`;
    }
    if (Buffer.byteLength(name) !== name.length) {
        this.getGeneralPurposeBit().useUTF8ForNames(true);
    }
    this.name = name;
};
/**
 * Sets the platform on which the entry was made.
 *
 * @param platform
 */ ZipArchiveEntry.prototype.setPlatform = function(platform) {
    this.platform = platform;
};
/**
 * Sets the size of the entry.
 *
 * @param size
 */ ZipArchiveEntry.prototype.setSize = function(size) {
    if (size < 0) {
        throw new Error("invalid entry size");
    }
    this.size = size;
};
/**
 * Sets the time of the entry.
 *
 * @param time
 * @param forceLocalTime
 */ ZipArchiveEntry.prototype.setTime = function(time, forceLocalTime) {
    if (!(time instanceof Date)) {
        throw new Error("invalid entry time");
    }
    this.time = zipUtil.dateToDos(time, forceLocalTime);
};
/**
 * Sets the UNIX file permissions for the entry.
 *
 * @param mode
 */ ZipArchiveEntry.prototype.setUnixMode = function(mode) {
    mode |= this.isDirectory() ? constants.S_IFDIR : constants.S_IFREG;
    var extattr = 0;
    extattr |= mode << constants.SHORT_SHIFT | (this.isDirectory() ? constants.S_DOS_D : constants.S_DOS_A);
    this.setExternalAttributes(extattr);
    this.mode = mode & constants.MODE_MASK;
    this.platform = constants.PLATFORM_UNIX;
};
/**
 * Sets the version of ZIP needed to extract this entry.
 *
 * @param minver
 */ ZipArchiveEntry.prototype.setVersionNeededToExtract = function(minver) {
    this.minver = minver;
};
/**
 * Returns true if this entry represents a directory.
 *
 * @returns {boolean}
 */ ZipArchiveEntry.prototype.isDirectory = function() {
    return this.getName().slice(-1) === "/";
};
/**
 * Returns true if this entry represents a unix symlink,
 * in which case the entry's content contains the target path
 * for the symlink.
 *
 * @returns {boolean}
 */ ZipArchiveEntry.prototype.isUnixSymlink = function() {
    return (this.getUnixMode() & UnixStat.FILE_TYPE_FLAG) === UnixStat.LINK_FLAG;
};
/**
 * Returns true if this entry is using the ZIP64 extension of ZIP.
 *
 * @returns {boolean}
 */ ZipArchiveEntry.prototype.isZip64 = function() {
    return this.csize > constants.ZIP64_MAGIC || this.size > constants.ZIP64_MAGIC;
};


/***/ }),

/***/ 16144:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * node-compress-commons
 *
 * Copyright (c) 2014 Chris Talkington, contributors.
 * Licensed under the MIT license.
 * https://github.com/archiverjs/node-compress-commons/blob/master/LICENSE-MIT
 */ 
var inherits = (__webpack_require__(73837).inherits);
var crc32 = __webpack_require__(78177);
var { CRC32Stream } = __webpack_require__(64492);
var { DeflateCRC32Stream } = __webpack_require__(64492);
var ArchiveOutputStream = __webpack_require__(71131);
var ZipArchiveEntry = __webpack_require__(82454);
var GeneralPurposeBit = __webpack_require__(94990);
var constants = __webpack_require__(30111);
var util = __webpack_require__(21248);
var zipUtil = __webpack_require__(46183);
var ZipArchiveOutputStream = module.exports = function(options) {
    if (!(this instanceof ZipArchiveOutputStream)) {
        return new ZipArchiveOutputStream(options);
    }
    options = this.options = this._defaults(options);
    ArchiveOutputStream.call(this, options);
    this._entry = null;
    this._entries = [];
    this._archive = {
        centralLength: 0,
        centralOffset: 0,
        comment: "",
        finish: false,
        finished: false,
        processing: false,
        forceZip64: options.forceZip64,
        forceLocalTime: options.forceLocalTime
    };
};
inherits(ZipArchiveOutputStream, ArchiveOutputStream);
ZipArchiveOutputStream.prototype._afterAppend = function(ae) {
    this._entries.push(ae);
    if (ae.getGeneralPurposeBit().usesDataDescriptor()) {
        this._writeDataDescriptor(ae);
    }
    this._archive.processing = false;
    this._entry = null;
    if (this._archive.finish && !this._archive.finished) {
        this._finish();
    }
};
ZipArchiveOutputStream.prototype._appendBuffer = function(ae, source, callback) {
    if (source.length === 0) {
        ae.setMethod(constants.METHOD_STORED);
    }
    var method = ae.getMethod();
    if (method === constants.METHOD_STORED) {
        ae.setSize(source.length);
        ae.setCompressedSize(source.length);
        ae.setCrc(crc32.unsigned(source));
    }
    this._writeLocalFileHeader(ae);
    if (method === constants.METHOD_STORED) {
        this.write(source);
        this._afterAppend(ae);
        callback(null, ae);
        return;
    } else if (method === constants.METHOD_DEFLATED) {
        this._smartStream(ae, callback).end(source);
        return;
    } else {
        callback(new Error("compression method " + method + " not implemented"));
        return;
    }
};
ZipArchiveOutputStream.prototype._appendStream = function(ae, source, callback) {
    ae.getGeneralPurposeBit().useDataDescriptor(true);
    ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
    this._writeLocalFileHeader(ae);
    var smart = this._smartStream(ae, callback);
    source.once("error", function(err) {
        smart.emit("error", err);
        smart.end();
    });
    source.pipe(smart);
};
ZipArchiveOutputStream.prototype._defaults = function(o) {
    if (typeof o !== "object") {
        o = {};
    }
    if (typeof o.zlib !== "object") {
        o.zlib = {};
    }
    if (typeof o.zlib.level !== "number") {
        o.zlib.level = constants.ZLIB_BEST_SPEED;
    }
    o.forceZip64 = !!o.forceZip64;
    o.forceLocalTime = !!o.forceLocalTime;
    return o;
};
ZipArchiveOutputStream.prototype._finish = function() {
    this._archive.centralOffset = this.offset;
    this._entries.forEach((function(ae) {
        this._writeCentralFileHeader(ae);
    }).bind(this));
    this._archive.centralLength = this.offset - this._archive.centralOffset;
    if (this.isZip64()) {
        this._writeCentralDirectoryZip64();
    }
    this._writeCentralDirectoryEnd();
    this._archive.processing = false;
    this._archive.finish = true;
    this._archive.finished = true;
    this.end();
};
ZipArchiveOutputStream.prototype._normalizeEntry = function(ae) {
    if (ae.getMethod() === -1) {
        ae.setMethod(constants.METHOD_DEFLATED);
    }
    if (ae.getMethod() === constants.METHOD_DEFLATED) {
        ae.getGeneralPurposeBit().useDataDescriptor(true);
        ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
    }
    if (ae.getTime() === -1) {
        ae.setTime(new Date(), this._archive.forceLocalTime);
    }
    ae._offsets = {
        file: 0,
        data: 0,
        contents: 0
    };
};
ZipArchiveOutputStream.prototype._smartStream = function(ae, callback) {
    var deflate = ae.getMethod() === constants.METHOD_DEFLATED;
    var process = deflate ? new DeflateCRC32Stream(this.options.zlib) : new CRC32Stream();
    var error = null;
    function handleStuff() {
        var digest = process.digest().readUInt32BE(0);
        ae.setCrc(digest);
        ae.setSize(process.size());
        ae.setCompressedSize(process.size(true));
        this._afterAppend(ae);
        callback(error, ae);
    }
    process.once("end", handleStuff.bind(this));
    process.once("error", function(err) {
        error = err;
    });
    process.pipe(this, {
        end: false
    });
    return process;
};
ZipArchiveOutputStream.prototype._writeCentralDirectoryEnd = function() {
    var records = this._entries.length;
    var size = this._archive.centralLength;
    var offset = this._archive.centralOffset;
    if (this.isZip64()) {
        records = constants.ZIP64_MAGIC_SHORT;
        size = constants.ZIP64_MAGIC;
        offset = constants.ZIP64_MAGIC;
    }
    // signature
    this.write(zipUtil.getLongBytes(constants.SIG_EOCD));
    // disk numbers
    this.write(constants.SHORT_ZERO);
    this.write(constants.SHORT_ZERO);
    // number of entries
    this.write(zipUtil.getShortBytes(records));
    this.write(zipUtil.getShortBytes(records));
    // length and location of CD
    this.write(zipUtil.getLongBytes(size));
    this.write(zipUtil.getLongBytes(offset));
    // archive comment
    var comment = this.getComment();
    var commentLength = Buffer.byteLength(comment);
    this.write(zipUtil.getShortBytes(commentLength));
    this.write(comment);
};
ZipArchiveOutputStream.prototype._writeCentralDirectoryZip64 = function() {
    // signature
    this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD));
    // size of the ZIP64 EOCD record
    this.write(zipUtil.getEightBytes(44));
    // version made by
    this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
    // version to extract
    this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
    // disk numbers
    this.write(constants.LONG_ZERO);
    this.write(constants.LONG_ZERO);
    // number of entries
    this.write(zipUtil.getEightBytes(this._entries.length));
    this.write(zipUtil.getEightBytes(this._entries.length));
    // length and location of CD
    this.write(zipUtil.getEightBytes(this._archive.centralLength));
    this.write(zipUtil.getEightBytes(this._archive.centralOffset));
    // extensible data sector
    // not implemented at this time
    // end of central directory locator
    this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD_LOC));
    // disk number holding the ZIP64 EOCD record
    this.write(constants.LONG_ZERO);
    // relative offset of the ZIP64 EOCD record
    this.write(zipUtil.getEightBytes(this._archive.centralOffset + this._archive.centralLength));
    // total number of disks
    this.write(zipUtil.getLongBytes(1));
};
ZipArchiveOutputStream.prototype._writeCentralFileHeader = function(ae) {
    var gpb = ae.getGeneralPurposeBit();
    var method = ae.getMethod();
    var offsets = ae._offsets;
    var size = ae.getSize();
    var compressedSize = ae.getCompressedSize();
    if (ae.isZip64() || offsets.file > constants.ZIP64_MAGIC) {
        size = constants.ZIP64_MAGIC;
        compressedSize = constants.ZIP64_MAGIC;
        ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
        var extraBuf = Buffer.concat([
            zipUtil.getShortBytes(constants.ZIP64_EXTRA_ID),
            zipUtil.getShortBytes(24),
            zipUtil.getEightBytes(ae.getSize()),
            zipUtil.getEightBytes(ae.getCompressedSize()),
            zipUtil.getEightBytes(offsets.file)
        ], 28);
        ae.setExtra(extraBuf);
    }
    // signature
    this.write(zipUtil.getLongBytes(constants.SIG_CFH));
    // version made by
    this.write(zipUtil.getShortBytes(ae.getPlatform() << 8 | constants.VERSION_MADEBY));
    // version to extract and general bit flag
    this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
    this.write(gpb.encode());
    // compression method
    this.write(zipUtil.getShortBytes(method));
    // datetime
    this.write(zipUtil.getLongBytes(ae.getTimeDos()));
    // crc32 checksum
    this.write(zipUtil.getLongBytes(ae.getCrc()));
    // sizes
    this.write(zipUtil.getLongBytes(compressedSize));
    this.write(zipUtil.getLongBytes(size));
    var name = ae.getName();
    var comment = ae.getComment();
    var extra = ae.getCentralDirectoryExtra();
    if (gpb.usesUTF8ForNames()) {
        name = Buffer.from(name);
        comment = Buffer.from(comment);
    }
    // name length
    this.write(zipUtil.getShortBytes(name.length));
    // extra length
    this.write(zipUtil.getShortBytes(extra.length));
    // comments length
    this.write(zipUtil.getShortBytes(comment.length));
    // disk number start
    this.write(constants.SHORT_ZERO);
    // internal attributes
    this.write(zipUtil.getShortBytes(ae.getInternalAttributes()));
    // external attributes
    this.write(zipUtil.getLongBytes(ae.getExternalAttributes()));
    // relative offset of LFH
    if (offsets.file > constants.ZIP64_MAGIC) {
        this.write(zipUtil.getLongBytes(constants.ZIP64_MAGIC));
    } else {
        this.write(zipUtil.getLongBytes(offsets.file));
    }
    // name
    this.write(name);
    // extra
    this.write(extra);
    // comment
    this.write(comment);
};
ZipArchiveOutputStream.prototype._writeDataDescriptor = function(ae) {
    // signature
    this.write(zipUtil.getLongBytes(constants.SIG_DD));
    // crc32 checksum
    this.write(zipUtil.getLongBytes(ae.getCrc()));
    // sizes
    if (ae.isZip64()) {
        this.write(zipUtil.getEightBytes(ae.getCompressedSize()));
        this.write(zipUtil.getEightBytes(ae.getSize()));
    } else {
        this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
        this.write(zipUtil.getLongBytes(ae.getSize()));
    }
};
ZipArchiveOutputStream.prototype._writeLocalFileHeader = function(ae) {
    var gpb = ae.getGeneralPurposeBit();
    var method = ae.getMethod();
    var name = ae.getName();
    var extra = ae.getLocalFileDataExtra();
    if (ae.isZip64()) {
        gpb.useDataDescriptor(true);
        ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
    }
    if (gpb.usesUTF8ForNames()) {
        name = Buffer.from(name);
    }
    ae._offsets.file = this.offset;
    // signature
    this.write(zipUtil.getLongBytes(constants.SIG_LFH));
    // version to extract and general bit flag
    this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
    this.write(gpb.encode());
    // compression method
    this.write(zipUtil.getShortBytes(method));
    // datetime
    this.write(zipUtil.getLongBytes(ae.getTimeDos()));
    ae._offsets.data = this.offset;
    // crc32 checksum and sizes
    if (gpb.usesDataDescriptor()) {
        this.write(constants.LONG_ZERO);
        this.write(constants.LONG_ZERO);
        this.write(constants.LONG_ZERO);
    } else {
        this.write(zipUtil.getLongBytes(ae.getCrc()));
        this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
        this.write(zipUtil.getLongBytes(ae.getSize()));
    }
    // name length
    this.write(zipUtil.getShortBytes(name.length));
    // extra length
    this.write(zipUtil.getShortBytes(extra.length));
    // name
    this.write(name);
    // extra
    this.write(extra);
    ae._offsets.contents = this.offset;
};
ZipArchiveOutputStream.prototype.getComment = function(comment) {
    return this._archive.comment !== null ? this._archive.comment : "";
};
ZipArchiveOutputStream.prototype.isZip64 = function() {
    return this._archive.forceZip64 || this._entries.length > constants.ZIP64_MAGIC_SHORT || this._archive.centralLength > constants.ZIP64_MAGIC || this._archive.centralOffset > constants.ZIP64_MAGIC;
};
ZipArchiveOutputStream.prototype.setComment = function(comment) {
    this._archive.comment = comment;
};


/***/ }),

/***/ 58700:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * node-compress-commons
 *
 * Copyright (c) 2014 Chris Talkington, contributors.
 * Licensed under the MIT license.
 * https://github.com/archiverjs/node-compress-commons/blob/master/LICENSE-MIT
 */ 
module.exports = {
    ArchiveEntry: __webpack_require__(59108),
    ZipArchiveEntry: __webpack_require__(82454),
    ArchiveOutputStream: __webpack_require__(71131),
    ZipArchiveOutputStream: __webpack_require__(16144)
};


/***/ }),

/***/ 21248:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * node-compress-commons
 *
 * Copyright (c) 2014 Chris Talkington, contributors.
 * Licensed under the MIT license.
 * https://github.com/archiverjs/node-compress-commons/blob/master/LICENSE-MIT
 */ 
var Stream = (__webpack_require__(12781).Stream);
var PassThrough = (__webpack_require__(98323).PassThrough);
var util = module.exports = {};
util.isStream = function(source) {
    return source instanceof Stream;
};
util.normalizeInputSource = function(source) {
    if (source === null) {
        return Buffer.alloc(0);
    } else if (typeof source === "string") {
        return Buffer.from(source);
    } else if (util.isStream(source) && !source._readableState) {
        var normalized = new PassThrough();
        source.pipe(normalized);
        return normalized;
    }
    return source;
};


/***/ }),

/***/ 23630:
/***/ ((module) => {

"use strict";

module.exports = function(xs, fn) {
    var res = [];
    for(var i = 0; i < xs.length; i++){
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};
var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
};


/***/ }),

/***/ 56303:
/***/ ((__unused_webpack_module, exports) => {

/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */ /* vim: set ts=2: */ /*exported CRC32 */ var CRC32;
(function(factory) {
    /*jshint ignore:start */ /*eslint-disable */ if (typeof DO_NOT_EXPORT_CRC === "undefined") {
        if (true) {
            factory(exports);
        } else {}
    } else {
        factory(CRC32 = {});
    }
/*eslint-enable */ /*jshint ignore:end */ })(function(CRC32) {
    CRC32.version = "1.2.2";
    /*global Int32Array */ function signed_crc_table() {
        var c = 0, table = new Array(256);
        for(var n = 0; n != 256; ++n){
            c = n;
            c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
            c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
            c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
            c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
            c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
            c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
            c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
            c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
            table[n] = c;
        }
        return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
    }
    var T0 = signed_crc_table();
    function slice_by_16_tables(T) {
        var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
        for(n = 0; n != 256; ++n)table[n] = T[n];
        for(n = 0; n != 256; ++n){
            v = T[n];
            for(c = 256 + n; c < 4096; c += 256)v = table[c] = v >>> 8 ^ T[v & 0xFF];
        }
        var out = [];
        for(n = 1; n != 16; ++n)out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
        return out;
    }
    var TT = slice_by_16_tables(T0);
    var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
    var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
    var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
    function crc32_bstr(bstr, seed) {
        var C = seed ^ -1;
        for(var i = 0, L = bstr.length; i < L;)C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 0xFF];
        return ~C;
    }
    function crc32_buf(B, seed) {
        var C = seed ^ -1, L = B.length - 15, i = 0;
        for(; i < L;)C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
        L += 15;
        while(i < L)C = C >>> 8 ^ T0[(C ^ B[i++]) & 0xFF];
        return ~C;
    }
    function crc32_str(str, seed) {
        var C = seed ^ -1;
        for(var i = 0, L = str.length, c = 0, d = 0; i < L;){
            c = str.charCodeAt(i++);
            if (c < 0x80) {
                C = C >>> 8 ^ T0[(C ^ c) & 0xFF];
            } else if (c < 0x800) {
                C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 0xFF];
                C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 0xFF];
            } else if (c >= 0xD800 && c < 0xE000) {
                c = (c & 1023) + 64;
                d = str.charCodeAt(i++) & 1023;
                C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 0xFF];
                C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 0xFF];
                C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 0xFF];
                C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 0xFF];
            } else {
                C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 0xFF];
                C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 0xFF];
                C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 0xFF];
            }
        }
        return ~C;
    }
    CRC32.table = T0;
    // $FlowIgnore
    CRC32.bstr = crc32_bstr;
    // $FlowIgnore
    CRC32.buf = crc32_buf;
    // $FlowIgnore
    CRC32.str = crc32_str;
});


/***/ }),

/***/ 42251:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * node-crc32-stream
 *
 * Copyright (c) 2014 Chris Talkington, contributors.
 * Licensed under the MIT license.
 * https://github.com/archiverjs/node-crc32-stream/blob/master/LICENSE-MIT
 */ 
const { Transform } = __webpack_require__(98323);
const crc32 = __webpack_require__(56303);
class CRC32Stream extends Transform {
    constructor(options){
        super(options);
        this.checksum = Buffer.allocUnsafe(4);
        this.checksum.writeInt32BE(0, 0);
        this.rawSize = 0;
    }
    _transform(chunk, encoding, callback) {
        if (chunk) {
            this.checksum = crc32.buf(chunk, this.checksum) >>> 0;
            this.rawSize += chunk.length;
        }
        callback(null, chunk);
    }
    digest(encoding) {
        const checksum = Buffer.allocUnsafe(4);
        checksum.writeUInt32BE(this.checksum >>> 0, 0);
        return encoding ? checksum.toString(encoding) : checksum;
    }
    hex() {
        return this.digest("hex").toUpperCase();
    }
    size() {
        return this.rawSize;
    }
}
module.exports = CRC32Stream;


/***/ }),

/***/ 53520:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * node-crc32-stream
 *
 * Copyright (c) 2014 Chris Talkington, contributors.
 * Licensed under the MIT license.
 * https://github.com/archiverjs/node-crc32-stream/blob/master/LICENSE-MIT
 */ 
const { DeflateRaw } = __webpack_require__(59796);
const crc32 = __webpack_require__(56303);
class DeflateCRC32Stream extends DeflateRaw {
    constructor(options){
        super(options);
        this.checksum = Buffer.allocUnsafe(4);
        this.checksum.writeInt32BE(0, 0);
        this.rawSize = 0;
        this.compressedSize = 0;
    }
    push(chunk, encoding) {
        if (chunk) {
            this.compressedSize += chunk.length;
        }
        return super.push(chunk, encoding);
    }
    _transform(chunk, encoding, callback) {
        if (chunk) {
            this.checksum = crc32.buf(chunk, this.checksum) >>> 0;
            this.rawSize += chunk.length;
        }
        super._transform(chunk, encoding, callback);
    }
    digest(encoding) {
        const checksum = Buffer.allocUnsafe(4);
        checksum.writeUInt32BE(this.checksum >>> 0, 0);
        return encoding ? checksum.toString(encoding) : checksum;
    }
    hex() {
        return this.digest("hex").toUpperCase();
    }
    size(compressed = false) {
        if (compressed) {
            return this.compressedSize;
        } else {
            return this.rawSize;
        }
    }
}
module.exports = DeflateCRC32Stream;


/***/ }),

/***/ 64492:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * node-crc32-stream
 *
 * Copyright (c) 2014 Chris Talkington, contributors.
 * Licensed under the MIT license.
 * https://github.com/archiverjs/node-crc32-stream/blob/master/LICENSE-MIT
 */ 
module.exports = {
    CRC32Stream: __webpack_require__(42251),
    DeflateCRC32Stream: __webpack_require__(53520)
};


/***/ }),

/***/ 81656:
/***/ ((module) => {

"use strict";

!function(t, e) {
     true ? module.exports = e() : 0;
}(void 0, function() {
    "use strict";
    var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = {
        name: "en",
        weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        ordinal: function(t) {
            var e = [
                "th",
                "st",
                "nd",
                "rd"
            ], n = t % 100;
            return "[" + t + (e[(n - 20) % 10] || e[n] || e[0]) + "]";
        }
    }, m = function(t, e, n) {
        var r = String(t);
        return !r || r.length >= e ? t : "" + Array(e + 1 - r.length).join(n) + t;
    }, v = {
        s: m,
        z: function(t) {
            var e = -t.utcOffset(), n = Math.abs(e), r = Math.floor(n / 60), i = n % 60;
            return (e <= 0 ? "+" : "-") + m(r, 2, "0") + ":" + m(i, 2, "0");
        },
        m: function t(e, n) {
            if (e.date() < n.date()) return -t(n, e);
            var r = 12 * (n.year() - e.year()) + (n.month() - e.month()), i = e.clone().add(r, c), s = n - i < 0, u = e.clone().add(r + (s ? -1 : 1), c);
            return +(-(r + (n - i) / (s ? i - u : u - i)) || 0);
        },
        a: function(t) {
            return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
        },
        p: function(t) {
            return ({
                M: c,
                y: h,
                w: o,
                d: a,
                D: d,
                h: u,
                m: s,
                s: i,
                ms: r,
                Q: f
            })[t] || String(t || "").toLowerCase().replace(/s$/, "");
        },
        u: function(t) {
            return void 0 === t;
        }
    }, g = "en", D = {};
    D[g] = M;
    var p = "$isDayjsObject", S = function(t) {
        return t instanceof _ || !(!t || !t[p]);
    }, w = function t(e, n, r) {
        var i;
        if (!e) return g;
        if ("string" == typeof e) {
            var s = e.toLowerCase();
            D[s] && (i = s), n && (D[s] = n, i = s);
            var u = e.split("-");
            if (!i && u.length > 1) return t(u[0]);
        } else {
            var a = e.name;
            D[a] = e, i = a;
        }
        return !r && i && (g = i), i || !r && g;
    }, O = function(t, e) {
        if (S(t)) return t.clone();
        var n = "object" == typeof e ? e : {};
        return n.date = t, n.args = arguments, new _(n);
    }, b = v;
    b.l = w, b.i = S, b.w = function(t, e) {
        return O(t, {
            locale: e.$L,
            utc: e.$u,
            x: e.$x,
            $offset: e.$offset
        });
    };
    var _ = function() {
        function M(t) {
            this.$L = w(t.locale, null, !0), this.parse(t), this.$x = this.$x || t.x || {}, this[p] = !0;
        }
        var m = M.prototype;
        return m.parse = function(t) {
            this.$d = function(t) {
                var e = t.date, n = t.utc;
                if (null === e) return new Date(NaN);
                if (b.u(e)) return new Date;
                if (e instanceof Date) return new Date(e);
                if ("string" == typeof e && !/Z$/i.test(e)) {
                    var r = e.match($);
                    if (r) {
                        var i = r[2] - 1 || 0, s = (r[7] || "0").substring(0, 3);
                        return n ? new Date(Date.UTC(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s)) : new Date(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s);
                    }
                }
                return new Date(e);
            }(t), this.init();
        }, m.init = function() {
            var t = this.$d;
            this.$y = t.getFullYear(), this.$M = t.getMonth(), this.$D = t.getDate(), this.$W = t.getDay(), this.$H = t.getHours(), this.$m = t.getMinutes(), this.$s = t.getSeconds(), this.$ms = t.getMilliseconds();
        }, m.$utils = function() {
            return b;
        }, m.isValid = function() {
            return !(this.$d.toString() === l);
        }, m.isSame = function(t, e) {
            var n = O(t);
            return this.startOf(e) <= n && n <= this.endOf(e);
        }, m.isAfter = function(t, e) {
            return O(t) < this.startOf(e);
        }, m.isBefore = function(t, e) {
            return this.endOf(e) < O(t);
        }, m.$g = function(t, e, n) {
            return b.u(t) ? this[e] : this.set(n, t);
        }, m.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
        }, m.valueOf = function() {
            return this.$d.getTime();
        }, m.startOf = function(t, e) {
            var n = this, r = !!b.u(e) || e, f = b.p(t), l = function(t, e) {
                var i = b.w(n.$u ? Date.UTC(n.$y, e, t) : new Date(n.$y, e, t), n);
                return r ? i : i.endOf(a);
            }, $ = function(t, e) {
                return b.w(n.toDate()[t].apply(n.toDate("s"), (r ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    23,
                    59,
                    59,
                    999
                ]).slice(e)), n);
            }, y = this.$W, M = this.$M, m = this.$D, v = "set" + (this.$u ? "UTC" : "");
            switch(f){
                case h:
                    return r ? l(1, 0) : l(31, 11);
                case c:
                    return r ? l(1, M) : l(0, M + 1);
                case o:
                    var g = this.$locale().weekStart || 0, D = (y < g ? y + 7 : y) - g;
                    return l(r ? m - D : m + (6 - D), M);
                case a:
                case d:
                    return $(v + "Hours", 0);
                case u:
                    return $(v + "Minutes", 1);
                case s:
                    return $(v + "Seconds", 2);
                case i:
                    return $(v + "Milliseconds", 3);
                default:
                    return this.clone();
            }
        }, m.endOf = function(t) {
            return this.startOf(t, !1);
        }, m.$set = function(t, e) {
            var n, o = b.p(t), f = "set" + (this.$u ? "UTC" : ""), l = (n = {}, n[a] = f + "Date", n[d] = f + "Date", n[c] = f + "Month", n[h] = f + "FullYear", n[u] = f + "Hours", n[s] = f + "Minutes", n[i] = f + "Seconds", n[r] = f + "Milliseconds", n)[o], $ = o === a ? this.$D + (e - this.$W) : e;
            if (o === c || o === h) {
                var y = this.clone().set(d, 1);
                y.$d[l]($), y.init(), this.$d = y.set(d, Math.min(this.$D, y.daysInMonth())).$d;
            } else l && this.$d[l]($);
            return this.init(), this;
        }, m.set = function(t, e) {
            return this.clone().$set(t, e);
        }, m.get = function(t) {
            return this[b.p(t)]();
        }, m.add = function(r, f) {
            var d, l = this;
            r = Number(r);
            var $ = b.p(f), y = function(t) {
                var e = O(l);
                return b.w(e.date(e.date() + Math.round(t * r)), l);
            };
            if ($ === c) return this.set(c, this.$M + r);
            if ($ === h) return this.set(h, this.$y + r);
            if ($ === a) return y(1);
            if ($ === o) return y(7);
            var M = (d = {}, d[s] = e, d[u] = n, d[i] = t, d)[$] || 1, m = this.$d.getTime() + r * M;
            return b.w(m, this);
        }, m.subtract = function(t, e) {
            return this.add(-1 * t, e);
        }, m.format = function(t) {
            var e = this, n = this.$locale();
            if (!this.isValid()) return n.invalidDate || l;
            var r = t || "YYYY-MM-DDTHH:mm:ssZ", i = b.z(this), s = this.$H, u = this.$m, a = this.$M, o = n.weekdays, c = n.months, f = n.meridiem, h = function(t, n, i, s) {
                return t && (t[n] || t(e, r)) || i[n].slice(0, s);
            }, d = function(t) {
                return b.s(s % 12 || 12, t, "0");
            }, $ = f || function(t, e, n) {
                var r = t < 12 ? "AM" : "PM";
                return n ? r.toLowerCase() : r;
            };
            return r.replace(y, function(t, r) {
                return r || function(t) {
                    switch(t){
                        case "YY":
                            return String(e.$y).slice(-2);
                        case "YYYY":
                            return b.s(e.$y, 4, "0");
                        case "M":
                            return a + 1;
                        case "MM":
                            return b.s(a + 1, 2, "0");
                        case "MMM":
                            return h(n.monthsShort, a, c, 3);
                        case "MMMM":
                            return h(c, a);
                        case "D":
                            return e.$D;
                        case "DD":
                            return b.s(e.$D, 2, "0");
                        case "d":
                            return String(e.$W);
                        case "dd":
                            return h(n.weekdaysMin, e.$W, o, 2);
                        case "ddd":
                            return h(n.weekdaysShort, e.$W, o, 3);
                        case "dddd":
                            return o[e.$W];
                        case "H":
                            return String(s);
                        case "HH":
                            return b.s(s, 2, "0");
                        case "h":
                            return d(1);
                        case "hh":
                            return d(2);
                        case "a":
                            return $(s, u, !0);
                        case "A":
                            return $(s, u, !1);
                        case "m":
                            return String(u);
                        case "mm":
                            return b.s(u, 2, "0");
                        case "s":
                            return String(e.$s);
                        case "ss":
                            return b.s(e.$s, 2, "0");
                        case "SSS":
                            return b.s(e.$ms, 3, "0");
                        case "Z":
                            return i;
                    }
                    return null;
                }(t) || i.replace(":", "");
            });
        }, m.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m.diff = function(r, d, l) {
            var $, y = this, M = b.p(d), m = O(r), v = (m.utcOffset() - this.utcOffset()) * e, g = this - m, D = function() {
                return b.m(y, m);
            };
            switch(M){
                case h:
                    $ = D() / 12;
                    break;
                case c:
                    $ = D();
                    break;
                case f:
                    $ = D() / 3;
                    break;
                case o:
                    $ = (g - v) / 6048e5;
                    break;
                case a:
                    $ = (g - v) / 864e5;
                    break;
                case u:
                    $ = g / n;
                    break;
                case s:
                    $ = g / e;
                    break;
                case i:
                    $ = g / t;
                    break;
                default:
                    $ = g;
            }
            return l ? $ : b.a($);
        }, m.daysInMonth = function() {
            return this.endOf(c).$D;
        }, m.$locale = function() {
            return D[this.$L];
        }, m.locale = function(t, e) {
            if (!t) return this.$L;
            var n = this.clone(), r = w(t, e, !0);
            return r && (n.$L = r), n;
        }, m.clone = function() {
            return b.w(this.$d, this);
        }, m.toDate = function() {
            return new Date(this.valueOf());
        }, m.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
        }, m.toISOString = function() {
            return this.$d.toISOString();
        }, m.toString = function() {
            return this.$d.toUTCString();
        }, M;
    }(), k = _.prototype;
    return O.prototype = k, [
        [
            "$ms",
            r
        ],
        [
            "$s",
            i
        ],
        [
            "$m",
            s
        ],
        [
            "$H",
            u
        ],
        [
            "$W",
            a
        ],
        [
            "$M",
            c
        ],
        [
            "$y",
            h
        ],
        [
            "$D",
            d
        ]
    ].forEach(function(t) {
        k[t[1]] = function(e) {
            return this.$g(e, t[0], t[1]);
        };
    }), O.extend = function(t, e) {
        return t.$i || (t(e, _, O), t.$i = !0), O;
    }, O.locale = w, O.isDayjs = S, O.unix = function(t) {
        return O(1e3 * t);
    }, O.en = D[g], O.Ls = D, O.p = {}, O;
});


/***/ }),

/***/ 59128:
/***/ ((module) => {

"use strict";

!function(e, t) {
     true ? module.exports = t() : 0;
}(void 0, function() {
    "use strict";
    var e = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
    }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d/, r = /\d\d/, i = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, s = {}, a = function(e) {
        return (e = +e) + (e > 68 ? 1900 : 2e3);
    };
    var f = function(e) {
        return function(t) {
            this[e] = +t;
        };
    }, h = [
        /[+-]\d\d:?(\d\d)?|Z/,
        function(e) {
            (this.zone || (this.zone = {})).offset = function(e) {
                if (!e) return 0;
                if ("Z" === e) return 0;
                var t = e.match(/([+-]|\d\d)/g), n = 60 * t[1] + (+t[2] || 0);
                return 0 === n ? 0 : "+" === t[0] ? -n : n;
            }(e);
        }
    ], u = function(e) {
        var t = s[e];
        return t && (t.indexOf ? t : t.s.concat(t.f));
    }, d = function(e, t) {
        var n, r = s.meridiem;
        if (r) {
            for(var i = 1; i <= 24; i += 1)if (e.indexOf(r(i, 0, t)) > -1) {
                n = i > 12;
                break;
            }
        } else n = e === (t ? "pm" : "PM");
        return n;
    }, c = {
        A: [
            o,
            function(e) {
                this.afternoon = d(e, !1);
            }
        ],
        a: [
            o,
            function(e) {
                this.afternoon = d(e, !0);
            }
        ],
        Q: [
            n,
            function(e) {
                this.month = 3 * (e - 1) + 1;
            }
        ],
        S: [
            n,
            function(e) {
                this.milliseconds = 100 * +e;
            }
        ],
        SS: [
            r,
            function(e) {
                this.milliseconds = 10 * +e;
            }
        ],
        SSS: [
            /\d{3}/,
            function(e) {
                this.milliseconds = +e;
            }
        ],
        s: [
            i,
            f("seconds")
        ],
        ss: [
            i,
            f("seconds")
        ],
        m: [
            i,
            f("minutes")
        ],
        mm: [
            i,
            f("minutes")
        ],
        H: [
            i,
            f("hours")
        ],
        h: [
            i,
            f("hours")
        ],
        HH: [
            i,
            f("hours")
        ],
        hh: [
            i,
            f("hours")
        ],
        D: [
            i,
            f("day")
        ],
        DD: [
            r,
            f("day")
        ],
        Do: [
            o,
            function(e) {
                var t = s.ordinal, n = e.match(/\d+/);
                if (this.day = n[0], t) for(var r = 1; r <= 31; r += 1)t(r).replace(/\[|\]/g, "") === e && (this.day = r);
            }
        ],
        w: [
            i,
            f("week")
        ],
        ww: [
            r,
            f("week")
        ],
        M: [
            i,
            f("month")
        ],
        MM: [
            r,
            f("month")
        ],
        MMM: [
            o,
            function(e) {
                var t = u("months"), n = (u("monthsShort") || t.map(function(e) {
                    return e.slice(0, 3);
                })).indexOf(e) + 1;
                if (n < 1) throw new Error;
                this.month = n % 12 || n;
            }
        ],
        MMMM: [
            o,
            function(e) {
                var t = u("months").indexOf(e) + 1;
                if (t < 1) throw new Error;
                this.month = t % 12 || t;
            }
        ],
        Y: [
            /[+-]?\d+/,
            f("year")
        ],
        YY: [
            r,
            function(e) {
                this.year = a(e);
            }
        ],
        YYYY: [
            /\d{4}/,
            f("year")
        ],
        Z: h,
        ZZ: h
    };
    function l(n) {
        var r, i;
        r = n, i = s && s.formats;
        for(var o = (n = r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t, n, r) {
            var o = r && r.toUpperCase();
            return n || i[r] || e[r] || i[o].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e, t, n) {
                return t || n.slice(1);
            });
        })).match(t), a = o.length, f = 0; f < a; f += 1){
            var h = o[f], u = c[h], d = u && u[0], l = u && u[1];
            o[f] = l ? {
                regex: d,
                parser: l
            } : h.replace(/^\[|\]$/g, "");
        }
        return function(e) {
            for(var t = {}, n = 0, r = 0; n < a; n += 1){
                var i = o[n];
                if ("string" == typeof i) r += i.length;
                else {
                    var s = i.regex, f = i.parser, h = e.slice(r), u = s.exec(h)[0];
                    f.call(t, u), e = e.replace(u, "");
                }
            }
            return function(e) {
                var t = e.afternoon;
                if (void 0 !== t) {
                    var n = e.hours;
                    t ? n < 12 && (e.hours += 12) : 12 === n && (e.hours = 0), delete e.afternoon;
                }
            }(t), t;
        };
    }
    return function(e, t, n) {
        n.p.customParseFormat = !0, e && e.parseTwoDigitYear && (a = e.parseTwoDigitYear);
        var r = t.prototype, i = r.parse;
        r.parse = function(e) {
            var t = e.date, r = e.utc, o = e.args;
            this.$u = r;
            var a = o[1];
            if ("string" == typeof a) {
                var f = !0 === o[2], h = !0 === o[3], u = f || h, d = o[2];
                h && (d = o[2]), s = this.$locale(), !f && d && (s = n.Ls[d]), this.$d = function(e, t, n, r) {
                    try {
                        if ([
                            "x",
                            "X"
                        ].indexOf(t) > -1) return new Date(("X" === t ? 1e3 : 1) * e);
                        var i = l(t)(e), o = i.year, s = i.month, a = i.day, f = i.hours, h = i.minutes, u = i.seconds, d = i.milliseconds, c = i.zone, m = i.week, M = new Date, Y = a || (o || s ? 1 : M.getDate()), p = o || M.getFullYear(), v = 0;
                        o && !s || (v = s > 0 ? s - 1 : M.getMonth());
                        var D, w = f || 0, g = h || 0, y = u || 0, L = d || 0;
                        return c ? new Date(Date.UTC(p, v, Y, w, g, y, L + 60 * c.offset * 1e3)) : n ? new Date(Date.UTC(p, v, Y, w, g, y, L)) : (D = new Date(p, v, Y, w, g, y, L), m && (D = r(D).week(m).toDate()), D);
                    } catch (e) {
                        return new Date("");
                    }
                }(t, a, r, n), this.init(), d && !0 !== d && (this.$L = this.locale(d).$L), u && t != this.format(a) && (this.$d = new Date("")), s = {};
            } else if (a instanceof Array) for(var c = a.length, m = 1; m <= c; m += 1){
                o[1] = a[m - 1];
                var M = n.apply(this, o);
                if (M.isValid()) {
                    this.$d = M.$d, this.$L = M.$L, this.init();
                    break;
                }
                m === c && (this.$d = new Date(""));
            }
            else i.call(this, e);
        };
    };
});


/***/ }),

/***/ 26865:
/***/ ((module) => {

"use strict";

!function(t, i) {
     true ? module.exports = i() : 0;
}(void 0, function() {
    "use strict";
    var t = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e = /([+-]|\d\d)/g;
    return function(s, f, n) {
        var u = f.prototype;
        n.utc = function(t) {
            var i = {
                date: t,
                utc: !0,
                args: arguments
            };
            return new f(i);
        }, u.utc = function(i) {
            var e = n(this.toDate(), {
                locale: this.$L,
                utc: !0
            });
            return i ? e.add(this.utcOffset(), t) : e;
        }, u.local = function() {
            return n(this.toDate(), {
                locale: this.$L,
                utc: !1
            });
        };
        var o = u.parse;
        u.parse = function(t) {
            t.utc && (this.$u = !0), this.$utils().u(t.$offset) || (this.$offset = t.$offset), o.call(this, t);
        };
        var r = u.init;
        u.init = function() {
            if (this.$u) {
                var t = this.$d;
                this.$y = t.getUTCFullYear(), this.$M = t.getUTCMonth(), this.$D = t.getUTCDate(), this.$W = t.getUTCDay(), this.$H = t.getUTCHours(), this.$m = t.getUTCMinutes(), this.$s = t.getUTCSeconds(), this.$ms = t.getUTCMilliseconds();
            } else r.call(this);
        };
        var a = u.utcOffset;
        u.utcOffset = function(s, f) {
            var n = this.$utils().u;
            if (n(s)) return this.$u ? 0 : n(this.$offset) ? a.call(this) : this.$offset;
            if ("string" == typeof s && (s = function(t) {
                void 0 === t && (t = "");
                var s = t.match(i);
                if (!s) return null;
                var f = ("" + s[0]).match(e) || [
                    "-",
                    0,
                    0
                ], n = f[0], u = 60 * +f[1] + +f[2];
                return 0 === u ? 0 : "+" === n ? u : -u;
            }(s), null === s)) return this;
            var u = Math.abs(s) <= 16 ? 60 * s : s, o = this;
            if (f) return o.$offset = u, o.$u = 0 === s, o;
            if (0 !== s) {
                var r = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
                (o = this.local().add(u + r, t)).$offset = u, o.$x.$localOffset = r;
            } else o = this.utc();
            return o;
        };
        var h = u.format;
        u.format = function(t) {
            var i = t || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
            return h.call(this, i);
        }, u.valueOf = function() {
            var t = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
            return this.$d.valueOf() - 6e4 * t;
        }, u.isUTC = function() {
            return !!this.$u;
        }, u.toISOString = function() {
            return this.toDate().toISOString();
        }, u.toString = function() {
            return this.toDate().toUTCString();
        };
        var l = u.toDate;
        u.toDate = function(t) {
            return "s" === t && this.$offset ? n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l.call(this);
        };
        var c = u.diff;
        u.diff = function(t, i, e) {
            if (t && this.$u === t.$u) return c.call(this, t, i, e);
            var s = this.local(), f = n(t).local();
            return c.call(s, f, i, e);
        };
    };
});


/***/ }),

/***/ 11652:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var stream = __webpack_require__(46116);
function DuplexWrapper(options, writable, readable) {
    if (typeof readable === "undefined") {
        readable = writable;
        writable = options;
        options = null;
    }
    stream.Duplex.call(this, options);
    if (typeof readable.read !== "function") {
        readable = new stream.Readable(options).wrap(readable);
    }
    this._writable = writable;
    this._readable = readable;
    this._waiting = false;
    var self = this;
    writable.once("finish", function() {
        self.end();
    });
    this.once("finish", function() {
        writable.end();
    });
    readable.on("readable", function() {
        if (self._waiting) {
            self._waiting = false;
            self._read();
        }
    });
    readable.once("end", function() {
        self.push(null);
    });
    if (!options || typeof options.bubbleErrors === "undefined" || options.bubbleErrors) {
        writable.on("error", function(err) {
            self.emit("error", err);
        });
        readable.on("error", function(err) {
            self.emit("error", err);
        });
    }
}
DuplexWrapper.prototype = Object.create(stream.Duplex.prototype, {
    constructor: {
        value: DuplexWrapper
    }
});
DuplexWrapper.prototype._write = function _write(input, encoding, done) {
    this._writable.write(input, encoding, done);
};
DuplexWrapper.prototype._read = function _read() {
    var buf;
    var reads = 0;
    while((buf = this._readable.read()) !== null){
        this.push(buf);
        reads++;
    }
    if (reads === 0) {
        this._waiting = true;
    }
};
module.exports = function duplex2(options, writable, readable) {
    return new DuplexWrapper(options, writable, readable);
};
module.exports.DuplexWrapper = DuplexWrapper;


/***/ }),

/***/ 68125:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/ var pna = __webpack_require__(11210);
/*</replacement>*/ /*<replacement>*/ var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for(var key in obj){
        keys.push(key);
    }
    return keys;
};
/*</replacement>*/ module.exports = Duplex;
/*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ var Readable = __webpack_require__(98828);
var Writable = __webpack_require__(6478);
util.inherits(Duplex, Readable);
{
    // avoid scope creep, the keys array can then be collected
    var keys = objectKeys(Writable.prototype);
    for(var v = 0; v < keys.length; v++){
        var method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
}function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
}
Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
        return this._writableState.highWaterMark;
    }
});
// the no-half-open enforcer
function onend() {
    // if we allow half-open state, or if the writable side ended,
    // then we're ok.
    if (this.allowHalfOpen || this._writableState.ended) return;
    // no more data can be written.
    // But allow more writes to happen in this tick.
    pna.nextTick(onEndNT, this);
}
function onEndNT(self) {
    self.end();
}
Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
        if (this._readableState === undefined || this._writableState === undefined) {
            return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});
Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
};


/***/ }),

/***/ 830:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;
var Transform = __webpack_require__(86255);
/*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ util.inherits(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};


/***/ }),

/***/ 98828:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/ var pna = __webpack_require__(11210);
/*</replacement>*/ module.exports = Readable;
/*<replacement>*/ var isArray = __webpack_require__(46405);
/*</replacement>*/ /*<replacement>*/ var Duplex;
/*</replacement>*/ Readable.ReadableState = ReadableState;
/*<replacement>*/ var EE = (__webpack_require__(82361).EventEmitter);
var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
};
/*</replacement>*/ /*<replacement>*/ var Stream = __webpack_require__(92894);
/*</replacement>*/ /*<replacement>*/ var Buffer = (__webpack_require__(12184).Buffer);
var OurUint8Array = (typeof global !== "undefined" ? global :  false ? 0 : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/ /*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ /*<replacement>*/ var debugUtil = __webpack_require__(73837);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
} else {
    debug = function() {};
}
/*</replacement>*/ var BufferList = __webpack_require__(36833);
var destroyImpl = __webpack_require__(91495);
var StringDecoder;
util.inherits(Readable, Stream);
var kProxyEvents = [
    "error",
    "close",
    "destroy",
    "pause",
    "resume"
];
function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [
        fn,
        emitter._events[event]
    ];
}
function ReadableState(options, stream) {
    Duplex = Duplex || __webpack_require__(68125);
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    var isDuplex = stream instanceof Duplex;
    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    // cast to ints.
    this.highWaterMark = Math.floor(this.highWaterMark);
    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true;
    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    // has it been destroyed
    this.destroyed = false;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;
    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!StringDecoder) StringDecoder = (__webpack_require__(81409)/* .StringDecoder */ .s);
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    Duplex = Duplex || __webpack_require__(68125);
    if (!(this instanceof Readable)) return new Readable(options);
    this._readableState = new ReadableState(options, this);
    // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
}
Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
        if (this._readableState === undefined) {
            return false;
        }
        return this._readableState.destroyed;
    },
    set: function(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
};
// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = "";
            }
            skipChunkCheck = true;
        }
    } else {
        skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};
// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
            stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
                if (state.endEmitted) stream.emit("error", new Error("stream.unshift() after end event"));
                else addChunk(stream, state, chunk, true);
            } else if (state.ended) {
                stream.emit("error", new Error("stream.push() after EOF"));
            } else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                    else maybeReadMore(stream, state);
                } else {
                    addChunk(stream, state, chunk, false);
                }
            }
        } else if (!addToFront) {
            state.reading = false;
        }
    }
    return needMoreData(state);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
    } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
}
// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
};
// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(81409)/* .StringDecoder */ .s);
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
};
// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
        n = MAX_HWM;
    } else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
}
// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false;
    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
    }
    n = howMuchToRead(n, state);
    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
    }
    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug("need readable", doRead);
    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
    }
    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
    } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = fromList(n, state);
    else ret = null;
    if (ret === null) {
        state.needReadable = true;
        n = 0;
    } else {
        state.length -= n;
    }
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;
        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
};
function onEofChunk(stream, state) {
    if (state.ended) return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    // emit 'readable' now to make sure it gets picked up.
    emitReadable(stream);
}
// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync) pna.nextTick(emitReadable_, stream);
        else emitReadable_(stream);
    }
}
function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
}
// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    var len = state.length;
    while(!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark){
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) break;
        else len = state.length;
    }
    state.readingMore = false;
}
// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch(state.pipesCount){
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [
                state.pipes,
                dest
            ];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) pna.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug("onend");
        dest.end();
    }
    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
        debug("cleanup");
        // cleanup event handlers once the pipe is broken
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    // If the user pushes more data while we're writing to dest then we'll end up
    // in ondata again. However, we only want to increase awaitDrain once because
    // dest will only emit one 'drain' event for the multiple writes.
    // => Introduce a guard on increasing awaitDrain.
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug("false write response, pause", state.awaitDrain);
                state.awaitDrain++;
                increasedAwaitDrain = true;
            }
            src.pause();
        }
    }
    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    // Make sure our error handler is attached before userland ones.
    prependListener(dest, "error", onerror);
    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
    }
    // tell the dest that it's being piped to
    dest.emit("pipe", src);
    // start the flow if it hasn't been started already.
    if (!state.flowing) {
        debug("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src) {
    return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    };
    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;
    // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
    }
    // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for(var i = 0; i < len; i++){
            dests[i].emit("unpipe", this, {
                hasUnpiped: false
            });
        }
        return this;
    }
    // try to find the right one.
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
        // Start flowing on next tick if stream isn't explicitly paused
        if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) {
                pna.nextTick(nReadingNextTick, this);
            } else if (state.length) {
                emitReadable(this);
            }
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self1) {
    debug("readable nexttick read 0");
    self1.read(0);
}
// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
    }
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
    }
}
function resume_(stream, state) {
    if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    return this;
};
function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while(state.flowing && stream.read() !== null){}
}
// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    });
    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for(var i in stream){
        if (this[i] === undefined && typeof stream[i] === "function") {
            this[i] = function(method) {
                return function() {
                    return stream[method].apply(stream, arguments);
                };
            }(i);
        }
    }
    // proxy certain important events.
    for(var n = 0; n < kProxyEvents.length; n++){
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};
Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
        return this._readableState.highWaterMark;
    }
});
// exposed for testing purposes only.
Readable._fromList = fromList;
// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.head.data;
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else {
        // read part of list
        ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
}
// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
        // slice is the same for buffers and strings
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
        // first chunk is a perfect match
        ret = list.shift();
    } else {
        // result spans more than one buffer
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
}
// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while(p = p.next){
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;
        else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
            if (nb === str.length) {
                ++c;
                if (p.next) list.head = p.next;
                else list.head = list.tail = null;
            } else {
                list.head = p;
                p.data = str.slice(nb);
            }
            break;
        }
        ++c;
    }
    list.length -= c;
    return ret;
}
// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
    var ret = Buffer.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while(p = p.next){
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
            if (nb === buf.length) {
                ++c;
                if (p.next) list.head = p.next;
                else list.head = list.tail = null;
            } else {
                list.head = p;
                p.data = buf.slice(nb);
            }
            break;
        }
        ++c;
    }
    list.length -= c;
    return ret;
}
function endReadable(stream) {
    var state = stream._readableState;
    // If we get here before consuming all the bytes, then that is a
    // bug in node.  Should never happen.
    if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
    }
}
function indexOf(xs, x) {
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}


/***/ }),

/***/ 86255:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;
var Duplex = __webpack_require__(68125);
/*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ util.inherits(Transform, Duplex);
function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
    }
}
function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
    };
    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;
    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;
    if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
    }
    // When the writable side finishes, then flush out anything remaining.
    this.on("prefinish", prefinish);
}
function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
        this._flush(function(er, data) {
            done(_this, er, data);
        });
    } else {
        done(this, null, null);
    }
}
Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
};
// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
};
Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
};
// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
    }
};
Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
    });
};
function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null) stream.push(data);
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream.push(null);
}


/***/ }),

/***/ 6478:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

/*<replacement>*/ var pna = __webpack_require__(11210);
/*</replacement>*/ module.exports = Writable;
/* <replacement> */ function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
}
// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
        onCorkedFinish(_this, state);
    };
}
/* </replacement> */ /*<replacement>*/ var asyncWrite =  true && [
    "v0.10",
    "v0.9."
].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/ /*<replacement>*/ var Duplex;
/*</replacement>*/ Writable.WritableState = WritableState;
/*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ /*<replacement>*/ var internalUtil = {
    deprecate: __webpack_require__(62337)
};
/*</replacement>*/ /*<replacement>*/ var Stream = __webpack_require__(92894);
/*</replacement>*/ /*<replacement>*/ var Buffer = (__webpack_require__(12184).Buffer);
var OurUint8Array = (typeof global !== "undefined" ? global :  false ? 0 : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/ var destroyImpl = __webpack_require__(91495);
util.inherits(Writable, Stream);
function nop() {}
function WritableState(options, stream) {
    Duplex = Duplex || __webpack_require__(68125);
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    var isDuplex = stream instanceof Duplex;
    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    // cast to ints.
    this.highWaterMark = Math.floor(this.highWaterMark);
    // if _final has been called
    this.finalCalled = false;
    // drain event flag.
    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;
    // has it been destroyed
    this.destroyed = false;
    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;
    // a flag to see when we're in the middle of a write.
    this.writing = false;
    // when true all writes will be buffered until .uncork() call
    this.corked = 0;
    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;
    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;
    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function(er) {
        onwrite(stream, er);
    };
    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;
    // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;
    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;
    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;
    // count buffered requests
    this.bufferedRequestCount = 0;
    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while(current){
        out.push(current);
        current = current.next;
    }
    return out;
};
(function() {
    try {
        Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function() {
                return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
        });
    } catch (_) {}
})();
// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
        }
    });
} else {
    realHasInstance = function(object) {
        return object instanceof this;
    };
}
function Writable(options) {
    Duplex = Duplex || __webpack_require__(68125);
    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
}
// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
};
function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    // TODO: defer error events consistently everywhere, not just the cb
    stream.emit("error", er);
    pna.nextTick(cb, er);
}
// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
        er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
    }
    return valid;
}
Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
};
Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!([
        "hex",
        "utf8",
        "utf-8",
        "ascii",
        "binary",
        "base64",
        "ucs2",
        "ucs-2",
        "utf16le",
        "utf-16le",
        "raw"
    ].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer.from(chunk, encoding);
    }
    return chunk;
}
Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
        return this._writableState.highWaterMark;
    }
});
// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) {
            last.next = state.lastBufferedRequest;
        } else {
            state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
    } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        pna.nextTick(cb, er);
        // this can emit finish, and it will always happen
        // after error
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
    } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        // this can emit finish, but finish must
        // always follow error
        finishMaybe(stream, state);
    }
}
function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
        }
        if (sync) {
            /*<replacement>*/ asyncWrite(afterWrite, stream, state, finished, cb);
        /*</replacement>*/ } else {
            afterWrite(stream, state, finished, cb);
        }
    }
}
function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
}
// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
    }
}
// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while(entry){
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        } else {
            state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
    } else {
        // Slow case, write chunks one-by-one
        while(entry){
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) {
                break;
            }
        }
        if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
    // .end() fully uncorks
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    // ignore unnecessary end() calls.
    if (!state.ending) endWritable(this, state, cb);
};
function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
    stream._final(function(err) {
        state.pendingcb--;
        if (err) {
            stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
    });
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
            state.pendingcb++;
            state.finalCalled = true;
            pna.nextTick(callFinal, stream, state);
        } else {
            state.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
        }
    }
    return need;
}
function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
        if (state.finished) pna.nextTick(cb);
        else stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while(entry){
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
    }
    // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
        if (this._writableState === undefined) {
            return false;
        }
        return this._writableState.destroyed;
    },
    set: function(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._writableState.destroyed = value;
    }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
};


/***/ }),

/***/ 36833:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
var Buffer = (__webpack_require__(12184).Buffer);
var util = __webpack_require__(73837);
function copyBuffer(src, target, offset) {
    src.copy(target, offset);
}
module.exports = function() {
    function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
        var entry = {
            data: v,
            next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
        var entry = {
            data: v,
            next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
    };
    BufferList.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
    };
    BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
    };
    BufferList.prototype.join = function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while(p = p.next){
            ret += s + p.data;
        }
        return ret;
    };
    BufferList.prototype.concat = function concat(n) {
        if (this.length === 0) return Buffer.alloc(0);
        var ret = Buffer.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while(p){
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
        }
        return ret;
    };
    return BufferList;
}();
if (util && util.inspect && util.inspect.custom) {
    module.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({
            length: this.length
        });
        return this.constructor.name + " " + obj;
    };
}


/***/ }),

/***/ 91495:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*<replacement>*/ var pna = __webpack_require__(11210);
/*</replacement>*/ // undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) {
            cb(err);
        } else if (err) {
            if (!this._writableState) {
                pna.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                pna.nextTick(emitErrorNT, this, err);
            }
        }
        return this;
    }
    // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) {
        this._readableState.destroyed = true;
    }
    // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) {
        this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err) {
        if (!cb && err) {
            if (!_this._writableState) {
                pna.nextTick(emitErrorNT, _this, err);
            } else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                pna.nextTick(emitErrorNT, _this, err);
            }
        } else if (cb) {
            cb(err);
        }
    });
    return this;
}
function undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function emitErrorNT(self, err) {
    self.emit("error", err);
}
module.exports = {
    destroy: destroy,
    undestroy: undestroy
};


/***/ }),

/***/ 92894:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(12781);


/***/ }),

/***/ 46116:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

var Stream = __webpack_require__(12781);
if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream;
    exports = module.exports = Stream.Readable;
    exports.Readable = Stream.Readable;
    exports.Writable = Stream.Writable;
    exports.Duplex = Stream.Duplex;
    exports.Transform = Stream.Transform;
    exports.PassThrough = Stream.PassThrough;
    exports.Stream = Stream;
} else {
    exports = module.exports = __webpack_require__(98828);
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = __webpack_require__(6478);
    exports.Duplex = __webpack_require__(68125);
    exports.Transform = __webpack_require__(86255);
    exports.PassThrough = __webpack_require__(830);
}


/***/ }),

/***/ 12184:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* eslint-disable node/no-deprecated-api */ 
var buffer = __webpack_require__(14300);
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src){
        dst[key] = src[key];
    }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
} else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
    }
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === "string") {
            buf.fill(fill, encoding);
        } else {
            buf.fill(fill);
        }
    } else {
        buf.fill(0);
    }
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
};


/***/ }),

/***/ 81409:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/ var Buffer = (__webpack_require__(12184).Buffer);
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch(encoding && encoding.toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while(true){
        switch(enc){
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return enc;
            default:
                if (retried) return; // undefined
                enc = ("" + enc).toLowerCase();
                retried = true;
        }
    }
}
;
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.s = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return "";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return "";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return "";
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "";
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}


/***/ }),

/***/ 39050:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * Copyright (c) 2014-2019 Guyon Roche
 * LICENCE: MIT - please refer to LICENSE file included with this module
 * or https://github.com/exceljs/exceljs/blob/master/LICENSE
 */ 
if (parseInt(process.versions.node.split(".")[0], 10) < 10) {
    throw new Error("For node versions older than 10, please use the ES5 Import: https://github.com/exceljs/exceljs#es5-imports");
}
module.exports = __webpack_require__(99685);


/***/ }),

/***/ 48437:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(57147);
const fastCsv = __webpack_require__(58029);
const customParseFormat = __webpack_require__(59128);
const utc = __webpack_require__(26865);
const dayjs = (__webpack_require__(81656).extend)(customParseFormat).extend(utc);
const StreamBuf = __webpack_require__(87273);
const { fs: { exists } } = __webpack_require__(90778);
/* eslint-disable quote-props */ const SpecialValues = {
    true: true,
    false: false,
    "#N/A": {
        error: "#N/A"
    },
    "#REF!": {
        error: "#REF!"
    },
    "#NAME?": {
        error: "#NAME?"
    },
    "#DIV/0!": {
        error: "#DIV/0!"
    },
    "#NULL!": {
        error: "#NULL!"
    },
    "#VALUE!": {
        error: "#VALUE!"
    },
    "#NUM!": {
        error: "#NUM!"
    }
};
/* eslint-ensable quote-props */ class CSV {
    constructor(workbook){
        this.workbook = workbook;
        this.worksheet = null;
    }
    async readFile(filename, options) {
        options = options || {};
        if (!await exists(filename)) {
            throw new Error(`File not found: ${filename}`);
        }
        const stream = fs.createReadStream(filename);
        const worksheet = await this.read(stream, options);
        stream.close();
        return worksheet;
    }
    read(stream, options) {
        options = options || {};
        return new Promise((resolve, reject)=>{
            const worksheet = this.workbook.addWorksheet(options.sheetName);
            const dateFormats = options.dateFormats || [
                "YYYY-MM-DD[T]HH:mm:ssZ",
                "YYYY-MM-DD[T]HH:mm:ss",
                "MM-DD-YYYY",
                "YYYY-MM-DD"
            ];
            const map = options.map || function(datum) {
                if (datum === "") {
                    return null;
                }
                const datumNumber = Number(datum);
                if (!Number.isNaN(datumNumber) && datumNumber !== Infinity) {
                    return datumNumber;
                }
                const dt = dateFormats.reduce((matchingDate, currentDateFormat)=>{
                    if (matchingDate) {
                        return matchingDate;
                    }
                    const dayjsObj = dayjs(datum, currentDateFormat, true);
                    if (dayjsObj.isValid()) {
                        return dayjsObj;
                    }
                    return null;
                }, null);
                if (dt) {
                    return new Date(dt.valueOf());
                }
                const special = SpecialValues[datum];
                if (special !== undefined) {
                    return special;
                }
                return datum;
            };
            const csvStream = fastCsv.parse(options.parserOptions).on("data", (data)=>{
                worksheet.addRow(data.map(map));
            }).on("end", ()=>{
                csvStream.emit("worksheet", worksheet);
            });
            csvStream.on("worksheet", resolve).on("error", reject);
            stream.pipe(csvStream);
        });
    }
    /**
   * @deprecated since version 4.0. You should use `CSV#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md
   */ createInputStream() {
        throw new Error("`CSV#createInputStream` is deprecated. You should use `CSV#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md");
    }
    write(stream, options) {
        return new Promise((resolve, reject)=>{
            options = options || {};
            // const encoding = options.encoding || 'utf8';
            // const separator = options.separator || ',';
            // const quoteChar = options.quoteChar || '\'';
            const worksheet = this.workbook.getWorksheet(options.sheetName || options.sheetId);
            const csvStream = fastCsv.format(options.formatterOptions);
            stream.on("finish", ()=>{
                resolve();
            });
            csvStream.on("error", reject);
            csvStream.pipe(stream);
            const { dateFormat, dateUTC } = options;
            const map = options.map || ((value)=>{
                if (value) {
                    if (value.text || value.hyperlink) {
                        return value.hyperlink || value.text || "";
                    }
                    if (value.formula || value.result) {
                        return value.result || "";
                    }
                    if (value instanceof Date) {
                        if (dateFormat) {
                            return dateUTC ? dayjs.utc(value).format(dateFormat) : dayjs(value).format(dateFormat);
                        }
                        return dateUTC ? dayjs.utc(value).format() : dayjs(value).format();
                    }
                    if (value.error) {
                        return value.error;
                    }
                    if (typeof value === "object") {
                        return JSON.stringify(value);
                    }
                }
                return value;
            });
            const includeEmptyRows = options.includeEmptyRows === undefined || options.includeEmptyRows;
            let lastRow = 1;
            if (worksheet) {
                worksheet.eachRow((row, rowNumber)=>{
                    if (includeEmptyRows) {
                        while(lastRow++ < rowNumber - 1){
                            csvStream.write([]);
                        }
                    }
                    const { values } = row;
                    values.shift();
                    csvStream.write(values.map(map));
                    lastRow = rowNumber;
                });
            }
            csvStream.end();
        });
    }
    writeFile(filename, options) {
        options = options || {};
        const streamOptions = {
            encoding: options.encoding || "utf8"
        };
        const stream = fs.createWriteStream(filename, streamOptions);
        return this.write(stream, options);
    }
    async writeBuffer(options) {
        const stream = new StreamBuf();
        await this.write(stream, options);
        return stream.read();
    }
}
module.exports = CSV;


/***/ }),

/***/ 28761:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const colCache = __webpack_require__(90609);
class Anchor {
    constructor(worksheet, address, offset = 0){
        this.worksheet = worksheet;
        if (!address) {
            this.nativeCol = 0;
            this.nativeColOff = 0;
            this.nativeRow = 0;
            this.nativeRowOff = 0;
        } else if (typeof address === "string") {
            const decoded = colCache.decodeAddress(address);
            this.nativeCol = decoded.col + offset;
            this.nativeColOff = 0;
            this.nativeRow = decoded.row + offset;
            this.nativeRowOff = 0;
        } else if (address.nativeCol !== undefined) {
            this.nativeCol = address.nativeCol || 0;
            this.nativeColOff = address.nativeColOff || 0;
            this.nativeRow = address.nativeRow || 0;
            this.nativeRowOff = address.nativeRowOff || 0;
        } else if (address.col !== undefined) {
            this.col = address.col + offset;
            this.row = address.row + offset;
        } else {
            this.nativeCol = 0;
            this.nativeColOff = 0;
            this.nativeRow = 0;
            this.nativeRowOff = 0;
        }
    }
    static asInstance(model) {
        return model instanceof Anchor || model == null ? model : new Anchor(model);
    }
    get col() {
        return this.nativeCol + Math.min(this.colWidth - 1, this.nativeColOff) / this.colWidth;
    }
    set col(v) {
        this.nativeCol = Math.floor(v);
        this.nativeColOff = Math.floor((v - this.nativeCol) * this.colWidth);
    }
    get row() {
        return this.nativeRow + Math.min(this.rowHeight - 1, this.nativeRowOff) / this.rowHeight;
    }
    set row(v) {
        this.nativeRow = Math.floor(v);
        this.nativeRowOff = Math.floor((v - this.nativeRow) * this.rowHeight);
    }
    get colWidth() {
        return this.worksheet && this.worksheet.getColumn(this.nativeCol + 1) && this.worksheet.getColumn(this.nativeCol + 1).isCustomWidth ? Math.floor(this.worksheet.getColumn(this.nativeCol + 1).width * 10000) : 640000;
    }
    get rowHeight() {
        return this.worksheet && this.worksheet.getRow(this.nativeRow + 1) && this.worksheet.getRow(this.nativeRow + 1).height ? Math.floor(this.worksheet.getRow(this.nativeRow + 1).height * 10000) : 180000;
    }
    get model() {
        return {
            nativeCol: this.nativeCol,
            nativeColOff: this.nativeColOff,
            nativeRow: this.nativeRow,
            nativeRowOff: this.nativeRowOff
        };
    }
    set model(value) {
        this.nativeCol = value.nativeCol;
        this.nativeColOff = value.nativeColOff;
        this.nativeRow = value.nativeRow;
        this.nativeRowOff = value.nativeRowOff;
    }
}
module.exports = Anchor;


/***/ }),

/***/ 24529:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable max-classes-per-file */ 
const colCache = __webpack_require__(90609);
const _ = __webpack_require__(96910);
const Enums = __webpack_require__(48688);
const { slideFormula } = __webpack_require__(69939);
const Note = __webpack_require__(92183);
// Cell requirements
//  Operate inside a worksheet
//  Store and retrieve a value with a range of types: text, number, date, hyperlink, reference, formula, etc.
//  Manage/use and manipulate cell format either as local to cell or inherited from column or row.
class Cell {
    constructor(row, column, address){
        if (!row || !column) {
            throw new Error("A Cell needs a Row");
        }
        this._row = row;
        this._column = column;
        colCache.validateAddress(address);
        this._address = address;
        // TODO: lazy evaluation of this._value
        this._value = Value.create(Cell.Types.Null, this);
        this.style = this._mergeStyle(row.style, column.style, {});
        this._mergeCount = 0;
    }
    get worksheet() {
        return this._row.worksheet;
    }
    get workbook() {
        return this._row.worksheet.workbook;
    }
    // help GC by removing cyclic (and other) references
    destroy() {
        delete this.style;
        delete this._value;
        delete this._row;
        delete this._column;
        delete this._address;
    }
    // =========================================================================
    // Styles stuff
    get numFmt() {
        return this.style.numFmt;
    }
    set numFmt(value) {
        this.style.numFmt = value;
    }
    get font() {
        return this.style.font;
    }
    set font(value) {
        this.style.font = value;
    }
    get alignment() {
        return this.style.alignment;
    }
    set alignment(value) {
        this.style.alignment = value;
    }
    get border() {
        return this.style.border;
    }
    set border(value) {
        this.style.border = value;
    }
    get fill() {
        return this.style.fill;
    }
    set fill(value) {
        this.style.fill = value;
    }
    get protection() {
        return this.style.protection;
    }
    set protection(value) {
        this.style.protection = value;
    }
    _mergeStyle(rowStyle, colStyle, style) {
        const numFmt = rowStyle && rowStyle.numFmt || colStyle && colStyle.numFmt;
        if (numFmt) style.numFmt = numFmt;
        const font = rowStyle && rowStyle.font || colStyle && colStyle.font;
        if (font) style.font = font;
        const alignment = rowStyle && rowStyle.alignment || colStyle && colStyle.alignment;
        if (alignment) style.alignment = alignment;
        const border = rowStyle && rowStyle.border || colStyle && colStyle.border;
        if (border) style.border = border;
        const fill = rowStyle && rowStyle.fill || colStyle && colStyle.fill;
        if (fill) style.fill = fill;
        const protection = rowStyle && rowStyle.protection || colStyle && colStyle.protection;
        if (protection) style.protection = protection;
        return style;
    }
    // =========================================================================
    // return the address for this cell
    get address() {
        return this._address;
    }
    get row() {
        return this._row.number;
    }
    get col() {
        return this._column.number;
    }
    get $col$row() {
        return `$${this._column.letter}$${this.row}`;
    }
    // =========================================================================
    // Value stuff
    get type() {
        return this._value.type;
    }
    get effectiveType() {
        return this._value.effectiveType;
    }
    toCsvString() {
        return this._value.toCsvString();
    }
    // =========================================================================
    // Merge stuff
    addMergeRef() {
        this._mergeCount++;
    }
    releaseMergeRef() {
        this._mergeCount--;
    }
    get isMerged() {
        return this._mergeCount > 0 || this.type === Cell.Types.Merge;
    }
    merge(master, ignoreStyle) {
        this._value.release();
        this._value = Value.create(Cell.Types.Merge, this, master);
        if (!ignoreStyle) {
            this.style = master.style;
        }
    }
    unmerge() {
        if (this.type === Cell.Types.Merge) {
            this._value.release();
            this._value = Value.create(Cell.Types.Null, this);
            this.style = this._mergeStyle(this._row.style, this._column.style, {});
        }
    }
    isMergedTo(master) {
        if (this._value.type !== Cell.Types.Merge) return false;
        return this._value.isMergedTo(master);
    }
    get master() {
        if (this.type === Cell.Types.Merge) {
            return this._value.master;
        }
        return this; // an unmerged cell is its own master
    }
    get isHyperlink() {
        return this._value.type === Cell.Types.Hyperlink;
    }
    get hyperlink() {
        return this._value.hyperlink;
    }
    // return the value
    get value() {
        return this._value.value;
    }
    // set the value - can be number, string or raw
    set value(v) {
        // special case - merge cells set their master's value
        if (this.type === Cell.Types.Merge) {
            this._value.master.value = v;
            return;
        }
        this._value.release();
        // assign value
        this._value = Value.create(Value.getType(v), this, v);
    }
    get note() {
        return this._comment && this._comment.note;
    }
    set note(note) {
        this._comment = new Note(note);
    }
    get text() {
        return this._value.toString();
    }
    get html() {
        return _.escapeHtml(this.text);
    }
    toString() {
        return this.text;
    }
    _upgradeToHyperlink(hyperlink) {
        // if this cell is a string, turn it into a Hyperlink
        if (this.type === Cell.Types.String) {
            this._value = Value.create(Cell.Types.Hyperlink, this, {
                text: this._value.value,
                hyperlink
            });
        }
    }
    // =========================================================================
    // Formula stuff
    get formula() {
        return this._value.formula;
    }
    get result() {
        return this._value.result;
    }
    get formulaType() {
        return this._value.formulaType;
    }
    // =========================================================================
    // Name stuff
    get fullAddress() {
        const { worksheet } = this._row;
        return {
            sheetName: worksheet.name,
            address: this.address,
            row: this.row,
            col: this.col
        };
    }
    get name() {
        return this.names[0];
    }
    set name(value) {
        this.names = [
            value
        ];
    }
    get names() {
        return this.workbook.definedNames.getNamesEx(this.fullAddress);
    }
    set names(value) {
        const { definedNames } = this.workbook;
        definedNames.removeAllNames(this.fullAddress);
        value.forEach((name)=>{
            definedNames.addEx(this.fullAddress, name);
        });
    }
    addName(name) {
        this.workbook.definedNames.addEx(this.fullAddress, name);
    }
    removeName(name) {
        this.workbook.definedNames.removeEx(this.fullAddress, name);
    }
    removeAllNames() {
        this.workbook.definedNames.removeAllNames(this.fullAddress);
    }
    // =========================================================================
    // Data Validation stuff
    get _dataValidations() {
        return this.worksheet.dataValidations;
    }
    get dataValidation() {
        return this._dataValidations.find(this.address);
    }
    set dataValidation(value) {
        this._dataValidations.add(this.address, value);
    }
    // =========================================================================
    // Model stuff
    get model() {
        const { model } = this._value;
        model.style = this.style;
        if (this._comment) {
            model.comment = this._comment.model;
        }
        return model;
    }
    set model(value) {
        this._value.release();
        this._value = Value.create(value.type, this);
        this._value.model = value;
        if (value.comment) {
            switch(value.comment.type){
                case "note":
                    this._comment = Note.fromModel(value.comment);
                    break;
            }
        }
        if (value.style) {
            this.style = value.style;
        } else {
            this.style = {};
        }
    }
}
Cell.Types = Enums.ValueType;
// =============================================================================
// Internal Value Types
class NullValue {
    constructor(cell){
        this.model = {
            address: cell.address,
            type: Cell.Types.Null
        };
    }
    get value() {
        return null;
    }
    set value(value) {
    // nothing to do
    }
    get type() {
        return Cell.Types.Null;
    }
    get effectiveType() {
        return Cell.Types.Null;
    }
    get address() {
        return this.model.address;
    }
    set address(value) {
        this.model.address = value;
    }
    toCsvString() {
        return "";
    }
    release() {}
    toString() {
        return "";
    }
}
class NumberValue {
    constructor(cell, value){
        this.model = {
            address: cell.address,
            type: Cell.Types.Number,
            value
        };
    }
    get value() {
        return this.model.value;
    }
    set value(value) {
        this.model.value = value;
    }
    get type() {
        return Cell.Types.Number;
    }
    get effectiveType() {
        return Cell.Types.Number;
    }
    get address() {
        return this.model.address;
    }
    set address(value) {
        this.model.address = value;
    }
    toCsvString() {
        return this.model.value.toString();
    }
    release() {}
    toString() {
        return this.model.value.toString();
    }
}
class StringValue {
    constructor(cell, value){
        this.model = {
            address: cell.address,
            type: Cell.Types.String,
            value
        };
    }
    get value() {
        return this.model.value;
    }
    set value(value) {
        this.model.value = value;
    }
    get type() {
        return Cell.Types.String;
    }
    get effectiveType() {
        return Cell.Types.String;
    }
    get address() {
        return this.model.address;
    }
    set address(value) {
        this.model.address = value;
    }
    toCsvString() {
        return `"${this.model.value.replace(/"/g, '""')}"`;
    }
    release() {}
    toString() {
        return this.model.value;
    }
}
class RichTextValue {
    constructor(cell, value){
        this.model = {
            address: cell.address,
            type: Cell.Types.String,
            value
        };
    }
    get value() {
        return this.model.value;
    }
    set value(value) {
        this.model.value = value;
    }
    toString() {
        return this.model.value.richText.map((t)=>t.text).join("");
    }
    get type() {
        return Cell.Types.RichText;
    }
    get effectiveType() {
        return Cell.Types.RichText;
    }
    get address() {
        return this.model.address;
    }
    set address(value) {
        this.model.address = value;
    }
    toCsvString() {
        return `"${this.text.replace(/"/g, '""')}"`;
    }
    release() {}
}
class DateValue {
    constructor(cell, value){
        this.model = {
            address: cell.address,
            type: Cell.Types.Date,
            value
        };
    }
    get value() {
        return this.model.value;
    }
    set value(value) {
        this.model.value = value;
    }
    get type() {
        return Cell.Types.Date;
    }
    get effectiveType() {
        return Cell.Types.Date;
    }
    get address() {
        return this.model.address;
    }
    set address(value) {
        this.model.address = value;
    }
    toCsvString() {
        return this.model.value.toISOString();
    }
    release() {}
    toString() {
        return this.model.value.toString();
    }
}
class HyperlinkValue {
    constructor(cell, value){
        this.model = {
            address: cell.address,
            type: Cell.Types.Hyperlink,
            text: value ? value.text : undefined,
            hyperlink: value ? value.hyperlink : undefined
        };
        if (value && value.tooltip) {
            this.model.tooltip = value.tooltip;
        }
    }
    get value() {
        const v = {
            text: this.model.text,
            hyperlink: this.model.hyperlink
        };
        if (this.model.tooltip) {
            v.tooltip = this.model.tooltip;
        }
        return v;
    }
    set value(value) {
        this.model = {
            text: value.text,
            hyperlink: value.hyperlink
        };
        if (value.tooltip) {
            this.model.tooltip = value.tooltip;
        }
    }
    get text() {
        return this.model.text;
    }
    set text(value) {
        this.model.text = value;
    }
    /*
  get tooltip() {
    return this.model.tooltip;
  }

  set tooltip(value) {
    this.model.tooltip = value;
  } */ get hyperlink() {
        return this.model.hyperlink;
    }
    set hyperlink(value) {
        this.model.hyperlink = value;
    }
    get type() {
        return Cell.Types.Hyperlink;
    }
    get effectiveType() {
        return Cell.Types.Hyperlink;
    }
    get address() {
        return this.model.address;
    }
    set address(value) {
        this.model.address = value;
    }
    toCsvString() {
        return this.model.hyperlink;
    }
    release() {}
    toString() {
        return this.model.text;
    }
}
class MergeValue {
    constructor(cell, master){
        this.model = {
            address: cell.address,
            type: Cell.Types.Merge,
            master: master ? master.address : undefined
        };
        this._master = master;
        if (master) {
            master.addMergeRef();
        }
    }
    get value() {
        return this._master.value;
    }
    set value(value) {
        if (value instanceof Cell) {
            if (this._master) {
                this._master.releaseMergeRef();
            }
            value.addMergeRef();
            this._master = value;
        } else {
            this._master.value = value;
        }
    }
    isMergedTo(master) {
        return master === this._master;
    }
    get master() {
        return this._master;
    }
    get type() {
        return Cell.Types.Merge;
    }
    get effectiveType() {
        return this._master.effectiveType;
    }
    get address() {
        return this.model.address;
    }
    set address(value) {
        this.model.address = value;
    }
    toCsvString() {
        return "";
    }
    release() {
        this._master.releaseMergeRef();
    }
    toString() {
        return this.value.toString();
    }
}
class FormulaValue {
    constructor(cell, value){
        this.cell = cell;
        this.model = {
            address: cell.address,
            type: Cell.Types.Formula,
            shareType: value ? value.shareType : undefined,
            ref: value ? value.ref : undefined,
            formula: value ? value.formula : undefined,
            sharedFormula: value ? value.sharedFormula : undefined,
            result: value ? value.result : undefined
        };
    }
    _copyModel(model) {
        const copy = {};
        const cp = (name)=>{
            const value = model[name];
            if (value) {
                copy[name] = value;
            }
        };
        cp("formula");
        cp("result");
        cp("ref");
        cp("shareType");
        cp("sharedFormula");
        return copy;
    }
    get value() {
        return this._copyModel(this.model);
    }
    set value(value) {
        this.model = this._copyModel(value);
    }
    validate(value) {
        switch(Value.getType(value)){
            case Cell.Types.Null:
            case Cell.Types.String:
            case Cell.Types.Number:
            case Cell.Types.Date:
                break;
            case Cell.Types.Hyperlink:
            case Cell.Types.Formula:
            default:
                throw new Error("Cannot process that type of result value");
        }
    }
    get dependencies() {
        // find all the ranges and cells mentioned in the formula
        const ranges = this.formula.match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g);
        const cells = this.formula.replace(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g, "").match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}/g);
        return {
            ranges,
            cells
        };
    }
    get formula() {
        return this.model.formula || this._getTranslatedFormula();
    }
    set formula(value) {
        this.model.formula = value;
    }
    get formulaType() {
        if (this.model.formula) {
            return Enums.FormulaType.Master;
        }
        if (this.model.sharedFormula) {
            return Enums.FormulaType.Shared;
        }
        return Enums.FormulaType.None;
    }
    get result() {
        return this.model.result;
    }
    set result(value) {
        this.model.result = value;
    }
    get type() {
        return Cell.Types.Formula;
    }
    get effectiveType() {
        const v = this.model.result;
        if (v === null || v === undefined) {
            return Enums.ValueType.Null;
        }
        if (v instanceof String || typeof v === "string") {
            return Enums.ValueType.String;
        }
        if (typeof v === "number") {
            return Enums.ValueType.Number;
        }
        if (v instanceof Date) {
            return Enums.ValueType.Date;
        }
        if (v.text && v.hyperlink) {
            return Enums.ValueType.Hyperlink;
        }
        if (v.formula) {
            return Enums.ValueType.Formula;
        }
        return Enums.ValueType.Null;
    }
    get address() {
        return this.model.address;
    }
    set address(value) {
        this.model.address = value;
    }
    _getTranslatedFormula() {
        if (!this._translatedFormula && this.model.sharedFormula) {
            const { worksheet } = this.cell;
            const master = worksheet.findCell(this.model.sharedFormula);
            this._translatedFormula = master && slideFormula(master.formula, master.address, this.model.address);
        }
        return this._translatedFormula;
    }
    toCsvString() {
        return `${this.model.result || ""}`;
    }
    release() {}
    toString() {
        return this.model.result ? this.model.result.toString() : "";
    }
}
class SharedStringValue {
    constructor(cell, value){
        this.model = {
            address: cell.address,
            type: Cell.Types.SharedString,
            value
        };
    }
    get value() {
        return this.model.value;
    }
    set value(value) {
        this.model.value = value;
    }
    get type() {
        return Cell.Types.SharedString;
    }
    get effectiveType() {
        return Cell.Types.SharedString;
    }
    get address() {
        return this.model.address;
    }
    set address(value) {
        this.model.address = value;
    }
    toCsvString() {
        return this.model.value.toString();
    }
    release() {}
    toString() {
        return this.model.value.toString();
    }
}
class BooleanValue {
    constructor(cell, value){
        this.model = {
            address: cell.address,
            type: Cell.Types.Boolean,
            value
        };
    }
    get value() {
        return this.model.value;
    }
    set value(value) {
        this.model.value = value;
    }
    get type() {
        return Cell.Types.Boolean;
    }
    get effectiveType() {
        return Cell.Types.Boolean;
    }
    get address() {
        return this.model.address;
    }
    set address(value) {
        this.model.address = value;
    }
    toCsvString() {
        return this.model.value ? 1 : 0;
    }
    release() {}
    toString() {
        return this.model.value.toString();
    }
}
class ErrorValue {
    constructor(cell, value){
        this.model = {
            address: cell.address,
            type: Cell.Types.Error,
            value
        };
    }
    get value() {
        return this.model.value;
    }
    set value(value) {
        this.model.value = value;
    }
    get type() {
        return Cell.Types.Error;
    }
    get effectiveType() {
        return Cell.Types.Error;
    }
    get address() {
        return this.model.address;
    }
    set address(value) {
        this.model.address = value;
    }
    toCsvString() {
        return this.toString();
    }
    release() {}
    toString() {
        return this.model.value.error.toString();
    }
}
class JSONValue {
    constructor(cell, value){
        this.model = {
            address: cell.address,
            type: Cell.Types.String,
            value: JSON.stringify(value),
            rawValue: value
        };
    }
    get value() {
        return this.model.rawValue;
    }
    set value(value) {
        this.model.rawValue = value;
        this.model.value = JSON.stringify(value);
    }
    get type() {
        return Cell.Types.String;
    }
    get effectiveType() {
        return Cell.Types.String;
    }
    get address() {
        return this.model.address;
    }
    set address(value) {
        this.model.address = value;
    }
    toCsvString() {
        return this.model.value;
    }
    release() {}
    toString() {
        return this.model.value;
    }
}
// Value is a place to hold common static Value type functions
const Value = {
    getType (value) {
        if (value === null || value === undefined) {
            return Cell.Types.Null;
        }
        if (value instanceof String || typeof value === "string") {
            return Cell.Types.String;
        }
        if (typeof value === "number") {
            return Cell.Types.Number;
        }
        if (typeof value === "boolean") {
            return Cell.Types.Boolean;
        }
        if (value instanceof Date) {
            return Cell.Types.Date;
        }
        if (value.text && value.hyperlink) {
            return Cell.Types.Hyperlink;
        }
        if (value.formula || value.sharedFormula) {
            return Cell.Types.Formula;
        }
        if (value.richText) {
            return Cell.Types.RichText;
        }
        if (value.sharedString) {
            return Cell.Types.SharedString;
        }
        if (value.error) {
            return Cell.Types.Error;
        }
        return Cell.Types.JSON;
    },
    // map valueType to constructor
    types: [
        {
            t: Cell.Types.Null,
            f: NullValue
        },
        {
            t: Cell.Types.Number,
            f: NumberValue
        },
        {
            t: Cell.Types.String,
            f: StringValue
        },
        {
            t: Cell.Types.Date,
            f: DateValue
        },
        {
            t: Cell.Types.Hyperlink,
            f: HyperlinkValue
        },
        {
            t: Cell.Types.Formula,
            f: FormulaValue
        },
        {
            t: Cell.Types.Merge,
            f: MergeValue
        },
        {
            t: Cell.Types.JSON,
            f: JSONValue
        },
        {
            t: Cell.Types.SharedString,
            f: SharedStringValue
        },
        {
            t: Cell.Types.RichText,
            f: RichTextValue
        },
        {
            t: Cell.Types.Boolean,
            f: BooleanValue
        },
        {
            t: Cell.Types.Error,
            f: ErrorValue
        }
    ].reduce((p, t)=>{
        p[t.t] = t.f;
        return p;
    }, []),
    create (type, cell, value) {
        const T = this.types[type];
        if (!T) {
            throw new Error(`Could not create Value of type ${type}`);
        }
        return new T(cell, value);
    }
};
module.exports = Cell;


/***/ }),

/***/ 72192:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
const Enums = __webpack_require__(48688);
const colCache = __webpack_require__(90609);
const DEFAULT_COLUMN_WIDTH = 9;
// Column defines the column properties for 1 column.
// This includes header rows, widths, key, (style), etc.
// Worksheet will condense the columns as appropriate during serialization
class Column {
    constructor(worksheet, number, defn){
        this._worksheet = worksheet;
        this._number = number;
        if (defn !== false) {
            // sometimes defn will follow
            this.defn = defn;
        }
    }
    get number() {
        return this._number;
    }
    get worksheet() {
        return this._worksheet;
    }
    get letter() {
        return colCache.n2l(this._number);
    }
    get isCustomWidth() {
        return this.width !== undefined && this.width !== DEFAULT_COLUMN_WIDTH;
    }
    get defn() {
        return {
            header: this._header,
            key: this.key,
            width: this.width,
            style: this.style,
            hidden: this.hidden,
            outlineLevel: this.outlineLevel
        };
    }
    set defn(value) {
        if (value) {
            this.key = value.key;
            this.width = value.width !== undefined ? value.width : DEFAULT_COLUMN_WIDTH;
            this.outlineLevel = value.outlineLevel;
            if (value.style) {
                this.style = value.style;
            } else {
                this.style = {};
            }
            // headers must be set after style
            this.header = value.header;
            this._hidden = !!value.hidden;
        } else {
            delete this._header;
            delete this._key;
            delete this.width;
            this.style = {};
            this.outlineLevel = 0;
        }
    }
    get headers() {
        return this._header && this._header instanceof Array ? this._header : [
            this._header
        ];
    }
    get header() {
        return this._header;
    }
    set header(value) {
        if (value !== undefined) {
            this._header = value;
            this.headers.forEach((text, index)=>{
                this._worksheet.getCell(index + 1, this.number).value = text;
            });
        } else {
            this._header = undefined;
        }
    }
    get key() {
        return this._key;
    }
    set key(value) {
        const column = this._key && this._worksheet.getColumnKey(this._key);
        if (column === this) {
            this._worksheet.deleteColumnKey(this._key);
        }
        this._key = value;
        if (value) {
            this._worksheet.setColumnKey(this._key, this);
        }
    }
    get hidden() {
        return !!this._hidden;
    }
    set hidden(value) {
        this._hidden = value;
    }
    get outlineLevel() {
        return this._outlineLevel || 0;
    }
    set outlineLevel(value) {
        this._outlineLevel = value;
    }
    get collapsed() {
        return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelCol);
    }
    toString() {
        return JSON.stringify({
            key: this.key,
            width: this.width,
            headers: this.headers.length ? this.headers : undefined
        });
    }
    equivalentTo(other) {
        return this.width === other.width && this.hidden === other.hidden && this.outlineLevel === other.outlineLevel && _.isEqual(this.style, other.style);
    }
    get isDefault() {
        if (this.isCustomWidth) {
            return false;
        }
        if (this.hidden) {
            return false;
        }
        if (this.outlineLevel) {
            return false;
        }
        const s = this.style;
        if (s && (s.font || s.numFmt || s.alignment || s.border || s.fill || s.protection)) {
            return false;
        }
        return true;
    }
    get headerCount() {
        return this.headers.length;
    }
    eachCell(options, iteratee) {
        const colNumber = this.number;
        if (!iteratee) {
            iteratee = options;
            options = null;
        }
        this._worksheet.eachRow(options, (row, rowNumber)=>{
            iteratee(row.getCell(colNumber), rowNumber);
        });
    }
    get values() {
        const v = [];
        this.eachCell((cell, rowNumber)=>{
            if (cell && cell.type !== Enums.ValueType.Null) {
                v[rowNumber] = cell.value;
            }
        });
        return v;
    }
    set values(v) {
        if (!v) {
            return;
        }
        const colNumber = this.number;
        let offset = 0;
        if (v.hasOwnProperty("0")) {
            // assume contiguous array, start at row 1
            offset = 1;
        }
        v.forEach((value, index)=>{
            this._worksheet.getCell(index + offset, colNumber).value = value;
        });
    }
    // =========================================================================
    // styles
    _applyStyle(name, value) {
        this.style[name] = value;
        this.eachCell((cell)=>{
            cell[name] = value;
        });
        return value;
    }
    get numFmt() {
        return this.style.numFmt;
    }
    set numFmt(value) {
        this._applyStyle("numFmt", value);
    }
    get font() {
        return this.style.font;
    }
    set font(value) {
        this._applyStyle("font", value);
    }
    get alignment() {
        return this.style.alignment;
    }
    set alignment(value) {
        this._applyStyle("alignment", value);
    }
    get protection() {
        return this.style.protection;
    }
    set protection(value) {
        this._applyStyle("protection", value);
    }
    get border() {
        return this.style.border;
    }
    set border(value) {
        this._applyStyle("border", value);
    }
    get fill() {
        return this.style.fill;
    }
    set fill(value) {
        this._applyStyle("fill", value);
    }
    // =============================================================================
    // static functions
    static toModel(columns) {
        // Convert array of Column into compressed list cols
        const cols = [];
        let col = null;
        if (columns) {
            columns.forEach((column, index)=>{
                if (column.isDefault) {
                    if (col) {
                        col = null;
                    }
                } else if (!col || !column.equivalentTo(col)) {
                    col = {
                        min: index + 1,
                        max: index + 1,
                        width: column.width !== undefined ? column.width : DEFAULT_COLUMN_WIDTH,
                        style: column.style,
                        isCustomWidth: column.isCustomWidth,
                        hidden: column.hidden,
                        outlineLevel: column.outlineLevel,
                        collapsed: column.collapsed
                    };
                    cols.push(col);
                } else {
                    col.max = index + 1;
                }
            });
        }
        return cols.length ? cols : undefined;
    }
    static fromModel(worksheet, cols) {
        cols = cols || [];
        const columns = [];
        let count = 1;
        let index = 0;
        /**
     * sort cols by min
     * If it is not sorted, the subsequent column configuration will be overwritten
     * */ cols = cols.sort(function(pre, next) {
            return pre.min - next.min;
        });
        while(index < cols.length){
            const col = cols[index++];
            while(count < col.min){
                columns.push(new Column(worksheet, count++));
            }
            while(count <= col.max){
                columns.push(new Column(worksheet, count++, col));
            }
        }
        return columns.length ? columns : null;
    }
}
module.exports = Column;


/***/ }),

/***/ 62828:
/***/ ((module) => {

"use strict";

class DataValidations {
    constructor(model){
        this.model = model || {};
    }
    add(address, validation) {
        return this.model[address] = validation;
    }
    find(address) {
        return this.model[address];
    }
    remove(address) {
        this.model[address] = undefined;
    }
}
module.exports = DataValidations;


/***/ }),

/***/ 68179:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
const colCache = __webpack_require__(90609);
const CellMatrix = __webpack_require__(16491);
const Range = __webpack_require__(77010);
const rangeRegexp = /[$](\w+)[$](\d+)(:[$](\w+)[$](\d+))?/;
class DefinedNames {
    constructor(){
        this.matrixMap = {};
    }
    getMatrix(name) {
        const matrix = this.matrixMap[name] || (this.matrixMap[name] = new CellMatrix());
        return matrix;
    }
    // add a name to a cell. locStr in the form SheetName!$col$row or SheetName!$c1$r1:$c2:$r2
    add(locStr, name) {
        const location = colCache.decodeEx(locStr);
        this.addEx(location, name);
    }
    addEx(location, name) {
        const matrix = this.getMatrix(name);
        if (location.top) {
            for(let col = location.left; col <= location.right; col++){
                for(let row = location.top; row <= location.bottom; row++){
                    const address = {
                        sheetName: location.sheetName,
                        address: colCache.n2l(col) + row,
                        row,
                        col
                    };
                    matrix.addCellEx(address);
                }
            }
        } else {
            matrix.addCellEx(location);
        }
    }
    remove(locStr, name) {
        const location = colCache.decodeEx(locStr);
        this.removeEx(location, name);
    }
    removeEx(location, name) {
        const matrix = this.getMatrix(name);
        matrix.removeCellEx(location);
    }
    removeAllNames(location) {
        _.each(this.matrixMap, (matrix)=>{
            matrix.removeCellEx(location);
        });
    }
    forEach(callback) {
        _.each(this.matrixMap, (matrix, name)=>{
            matrix.forEach((cell)=>{
                callback(name, cell);
            });
        });
    }
    // get all the names of a cell
    getNames(addressStr) {
        return this.getNamesEx(colCache.decodeEx(addressStr));
    }
    getNamesEx(address) {
        return _.map(this.matrixMap, (matrix, name)=>matrix.findCellEx(address) && name).filter(Boolean);
    }
    _explore(matrix, cell) {
        cell.mark = false;
        const { sheetName } = cell;
        const range = new Range(cell.row, cell.col, cell.row, cell.col, sheetName);
        let x;
        let y;
        // grow vertical - only one col to worry about
        function vGrow(yy, edge) {
            const c = matrix.findCellAt(sheetName, yy, cell.col);
            if (!c || !c.mark) {
                return false;
            }
            range[edge] = yy;
            c.mark = false;
            return true;
        }
        for(y = cell.row - 1; vGrow(y, "top"); y--);
        for(y = cell.row + 1; vGrow(y, "bottom"); y++);
        // grow horizontal - ensure all rows can grow
        function hGrow(xx, edge) {
            const cells = [];
            for(y = range.top; y <= range.bottom; y++){
                const c = matrix.findCellAt(sheetName, y, xx);
                if (c && c.mark) {
                    cells.push(c);
                } else {
                    return false;
                }
            }
            range[edge] = xx;
            for(let i = 0; i < cells.length; i++){
                cells[i].mark = false;
            }
            return true;
        }
        for(x = cell.col - 1; hGrow(x, "left"); x--);
        for(x = cell.col + 1; hGrow(x, "right"); x++);
        return range;
    }
    getRanges(name, matrix) {
        matrix = matrix || this.matrixMap[name];
        if (!matrix) {
            return {
                name,
                ranges: []
            };
        }
        // mark and sweep!
        matrix.forEach((cell)=>{
            cell.mark = true;
        });
        const ranges = matrix.map((cell)=>cell.mark && this._explore(matrix, cell)).filter(Boolean).map((range)=>range.$shortRange);
        return {
            name,
            ranges
        };
    }
    normaliseMatrix(matrix, sheetName) {
        // some of the cells might have shifted on specified sheet
        // need to reassign rows, cols
        matrix.forEachInSheet(sheetName, (cell, row, col)=>{
            if (cell) {
                if (cell.row !== row || cell.col !== col) {
                    cell.row = row;
                    cell.col = col;
                    cell.address = colCache.n2l(col) + row;
                }
            }
        });
    }
    spliceRows(sheetName, start, numDelete, numInsert) {
        _.each(this.matrixMap, (matrix)=>{
            matrix.spliceRows(sheetName, start, numDelete, numInsert);
            this.normaliseMatrix(matrix, sheetName);
        });
    }
    spliceColumns(sheetName, start, numDelete, numInsert) {
        _.each(this.matrixMap, (matrix)=>{
            matrix.spliceColumns(sheetName, start, numDelete, numInsert);
            this.normaliseMatrix(matrix, sheetName);
        });
    }
    get model() {
        // To get names per cell - just iterate over all names finding cells if they exist
        return _.map(this.matrixMap, (matrix, name)=>this.getRanges(name, matrix)).filter((definedName)=>definedName.ranges.length);
    }
    set model(value) {
        // value is [ { name, ranges }, ... ]
        const matrixMap = this.matrixMap = {};
        value.forEach((definedName)=>{
            const matrix = matrixMap[definedName.name] = new CellMatrix();
            definedName.ranges.forEach((rangeStr)=>{
                if (rangeRegexp.test(rangeStr.split("!").pop() || "")) {
                    matrix.addCell(rangeStr);
                }
            });
        });
    }
}
module.exports = DefinedNames;


/***/ }),

/***/ 48688:
/***/ ((module) => {

"use strict";

module.exports = {
    ValueType: {
        Null: 0,
        Merge: 1,
        Number: 2,
        String: 3,
        Date: 4,
        Hyperlink: 5,
        Formula: 6,
        SharedString: 7,
        RichText: 8,
        Boolean: 9,
        Error: 10
    },
    FormulaType: {
        None: 0,
        Master: 1,
        Shared: 2
    },
    RelationshipType: {
        None: 0,
        OfficeDocument: 1,
        Worksheet: 2,
        CalcChain: 3,
        SharedStrings: 4,
        Styles: 5,
        Theme: 6,
        Hyperlink: 7
    },
    DocumentType: {
        Xlsx: 1
    },
    ReadingOrder: {
        LeftToRight: 1,
        RightToLeft: 2
    },
    ErrorValue: {
        NotApplicable: "#N/A",
        Ref: "#REF!",
        Name: "#NAME?",
        DivZero: "#DIV/0!",
        Null: "#NULL!",
        Value: "#VALUE!",
        Num: "#NUM!"
    }
};


/***/ }),

/***/ 15468:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const colCache = __webpack_require__(90609);
const Anchor = __webpack_require__(28761);
class Image {
    constructor(worksheet, model){
        this.worksheet = worksheet;
        this.model = model;
    }
    get model() {
        switch(this.type){
            case "background":
                return {
                    type: this.type,
                    imageId: this.imageId
                };
            case "image":
                return {
                    type: this.type,
                    imageId: this.imageId,
                    hyperlinks: this.range.hyperlinks,
                    range: {
                        tl: this.range.tl.model,
                        br: this.range.br && this.range.br.model,
                        ext: this.range.ext,
                        editAs: this.range.editAs
                    }
                };
            default:
                throw new Error("Invalid Image Type");
        }
    }
    set model({ type, imageId, range, hyperlinks }) {
        this.type = type;
        this.imageId = imageId;
        if (type === "image") {
            if (typeof range === "string") {
                const decoded = colCache.decode(range);
                this.range = {
                    tl: new Anchor(this.worksheet, {
                        col: decoded.left,
                        row: decoded.top
                    }, -1),
                    br: new Anchor(this.worksheet, {
                        col: decoded.right,
                        row: decoded.bottom
                    }, 0),
                    editAs: "oneCell"
                };
            } else {
                this.range = {
                    tl: new Anchor(this.worksheet, range.tl, 0),
                    br: range.br && new Anchor(this.worksheet, range.br, 0),
                    ext: range.ext,
                    editAs: range.editAs,
                    hyperlinks: hyperlinks || range.hyperlinks
                };
            }
        }
    }
}
module.exports = Image;


/***/ }),

/***/ 60889:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const XLSX = __webpack_require__(22008);
class ModelContainer {
    constructor(model){
        this.model = model;
    }
    get xlsx() {
        if (!this._xlsx) {
            this._xlsx = new XLSX(this);
        }
        return this._xlsx;
    }
}
module.exports = ModelContainer;


/***/ }),

/***/ 92183:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
class Note {
    constructor(note){
        this.note = note;
    }
    get model() {
        let value = null;
        switch(typeof this.note){
            case "string":
                value = {
                    type: "note",
                    note: {
                        texts: [
                            {
                                text: this.note
                            }
                        ]
                    }
                };
                break;
            default:
                value = {
                    type: "note",
                    note: this.note
                };
                break;
        }
        // Suitable for all cell comments
        return _.deepMerge({}, Note.DEFAULT_CONFIGS, value);
    }
    set model(value) {
        const { note } = value;
        const { texts } = note;
        if (texts.length === 1 && Object.keys(texts[0]).length === 1) {
            this.note = texts[0].text;
        } else {
            this.note = note;
        }
    }
    static fromModel(model) {
        const note = new Note();
        note.model = model;
        return note;
    }
}
Note.DEFAULT_CONFIGS = {
    note: {
        margins: {
            insetmode: "auto",
            inset: [
                0.13,
                0.13,
                0.25,
                0.25
            ]
        },
        protection: {
            locked: "True",
            lockText: "True"
        },
        editAs: "absolute"
    }
};
module.exports = Note;


/***/ }),

/***/ 77010:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const colCache = __webpack_require__(90609);
// used by worksheet to calculate sheet dimensions
class Range {
    constructor(){
        this.decode(arguments);
    }
    setTLBR(t, l, b, r, s) {
        if (arguments.length < 4) {
            // setTLBR(tl, br, s)
            const tl = colCache.decodeAddress(t);
            const br = colCache.decodeAddress(l);
            this.model = {
                top: Math.min(tl.row, br.row),
                left: Math.min(tl.col, br.col),
                bottom: Math.max(tl.row, br.row),
                right: Math.max(tl.col, br.col),
                sheetName: b
            };
            this.setTLBR(tl.row, tl.col, br.row, br.col, s);
        } else {
            // setTLBR(t, l, b, r, s)
            this.model = {
                top: Math.min(t, b),
                left: Math.min(l, r),
                bottom: Math.max(t, b),
                right: Math.max(l, r),
                sheetName: s
            };
        }
    }
    decode(argv) {
        switch(argv.length){
            case 5:
                this.setTLBR(argv[0], argv[1], argv[2], argv[3], argv[4]);
                break;
            case 4:
                this.setTLBR(argv[0], argv[1], argv[2], argv[3]);
                break;
            case 3:
                this.setTLBR(argv[0], argv[1], argv[2]);
                break;
            case 2:
                this.setTLBR(argv[0], argv[1]);
                break;
            case 1:
                {
                    const value = argv[0];
                    if (value instanceof Range) {
                        // copy constructor
                        this.model = {
                            top: value.model.top,
                            left: value.model.left,
                            bottom: value.model.bottom,
                            right: value.model.right,
                            sheetName: value.sheetName
                        };
                    } else if (value instanceof Array) {
                        // an arguments array
                        this.decode(value);
                    } else if (value.top && value.left && value.bottom && value.right) {
                        // a model
                        this.model = {
                            top: value.top,
                            left: value.left,
                            bottom: value.bottom,
                            right: value.right,
                            sheetName: value.sheetName
                        };
                    } else {
                        // [sheetName!]tl:br
                        const tlbr = colCache.decodeEx(value);
                        if (tlbr.top) {
                            this.model = {
                                top: tlbr.top,
                                left: tlbr.left,
                                bottom: tlbr.bottom,
                                right: tlbr.right,
                                sheetName: tlbr.sheetName
                            };
                        } else {
                            this.model = {
                                top: tlbr.row,
                                left: tlbr.col,
                                bottom: tlbr.row,
                                right: tlbr.col,
                                sheetName: tlbr.sheetName
                            };
                        }
                    }
                    break;
                }
            case 0:
                this.model = {
                    top: 0,
                    left: 0,
                    bottom: 0,
                    right: 0
                };
                break;
            default:
                throw new Error(`Invalid number of arguments to _getDimensions() - ${argv.length}`);
        }
    }
    get top() {
        return this.model.top || 1;
    }
    set top(value) {
        this.model.top = value;
    }
    get left() {
        return this.model.left || 1;
    }
    set left(value) {
        this.model.left = value;
    }
    get bottom() {
        return this.model.bottom || 1;
    }
    set bottom(value) {
        this.model.bottom = value;
    }
    get right() {
        return this.model.right || 1;
    }
    set right(value) {
        this.model.right = value;
    }
    get sheetName() {
        return this.model.sheetName;
    }
    set sheetName(value) {
        this.model.sheetName = value;
    }
    get _serialisedSheetName() {
        const { sheetName } = this.model;
        if (sheetName) {
            if (/^[a-zA-Z0-9]*$/.test(sheetName)) {
                return `${sheetName}!`;
            }
            return `'${sheetName}'!`;
        }
        return "";
    }
    expand(top, left, bottom, right) {
        if (!this.model.top || top < this.top) this.top = top;
        if (!this.model.left || left < this.left) this.left = left;
        if (!this.model.bottom || bottom > this.bottom) this.bottom = bottom;
        if (!this.model.right || right > this.right) this.right = right;
    }
    expandRow(row) {
        if (row) {
            const { dimensions, number } = row;
            if (dimensions) {
                this.expand(number, dimensions.min, number, dimensions.max);
            }
        }
    }
    expandToAddress(addressStr) {
        const address = colCache.decodeEx(addressStr);
        this.expand(address.row, address.col, address.row, address.col);
    }
    get tl() {
        return colCache.n2l(this.left) + this.top;
    }
    get $t$l() {
        return `$${colCache.n2l(this.left)}$${this.top}`;
    }
    get br() {
        return colCache.n2l(this.right) + this.bottom;
    }
    get $b$r() {
        return `$${colCache.n2l(this.right)}$${this.bottom}`;
    }
    get range() {
        return `${this._serialisedSheetName + this.tl}:${this.br}`;
    }
    get $range() {
        return `${this._serialisedSheetName + this.$t$l}:${this.$b$r}`;
    }
    get shortRange() {
        return this.count > 1 ? this.range : this._serialisedSheetName + this.tl;
    }
    get $shortRange() {
        return this.count > 1 ? this.$range : this._serialisedSheetName + this.$t$l;
    }
    get count() {
        return (1 + this.bottom - this.top) * (1 + this.right - this.left);
    }
    toString() {
        return this.range;
    }
    intersects(other) {
        if (other.sheetName && this.sheetName && other.sheetName !== this.sheetName) return false;
        if (other.bottom < this.top) return false;
        if (other.top > this.bottom) return false;
        if (other.right < this.left) return false;
        if (other.left > this.right) return false;
        return true;
    }
    contains(addressStr) {
        const address = colCache.decodeEx(addressStr);
        return this.containsEx(address);
    }
    containsEx(address) {
        if (address.sheetName && this.sheetName && address.sheetName !== this.sheetName) return false;
        return address.row >= this.top && address.row <= this.bottom && address.col >= this.left && address.col <= this.right;
    }
    forEachAddress(cb) {
        for(let col = this.left; col <= this.right; col++){
            for(let row = this.top; row <= this.bottom; row++){
                cb(colCache.encodeAddress(row, col), row, col);
            }
        }
    }
}
module.exports = Range;


/***/ }),

/***/ 97524:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
const Enums = __webpack_require__(48688);
const colCache = __webpack_require__(90609);
const Cell = __webpack_require__(24529);
class Row {
    constructor(worksheet, number){
        this._worksheet = worksheet;
        this._number = number;
        this._cells = [];
        this.style = {};
        this.outlineLevel = 0;
    }
    // return the row number
    get number() {
        return this._number;
    }
    get worksheet() {
        return this._worksheet;
    }
    // Inform Streaming Writer that this row (and all rows before it) are complete
    // and ready to write. Has no effect on Worksheet document
    commit() {
        this._worksheet._commitRow(this); // eslint-disable-line no-underscore-dangle
    }
    // helps GC by breaking cyclic references
    destroy() {
        delete this._worksheet;
        delete this._cells;
        delete this.style;
    }
    findCell(colNumber) {
        return this._cells[colNumber - 1];
    }
    // given {address, row, col}, find or create new cell
    getCellEx(address) {
        let cell = this._cells[address.col - 1];
        if (!cell) {
            const column = this._worksheet.getColumn(address.col);
            cell = new Cell(this, column, address.address);
            this._cells[address.col - 1] = cell;
        }
        return cell;
    }
    // get cell by key, letter or column number
    getCell(col) {
        if (typeof col === "string") {
            // is it a key?
            const column = this._worksheet.getColumnKey(col);
            if (column) {
                col = column.number;
            } else {
                col = colCache.l2n(col);
            }
        }
        return this._cells[col - 1] || this.getCellEx({
            address: colCache.encodeAddress(this._number, col),
            row: this._number,
            col
        });
    }
    // remove cell(s) and shift all higher cells down by count
    splice(start, count, ...inserts) {
        const nKeep = start + count;
        const nExpand = inserts.length - count;
        const nEnd = this._cells.length;
        let i;
        let cSrc;
        let cDst;
        if (nExpand < 0) {
            // remove cells
            for(i = start + inserts.length; i <= nEnd; i++){
                cDst = this._cells[i - 1];
                cSrc = this._cells[i - nExpand - 1];
                if (cSrc) {
                    cDst = this.getCell(i);
                    cDst.value = cSrc.value;
                    cDst.style = cSrc.style;
                    // eslint-disable-next-line no-underscore-dangle
                    cDst._comment = cSrc._comment;
                } else if (cDst) {
                    cDst.value = null;
                    cDst.style = {};
                    // eslint-disable-next-line no-underscore-dangle
                    cDst._comment = undefined;
                }
            }
        } else if (nExpand > 0) {
            // insert new cells
            for(i = nEnd; i >= nKeep; i--){
                cSrc = this._cells[i - 1];
                if (cSrc) {
                    cDst = this.getCell(i + nExpand);
                    cDst.value = cSrc.value;
                    cDst.style = cSrc.style;
                    // eslint-disable-next-line no-underscore-dangle
                    cDst._comment = cSrc._comment;
                } else {
                    this._cells[i + nExpand - 1] = undefined;
                }
            }
        }
        // now add the new values
        for(i = 0; i < inserts.length; i++){
            cDst = this.getCell(start + i);
            cDst.value = inserts[i];
            cDst.style = {};
            // eslint-disable-next-line no-underscore-dangle
            cDst._comment = undefined;
        }
    }
    // Iterate over all non-null cells in this row
    eachCell(options, iteratee) {
        if (!iteratee) {
            iteratee = options;
            options = null;
        }
        if (options && options.includeEmpty) {
            const n = this._cells.length;
            for(let i = 1; i <= n; i++){
                iteratee(this.getCell(i), i);
            }
        } else {
            this._cells.forEach((cell, index)=>{
                if (cell && cell.type !== Enums.ValueType.Null) {
                    iteratee(cell, index + 1);
                }
            });
        }
    }
    // ===========================================================================
    // Page Breaks
    addPageBreak(lft, rght) {
        const ws = this._worksheet;
        const left = Math.max(0, lft - 1) || 0;
        const right = Math.max(0, rght - 1) || 16838;
        const pb = {
            id: this._number,
            max: right,
            man: 1
        };
        if (left) pb.min = left;
        ws.rowBreaks.push(pb);
    }
    // return a sparse array of cell values
    get values() {
        const values = [];
        this._cells.forEach((cell)=>{
            if (cell && cell.type !== Enums.ValueType.Null) {
                values[cell.col] = cell.value;
            }
        });
        return values;
    }
    // set the values by contiguous or sparse array, or by key'd object literal
    set values(value) {
        // this operation is not additive - any prior cells are removed
        this._cells = [];
        if (!value) {
        // empty row
        } else if (value instanceof Array) {
            let offset = 0;
            if (value.hasOwnProperty("0")) {
                // contiguous array - start at column 1
                offset = 1;
            }
            value.forEach((item, index)=>{
                if (item !== undefined) {
                    this.getCellEx({
                        address: colCache.encodeAddress(this._number, index + offset),
                        row: this._number,
                        col: index + offset
                    }).value = item;
                }
            });
        } else {
            // assume object with column keys
            this._worksheet.eachColumnKey((column, key)=>{
                if (value[key] !== undefined) {
                    this.getCellEx({
                        address: colCache.encodeAddress(this._number, column.number),
                        row: this._number,
                        col: column.number
                    }).value = value[key];
                }
            });
        }
    }
    // returns true if the row includes at least one cell with a value
    get hasValues() {
        return _.some(this._cells, (cell)=>cell && cell.type !== Enums.ValueType.Null);
    }
    get cellCount() {
        return this._cells.length;
    }
    get actualCellCount() {
        let count = 0;
        this.eachCell(()=>{
            count++;
        });
        return count;
    }
    // get the min and max column number for the non-null cells in this row or null
    get dimensions() {
        let min = 0;
        let max = 0;
        this._cells.forEach((cell)=>{
            if (cell && cell.type !== Enums.ValueType.Null) {
                if (!min || min > cell.col) {
                    min = cell.col;
                }
                if (max < cell.col) {
                    max = cell.col;
                }
            }
        });
        return min > 0 ? {
            min,
            max
        } : null;
    }
    // =========================================================================
    // styles
    _applyStyle(name, value) {
        this.style[name] = value;
        this._cells.forEach((cell)=>{
            if (cell) {
                cell[name] = value;
            }
        });
        return value;
    }
    get numFmt() {
        return this.style.numFmt;
    }
    set numFmt(value) {
        this._applyStyle("numFmt", value);
    }
    get font() {
        return this.style.font;
    }
    set font(value) {
        this._applyStyle("font", value);
    }
    get alignment() {
        return this.style.alignment;
    }
    set alignment(value) {
        this._applyStyle("alignment", value);
    }
    get protection() {
        return this.style.protection;
    }
    set protection(value) {
        this._applyStyle("protection", value);
    }
    get border() {
        return this.style.border;
    }
    set border(value) {
        this._applyStyle("border", value);
    }
    get fill() {
        return this.style.fill;
    }
    set fill(value) {
        this._applyStyle("fill", value);
    }
    get hidden() {
        return !!this._hidden;
    }
    set hidden(value) {
        this._hidden = value;
    }
    get outlineLevel() {
        return this._outlineLevel || 0;
    }
    set outlineLevel(value) {
        this._outlineLevel = value;
    }
    get collapsed() {
        return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelRow);
    }
    // =========================================================================
    get model() {
        const cells = [];
        let min = 0;
        let max = 0;
        this._cells.forEach((cell)=>{
            if (cell) {
                const cellModel = cell.model;
                if (cellModel) {
                    if (!min || min > cell.col) {
                        min = cell.col;
                    }
                    if (max < cell.col) {
                        max = cell.col;
                    }
                    cells.push(cellModel);
                }
            }
        });
        return this.height || cells.length ? {
            cells,
            number: this.number,
            min,
            max,
            height: this.height,
            style: this.style,
            hidden: this.hidden,
            outlineLevel: this.outlineLevel,
            collapsed: this.collapsed
        } : null;
    }
    set model(value) {
        if (value.number !== this._number) {
            throw new Error("Invalid row number in model");
        }
        this._cells = [];
        let previousAddress;
        value.cells.forEach((cellModel)=>{
            switch(cellModel.type){
                case Cell.Types.Merge:
                    break;
                default:
                    {
                        let address;
                        if (cellModel.address) {
                            address = colCache.decodeAddress(cellModel.address);
                        } else if (previousAddress) {
                            // This is a <c> element without an r attribute
                            // Assume that it's the cell for the next column
                            const { row } = previousAddress;
                            const col = previousAddress.col + 1;
                            address = {
                                row,
                                col,
                                address: colCache.encodeAddress(row, col),
                                $col$row: `$${colCache.n2l(col)}$${row}`
                            };
                        }
                        previousAddress = address;
                        const cell = this.getCellEx(address);
                        cell.model = cellModel;
                        break;
                    }
            }
        });
        if (value.height) {
            this.height = value.height;
        } else {
            delete this.height;
        }
        this.hidden = value.hidden;
        this.outlineLevel = value.outlineLevel || 0;
        this.style = value.style && JSON.parse(JSON.stringify(value.style)) || {};
    }
}
module.exports = Row;


/***/ }),

/***/ 46846:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable max-classes-per-file */ 
const colCache = __webpack_require__(90609);
class Column {
    // wrapper around column model, allowing access and manipulation
    constructor(table, column, index){
        this.table = table;
        this.column = column;
        this.index = index;
    }
    _set(name, value) {
        this.table.cacheState();
        this.column[name] = value;
    }
    /* eslint-disable lines-between-class-members */ get name() {
        return this.column.name;
    }
    set name(value) {
        this._set("name", value);
    }
    get filterButton() {
        return this.column.filterButton;
    }
    set filterButton(value) {
        this.column.filterButton = value;
    }
    get style() {
        return this.column.style;
    }
    set style(value) {
        this.column.style = value;
    }
    get totalsRowLabel() {
        return this.column.totalsRowLabel;
    }
    set totalsRowLabel(value) {
        this._set("totalsRowLabel", value);
    }
    get totalsRowFunction() {
        return this.column.totalsRowFunction;
    }
    set totalsRowFunction(value) {
        this._set("totalsRowFunction", value);
    }
    get totalsRowResult() {
        return this.column.totalsRowResult;
    }
    set totalsRowResult(value) {
        this._set("totalsRowResult", value);
    }
    get totalsRowFormula() {
        return this.column.totalsRowFormula;
    }
    set totalsRowFormula(value) {
        this._set("totalsRowFormula", value);
    }
}
class Table {
    constructor(worksheet, table){
        this.worksheet = worksheet;
        if (table) {
            this.table = table;
            // check things are ok first
            this.validate();
            this.store();
        }
    }
    getFormula(column) {
        // get the correct formula to apply to the totals row
        switch(column.totalsRowFunction){
            case "none":
                return null;
            case "average":
                return `SUBTOTAL(101,${this.table.name}[${column.name}])`;
            case "countNums":
                return `SUBTOTAL(102,${this.table.name}[${column.name}])`;
            case "count":
                return `SUBTOTAL(103,${this.table.name}[${column.name}])`;
            case "max":
                return `SUBTOTAL(104,${this.table.name}[${column.name}])`;
            case "min":
                return `SUBTOTAL(105,${this.table.name}[${column.name}])`;
            case "stdDev":
                return `SUBTOTAL(106,${this.table.name}[${column.name}])`;
            case "var":
                return `SUBTOTAL(107,${this.table.name}[${column.name}])`;
            case "sum":
                return `SUBTOTAL(109,${this.table.name}[${column.name}])`;
            case "custom":
                return column.totalsRowFormula;
            default:
                throw new Error(`Invalid Totals Row Function: ${column.totalsRowFunction}`);
        }
    }
    get width() {
        // width of the table
        return this.table.columns.length;
    }
    get height() {
        // height of the table data
        return this.table.rows.length;
    }
    get filterHeight() {
        // height of the table data plus optional header row
        return this.height + (this.table.headerRow ? 1 : 0);
    }
    get tableHeight() {
        // full height of the table on the sheet
        return this.filterHeight + (this.table.totalsRow ? 1 : 0);
    }
    validate() {
        const { table } = this;
        // set defaults and check is valid
        const assign = (o, name, dflt)=>{
            if (o[name] === undefined) {
                o[name] = dflt;
            }
        };
        assign(table, "headerRow", true);
        assign(table, "totalsRow", false);
        assign(table, "style", {});
        assign(table.style, "theme", "TableStyleMedium2");
        assign(table.style, "showFirstColumn", false);
        assign(table.style, "showLastColumn", false);
        assign(table.style, "showRowStripes", false);
        assign(table.style, "showColumnStripes", false);
        const assert = (test, message)=>{
            if (!test) {
                throw new Error(message);
            }
        };
        assert(table.ref, "Table must have ref");
        assert(table.columns, "Table must have column definitions");
        assert(table.rows, "Table must have row definitions");
        table.tl = colCache.decodeAddress(table.ref);
        const { row, col } = table.tl;
        assert(row > 0, "Table must be on valid row");
        assert(col > 0, "Table must be on valid col");
        const { width, filterHeight, tableHeight } = this;
        // autoFilterRef is a range that includes optional headers only
        table.autoFilterRef = colCache.encode(row, col, row + filterHeight - 1, col + width - 1);
        // tableRef is a range that includes optional headers and totals
        table.tableRef = colCache.encode(row, col, row + tableHeight - 1, col + width - 1);
        table.columns.forEach((column, i)=>{
            assert(column.name, `Column ${i} must have a name`);
            if (i === 0) {
                assign(column, "totalsRowLabel", "Total");
            } else {
                assign(column, "totalsRowFunction", "none");
                column.totalsRowFormula = this.getFormula(column);
            }
        });
    }
    store() {
        // where the table needs to store table data, headers, footers in
        // the sheet...
        const assignStyle = (cell, style)=>{
            if (style) {
                Object.keys(style).forEach((key)=>{
                    cell[key] = style[key];
                });
            }
        };
        const { worksheet, table } = this;
        const { row, col } = table.tl;
        let count = 0;
        if (table.headerRow) {
            const r = worksheet.getRow(row + count++);
            table.columns.forEach((column, j)=>{
                const { style, name } = column;
                const cell = r.getCell(col + j);
                cell.value = name;
                assignStyle(cell, style);
            });
        }
        table.rows.forEach((data)=>{
            const r = worksheet.getRow(row + count++);
            data.forEach((value, j)=>{
                const cell = r.getCell(col + j);
                cell.value = value;
                assignStyle(cell, table.columns[j].style);
            });
        });
        if (table.totalsRow) {
            const r = worksheet.getRow(row + count++);
            table.columns.forEach((column, j)=>{
                const cell = r.getCell(col + j);
                if (j === 0) {
                    cell.value = column.totalsRowLabel;
                } else {
                    const formula = this.getFormula(column);
                    if (formula) {
                        cell.value = {
                            formula: column.totalsRowFormula,
                            result: column.totalsRowResult
                        };
                    } else {
                        cell.value = null;
                    }
                }
                assignStyle(cell, column.style);
            });
        }
    }
    load(worksheet) {
        // where the table will read necessary features from a loaded sheet
        const { table } = this;
        const { row, col } = table.tl;
        let count = 0;
        if (table.headerRow) {
            const r = worksheet.getRow(row + count++);
            table.columns.forEach((column, j)=>{
                const cell = r.getCell(col + j);
                cell.value = column.name;
            });
        }
        table.rows.forEach((data)=>{
            const r = worksheet.getRow(row + count++);
            data.forEach((value, j)=>{
                const cell = r.getCell(col + j);
                cell.value = value;
            });
        });
        if (table.totalsRow) {
            const r = worksheet.getRow(row + count++);
            table.columns.forEach((column, j)=>{
                const cell = r.getCell(col + j);
                if (j === 0) {
                    cell.value = column.totalsRowLabel;
                } else {
                    const formula = this.getFormula(column);
                    if (formula) {
                        cell.value = {
                            formula: column.totalsRowFormula,
                            result: column.totalsRowResult
                        };
                    }
                }
            });
        }
    }
    get model() {
        return this.table;
    }
    set model(value) {
        this.table = value;
    }
    // ================================================================
    // TODO: Mutating methods
    cacheState() {
        if (!this._cache) {
            this._cache = {
                ref: this.ref,
                width: this.width,
                tableHeight: this.tableHeight
            };
        }
    }
    commit() {
        // changes may have been made that might have on-sheet effects
        if (!this._cache) {
            return;
        }
        // check things are ok first
        this.validate();
        const ref = colCache.decodeAddress(this._cache.ref);
        if (this.ref !== this._cache.ref) {
            // wipe out whole table footprint at previous location
            for(let i = 0; i < this._cache.tableHeight; i++){
                const row = this.worksheet.getRow(ref.row + i);
                for(let j = 0; j < this._cache.width; j++){
                    const cell = row.getCell(ref.col + j);
                    cell.value = null;
                }
            }
        } else {
            // clear out below table if it has shrunk
            for(let i = this.tableHeight; i < this._cache.tableHeight; i++){
                const row = this.worksheet.getRow(ref.row + i);
                for(let j = 0; j < this._cache.width; j++){
                    const cell = row.getCell(ref.col + j);
                    cell.value = null;
                }
            }
            // clear out to right of table if it has lost columns
            for(let i = 0; i < this.tableHeight; i++){
                const row = this.worksheet.getRow(ref.row + i);
                for(let j = this.width; j < this._cache.width; j++){
                    const cell = row.getCell(ref.col + j);
                    cell.value = null;
                }
            }
        }
        this.store();
    }
    addRow(values, rowNumber) {
        // Add a row of data, either insert at rowNumber or append
        this.cacheState();
        if (rowNumber === undefined) {
            this.table.rows.push(values);
        } else {
            this.table.rows.splice(rowNumber, 0, values);
        }
    }
    removeRows(rowIndex, count = 1) {
        // Remove a rows of data
        this.cacheState();
        this.table.rows.splice(rowIndex, count);
    }
    getColumn(colIndex) {
        const column = this.table.columns[colIndex];
        return new Column(this, column, colIndex);
    }
    addColumn(column, values, colIndex) {
        // Add a new column, including column defn and values
        // Inserts at colNumber or adds to the right
        this.cacheState();
        if (colIndex === undefined) {
            this.table.columns.push(column);
            this.table.rows.forEach((row, i)=>{
                row.push(values[i]);
            });
        } else {
            this.table.columns.splice(colIndex, 0, column);
            this.table.rows.forEach((row, i)=>{
                row.splice(colIndex, 0, values[i]);
            });
        }
    }
    removeColumns(colIndex, count = 1) {
        // Remove a column with data
        this.cacheState();
        this.table.columns.splice(colIndex, count);
        this.table.rows.forEach((row)=>{
            row.splice(colIndex, count);
        });
    }
    _assign(target, prop, value) {
        this.cacheState();
        target[prop] = value;
    }
    /* eslint-disable lines-between-class-members */ get ref() {
        return this.table.ref;
    }
    set ref(value) {
        this._assign(this.table, "ref", value);
    }
    get name() {
        return this.table.name;
    }
    set name(value) {
        this.table.name = value;
    }
    get displayName() {
        return this.table.displyName || this.table.name;
    }
    set displayNamename(value) {
        this.table.displayName = value;
    }
    get headerRow() {
        return this.table.headerRow;
    }
    set headerRow(value) {
        this._assign(this.table, "headerRow", value);
    }
    get totalsRow() {
        return this.table.totalsRow;
    }
    set totalsRow(value) {
        this._assign(this.table, "totalsRow", value);
    }
    get theme() {
        return this.table.style.name;
    }
    set theme(value) {
        this.table.style.name = value;
    }
    get showFirstColumn() {
        return this.table.style.showFirstColumn;
    }
    set showFirstColumn(value) {
        this.table.style.showFirstColumn = value;
    }
    get showLastColumn() {
        return this.table.style.showLastColumn;
    }
    set showLastColumn(value) {
        this.table.style.showLastColumn = value;
    }
    get showRowStripes() {
        return this.table.style.showRowStripes;
    }
    set showRowStripes(value) {
        this.table.style.showRowStripes = value;
    }
    get showColumnStripes() {
        return this.table.style.showColumnStripes;
    }
    set showColumnStripes(value) {
        this.table.style.showColumnStripes = value;
    }
}
module.exports = Table;


/***/ }),

/***/ 30082:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Worksheet = __webpack_require__(28602);
const DefinedNames = __webpack_require__(68179);
const XLSX = __webpack_require__(22008);
const CSV = __webpack_require__(48437);
// Workbook requirements
//  Load and Save from file and stream
//  Access/Add/Delete individual worksheets
//  Manage String table, Hyperlink table, etc.
//  Manage scaffolding for contained objects to write to/read from
class Workbook {
    constructor(){
        this.category = "";
        this.company = "";
        this.created = new Date();
        this.description = "";
        this.keywords = "";
        this.manager = "";
        this.modified = this.created;
        this.properties = {};
        this.calcProperties = {};
        this._worksheets = [];
        this.subject = "";
        this.title = "";
        this.views = [];
        this.media = [];
        this._definedNames = new DefinedNames();
    }
    get xlsx() {
        if (!this._xlsx) this._xlsx = new XLSX(this);
        return this._xlsx;
    }
    get csv() {
        if (!this._csv) this._csv = new CSV(this);
        return this._csv;
    }
    get nextId() {
        // find the next unique spot to add worksheet
        for(let i = 1; i < this._worksheets.length; i++){
            if (!this._worksheets[i]) {
                return i;
            }
        }
        return this._worksheets.length || 1;
    }
    addWorksheet(name, options) {
        const id = this.nextId;
        // if options is a color, call it tabColor (and signal deprecated message)
        if (options) {
            if (typeof options === "string") {
                // eslint-disable-next-line no-console
                console.trace('tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { argb: "rbg value" } }');
                options = {
                    properties: {
                        tabColor: {
                            argb: options
                        }
                    }
                };
            } else if (options.argb || options.theme || options.indexed) {
                // eslint-disable-next-line no-console
                console.trace("tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { ... } }");
                options = {
                    properties: {
                        tabColor: options
                    }
                };
            }
        }
        const lastOrderNo = this._worksheets.reduce((acc, ws)=>(ws && ws.orderNo) > acc ? ws.orderNo : acc, 0);
        const worksheetOptions = Object.assign({}, options, {
            id,
            name,
            orderNo: lastOrderNo + 1,
            workbook: this
        });
        const worksheet = new Worksheet(worksheetOptions);
        this._worksheets[id] = worksheet;
        return worksheet;
    }
    removeWorksheetEx(worksheet) {
        delete this._worksheets[worksheet.id];
    }
    removeWorksheet(id) {
        const worksheet = this.getWorksheet(id);
        if (worksheet) {
            worksheet.destroy();
        }
    }
    getWorksheet(id) {
        if (id === undefined) {
            return this._worksheets.find(Boolean);
        }
        if (typeof id === "number") {
            return this._worksheets[id];
        }
        if (typeof id === "string") {
            return this._worksheets.find((worksheet)=>worksheet && worksheet.name === id);
        }
        return undefined;
    }
    get worksheets() {
        // return a clone of _worksheets
        return this._worksheets.slice(1).sort((a, b)=>a.orderNo - b.orderNo).filter(Boolean);
    }
    eachSheet(iteratee) {
        this.worksheets.forEach((sheet)=>{
            iteratee(sheet, sheet.id);
        });
    }
    get definedNames() {
        return this._definedNames;
    }
    clearThemes() {
        // Note: themes are not an exposed feature, meddle at your peril!
        this._themes = undefined;
    }
    addImage(image) {
        // TODO:  validation?
        const id = this.media.length;
        this.media.push(Object.assign({}, image, {
            type: "image"
        }));
        return id;
    }
    getImage(id) {
        return this.media[id];
    }
    get model() {
        return {
            creator: this.creator || "Unknown",
            lastModifiedBy: this.lastModifiedBy || "Unknown",
            lastPrinted: this.lastPrinted,
            created: this.created,
            modified: this.modified,
            properties: this.properties,
            worksheets: this.worksheets.map((worksheet)=>worksheet.model),
            sheets: this.worksheets.map((ws)=>ws.model).filter(Boolean),
            definedNames: this._definedNames.model,
            views: this.views,
            company: this.company,
            manager: this.manager,
            title: this.title,
            subject: this.subject,
            keywords: this.keywords,
            category: this.category,
            description: this.description,
            language: this.language,
            revision: this.revision,
            contentStatus: this.contentStatus,
            themes: this._themes,
            media: this.media,
            calcProperties: this.calcProperties
        };
    }
    set model(value) {
        this.creator = value.creator;
        this.lastModifiedBy = value.lastModifiedBy;
        this.lastPrinted = value.lastPrinted;
        this.created = value.created;
        this.modified = value.modified;
        this.company = value.company;
        this.manager = value.manager;
        this.title = value.title;
        this.subject = value.subject;
        this.keywords = value.keywords;
        this.category = value.category;
        this.description = value.description;
        this.language = value.language;
        this.revision = value.revision;
        this.contentStatus = value.contentStatus;
        this.properties = value.properties;
        this.calcProperties = value.calcProperties;
        this._worksheets = [];
        value.worksheets.forEach((worksheetModel)=>{
            const { id, name, state } = worksheetModel;
            const orderNo = value.sheets && value.sheets.findIndex((ws)=>ws.id === id);
            const worksheet = this._worksheets[id] = new Worksheet({
                id,
                name,
                orderNo,
                state,
                workbook: this
            });
            worksheet.model = worksheetModel;
        });
        this._definedNames.model = value.definedNames;
        this.views = value.views;
        this._themes = value.themes;
        this.media = value.media || [];
    }
}
module.exports = Workbook;


/***/ }),

/***/ 28602:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
const colCache = __webpack_require__(90609);
const Range = __webpack_require__(77010);
const Row = __webpack_require__(97524);
const Column = __webpack_require__(72192);
const Enums = __webpack_require__(48688);
const Image = __webpack_require__(15468);
const Table = __webpack_require__(46846);
const DataValidations = __webpack_require__(62828);
const Encryptor = __webpack_require__(91573);
const { copyStyle } = __webpack_require__(8730);
// Worksheet requirements
//  Operate as sheet inside workbook or standalone
//  Load and Save from file and stream
//  Access/Add/Delete individual cells
//  Manage column widths and row heights
class Worksheet {
    constructor(options){
        options = options || {};
        this._workbook = options.workbook;
        // in a workbook, each sheet will have a number
        this.id = options.id;
        this.orderNo = options.orderNo;
        // and a name
        this.name = options.name;
        // add a state
        this.state = options.state || "visible";
        // rows allows access organised by row. Sparse array of arrays indexed by row-1, col
        // Note: _rows is zero based. Must subtract 1 to go from cell.row to index
        this._rows = [];
        // column definitions
        this._columns = null;
        // column keys (addRow convenience): key ==> this._collumns index
        this._keys = {};
        // keep record of all merges
        this._merges = {};
        // record of all row and column pageBreaks
        this.rowBreaks = [];
        // for tabColor, default row height, outline levels, etc
        this.properties = Object.assign({}, {
            defaultRowHeight: 15,
            dyDescent: 55,
            outlineLevelCol: 0,
            outlineLevelRow: 0
        }, options.properties);
        // for all things printing
        this.pageSetup = Object.assign({}, {
            margins: {
                left: 0.7,
                right: 0.7,
                top: 0.75,
                bottom: 0.75,
                header: 0.3,
                footer: 0.3
            },
            orientation: "portrait",
            horizontalDpi: 4294967295,
            verticalDpi: 4294967295,
            fitToPage: !!(options.pageSetup && (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) && !options.pageSetup.scale),
            pageOrder: "downThenOver",
            blackAndWhite: false,
            draft: false,
            cellComments: "None",
            errors: "displayed",
            scale: 100,
            fitToWidth: 1,
            fitToHeight: 1,
            paperSize: undefined,
            showRowColHeaders: false,
            showGridLines: false,
            firstPageNumber: undefined,
            horizontalCentered: false,
            verticalCentered: false,
            rowBreaks: null,
            colBreaks: null
        }, options.pageSetup);
        this.headerFooter = Object.assign({}, {
            differentFirst: false,
            differentOddEven: false,
            oddHeader: null,
            oddFooter: null,
            evenHeader: null,
            evenFooter: null,
            firstHeader: null,
            firstFooter: null
        }, options.headerFooter);
        this.dataValidations = new DataValidations();
        // for freezepanes, split, zoom, gridlines, etc
        this.views = options.views || [];
        this.autoFilter = options.autoFilter || null;
        // for images, etc
        this._media = [];
        // worksheet protection
        this.sheetProtection = null;
        // for tables
        this.tables = {};
        this.conditionalFormattings = [];
    }
    get name() {
        return this._name;
    }
    set name(name) {
        if (name === undefined) {
            name = `sheet${this.id}`;
        }
        if (this._name === name) return;
        if (typeof name !== "string") {
            throw new Error("The name has to be a string.");
        }
        if (name === "") {
            throw new Error("The name can't be empty.");
        }
        if (name === "History") {
            throw new Error('The name "History" is protected. Please use a different name.');
        }
        // Illegal character in worksheet name: asterisk (*), question mark (?),
        // colon (:), forward slash (/ \), or bracket ([])
        if (/[*?:/\\[\]]/.test(name)) {
            throw new Error(`Worksheet name ${name} cannot include any of the following characters: * ? : \\ / [ ]`);
        }
        if (/(^')|('$)/.test(name)) {
            throw new Error(`The first or last character of worksheet name cannot be a single quotation mark: ${name}`);
        }
        if (name && name.length > 31) {
            // eslint-disable-next-line no-console
            console.warn(`Worksheet name ${name} exceeds 31 chars. This will be truncated`);
            name = name.substring(0, 31);
        }
        if (this._workbook._worksheets.find((ws)=>ws && ws.name.toLowerCase() === name.toLowerCase())) {
            throw new Error(`Worksheet name already exists: ${name}`);
        }
        this._name = name;
    }
    get workbook() {
        return this._workbook;
    }
    // when you're done with this worksheet, call this to remove from workbook
    destroy() {
        this._workbook.removeWorksheetEx(this);
    }
    // Get the bounding range of the cells in this worksheet
    get dimensions() {
        const dimensions = new Range();
        this._rows.forEach((row)=>{
            if (row) {
                const rowDims = row.dimensions;
                if (rowDims) {
                    dimensions.expand(row.number, rowDims.min, row.number, rowDims.max);
                }
            }
        });
        return dimensions;
    }
    // =========================================================================
    // Columns
    // get the current columns array.
    get columns() {
        return this._columns;
    }
    // set the columns from an array of column definitions.
    // Note: any headers defined will overwrite existing values.
    set columns(value) {
        // calculate max header row count
        this._headerRowCount = value.reduce((pv, cv)=>{
            const headerCount = cv.header && 1 || cv.headers && cv.headers.length || 0;
            return Math.max(pv, headerCount);
        }, 0);
        // construct Column objects
        let count = 1;
        const columns = this._columns = [];
        value.forEach((defn)=>{
            const column = new Column(this, count++, false);
            columns.push(column);
            column.defn = defn;
        });
    }
    getColumnKey(key) {
        return this._keys[key];
    }
    setColumnKey(key, value) {
        this._keys[key] = value;
    }
    deleteColumnKey(key) {
        delete this._keys[key];
    }
    eachColumnKey(f) {
        _.each(this._keys, f);
    }
    // get a single column by col number. If it doesn't exist, create it and any gaps before it
    getColumn(c) {
        if (typeof c === "string") {
            // if it matches a key'd column, return that
            const col = this._keys[c];
            if (col) return col;
            // otherwise, assume letter
            c = colCache.l2n(c);
        }
        if (!this._columns) {
            this._columns = [];
        }
        if (c > this._columns.length) {
            let n = this._columns.length + 1;
            while(n <= c){
                this._columns.push(new Column(this, n++));
            }
        }
        return this._columns[c - 1];
    }
    spliceColumns(start, count, ...inserts) {
        const rows = this._rows;
        const nRows = rows.length;
        if (inserts.length > 0) {
            // must iterate over all rows whether they exist yet or not
            for(let i = 0; i < nRows; i++){
                const rowArguments = [
                    start,
                    count
                ];
                // eslint-disable-next-line no-loop-func
                inserts.forEach((insert)=>{
                    rowArguments.push(insert[i] || null);
                });
                const row = this.getRow(i + 1);
                // eslint-disable-next-line prefer-spread
                row.splice.apply(row, rowArguments);
            }
        } else {
            // nothing to insert, so just splice all rows
            this._rows.forEach((r)=>{
                if (r) {
                    r.splice(start, count);
                }
            });
        }
        // splice column definitions
        const nExpand = inserts.length - count;
        const nKeep = start + count;
        const nEnd = this._columns.length;
        if (nExpand < 0) {
            for(let i = start + inserts.length; i <= nEnd; i++){
                this.getColumn(i).defn = this.getColumn(i - nExpand).defn;
            }
        } else if (nExpand > 0) {
            for(let i = nEnd; i >= nKeep; i--){
                this.getColumn(i + nExpand).defn = this.getColumn(i).defn;
            }
        }
        for(let i = start; i < start + inserts.length; i++){
            this.getColumn(i).defn = null;
        }
        // account for defined names
        this.workbook.definedNames.spliceColumns(this.name, start, count, inserts.length);
    }
    get lastColumn() {
        return this.getColumn(this.columnCount);
    }
    get columnCount() {
        let maxCount = 0;
        this.eachRow((row)=>{
            maxCount = Math.max(maxCount, row.cellCount);
        });
        return maxCount;
    }
    get actualColumnCount() {
        // performance nightmare - for each row, counts all the columns used
        const counts = [];
        let count = 0;
        this.eachRow((row)=>{
            row.eachCell(({ col })=>{
                if (!counts[col]) {
                    counts[col] = true;
                    count++;
                }
            });
        });
        return count;
    }
    // =========================================================================
    // Rows
    _commitRow() {
    // nop - allows streaming reader to fill a document
    }
    get _lastRowNumber() {
        // need to cope with results of splice
        const rows = this._rows;
        let n = rows.length;
        while(n > 0 && rows[n - 1] === undefined){
            n--;
        }
        return n;
    }
    get _nextRow() {
        return this._lastRowNumber + 1;
    }
    get lastRow() {
        if (this._rows.length) {
            return this._rows[this._rows.length - 1];
        }
        return undefined;
    }
    // find a row (if exists) by row number
    findRow(r) {
        return this._rows[r - 1];
    }
    // find multiple rows (if exists) by row number
    findRows(start, length) {
        return this._rows.slice(start - 1, start - 1 + length);
    }
    get rowCount() {
        return this._lastRowNumber;
    }
    get actualRowCount() {
        // counts actual rows that have actual data
        let count = 0;
        this.eachRow(()=>{
            count++;
        });
        return count;
    }
    // get a row by row number.
    getRow(r) {
        let row = this._rows[r - 1];
        if (!row) {
            row = this._rows[r - 1] = new Row(this, r);
        }
        return row;
    }
    // get multiple rows by row number.
    getRows(start, length) {
        if (length < 1) return undefined;
        const rows = [];
        for(let i = start; i < start + length; i++){
            rows.push(this.getRow(i));
        }
        return rows;
    }
    addRow(value, style = "n") {
        const rowNo = this._nextRow;
        const row = this.getRow(rowNo);
        row.values = value;
        this._setStyleOption(rowNo, style[0] === "i" ? style : "n");
        return row;
    }
    addRows(value, style = "n") {
        const rows = [];
        value.forEach((row)=>{
            rows.push(this.addRow(row, style));
        });
        return rows;
    }
    insertRow(pos, value, style = "n") {
        this.spliceRows(pos, 0, value);
        this._setStyleOption(pos, style);
        return this.getRow(pos);
    }
    insertRows(pos, values, style = "n") {
        this.spliceRows(pos, 0, ...values);
        if (style !== "n") {
            // copy over the styles
            for(let i = 0; i < values.length; i++){
                if (style[0] === "o" && this.findRow(values.length + pos + i) !== undefined) {
                    this._copyStyle(values.length + pos + i, pos + i, style[1] === "+");
                } else if (style[0] === "i" && this.findRow(pos - 1) !== undefined) {
                    this._copyStyle(pos - 1, pos + i, style[1] === "+");
                }
            }
        }
        return this.getRows(pos, values.length);
    }
    // set row at position to same style as of either pervious row (option 'i') or next row (option 'o')
    _setStyleOption(pos, style = "n") {
        if (style[0] === "o" && this.findRow(pos + 1) !== undefined) {
            this._copyStyle(pos + 1, pos, style[1] === "+");
        } else if (style[0] === "i" && this.findRow(pos - 1) !== undefined) {
            this._copyStyle(pos - 1, pos, style[1] === "+");
        }
    }
    _copyStyle(src, dest, styleEmpty = false) {
        const rSrc = this.getRow(src);
        const rDst = this.getRow(dest);
        rDst.style = copyStyle(rSrc.style);
        // eslint-disable-next-line no-loop-func
        rSrc.eachCell({
            includeEmpty: styleEmpty
        }, (cell, colNumber)=>{
            rDst.getCell(colNumber).style = copyStyle(cell.style);
        });
        rDst.height = rSrc.height;
    }
    duplicateRow(rowNum, count, insert = false) {
        // create count duplicates of rowNum
        // either inserting new or overwriting existing rows
        const rSrc = this._rows[rowNum - 1];
        const inserts = new Array(count).fill(rSrc.values);
        this.spliceRows(rowNum + 1, insert ? 0 : count, ...inserts);
        // now copy styles...
        for(let i = 0; i < count; i++){
            const rDst = this._rows[rowNum + i];
            rDst.style = rSrc.style;
            rDst.height = rSrc.height;
            // eslint-disable-next-line no-loop-func
            rSrc.eachCell({
                includeEmpty: true
            }, (cell, colNumber)=>{
                rDst.getCell(colNumber).style = cell.style;
            });
        }
    }
    spliceRows(start, count, ...inserts) {
        // same problem as row.splice, except worse.
        const nKeep = start + count;
        const nInserts = inserts.length;
        const nExpand = nInserts - count;
        const nEnd = this._rows.length;
        let i;
        let rSrc;
        if (nExpand < 0) {
            // remove rows
            if (start === nEnd) {
                this._rows[nEnd - 1] = undefined;
            }
            for(i = nKeep; i <= nEnd; i++){
                rSrc = this._rows[i - 1];
                if (rSrc) {
                    const rDst = this.getRow(i + nExpand);
                    rDst.values = rSrc.values;
                    rDst.style = rSrc.style;
                    rDst.height = rSrc.height;
                    // eslint-disable-next-line no-loop-func
                    rSrc.eachCell({
                        includeEmpty: true
                    }, (cell, colNumber)=>{
                        rDst.getCell(colNumber).style = cell.style;
                    });
                    this._rows[i - 1] = undefined;
                } else {
                    this._rows[i + nExpand - 1] = undefined;
                }
            }
        } else if (nExpand > 0) {
            // insert new cells
            for(i = nEnd; i >= nKeep; i--){
                rSrc = this._rows[i - 1];
                if (rSrc) {
                    const rDst = this.getRow(i + nExpand);
                    rDst.values = rSrc.values;
                    rDst.style = rSrc.style;
                    rDst.height = rSrc.height;
                    // eslint-disable-next-line no-loop-func
                    rSrc.eachCell({
                        includeEmpty: true
                    }, (cell, colNumber)=>{
                        rDst.getCell(colNumber).style = cell.style;
                        // remerge cells accounting for insert offset
                        if (cell._value.constructor.name === "MergeValue") {
                            const cellToBeMerged = this.getRow(cell._row._number + nInserts).getCell(colNumber);
                            const prevMaster = cell._value._master;
                            const newMaster = this.getRow(prevMaster._row._number + nInserts).getCell(prevMaster._column._number);
                            cellToBeMerged.merge(newMaster);
                        }
                    });
                } else {
                    this._rows[i + nExpand - 1] = undefined;
                }
            }
        }
        // now copy over the new values
        for(i = 0; i < nInserts; i++){
            const rDst = this.getRow(start + i);
            rDst.style = {};
            rDst.values = inserts[i];
        }
        // account for defined names
        this.workbook.definedNames.spliceRows(this.name, start, count, nInserts);
    }
    // iterate over every row in the worksheet, including maybe empty rows
    eachRow(options, iteratee) {
        if (!iteratee) {
            iteratee = options;
            options = undefined;
        }
        if (options && options.includeEmpty) {
            const n = this._rows.length;
            for(let i = 1; i <= n; i++){
                iteratee(this.getRow(i), i);
            }
        } else {
            this._rows.forEach((row)=>{
                if (row && row.hasValues) {
                    iteratee(row, row.number);
                }
            });
        }
    }
    // return all rows as sparse array
    getSheetValues() {
        const rows = [];
        this._rows.forEach((row)=>{
            if (row) {
                rows[row.number] = row.values;
            }
        });
        return rows;
    }
    // =========================================================================
    // Cells
    // returns the cell at [r,c] or address given by r. If not found, return undefined
    findCell(r, c) {
        const address = colCache.getAddress(r, c);
        const row = this._rows[address.row - 1];
        return row ? row.findCell(address.col) : undefined;
    }
    // return the cell at [r,c] or address given by r. If not found, create a new one.
    getCell(r, c) {
        const address = colCache.getAddress(r, c);
        const row = this.getRow(address.row);
        return row.getCellEx(address);
    }
    // =========================================================================
    // Merge
    // convert the range defined by ['tl:br'], [tl,br] or [t,l,b,r] into a single 'merged' cell
    mergeCells(...cells) {
        const dimensions = new Range(cells);
        this._mergeCellsInternal(dimensions);
    }
    mergeCellsWithoutStyle(...cells) {
        const dimensions = new Range(cells);
        this._mergeCellsInternal(dimensions, true);
    }
    _mergeCellsInternal(dimensions, ignoreStyle) {
        // check cells aren't already merged
        _.each(this._merges, (merge)=>{
            if (merge.intersects(dimensions)) {
                throw new Error("Cannot merge already merged cells");
            }
        });
        // apply merge
        const master = this.getCell(dimensions.top, dimensions.left);
        for(let i = dimensions.top; i <= dimensions.bottom; i++){
            for(let j = dimensions.left; j <= dimensions.right; j++){
                // merge all but the master cell
                if (i > dimensions.top || j > dimensions.left) {
                    this.getCell(i, j).merge(master, ignoreStyle);
                }
            }
        }
        // index merge
        this._merges[master.address] = dimensions;
    }
    _unMergeMaster(master) {
        // master is always top left of a rectangle
        const merge = this._merges[master.address];
        if (merge) {
            for(let i = merge.top; i <= merge.bottom; i++){
                for(let j = merge.left; j <= merge.right; j++){
                    this.getCell(i, j).unmerge();
                }
            }
            delete this._merges[master.address];
        }
    }
    get hasMerges() {
        // return true if this._merges has a merge object
        return _.some(this._merges, Boolean);
    }
    // scan the range defined by ['tl:br'], [tl,br] or [t,l,b,r] and if any cell is part of a merge,
    // un-merge the group. Note this function can affect multiple merges and merge-blocks are
    // atomic - either they're all merged or all un-merged.
    unMergeCells(...cells) {
        const dimensions = new Range(cells);
        // find any cells in that range and unmerge them
        for(let i = dimensions.top; i <= dimensions.bottom; i++){
            for(let j = dimensions.left; j <= dimensions.right; j++){
                const cell = this.findCell(i, j);
                if (cell) {
                    if (cell.type === Enums.ValueType.Merge) {
                        // this cell merges to another master
                        this._unMergeMaster(cell.master);
                    } else if (this._merges[cell.address]) {
                        // this cell is a master
                        this._unMergeMaster(cell);
                    }
                }
            }
        }
    }
    // ===========================================================================
    // Shared/Array Formula
    fillFormula(range, formula, results, shareType = "shared") {
        // Define formula for top-left cell and share to rest
        const decoded = colCache.decode(range);
        const { top, left, bottom, right } = decoded;
        const width = right - left + 1;
        const masterAddress = colCache.encodeAddress(top, left);
        const isShared = shareType === "shared";
        // work out result accessor
        let getResult;
        if (typeof results === "function") {
            getResult = results;
        } else if (Array.isArray(results)) {
            if (Array.isArray(results[0])) {
                getResult = (row, col)=>results[row - top][col - left];
            } else {
                // eslint-disable-next-line no-mixed-operators
                getResult = (row, col)=>results[(row - top) * width + (col - left)];
            }
        } else {
            getResult = ()=>undefined;
        }
        let first = true;
        for(let r = top; r <= bottom; r++){
            for(let c = left; c <= right; c++){
                if (first) {
                    this.getCell(r, c).value = {
                        shareType,
                        formula,
                        ref: range,
                        result: getResult(r, c)
                    };
                    first = false;
                } else {
                    this.getCell(r, c).value = isShared ? {
                        sharedFormula: masterAddress,
                        result: getResult(r, c)
                    } : getResult(r, c);
                }
            }
        }
    }
    // =========================================================================
    // Images
    addImage(imageId, range) {
        const model = {
            type: "image",
            imageId,
            range
        };
        this._media.push(new Image(this, model));
    }
    getImages() {
        return this._media.filter((m)=>m.type === "image");
    }
    addBackgroundImage(imageId) {
        const model = {
            type: "background",
            imageId
        };
        this._media.push(new Image(this, model));
    }
    getBackgroundImageId() {
        const image = this._media.find((m)=>m.type === "background");
        return image && image.imageId;
    }
    // =========================================================================
    // Worksheet Protection
    protect(password, options) {
        // TODO: make this function truly async
        // perhaps marshal to worker thread or something
        return new Promise((resolve)=>{
            this.sheetProtection = {
                sheet: true
            };
            if (options && "spinCount" in options) {
                // force spinCount to be integer >= 0
                options.spinCount = Number.isFinite(options.spinCount) ? Math.round(Math.max(0, options.spinCount)) : 100000;
            }
            if (password) {
                this.sheetProtection.algorithmName = "SHA-512";
                this.sheetProtection.saltValue = Encryptor.randomBytes(16).toString("base64");
                this.sheetProtection.spinCount = options && "spinCount" in options ? options.spinCount : 100000; // allow user specified spinCount
                this.sheetProtection.hashValue = Encryptor.convertPasswordToHash(password, "SHA512", this.sheetProtection.saltValue, this.sheetProtection.spinCount);
            }
            if (options) {
                this.sheetProtection = Object.assign(this.sheetProtection, options);
                if (!password && "spinCount" in options) {
                    delete this.sheetProtection.spinCount;
                }
            }
            resolve();
        });
    }
    unprotect() {
        this.sheetProtection = null;
    }
    // =========================================================================
    // Tables
    addTable(model) {
        const table = new Table(this, model);
        this.tables[model.name] = table;
        return table;
    }
    getTable(name) {
        return this.tables[name];
    }
    removeTable(name) {
        delete this.tables[name];
    }
    getTables() {
        return Object.values(this.tables);
    }
    // ===========================================================================
    // Conditional Formatting
    addConditionalFormatting(cf) {
        this.conditionalFormattings.push(cf);
    }
    removeConditionalFormatting(filter) {
        if (typeof filter === "number") {
            this.conditionalFormattings.splice(filter, 1);
        } else if (filter instanceof Function) {
            this.conditionalFormattings = this.conditionalFormattings.filter(filter);
        } else {
            this.conditionalFormattings = [];
        }
    }
    // ===========================================================================
    // Deprecated
    get tabColor() {
        // eslint-disable-next-line no-console
        console.trace("worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor");
        return this.properties.tabColor;
    }
    set tabColor(value) {
        // eslint-disable-next-line no-console
        console.trace("worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor");
        this.properties.tabColor = value;
    }
    // ===========================================================================
    // Model
    get model() {
        const model = {
            id: this.id,
            name: this.name,
            dataValidations: this.dataValidations.model,
            properties: this.properties,
            state: this.state,
            pageSetup: this.pageSetup,
            headerFooter: this.headerFooter,
            rowBreaks: this.rowBreaks,
            views: this.views,
            autoFilter: this.autoFilter,
            media: this._media.map((medium)=>medium.model),
            sheetProtection: this.sheetProtection,
            tables: Object.values(this.tables).map((table)=>table.model),
            conditionalFormattings: this.conditionalFormattings
        };
        // =================================================
        // columns
        model.cols = Column.toModel(this.columns);
        // ==========================================================
        // Rows
        const rows = model.rows = [];
        const dimensions = model.dimensions = new Range();
        this._rows.forEach((row)=>{
            const rowModel = row && row.model;
            if (rowModel) {
                dimensions.expand(rowModel.number, rowModel.min, rowModel.number, rowModel.max);
                rows.push(rowModel);
            }
        });
        // ==========================================================
        // Merges
        model.merges = [];
        _.each(this._merges, (merge)=>{
            model.merges.push(merge.range);
        });
        return model;
    }
    _parseRows(model) {
        this._rows = [];
        model.rows.forEach((rowModel)=>{
            const row = new Row(this, rowModel.number);
            this._rows[row.number - 1] = row;
            row.model = rowModel;
        });
    }
    _parseMergeCells(model) {
        _.each(model.mergeCells, (merge)=>{
            // Do not merge styles when importing an Excel file
            // since each cell may have different styles intentionally.
            this.mergeCellsWithoutStyle(merge);
        });
    }
    set model(value) {
        this.name = value.name;
        this._columns = Column.fromModel(this, value.cols);
        this._parseRows(value);
        this._parseMergeCells(value);
        this.dataValidations = new DataValidations(value.dataValidations);
        this.properties = value.properties;
        this.pageSetup = value.pageSetup;
        this.headerFooter = value.headerFooter;
        this.views = value.views;
        this.autoFilter = value.autoFilter;
        this._media = value.media.map((medium)=>new Image(this, medium));
        this.sheetProtection = value.sheetProtection;
        this.tables = value.tables.reduce((tables, table)=>{
            const t = new Table();
            t.model = table;
            tables[table.name] = t;
            return tables;
        }, {});
        this.conditionalFormattings = value.conditionalFormattings;
    }
}
module.exports = Worksheet;


/***/ }),

/***/ 99685:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ExcelJS = {
    Workbook: __webpack_require__(30082),
    ModelContainer: __webpack_require__(60889),
    stream: {
        xlsx: {
            WorkbookWriter: __webpack_require__(78788),
            WorkbookReader: __webpack_require__(44537)
        }
    }
};
Object.assign(ExcelJS, __webpack_require__(48688));
module.exports = ExcelJS;


/***/ }),

/***/ 41684:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { EventEmitter } = __webpack_require__(82361);
const parseSax = __webpack_require__(68595);
const Enums = __webpack_require__(48688);
const RelType = __webpack_require__(39982);
class HyperlinkReader extends EventEmitter {
    constructor({ workbook, id, iterator, options }){
        super();
        this.workbook = workbook;
        this.id = id;
        this.iterator = iterator;
        this.options = options;
    }
    get count() {
        return this.hyperlinks && this.hyperlinks.length || 0;
    }
    each(fn) {
        return this.hyperlinks.forEach(fn);
    }
    async read() {
        const { iterator, options } = this;
        let emitHyperlinks = false;
        let hyperlinks = null;
        switch(options.hyperlinks){
            case "emit":
                emitHyperlinks = true;
                break;
            case "cache":
                this.hyperlinks = hyperlinks = {};
                break;
            default:
                break;
        }
        if (!emitHyperlinks && !hyperlinks) {
            this.emit("finished");
            return;
        }
        try {
            for await (const events of parseSax(iterator)){
                for (const { eventType, value } of events){
                    if (eventType === "opentag") {
                        const node = value;
                        if (node.name === "Relationship") {
                            const rId = node.attributes.Id;
                            switch(node.attributes.Type){
                                case RelType.Hyperlink:
                                    {
                                        const relationship = {
                                            type: Enums.RelationshipType.Styles,
                                            rId,
                                            target: node.attributes.Target,
                                            targetMode: node.attributes.TargetMode
                                        };
                                        if (emitHyperlinks) {
                                            this.emit("hyperlink", relationship);
                                        } else {
                                            hyperlinks[relationship.rId] = relationship;
                                        }
                                    }
                                    break;
                                default:
                                    break;
                            }
                        }
                    }
                }
            }
            this.emit("finished");
        } catch (error) {
            this.emit("error", error);
        }
    }
}
module.exports = HyperlinkReader;


/***/ }),

/***/ 87405:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const XmlStream = __webpack_require__(18749);
const RelType = __webpack_require__(39982);
const colCache = __webpack_require__(90609);
const CommentXform = __webpack_require__(32977);
const VmlShapeXform = __webpack_require__(15343);
class SheetCommentsWriter {
    constructor(worksheet, sheetRelsWriter, options){
        // in a workbook, each sheet will have a number
        this.id = options.id;
        this.count = 0;
        this._worksheet = worksheet;
        this._workbook = options.workbook;
        this._sheetRelsWriter = sheetRelsWriter;
    }
    get commentsStream() {
        if (!this._commentsStream) {
            // eslint-disable-next-line no-underscore-dangle
            this._commentsStream = this._workbook._openStream(`/xl/comments${this.id}.xml`);
        }
        return this._commentsStream;
    }
    get vmlStream() {
        if (!this._vmlStream) {
            // eslint-disable-next-line no-underscore-dangle
            this._vmlStream = this._workbook._openStream(`xl/drawings/vmlDrawing${this.id}.vml`);
        }
        return this._vmlStream;
    }
    _addRelationships() {
        const commentRel = {
            Type: RelType.Comments,
            Target: `../comments${this.id}.xml`
        };
        this._sheetRelsWriter.addRelationship(commentRel);
        const vmlDrawingRel = {
            Type: RelType.VmlDrawing,
            Target: `../drawings/vmlDrawing${this.id}.vml`
        };
        this.vmlRelId = this._sheetRelsWriter.addRelationship(vmlDrawingRel);
    }
    _addCommentRefs() {
        this._workbook.commentRefs.push({
            commentName: `comments${this.id}`,
            vmlDrawing: `vmlDrawing${this.id}`
        });
    }
    _writeOpen() {
        this.commentsStream.write('<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + '<comments xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">' + "<authors><author>Author</author></authors>" + "<commentList>");
        this.vmlStream.write('<?xml version="1.0" encoding="UTF-8"?>' + '<xml xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:x="urn:schemas-microsoft-com:office:excel">' + '<o:shapelayout v:ext="edit">' + '<o:idmap v:ext="edit" data="1" />' + "</o:shapelayout>" + '<v:shapetype id="_x0000_t202" coordsize="21600,21600" o:spt="202" path="m,l,21600r21600,l21600,xe">' + '<v:stroke joinstyle="miter" />' + '<v:path gradientshapeok="t" o:connecttype="rect" />' + "</v:shapetype>");
    }
    _writeComment(comment, index) {
        const commentXform = new CommentXform();
        const commentsXmlStream = new XmlStream();
        commentXform.render(commentsXmlStream, comment);
        this.commentsStream.write(commentsXmlStream.xml);
        const vmlShapeXform = new VmlShapeXform();
        const vmlXmlStream = new XmlStream();
        vmlShapeXform.render(vmlXmlStream, comment, index);
        this.vmlStream.write(vmlXmlStream.xml);
    }
    _writeClose() {
        this.commentsStream.write("</commentList></comments>");
        this.vmlStream.write("</xml>");
    }
    addComments(comments) {
        if (comments && comments.length) {
            if (!this.startedData) {
                this._worksheet.comments = [];
                this._writeOpen();
                this._addRelationships();
                this._addCommentRefs();
                this.startedData = true;
            }
            comments.forEach((item)=>{
                item.refAddress = colCache.decodeAddress(item.ref);
            });
            comments.forEach((comment)=>{
                this._writeComment(comment, this.count);
                this.count += 1;
            });
        }
    }
    commit() {
        if (this.count) {
            this._writeClose();
            this.commentsStream.end();
            this.vmlStream.end();
        }
    }
}
module.exports = SheetCommentsWriter;


/***/ }),

/***/ 48501:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable max-classes-per-file */ 
const utils = __webpack_require__(90778);
const RelType = __webpack_require__(39982);
class HyperlinksProxy {
    constructor(sheetRelsWriter){
        this.writer = sheetRelsWriter;
    }
    push(hyperlink) {
        this.writer.addHyperlink(hyperlink);
    }
}
class SheetRelsWriter {
    constructor(options){
        // in a workbook, each sheet will have a number
        this.id = options.id;
        // count of all relationships
        this.count = 0;
        // keep record of all hyperlinks
        this._hyperlinks = [];
        this._workbook = options.workbook;
    }
    get stream() {
        if (!this._stream) {
            // eslint-disable-next-line no-underscore-dangle
            this._stream = this._workbook._openStream(`/xl/worksheets/_rels/sheet${this.id}.xml.rels`);
        }
        return this._stream;
    }
    get length() {
        return this._hyperlinks.length;
    }
    each(fn) {
        return this._hyperlinks.forEach(fn);
    }
    get hyperlinksProxy() {
        return this._hyperlinksProxy || (this._hyperlinksProxy = new HyperlinksProxy(this));
    }
    addHyperlink(hyperlink) {
        // Write to stream
        const relationship = {
            Target: hyperlink.target,
            Type: RelType.Hyperlink,
            TargetMode: "External"
        };
        const rId = this._writeRelationship(relationship);
        // store sheet stuff for later
        this._hyperlinks.push({
            rId,
            address: hyperlink.address
        });
    }
    addMedia(media) {
        return this._writeRelationship(media);
    }
    addRelationship(rel) {
        return this._writeRelationship(rel);
    }
    commit() {
        if (this.count) {
            // write xml utro
            this._writeClose();
            // and close stream
            this.stream.end();
        }
    }
    // ================================================================================
    _writeOpen() {
        this.stream.write(`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
       <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">`);
    }
    _writeRelationship(relationship) {
        if (!this.count) {
            this._writeOpen();
        }
        const rId = `rId${++this.count}`;
        if (relationship.TargetMode) {
            this.stream.write(`<Relationship Id="${rId}"` + ` Type="${relationship.Type}"` + ` Target="${utils.xmlEncode(relationship.Target)}"` + ` TargetMode="${relationship.TargetMode}"` + "/>");
        } else {
            this.stream.write(`<Relationship Id="${rId}" Type="${relationship.Type}" Target="${relationship.Target}"/>`);
        }
        return rId;
    }
    _writeClose() {
        this.stream.write("</Relationships>");
    }
}
module.exports = SheetRelsWriter;


/***/ }),

/***/ 44537:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(57147);
const { EventEmitter } = __webpack_require__(82361);
const { PassThrough, Readable } = __webpack_require__(98323);
const nodeStream = __webpack_require__(12781);
const unzip = __webpack_require__(67494);
const tmp = __webpack_require__(28861);
const iterateStream = __webpack_require__(25885);
const parseSax = __webpack_require__(68595);
const StyleManager = __webpack_require__(20429);
const WorkbookXform = __webpack_require__(89297);
const RelationshipsXform = __webpack_require__(6849);
const WorksheetReader = __webpack_require__(96487);
const HyperlinkReader = __webpack_require__(41684);
tmp.setGracefulCleanup();
class WorkbookReader extends EventEmitter {
    constructor(input, options = {}){
        super();
        this.input = input;
        this.options = {
            worksheets: "emit",
            sharedStrings: "cache",
            hyperlinks: "ignore",
            styles: "ignore",
            entries: "ignore",
            ...options
        };
        this.styles = new StyleManager();
        this.styles.init();
    }
    _getStream(input) {
        if (input instanceof nodeStream.Readable || input instanceof Readable) {
            return input;
        }
        if (typeof input === "string") {
            return fs.createReadStream(input);
        }
        throw new Error(`Could not recognise input: ${input}`);
    }
    async read(input, options) {
        try {
            for await (const { eventType, value } of this.parse(input, options)){
                switch(eventType){
                    case "shared-strings":
                        this.emit(eventType, value);
                        break;
                    case "worksheet":
                        this.emit(eventType, value);
                        await value.read();
                        break;
                    case "hyperlinks":
                        this.emit(eventType, value);
                        break;
                }
            }
            this.emit("end");
            this.emit("finished");
        } catch (error) {
            this.emit("error", error);
        }
    }
    async *[Symbol.asyncIterator]() {
        for await (const { eventType, value } of this.parse()){
            if (eventType === "worksheet") {
                yield value;
            }
        }
    }
    async *parse(input, options) {
        if (options) this.options = options;
        const stream = this.stream = this._getStream(input || this.input);
        const zip = unzip.Parse({
            forceStream: true
        });
        stream.pipe(zip);
        // worksheets, deferred for parsing after shared strings reading
        const waitingWorkSheets = [];
        for await (const entry of iterateStream(zip)){
            let match;
            let sheetNo;
            switch(entry.path){
                case "_rels/.rels":
                    break;
                case "xl/_rels/workbook.xml.rels":
                    await this._parseRels(entry);
                    break;
                case "xl/workbook.xml":
                    await this._parseWorkbook(entry);
                    break;
                case "xl/sharedStrings.xml":
                    yield* this._parseSharedStrings(entry);
                    break;
                case "xl/styles.xml":
                    await this._parseStyles(entry);
                    break;
                default:
                    if (entry.path.match(/xl\/worksheets\/sheet\d+[.]xml/)) {
                        match = entry.path.match(/xl\/worksheets\/sheet(\d+)[.]xml/);
                        sheetNo = match[1];
                        if (this.sharedStrings && this.workbookRels) {
                            yield* this._parseWorksheet(iterateStream(entry), sheetNo);
                        } else {
                            // create temp file for each worksheet
                            await new Promise((resolve, reject)=>{
                                tmp.file((err, path, fd, tempFileCleanupCallback)=>{
                                    if (err) {
                                        return reject(err);
                                    }
                                    waitingWorkSheets.push({
                                        sheetNo,
                                        path,
                                        tempFileCleanupCallback
                                    });
                                    const tempStream = fs.createWriteStream(path);
                                    tempStream.on("error", reject);
                                    entry.pipe(tempStream);
                                    return tempStream.on("finish", ()=>{
                                        return resolve();
                                    });
                                });
                            });
                        }
                    } else if (entry.path.match(/xl\/worksheets\/_rels\/sheet\d+[.]xml.rels/)) {
                        match = entry.path.match(/xl\/worksheets\/_rels\/sheet(\d+)[.]xml.rels/);
                        sheetNo = match[1];
                        yield* this._parseHyperlinks(iterateStream(entry), sheetNo);
                    }
                    break;
            }
            entry.autodrain();
        }
        for (const { sheetNo, path, tempFileCleanupCallback } of waitingWorkSheets){
            let fileStream = fs.createReadStream(path);
            // TODO: Remove once node v8 is deprecated
            // Detect and upgrade old fileStreams
            if (!fileStream[Symbol.asyncIterator]) {
                fileStream = fileStream.pipe(new PassThrough());
            }
            yield* this._parseWorksheet(fileStream, sheetNo);
            tempFileCleanupCallback();
        }
    }
    _emitEntry(payload) {
        if (this.options.entries === "emit") {
            this.emit("entry", payload);
        }
    }
    async _parseRels(entry) {
        const xform = new RelationshipsXform();
        this.workbookRels = await xform.parseStream(iterateStream(entry));
    }
    async _parseWorkbook(entry) {
        this._emitEntry({
            type: "workbook"
        });
        const workbook = new WorkbookXform();
        await workbook.parseStream(iterateStream(entry));
        this.properties = workbook.map.workbookPr;
        this.model = workbook.model;
    }
    async *_parseSharedStrings(entry) {
        this._emitEntry({
            type: "shared-strings"
        });
        switch(this.options.sharedStrings){
            case "cache":
                this.sharedStrings = [];
                break;
            case "emit":
                break;
            default:
                return;
        }
        let text = null;
        let richText = [];
        let index = 0;
        let font = null;
        for await (const events of parseSax(iterateStream(entry))){
            for (const { eventType, value } of events){
                if (eventType === "opentag") {
                    const node = value;
                    switch(node.name){
                        case "b":
                            font = font || {};
                            font.bold = true;
                            break;
                        case "charset":
                            font = font || {};
                            font.charset = parseInt(node.attributes.charset, 10);
                            break;
                        case "color":
                            font = font || {};
                            font.color = {};
                            if (node.attributes.rgb) {
                                font.color.argb = node.attributes.argb;
                            }
                            if (node.attributes.val) {
                                font.color.argb = node.attributes.val;
                            }
                            if (node.attributes.theme) {
                                font.color.theme = node.attributes.theme;
                            }
                            break;
                        case "family":
                            font = font || {};
                            font.family = parseInt(node.attributes.val, 10);
                            break;
                        case "i":
                            font = font || {};
                            font.italic = true;
                            break;
                        case "outline":
                            font = font || {};
                            font.outline = true;
                            break;
                        case "rFont":
                            font = font || {};
                            font.name = node.value;
                            break;
                        case "si":
                            font = null;
                            richText = [];
                            text = null;
                            break;
                        case "sz":
                            font = font || {};
                            font.size = parseInt(node.attributes.val, 10);
                            break;
                        case "strike":
                            break;
                        case "t":
                            text = null;
                            break;
                        case "u":
                            font = font || {};
                            font.underline = true;
                            break;
                        case "vertAlign":
                            font = font || {};
                            font.vertAlign = node.attributes.val;
                            break;
                    }
                } else if (eventType === "text") {
                    text = text ? text + value : value;
                } else if (eventType === "closetag") {
                    const node = value;
                    switch(node.name){
                        case "r":
                            richText.push({
                                font,
                                text
                            });
                            font = null;
                            text = null;
                            break;
                        case "si":
                            if (this.options.sharedStrings === "cache") {
                                this.sharedStrings.push(richText.length ? {
                                    richText
                                } : text);
                            } else if (this.options.sharedStrings === "emit") {
                                yield {
                                    index: index++,
                                    text: richText.length ? {
                                        richText
                                    } : text
                                };
                            }
                            richText = [];
                            font = null;
                            text = null;
                            break;
                    }
                }
            }
        }
    }
    async _parseStyles(entry) {
        this._emitEntry({
            type: "styles"
        });
        if (this.options.styles === "cache") {
            this.styles = new StyleManager();
            await this.styles.parseStream(iterateStream(entry));
        }
    }
    *_parseWorksheet(iterator, sheetNo) {
        this._emitEntry({
            type: "worksheet",
            id: sheetNo
        });
        const worksheetReader = new WorksheetReader({
            workbook: this,
            id: sheetNo,
            iterator,
            options: this.options
        });
        const matchingRel = (this.workbookRels || []).find((rel)=>rel.Target === `worksheets/sheet${sheetNo}.xml`);
        const matchingSheet = matchingRel && (this.model.sheets || []).find((sheet)=>sheet.rId === matchingRel.Id);
        if (matchingSheet) {
            worksheetReader.id = matchingSheet.id;
            worksheetReader.name = matchingSheet.name;
            worksheetReader.state = matchingSheet.state;
        }
        if (this.options.worksheets === "emit") {
            yield {
                eventType: "worksheet",
                value: worksheetReader
            };
        }
    }
    *_parseHyperlinks(iterator, sheetNo) {
        this._emitEntry({
            type: "hyperlinks",
            id: sheetNo
        });
        const hyperlinksReader = new HyperlinkReader({
            workbook: this,
            id: sheetNo,
            iterator,
            options: this.options
        });
        if (this.options.hyperlinks === "emit") {
            yield {
                eventType: "hyperlinks",
                value: hyperlinksReader
            };
        }
    }
}
// for reference - these are the valid values for options
WorkbookReader.Options = {
    worksheets: [
        "emit",
        "ignore"
    ],
    sharedStrings: [
        "cache",
        "emit",
        "ignore"
    ],
    hyperlinks: [
        "cache",
        "emit",
        "ignore"
    ],
    styles: [
        "cache",
        "ignore"
    ],
    entries: [
        "emit",
        "ignore"
    ]
};
module.exports = WorkbookReader;


/***/ }),

/***/ 78788:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(57147);
const Archiver = __webpack_require__(75985);
const StreamBuf = __webpack_require__(87273);
const RelType = __webpack_require__(39982);
const StylesXform = __webpack_require__(20429);
const SharedStrings = __webpack_require__(95925);
const DefinedNames = __webpack_require__(68179);
const CoreXform = __webpack_require__(81637);
const RelationshipsXform = __webpack_require__(6849);
const ContentTypesXform = __webpack_require__(13518);
const AppXform = __webpack_require__(15081);
const WorkbookXform = __webpack_require__(89297);
const SharedStringsXform = __webpack_require__(99582);
const WorksheetWriter = __webpack_require__(95207);
const theme1Xml = __webpack_require__(90530);
class WorkbookWriter {
    constructor(options){
        options = options || {};
        this.created = options.created || new Date();
        this.modified = options.modified || this.created;
        this.creator = options.creator || "ExcelJS";
        this.lastModifiedBy = options.lastModifiedBy || "ExcelJS";
        this.lastPrinted = options.lastPrinted;
        // using shared strings creates a smaller xlsx file but may use more memory
        this.useSharedStrings = options.useSharedStrings || false;
        this.sharedStrings = new SharedStrings();
        // style manager
        this.styles = options.useStyles ? new StylesXform(true) : new StylesXform.Mock(true);
        // defined names
        this._definedNames = new DefinedNames();
        this._worksheets = [];
        this.views = [];
        this.zipOptions = options.zip;
        this.media = [];
        this.commentRefs = [];
        this.zip = Archiver("zip", this.zipOptions);
        if (options.stream) {
            this.stream = options.stream;
        } else if (options.filename) {
            this.stream = fs.createWriteStream(options.filename);
        } else {
            this.stream = new StreamBuf();
        }
        this.zip.pipe(this.stream);
        // these bits can be added right now
        this.promise = Promise.all([
            this.addThemes(),
            this.addOfficeRels()
        ]);
    }
    get definedNames() {
        return this._definedNames;
    }
    _openStream(path) {
        const stream = new StreamBuf({
            bufSize: 65536,
            batch: true
        });
        this.zip.append(stream, {
            name: path
        });
        stream.on("finish", ()=>{
            stream.emit("zipped");
        });
        return stream;
    }
    _commitWorksheets() {
        const commitWorksheet = function(worksheet) {
            if (!worksheet.committed) {
                return new Promise((resolve)=>{
                    worksheet.stream.on("zipped", ()=>{
                        resolve();
                    });
                    worksheet.commit();
                });
            }
            return Promise.resolve();
        };
        // if there are any uncommitted worksheets, commit them now and wait
        const promises = this._worksheets.map(commitWorksheet);
        if (promises.length) {
            return Promise.all(promises);
        }
        return Promise.resolve();
    }
    async commit() {
        // commit all worksheets, then add suplimentary files
        await this.promise;
        await this.addMedia();
        await this._commitWorksheets();
        await Promise.all([
            this.addContentTypes(),
            this.addApp(),
            this.addCore(),
            this.addSharedStrings(),
            this.addStyles(),
            this.addWorkbookRels()
        ]);
        await this.addWorkbook();
        return this._finalize();
    }
    get nextId() {
        // find the next unique spot to add worksheet
        let i;
        for(i = 1; i < this._worksheets.length; i++){
            if (!this._worksheets[i]) {
                return i;
            }
        }
        return this._worksheets.length || 1;
    }
    addImage(image) {
        const id = this.media.length;
        const medium = Object.assign({}, image, {
            type: "image",
            name: `image${id}.${image.extension}`
        });
        this.media.push(medium);
        return id;
    }
    getImage(id) {
        return this.media[id];
    }
    addWorksheet(name, options) {
        // it's possible to add a worksheet with different than default
        // shared string handling
        // in fact, it's even possible to switch it mid-sheet
        options = options || {};
        const useSharedStrings = options.useSharedStrings !== undefined ? options.useSharedStrings : this.useSharedStrings;
        if (options.tabColor) {
            // eslint-disable-next-line no-console
            console.trace("tabColor option has moved to { properties: tabColor: {...} }");
            options.properties = Object.assign({
                tabColor: options.tabColor
            }, options.properties);
        }
        const id = this.nextId;
        name = name || `sheet${id}`;
        const worksheet = new WorksheetWriter({
            id,
            name,
            workbook: this,
            useSharedStrings,
            properties: options.properties,
            state: options.state,
            pageSetup: options.pageSetup,
            views: options.views,
            autoFilter: options.autoFilter,
            headerFooter: options.headerFooter
        });
        this._worksheets[id] = worksheet;
        return worksheet;
    }
    getWorksheet(id) {
        if (id === undefined) {
            return this._worksheets.find(()=>true);
        }
        if (typeof id === "number") {
            return this._worksheets[id];
        }
        if (typeof id === "string") {
            return this._worksheets.find((worksheet)=>worksheet && worksheet.name === id);
        }
        return undefined;
    }
    addStyles() {
        return new Promise((resolve)=>{
            this.zip.append(this.styles.xml, {
                name: "xl/styles.xml"
            });
            resolve();
        });
    }
    addThemes() {
        return new Promise((resolve)=>{
            this.zip.append(theme1Xml, {
                name: "xl/theme/theme1.xml"
            });
            resolve();
        });
    }
    addOfficeRels() {
        return new Promise((resolve)=>{
            const xform = new RelationshipsXform();
            const xml = xform.toXml([
                {
                    Id: "rId1",
                    Type: RelType.OfficeDocument,
                    Target: "xl/workbook.xml"
                },
                {
                    Id: "rId2",
                    Type: RelType.CoreProperties,
                    Target: "docProps/core.xml"
                },
                {
                    Id: "rId3",
                    Type: RelType.ExtenderProperties,
                    Target: "docProps/app.xml"
                }
            ]);
            this.zip.append(xml, {
                name: "/_rels/.rels"
            });
            resolve();
        });
    }
    addContentTypes() {
        return new Promise((resolve)=>{
            const model = {
                worksheets: this._worksheets.filter(Boolean),
                sharedStrings: this.sharedStrings,
                commentRefs: this.commentRefs,
                media: this.media
            };
            const xform = new ContentTypesXform();
            const xml = xform.toXml(model);
            this.zip.append(xml, {
                name: "[Content_Types].xml"
            });
            resolve();
        });
    }
    addMedia() {
        return Promise.all(this.media.map((medium)=>{
            if (medium.type === "image") {
                const filename = `xl/media/${medium.name}`;
                if (medium.filename) {
                    return this.zip.file(medium.filename, {
                        name: filename
                    });
                }
                if (medium.buffer) {
                    return this.zip.append(medium.buffer, {
                        name: filename
                    });
                }
                if (medium.base64) {
                    const dataimg64 = medium.base64;
                    const content = dataimg64.substring(dataimg64.indexOf(",") + 1);
                    return this.zip.append(content, {
                        name: filename,
                        base64: true
                    });
                }
            }
            throw new Error("Unsupported media");
        }));
    }
    addApp() {
        return new Promise((resolve)=>{
            const model = {
                worksheets: this._worksheets.filter(Boolean)
            };
            const xform = new AppXform();
            const xml = xform.toXml(model);
            this.zip.append(xml, {
                name: "docProps/app.xml"
            });
            resolve();
        });
    }
    addCore() {
        return new Promise((resolve)=>{
            const coreXform = new CoreXform();
            const xml = coreXform.toXml(this);
            this.zip.append(xml, {
                name: "docProps/core.xml"
            });
            resolve();
        });
    }
    addSharedStrings() {
        if (this.sharedStrings.count) {
            return new Promise((resolve)=>{
                const sharedStringsXform = new SharedStringsXform();
                const xml = sharedStringsXform.toXml(this.sharedStrings);
                this.zip.append(xml, {
                    name: "/xl/sharedStrings.xml"
                });
                resolve();
            });
        }
        return Promise.resolve();
    }
    addWorkbookRels() {
        let count = 1;
        const relationships = [
            {
                Id: `rId${count++}`,
                Type: RelType.Styles,
                Target: "styles.xml"
            },
            {
                Id: `rId${count++}`,
                Type: RelType.Theme,
                Target: "theme/theme1.xml"
            }
        ];
        if (this.sharedStrings.count) {
            relationships.push({
                Id: `rId${count++}`,
                Type: RelType.SharedStrings,
                Target: "sharedStrings.xml"
            });
        }
        this._worksheets.forEach((worksheet)=>{
            if (worksheet) {
                worksheet.rId = `rId${count++}`;
                relationships.push({
                    Id: worksheet.rId,
                    Type: RelType.Worksheet,
                    Target: `worksheets/sheet${worksheet.id}.xml`
                });
            }
        });
        return new Promise((resolve)=>{
            const xform = new RelationshipsXform();
            const xml = xform.toXml(relationships);
            this.zip.append(xml, {
                name: "/xl/_rels/workbook.xml.rels"
            });
            resolve();
        });
    }
    addWorkbook() {
        const { zip } = this;
        const model = {
            worksheets: this._worksheets.filter(Boolean),
            definedNames: this._definedNames.model,
            views: this.views,
            properties: {},
            calcProperties: {}
        };
        return new Promise((resolve)=>{
            const xform = new WorkbookXform();
            xform.prepare(model);
            zip.append(xform.toXml(model), {
                name: "/xl/workbook.xml"
            });
            resolve();
        });
    }
    _finalize() {
        return new Promise((resolve, reject)=>{
            this.stream.on("error", reject);
            this.stream.on("finish", ()=>{
                resolve(this);
            });
            this.zip.on("error", reject);
            this.zip.finalize();
        });
    }
}
module.exports = WorkbookWriter;


/***/ }),

/***/ 96487:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { EventEmitter } = __webpack_require__(82361);
const parseSax = __webpack_require__(68595);
const _ = __webpack_require__(96910);
const utils = __webpack_require__(90778);
const colCache = __webpack_require__(90609);
const Dimensions = __webpack_require__(77010);
const Row = __webpack_require__(97524);
const Column = __webpack_require__(72192);
class WorksheetReader extends EventEmitter {
    constructor({ workbook, id, iterator, options }){
        super();
        this.workbook = workbook;
        this.id = id;
        this.iterator = iterator;
        this.options = options || {};
        // and a name
        this.name = `Sheet${this.id}`;
        // column definitions
        this._columns = null;
        this._keys = {};
        // keep a record of dimensions
        this._dimensions = new Dimensions();
    }
    // destroy - not a valid operation for a streaming writer
    // even though some streamers might be able to, it's a bad idea.
    destroy() {
        throw new Error("Invalid Operation: destroy");
    }
    // return the current dimensions of the writer
    get dimensions() {
        return this._dimensions;
    }
    // =========================================================================
    // Columns
    // get the current columns array.
    get columns() {
        return this._columns;
    }
    // get a single column by col number. If it doesn't exist, it and any gaps before it
    // are created.
    getColumn(c) {
        if (typeof c === "string") {
            // if it matches a key'd column, return that
            const col = this._keys[c];
            if (col) {
                return col;
            }
            // otherise, assume letter
            c = colCache.l2n(c);
        }
        if (!this._columns) {
            this._columns = [];
        }
        if (c > this._columns.length) {
            let n = this._columns.length + 1;
            while(n <= c){
                this._columns.push(new Column(this, n++));
            }
        }
        return this._columns[c - 1];
    }
    getColumnKey(key) {
        return this._keys[key];
    }
    setColumnKey(key, value) {
        this._keys[key] = value;
    }
    deleteColumnKey(key) {
        delete this._keys[key];
    }
    eachColumnKey(f) {
        _.each(this._keys, f);
    }
    async read() {
        try {
            for await (const events of this.parse()){
                for (const { eventType, value } of events){
                    this.emit(eventType, value);
                }
            }
            this.emit("finished");
        } catch (error) {
            this.emit("error", error);
        }
    }
    async *[Symbol.asyncIterator]() {
        for await (const events of this.parse()){
            for (const { eventType, value } of events){
                if (eventType === "row") {
                    yield value;
                }
            }
        }
    }
    async *parse() {
        const { iterator, options } = this;
        let emitSheet = false;
        let emitHyperlinks = false;
        let hyperlinks = null;
        switch(options.worksheets){
            case "emit":
                emitSheet = true;
                break;
            case "prep":
                break;
            default:
                break;
        }
        switch(options.hyperlinks){
            case "emit":
                emitHyperlinks = true;
                break;
            case "cache":
                this.hyperlinks = hyperlinks = {};
                break;
            default:
                break;
        }
        if (!emitSheet && !emitHyperlinks && !hyperlinks) {
            return;
        }
        // references
        const { sharedStrings, styles, properties } = this.workbook;
        // xml position
        let inCols = false;
        let inRows = false;
        let inHyperlinks = false;
        // parse state
        let cols = null;
        let row = null;
        let c = null;
        let current = null;
        for await (const events of parseSax(iterator)){
            const worksheetEvents = [];
            for (const { eventType, value } of events){
                if (eventType === "opentag") {
                    const node = value;
                    if (emitSheet) {
                        switch(node.name){
                            case "cols":
                                inCols = true;
                                cols = [];
                                break;
                            case "sheetData":
                                inRows = true;
                                break;
                            case "col":
                                if (inCols) {
                                    cols.push({
                                        min: parseInt(node.attributes.min, 10),
                                        max: parseInt(node.attributes.max, 10),
                                        width: parseFloat(node.attributes.width),
                                        styleId: parseInt(node.attributes.style || "0", 10)
                                    });
                                }
                                break;
                            case "row":
                                if (inRows) {
                                    const r = parseInt(node.attributes.r, 10);
                                    row = new Row(this, r);
                                    if (node.attributes.ht) {
                                        row.height = parseFloat(node.attributes.ht);
                                    }
                                    if (node.attributes.s) {
                                        const styleId = parseInt(node.attributes.s, 10);
                                        const style = styles.getStyleModel(styleId);
                                        if (style) {
                                            row.style = style;
                                        }
                                    }
                                }
                                break;
                            case "c":
                                if (row) {
                                    c = {
                                        ref: node.attributes.r,
                                        s: parseInt(node.attributes.s, 10),
                                        t: node.attributes.t
                                    };
                                }
                                break;
                            case "f":
                                if (c) {
                                    current = c.f = {
                                        text: ""
                                    };
                                }
                                break;
                            case "v":
                                if (c) {
                                    current = c.v = {
                                        text: ""
                                    };
                                }
                                break;
                            case "is":
                            case "t":
                                if (c) {
                                    current = c.v = {
                                        text: ""
                                    };
                                }
                                break;
                            case "mergeCell":
                                break;
                            default:
                                break;
                        }
                    }
                    // =================================================================
                    //
                    if (emitHyperlinks || hyperlinks) {
                        switch(node.name){
                            case "hyperlinks":
                                inHyperlinks = true;
                                break;
                            case "hyperlink":
                                if (inHyperlinks) {
                                    const hyperlink = {
                                        ref: node.attributes.ref,
                                        rId: node.attributes["r:id"]
                                    };
                                    if (emitHyperlinks) {
                                        worksheetEvents.push({
                                            eventType: "hyperlink",
                                            value: hyperlink
                                        });
                                    } else {
                                        hyperlinks[hyperlink.ref] = hyperlink;
                                    }
                                }
                                break;
                            default:
                                break;
                        }
                    }
                } else if (eventType === "text") {
                    // only text data is for sheet values
                    if (emitSheet) {
                        if (current) {
                            current.text += value;
                        }
                    }
                } else if (eventType === "closetag") {
                    const node = value;
                    if (emitSheet) {
                        switch(node.name){
                            case "cols":
                                inCols = false;
                                this._columns = Column.fromModel(cols);
                                break;
                            case "sheetData":
                                inRows = false;
                                break;
                            case "row":
                                this._dimensions.expandRow(row);
                                worksheetEvents.push({
                                    eventType: "row",
                                    value: row
                                });
                                row = null;
                                break;
                            case "c":
                                if (row && c) {
                                    const address = colCache.decodeAddress(c.ref);
                                    const cell = row.getCell(address.col);
                                    if (c.s) {
                                        const style = styles.getStyleModel(c.s);
                                        if (style) {
                                            cell.style = style;
                                        }
                                    }
                                    if (c.f) {
                                        const cellValue = {
                                            formula: c.f.text
                                        };
                                        if (c.v) {
                                            if (c.t === "str") {
                                                cellValue.result = utils.xmlDecode(c.v.text);
                                            } else {
                                                cellValue.result = parseFloat(c.v.text);
                                            }
                                        }
                                        cell.value = cellValue;
                                    } else if (c.v) {
                                        switch(c.t){
                                            case "s":
                                                {
                                                    const index = parseInt(c.v.text, 10);
                                                    if (sharedStrings) {
                                                        cell.value = sharedStrings[index];
                                                    } else {
                                                        cell.value = {
                                                            sharedString: index
                                                        };
                                                    }
                                                    break;
                                                }
                                            case "inlineStr":
                                            case "str":
                                                cell.value = utils.xmlDecode(c.v.text);
                                                break;
                                            case "e":
                                                cell.value = {
                                                    error: c.v.text
                                                };
                                                break;
                                            case "b":
                                                cell.value = parseInt(c.v.text, 10) !== 0;
                                                break;
                                            default:
                                                if (utils.isDateFmt(cell.numFmt)) {
                                                    cell.value = utils.excelToDate(parseFloat(c.v.text), properties.model && properties.model.date1904);
                                                } else {
                                                    cell.value = parseFloat(c.v.text);
                                                }
                                                break;
                                        }
                                    }
                                    if (hyperlinks) {
                                        const hyperlink = hyperlinks[c.ref];
                                        if (hyperlink) {
                                            cell.text = cell.value;
                                            cell.value = undefined;
                                            cell.hyperlink = hyperlink;
                                        }
                                    }
                                    c = null;
                                }
                                break;
                            default:
                                break;
                        }
                    }
                    if (emitHyperlinks || hyperlinks) {
                        switch(node.name){
                            case "hyperlinks":
                                inHyperlinks = false;
                                break;
                            default:
                                break;
                        }
                    }
                }
            }
            if (worksheetEvents.length > 0) {
                yield worksheetEvents;
            }
        }
    }
}
module.exports = WorksheetReader;


/***/ }),

/***/ 95207:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
const RelType = __webpack_require__(39982);
const colCache = __webpack_require__(90609);
const Encryptor = __webpack_require__(91573);
const Dimensions = __webpack_require__(77010);
const StringBuf = __webpack_require__(53096);
const Row = __webpack_require__(97524);
const Column = __webpack_require__(72192);
const SheetRelsWriter = __webpack_require__(48501);
const SheetCommentsWriter = __webpack_require__(87405);
const DataValidations = __webpack_require__(62828);
const xmlBuffer = new StringBuf();
// ============================================================================================
// Xforms
const ListXform = __webpack_require__(34397);
const DataValidationsXform = __webpack_require__(23303);
const SheetPropertiesXform = __webpack_require__(83050);
const SheetFormatPropertiesXform = __webpack_require__(79682);
const ColXform = __webpack_require__(57950);
const RowXform = __webpack_require__(39285);
const HyperlinkXform = __webpack_require__(83942);
const SheetViewXform = __webpack_require__(94120);
const SheetProtectionXform = __webpack_require__(59438);
const PageMarginsXform = __webpack_require__(27674);
const PageSetupXform = __webpack_require__(20358);
const AutoFilterXform = __webpack_require__(44353);
const PictureXform = __webpack_require__(718);
const ConditionalFormattingsXform = __webpack_require__(88312);
const HeaderFooterXform = __webpack_require__(28086);
const RowBreaksXform = __webpack_require__(7077);
// since prepare and render are functional, we can use singletons
const xform = {
    dataValidations: new DataValidationsXform(),
    sheetProperties: new SheetPropertiesXform(),
    sheetFormatProperties: new SheetFormatPropertiesXform(),
    columns: new ListXform({
        tag: "cols",
        length: false,
        childXform: new ColXform()
    }),
    row: new RowXform(),
    hyperlinks: new ListXform({
        tag: "hyperlinks",
        length: false,
        childXform: new HyperlinkXform()
    }),
    sheetViews: new ListXform({
        tag: "sheetViews",
        length: false,
        childXform: new SheetViewXform()
    }),
    sheetProtection: new SheetProtectionXform(),
    pageMargins: new PageMarginsXform(),
    pageSeteup: new PageSetupXform(),
    autoFilter: new AutoFilterXform(),
    picture: new PictureXform(),
    conditionalFormattings: new ConditionalFormattingsXform(),
    headerFooter: new HeaderFooterXform(),
    rowBreaks: new RowBreaksXform()
};
// ============================================================================================
class WorksheetWriter {
    constructor(options){
        // in a workbook, each sheet will have a number
        this.id = options.id;
        // and a name
        this.name = options.name || `Sheet${this.id}`;
        // add a state
        this.state = options.state || "visible";
        // rows are stored here while they need to be worked on.
        // when they are committed, they will be deleted.
        this._rows = [];
        // column definitions
        this._columns = null;
        // column keys (addRow convenience): key ==> this._columns index
        this._keys = {};
        // keep a record of all row and column pageBreaks
        this._merges = [];
        this._merges.add = function() {}; // ignore cell instruction
        // keep record of all hyperlinks
        this._sheetRelsWriter = new SheetRelsWriter(options);
        this._sheetCommentsWriter = new SheetCommentsWriter(this, this._sheetRelsWriter, options);
        // keep a record of dimensions
        this._dimensions = new Dimensions();
        // first uncommitted row
        this._rowZero = 1;
        // committed flag
        this.committed = false;
        // for data validations
        this.dataValidations = new DataValidations();
        // for sharing formulae
        this._formulae = {};
        this._siFormulae = 0;
        // keep a record of conditionalFormattings
        this.conditionalFormatting = [];
        // keep a record of all row and column pageBreaks
        this.rowBreaks = [];
        // for default row height, outline levels, etc
        this.properties = Object.assign({}, {
            defaultRowHeight: 15,
            dyDescent: 55,
            outlineLevelCol: 0,
            outlineLevelRow: 0
        }, options.properties);
        this.headerFooter = Object.assign({}, {
            differentFirst: false,
            differentOddEven: false,
            oddHeader: null,
            oddFooter: null,
            evenHeader: null,
            evenFooter: null,
            firstHeader: null,
            firstFooter: null
        }, options.headerFooter);
        // for all things printing
        this.pageSetup = Object.assign({}, {
            margins: {
                left: 0.7,
                right: 0.7,
                top: 0.75,
                bottom: 0.75,
                header: 0.3,
                footer: 0.3
            },
            orientation: "portrait",
            horizontalDpi: 4294967295,
            verticalDpi: 4294967295,
            fitToPage: !!(options.pageSetup && (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) && !options.pageSetup.scale),
            pageOrder: "downThenOver",
            blackAndWhite: false,
            draft: false,
            cellComments: "None",
            errors: "displayed",
            scale: 100,
            fitToWidth: 1,
            fitToHeight: 1,
            paperSize: undefined,
            showRowColHeaders: false,
            showGridLines: false,
            horizontalCentered: false,
            verticalCentered: false,
            rowBreaks: null,
            colBreaks: null
        }, options.pageSetup);
        // using shared strings creates a smaller xlsx file but may use more memory
        this.useSharedStrings = options.useSharedStrings || false;
        this._workbook = options.workbook;
        this.hasComments = false;
        // views
        this._views = options.views || [];
        // auto filter
        this.autoFilter = options.autoFilter || null;
        this._media = [];
        // worksheet protection
        this.sheetProtection = null;
        // start writing to stream now
        this._writeOpenWorksheet();
        this.startedData = false;
    }
    get workbook() {
        return this._workbook;
    }
    get stream() {
        if (!this._stream) {
            // eslint-disable-next-line no-underscore-dangle
            this._stream = this._workbook._openStream(`/xl/worksheets/sheet${this.id}.xml`);
            // pause stream to prevent 'data' events
            this._stream.pause();
        }
        return this._stream;
    }
    // destroy - not a valid operation for a streaming writer
    // even though some streamers might be able to, it's a bad idea.
    destroy() {
        throw new Error("Invalid Operation: destroy");
    }
    commit() {
        if (this.committed) {
            return;
        }
        // commit all rows
        this._rows.forEach((cRow)=>{
            if (cRow) {
                // write the row to the stream
                this._writeRow(cRow);
            }
        });
        // we _cannot_ accept new rows from now on
        this._rows = null;
        if (!this.startedData) {
            this._writeOpenSheetData();
        }
        this._writeCloseSheetData();
        this._writeAutoFilter();
        this._writeMergeCells();
        // for some reason, Excel can't handle dimensions at the bottom of the file
        // this._writeDimensions();
        this._writeHyperlinks();
        this._writeConditionalFormatting();
        this._writeDataValidations();
        this._writeSheetProtection();
        this._writePageMargins();
        this._writePageSetup();
        this._writeBackground();
        this._writeHeaderFooter();
        this._writeRowBreaks();
        // Legacy Data tag for comments
        this._writeLegacyData();
        this._writeCloseWorksheet();
        // signal end of stream to workbook
        this.stream.end();
        this._sheetCommentsWriter.commit();
        // also commit the hyperlinks if any
        this._sheetRelsWriter.commit();
        this.committed = true;
    }
    // return the current dimensions of the writer
    get dimensions() {
        return this._dimensions;
    }
    get views() {
        return this._views;
    }
    // =========================================================================
    // Columns
    // get the current columns array.
    get columns() {
        return this._columns;
    }
    // set the columns from an array of column definitions.
    // Note: any headers defined will overwrite existing values.
    set columns(value) {
        // calculate max header row count
        this._headerRowCount = value.reduce((pv, cv)=>{
            const headerCount = cv.header && 1 || cv.headers && cv.headers.length || 0;
            return Math.max(pv, headerCount);
        }, 0);
        // construct Column objects
        let count = 1;
        const columns = this._columns = [];
        value.forEach((defn)=>{
            const column = new Column(this, count++, false);
            columns.push(column);
            column.defn = defn;
        });
    }
    getColumnKey(key) {
        return this._keys[key];
    }
    setColumnKey(key, value) {
        this._keys[key] = value;
    }
    deleteColumnKey(key) {
        delete this._keys[key];
    }
    eachColumnKey(f) {
        _.each(this._keys, f);
    }
    // get a single column by col number. If it doesn't exist, it and any gaps before it
    // are created.
    getColumn(c) {
        if (typeof c === "string") {
            // if it matches a key'd column, return that
            const col = this._keys[c];
            if (col) return col;
            // otherwise, assume letter
            c = colCache.l2n(c);
        }
        if (!this._columns) {
            this._columns = [];
        }
        if (c > this._columns.length) {
            let n = this._columns.length + 1;
            while(n <= c){
                this._columns.push(new Column(this, n++));
            }
        }
        return this._columns[c - 1];
    }
    // =========================================================================
    // Rows
    get _nextRow() {
        return this._rowZero + this._rows.length;
    }
    // iterate over every uncommitted row in the worksheet, including maybe empty rows
    eachRow(options, iteratee) {
        if (!iteratee) {
            iteratee = options;
            options = undefined;
        }
        if (options && options.includeEmpty) {
            const n = this._nextRow;
            for(let i = this._rowZero; i < n; i++){
                iteratee(this.getRow(i), i);
            }
        } else {
            this._rows.forEach((row)=>{
                if (row.hasValues) {
                    iteratee(row, row.number);
                }
            });
        }
    }
    _commitRow(cRow) {
        // since rows must be written in order, we commit all rows up till and including cRow
        let found = false;
        while(this._rows.length && !found){
            const row = this._rows.shift();
            this._rowZero++;
            if (row) {
                this._writeRow(row);
                found = row.number === cRow.number;
                this._rowZero = row.number + 1;
            }
        }
    }
    get lastRow() {
        // returns last uncommitted row
        if (this._rows.length) {
            return this._rows[this._rows.length - 1];
        }
        return undefined;
    }
    // find a row (if exists) by row number
    findRow(rowNumber) {
        const index = rowNumber - this._rowZero;
        return this._rows[index];
    }
    getRow(rowNumber) {
        const index = rowNumber - this._rowZero;
        // may fail if rows have been comitted
        if (index < 0) {
            throw new Error("Out of bounds: this row has been committed");
        }
        let row = this._rows[index];
        if (!row) {
            this._rows[index] = row = new Row(this, rowNumber);
        }
        return row;
    }
    addRow(value) {
        const row = new Row(this, this._nextRow);
        this._rows[row.number - this._rowZero] = row;
        row.values = value;
        return row;
    }
    // ================================================================================
    // Cells
    // returns the cell at [r,c] or address given by r. If not found, return undefined
    findCell(r, c) {
        const address = colCache.getAddress(r, c);
        const row = this.findRow(address.row);
        return row ? row.findCell(address.column) : undefined;
    }
    // return the cell at [r,c] or address given by r. If not found, create a new one.
    getCell(r, c) {
        const address = colCache.getAddress(r, c);
        const row = this.getRow(address.row);
        return row.getCellEx(address);
    }
    mergeCells(...cells) {
        // may fail if rows have been comitted
        const dimensions = new Dimensions(cells);
        // check cells aren't already merged
        this._merges.forEach((merge)=>{
            if (merge.intersects(dimensions)) {
                throw new Error("Cannot merge already merged cells");
            }
        });
        // apply merge
        const master = this.getCell(dimensions.top, dimensions.left);
        for(let i = dimensions.top; i <= dimensions.bottom; i++){
            for(let j = dimensions.left; j <= dimensions.right; j++){
                if (i > dimensions.top || j > dimensions.left) {
                    this.getCell(i, j).merge(master);
                }
            }
        }
        // index merge
        this._merges.push(dimensions);
    }
    // ===========================================================================
    // Conditional Formatting
    addConditionalFormatting(cf) {
        this.conditionalFormatting.push(cf);
    }
    removeConditionalFormatting(filter) {
        if (typeof filter === "number") {
            this.conditionalFormatting.splice(filter, 1);
        } else if (filter instanceof Function) {
            this.conditionalFormatting = this.conditionalFormatting.filter(filter);
        } else {
            this.conditionalFormatting = [];
        }
    }
    // =========================================================================
    addBackgroundImage(imageId) {
        this._background = {
            imageId
        };
    }
    getBackgroundImageId() {
        return this._background && this._background.imageId;
    }
    // =========================================================================
    // Worksheet Protection
    protect(password, options) {
        // TODO: make this function truly async
        // perhaps marshal to worker thread or something
        return new Promise((resolve)=>{
            this.sheetProtection = {
                sheet: true
            };
            if (options && "spinCount" in options) {
                // force spinCount to be integer >= 0
                options.spinCount = Number.isFinite(options.spinCount) ? Math.round(Math.max(0, options.spinCount)) : 100000;
            }
            if (password) {
                this.sheetProtection.algorithmName = "SHA-512";
                this.sheetProtection.saltValue = Encryptor.randomBytes(16).toString("base64");
                this.sheetProtection.spinCount = options && "spinCount" in options ? options.spinCount : 100000; // allow user specified spinCount
                this.sheetProtection.hashValue = Encryptor.convertPasswordToHash(password, "SHA512", this.sheetProtection.saltValue, this.sheetProtection.spinCount);
            }
            if (options) {
                this.sheetProtection = Object.assign(this.sheetProtection, options);
                if (!password && "spinCount" in options) {
                    delete this.sheetProtection.spinCount;
                }
            }
            resolve();
        });
    }
    unprotect() {
        this.sheetProtection = null;
    }
    // ================================================================================
    _write(text) {
        xmlBuffer.reset();
        xmlBuffer.addText(text);
        this.stream.write(xmlBuffer);
    }
    _writeSheetProperties(xmlBuf, properties, pageSetup) {
        const sheetPropertiesModel = {
            outlineProperties: properties && properties.outlineProperties,
            tabColor: properties && properties.tabColor,
            pageSetup: pageSetup && pageSetup.fitToPage ? {
                fitToPage: pageSetup.fitToPage
            } : undefined
        };
        xmlBuf.addText(xform.sheetProperties.toXml(sheetPropertiesModel));
    }
    _writeSheetFormatProperties(xmlBuf, properties) {
        const sheetFormatPropertiesModel = properties ? {
            defaultRowHeight: properties.defaultRowHeight,
            dyDescent: properties.dyDescent,
            outlineLevelCol: properties.outlineLevelCol,
            outlineLevelRow: properties.outlineLevelRow
        } : undefined;
        if (properties.defaultColWidth) {
            sheetFormatPropertiesModel.defaultColWidth = properties.defaultColWidth;
        }
        xmlBuf.addText(xform.sheetFormatProperties.toXml(sheetFormatPropertiesModel));
    }
    _writeOpenWorksheet() {
        xmlBuffer.reset();
        xmlBuffer.addText('<?xml version="1.0" encoding="UTF-8" standalone="yes"?>');
        xmlBuffer.addText('<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"' + ' xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"' + ' xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"' + ' mc:Ignorable="x14ac"' + ' xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">');
        this._writeSheetProperties(xmlBuffer, this.properties, this.pageSetup);
        xmlBuffer.addText(xform.sheetViews.toXml(this.views));
        this._writeSheetFormatProperties(xmlBuffer, this.properties);
        this.stream.write(xmlBuffer);
    }
    _writeColumns() {
        const cols = Column.toModel(this.columns);
        if (cols) {
            xform.columns.prepare(cols, {
                styles: this._workbook.styles
            });
            this.stream.write(xform.columns.toXml(cols));
        }
    }
    _writeOpenSheetData() {
        this._write("<sheetData>");
    }
    _writeRow(row) {
        if (!this.startedData) {
            this._writeColumns();
            this._writeOpenSheetData();
            this.startedData = true;
        }
        if (row.hasValues || row.height) {
            const { model } = row;
            const options = {
                styles: this._workbook.styles,
                sharedStrings: this.useSharedStrings ? this._workbook.sharedStrings : undefined,
                hyperlinks: this._sheetRelsWriter.hyperlinksProxy,
                merges: this._merges,
                formulae: this._formulae,
                siFormulae: this._siFormulae,
                comments: []
            };
            xform.row.prepare(model, options);
            this.stream.write(xform.row.toXml(model));
            if (options.comments.length) {
                this.hasComments = true;
                this._sheetCommentsWriter.addComments(options.comments);
            }
        }
    }
    _writeCloseSheetData() {
        this._write("</sheetData>");
    }
    _writeMergeCells() {
        if (this._merges.length) {
            xmlBuffer.reset();
            xmlBuffer.addText(`<mergeCells count="${this._merges.length}">`);
            this._merges.forEach((merge)=>{
                xmlBuffer.addText(`<mergeCell ref="${merge}"/>`);
            });
            xmlBuffer.addText("</mergeCells>");
            this.stream.write(xmlBuffer);
        }
    }
    _writeHyperlinks() {
        // eslint-disable-next-line no-underscore-dangle
        this.stream.write(xform.hyperlinks.toXml(this._sheetRelsWriter._hyperlinks));
    }
    _writeConditionalFormatting() {
        const options = {
            styles: this._workbook.styles
        };
        xform.conditionalFormattings.prepare(this.conditionalFormatting, options);
        this.stream.write(xform.conditionalFormattings.toXml(this.conditionalFormatting));
    }
    _writeRowBreaks() {
        this.stream.write(xform.rowBreaks.toXml(this.rowBreaks));
    }
    _writeDataValidations() {
        this.stream.write(xform.dataValidations.toXml(this.dataValidations.model));
    }
    _writeSheetProtection() {
        this.stream.write(xform.sheetProtection.toXml(this.sheetProtection));
    }
    _writePageMargins() {
        this.stream.write(xform.pageMargins.toXml(this.pageSetup.margins));
    }
    _writePageSetup() {
        this.stream.write(xform.pageSeteup.toXml(this.pageSetup));
    }
    _writeHeaderFooter() {
        this.stream.write(xform.headerFooter.toXml(this.headerFooter));
    }
    _writeAutoFilter() {
        this.stream.write(xform.autoFilter.toXml(this.autoFilter));
    }
    _writeBackground() {
        if (this._background) {
            if (this._background.imageId !== undefined) {
                const image = this._workbook.getImage(this._background.imageId);
                const pictureId = this._sheetRelsWriter.addMedia({
                    Target: `../media/${image.name}`,
                    Type: RelType.Image
                });
                this._background = {
                    ...this._background,
                    rId: pictureId
                };
            }
            this.stream.write(xform.picture.toXml({
                rId: this._background.rId
            }));
        }
    }
    _writeLegacyData() {
        if (this.hasComments) {
            xmlBuffer.reset();
            xmlBuffer.addText(`<legacyDrawing r:id="${this._sheetCommentsWriter.vmlRelId}"/>`);
            this.stream.write(xmlBuffer);
        }
    }
    _writeDimensions() {
    // for some reason, Excel can't handle dimensions at the bottom of the file
    // and we don't know the dimensions until the commit, so don't write them.
    // this._write('<dimension ref="' + this._dimensions + '"/>');
    }
    _writeCloseWorksheet() {
        this._write("</worksheet>");
    }
}
module.exports = WorksheetWriter;


/***/ }),

/***/ 13491:
/***/ ((__unused_webpack_module, exports) => {

// eslint-disable-next-line node/no-unsupported-features/node-builtins
const textDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8");
function bufferToString(chunk) {
    if (typeof chunk === "string") {
        return chunk;
    }
    if (textDecoder) {
        return textDecoder.decode(chunk);
    }
    return chunk.toString();
}
exports.bufferToString = bufferToString;


/***/ }),

/***/ 27615:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// eslint-disable-next-line node/no-unsupported-features/node-builtins
const textEncoder = typeof TextEncoder === "undefined" ? null : new TextEncoder("utf-8");
const { Buffer } = __webpack_require__(14300);
function stringToBuffer(str) {
    if (typeof str !== "string") {
        return str;
    }
    if (textEncoder) {
        return Buffer.from(textEncoder.encode(str).buffer);
    }
    return Buffer.from(str);
}
exports.stringToBuffer = stringToBuffer;


/***/ }),

/***/ 16491:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
const colCache = __webpack_require__(90609);
class CellMatrix {
    constructor(template){
        this.template = template;
        this.sheets = {};
    }
    addCell(addressStr) {
        this.addCellEx(colCache.decodeEx(addressStr));
    }
    getCell(addressStr) {
        return this.findCellEx(colCache.decodeEx(addressStr), true);
    }
    findCell(addressStr) {
        return this.findCellEx(colCache.decodeEx(addressStr), false);
    }
    findCellAt(sheetName, rowNumber, colNumber) {
        const sheet = this.sheets[sheetName];
        const row = sheet && sheet[rowNumber];
        return row && row[colNumber];
    }
    addCellEx(address) {
        if (address.top) {
            for(let row = address.top; row <= address.bottom; row++){
                for(let col = address.left; col <= address.right; col++){
                    this.getCellAt(address.sheetName, row, col);
                }
            }
        } else {
            this.findCellEx(address, true);
        }
    }
    getCellEx(address) {
        return this.findCellEx(address, true);
    }
    findCellEx(address, create) {
        const sheet = this.findSheet(address, create);
        const row = this.findSheetRow(sheet, address, create);
        return this.findRowCell(row, address, create);
    }
    getCellAt(sheetName, rowNumber, colNumber) {
        const sheet = this.sheets[sheetName] || (this.sheets[sheetName] = []);
        const row = sheet[rowNumber] || (sheet[rowNumber] = []);
        const cell = row[colNumber] || (row[colNumber] = {
            sheetName,
            address: colCache.n2l(colNumber) + rowNumber,
            row: rowNumber,
            col: colNumber
        });
        return cell;
    }
    removeCellEx(address) {
        const sheet = this.findSheet(address);
        if (!sheet) {
            return;
        }
        const row = this.findSheetRow(sheet, address);
        if (!row) {
            return;
        }
        delete row[address.col];
    }
    forEachInSheet(sheetName, callback) {
        const sheet = this.sheets[sheetName];
        if (sheet) {
            sheet.forEach((row, rowNumber)=>{
                if (row) {
                    row.forEach((cell, colNumber)=>{
                        if (cell) {
                            callback(cell, rowNumber, colNumber);
                        }
                    });
                }
            });
        }
    }
    forEach(callback) {
        _.each(this.sheets, (sheet, sheetName)=>{
            this.forEachInSheet(sheetName, callback);
        });
    }
    map(callback) {
        const results = [];
        this.forEach((cell)=>{
            results.push(callback(cell));
        });
        return results;
    }
    findSheet(address, create) {
        const name = address.sheetName;
        if (this.sheets[name]) {
            return this.sheets[name];
        }
        if (create) {
            return this.sheets[name] = [];
        }
        return undefined;
    }
    findSheetRow(sheet, address, create) {
        const { row } = address;
        if (sheet && sheet[row]) {
            return sheet[row];
        }
        if (create) {
            return sheet[row] = [];
        }
        return undefined;
    }
    findRowCell(row, address, create) {
        const { col } = address;
        if (row && row[col]) {
            return row[col];
        }
        if (create) {
            return row[col] = this.template ? Object.assign(address, JSON.parse(JSON.stringify(this.template))) : address;
        }
        return undefined;
    }
    spliceRows(sheetName, start, numDelete, numInsert) {
        const sheet = this.sheets[sheetName];
        if (sheet) {
            const inserts = [];
            for(let i = 0; i < numInsert; i++){
                inserts.push([]);
            }
            sheet.splice(start, numDelete, ...inserts);
        }
    }
    spliceColumns(sheetName, start, numDelete, numInsert) {
        const sheet = this.sheets[sheetName];
        if (sheet) {
            const inserts = [];
            for(let i = 0; i < numInsert; i++){
                inserts.push(null);
            }
            _.each(sheet, (row)=>{
                row.splice(start, numDelete, ...inserts);
            });
        }
    }
}
module.exports = CellMatrix;


/***/ }),

/***/ 90609:
/***/ ((module) => {

"use strict";

const addressRegex = /^[A-Z]+\d+$/;
// =========================================================================
// Column Letter to Number conversion
const colCache = {
    _dictionary: [
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z"
    ],
    _l2nFill: 0,
    _l2n: {},
    _n2l: [],
    _level (n) {
        if (n <= 26) {
            return 1;
        }
        if (n <= 26 * 26) {
            return 2;
        }
        return 3;
    },
    _fill (level) {
        let c;
        let v;
        let l1;
        let l2;
        let l3;
        let n = 1;
        if (level >= 4) {
            throw new Error("Out of bounds. Excel supports columns from 1 to 16384");
        }
        if (this._l2nFill < 1 && level >= 1) {
            while(n <= 26){
                c = this._dictionary[n - 1];
                this._n2l[n] = c;
                this._l2n[c] = n;
                n++;
            }
            this._l2nFill = 1;
        }
        if (this._l2nFill < 2 && level >= 2) {
            n = 27;
            while(n <= 26 + 26 * 26){
                v = n - (26 + 1);
                l1 = v % 26;
                l2 = Math.floor(v / 26);
                c = this._dictionary[l2] + this._dictionary[l1];
                this._n2l[n] = c;
                this._l2n[c] = n;
                n++;
            }
            this._l2nFill = 2;
        }
        if (this._l2nFill < 3 && level >= 3) {
            n = 26 + 26 * 26 + 1;
            while(n <= 16384){
                v = n - (26 * 26 + 26 + 1);
                l1 = v % 26;
                l2 = Math.floor(v / 26) % 26;
                l3 = Math.floor(v / (26 * 26));
                c = this._dictionary[l3] + this._dictionary[l2] + this._dictionary[l1];
                this._n2l[n] = c;
                this._l2n[c] = n;
                n++;
            }
            this._l2nFill = 3;
        }
    },
    l2n (l) {
        if (!this._l2n[l]) {
            this._fill(l.length);
        }
        if (!this._l2n[l]) {
            throw new Error(`Out of bounds. Invalid column letter: ${l}`);
        }
        return this._l2n[l];
    },
    n2l (n) {
        if (n < 1 || n > 16384) {
            throw new Error(`${n} is out of bounds. Excel supports columns from 1 to 16384`);
        }
        if (!this._n2l[n]) {
            this._fill(this._level(n));
        }
        return this._n2l[n];
    },
    // =========================================================================
    // Address processing
    _hash: {},
    // check if value looks like an address
    validateAddress (value) {
        if (!addressRegex.test(value)) {
            throw new Error(`Invalid Address: ${value}`);
        }
        return true;
    },
    // convert address string into structure
    decodeAddress (value) {
        const addr = value.length < 5 && this._hash[value];
        if (addr) {
            return addr;
        }
        let hasCol = false;
        let col = "";
        let colNumber = 0;
        let hasRow = false;
        let row = "";
        let rowNumber = 0;
        for(let i = 0, char; i < value.length; i++){
            char = value.charCodeAt(i);
            // col should before row
            if (!hasRow && char >= 65 && char <= 90) {
                // 65 = 'A'.charCodeAt(0)
                // 90 = 'Z'.charCodeAt(0)
                hasCol = true;
                col += value[i];
                // colNumber starts from 1
                colNumber = colNumber * 26 + char - 64;
            } else if (char >= 48 && char <= 57) {
                // 48 = '0'.charCodeAt(0)
                // 57 = '9'.charCodeAt(0)
                hasRow = true;
                row += value[i];
                // rowNumber starts from 0
                rowNumber = rowNumber * 10 + char - 48;
            } else if (hasRow && hasCol && char !== 36) {
                break;
            }
        }
        if (!hasCol) {
            colNumber = undefined;
        } else if (colNumber > 16384) {
            throw new Error(`Out of bounds. Invalid column letter: ${col}`);
        }
        if (!hasRow) {
            rowNumber = undefined;
        }
        // in case $row$col
        value = col + row;
        const address = {
            address: value,
            col: colNumber,
            row: rowNumber,
            $col$row: `$${col}$${row}`
        };
        // mem fix - cache only the tl 100x100 square
        if (colNumber <= 100 && rowNumber <= 100) {
            this._hash[value] = address;
            this._hash[address.$col$row] = address;
        }
        return address;
    },
    // convert r,c into structure (if only 1 arg, assume r is address string)
    getAddress (r, c) {
        if (c) {
            const address = this.n2l(c) + r;
            return this.decodeAddress(address);
        }
        return this.decodeAddress(r);
    },
    // convert [address], [tl:br] into address structures
    decode (value) {
        const parts = value.split(":");
        if (parts.length === 2) {
            const tl = this.decodeAddress(parts[0]);
            const br = this.decodeAddress(parts[1]);
            const result = {
                top: Math.min(tl.row, br.row),
                left: Math.min(tl.col, br.col),
                bottom: Math.max(tl.row, br.row),
                right: Math.max(tl.col, br.col)
            };
            // reconstruct tl, br and dimensions
            result.tl = this.n2l(result.left) + result.top;
            result.br = this.n2l(result.right) + result.bottom;
            result.dimensions = `${result.tl}:${result.br}`;
            return result;
        }
        return this.decodeAddress(value);
    },
    // convert [sheetName!][$]col[$]row[[$]col[$]row] into address or range structures
    decodeEx (value) {
        const groups = value.match(/(?:(?:(?:'((?:[^']|'')*)')|([^'^ !]*))!)?(.*)/);
        const sheetName = groups[1] || groups[2]; // Qouted and unqouted groups
        const reference = groups[3]; // Remaining address
        const parts = reference.split(":");
        if (parts.length > 1) {
            let tl = this.decodeAddress(parts[0]);
            let br = this.decodeAddress(parts[1]);
            const top = Math.min(tl.row, br.row);
            const left = Math.min(tl.col, br.col);
            const bottom = Math.max(tl.row, br.row);
            const right = Math.max(tl.col, br.col);
            tl = this.n2l(left) + top;
            br = this.n2l(right) + bottom;
            return {
                top,
                left,
                bottom,
                right,
                sheetName,
                tl: {
                    address: tl,
                    col: left,
                    row: top,
                    $col$row: `$${this.n2l(left)}$${top}`,
                    sheetName
                },
                br: {
                    address: br,
                    col: right,
                    row: bottom,
                    $col$row: `$${this.n2l(right)}$${bottom}`,
                    sheetName
                },
                dimensions: `${tl}:${br}`
            };
        }
        if (reference.startsWith("#")) {
            return sheetName ? {
                sheetName,
                error: reference
            } : {
                error: reference
            };
        }
        const address = this.decodeAddress(reference);
        return sheetName ? {
            sheetName,
            ...address
        } : address;
    },
    // convert row,col into address string
    encodeAddress (row, col) {
        return colCache.n2l(col) + row;
    },
    // convert row,col into string address or t,l,b,r into range
    encode () {
        switch(arguments.length){
            case 2:
                return colCache.encodeAddress(arguments[0], arguments[1]);
            case 4:
                return `${colCache.encodeAddress(arguments[0], arguments[1])}:${colCache.encodeAddress(arguments[2], arguments[3])}`;
            default:
                throw new Error("Can only encode with 2 or 4 arguments");
        }
    },
    // return true if address is contained within range
    inRange (range, address) {
        const [left, top, , right, bottom] = range;
        const [col, row] = address;
        return col >= left && col <= right && row >= top && row <= bottom;
    }
};
module.exports = colCache;


/***/ }),

/***/ 8730:
/***/ ((__unused_webpack_module, exports) => {

const oneDepthCopy = (obj, nestKeys)=>({
        ...obj,
        ...nestKeys.reduce((memo, key)=>{
            if (obj[key]) memo[key] = {
                ...obj[key]
            };
            return memo;
        }, {})
    });
const setIfExists = (src, dst, key, nestKeys = [])=>{
    if (src[key]) dst[key] = oneDepthCopy(src[key], nestKeys);
};
const isEmptyObj = (obj)=>Object.keys(obj).length === 0;
const copyStyle = (style)=>{
    if (!style) return style;
    if (isEmptyObj(style)) return {};
    const copied = {
        ...style
    };
    setIfExists(style, copied, "font", [
        "color"
    ]);
    setIfExists(style, copied, "alignment");
    setIfExists(style, copied, "protection");
    if (style.border) {
        setIfExists(style, copied, "border");
        setIfExists(style.border, copied.border, "top", [
            "color"
        ]);
        setIfExists(style.border, copied.border, "left", [
            "color"
        ]);
        setIfExists(style.border, copied.border, "bottom", [
            "color"
        ]);
        setIfExists(style.border, copied.border, "right", [
            "color"
        ]);
        setIfExists(style.border, copied.border, "diagonal", [
            "color"
        ]);
    }
    if (style.fill) {
        setIfExists(style, copied, "fill", [
            "fgColor",
            "bgColor",
            "center"
        ]);
        if (style.fill.stops) {
            copied.fill.stops = style.fill.stops.map((s)=>oneDepthCopy(s, [
                    "color"
                ]));
        }
    }
    return copied;
};
exports.copyStyle = copyStyle;


/***/ }),

/***/ 91573:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const crypto = __webpack_require__(6113);
const Encryptor = {
    /**
   * Calculate a hash of the concatenated buffers with the given algorithm.
   * @param {string} algorithm - The hash algorithm.
   * @returns {Buffer} The hash
   */ hash (algorithm, ...buffers) {
        const hash = crypto.createHash(algorithm);
        hash.update(Buffer.concat(buffers));
        return hash.digest();
    },
    /**
   * Convert a password into an encryption key
   * @param {string} password - The password
   * @param {string} hashAlgorithm - The hash algoritm
   * @param {string} saltValue - The salt value
   * @param {number} spinCount - The spin count
   * @param {number} keyBits - The length of the key in bits
   * @param {Buffer} blockKey - The block key
   * @returns {Buffer} The encryption key
   */ convertPasswordToHash (password, hashAlgorithm, saltValue, spinCount) {
        hashAlgorithm = hashAlgorithm.toLowerCase();
        const hashes = crypto.getHashes();
        if (hashes.indexOf(hashAlgorithm) < 0) {
            throw new Error(`Hash algorithm '${hashAlgorithm}' not supported!`);
        }
        // Password must be in unicode buffer
        const passwordBuffer = Buffer.from(password, "utf16le");
        // Generate the initial hash
        let key = this.hash(hashAlgorithm, Buffer.from(saltValue, "base64"), passwordBuffer);
        // Now regenerate until spin count
        for(let i = 0; i < spinCount; i++){
            const iterator = Buffer.alloc(4);
            // this is the 'special' element of Excel password hashing
            // that stops us from using crypto.pbkdf2()
            iterator.writeUInt32LE(i, 0);
            key = this.hash(hashAlgorithm, key, iterator);
        }
        return key.toString("base64");
    },
    /**
   * Generates cryptographically strong pseudo-random data.
   * @param size The size argument is a number indicating the number of bytes to generate.
   */ randomBytes (size) {
        return crypto.randomBytes(size);
    }
};
module.exports = Encryptor;


/***/ }),

/***/ 25885:
/***/ ((module) => {

"use strict";

module.exports = async function* iterateStream(stream) {
    const contents = [];
    stream.on("data", (data)=>contents.push(data));
    let resolveStreamEndedPromise;
    const streamEndedPromise = new Promise((resolve)=>resolveStreamEndedPromise = resolve);
    let ended = false;
    stream.on("end", ()=>{
        ended = true;
        resolveStreamEndedPromise();
    });
    let error = false;
    stream.on("error", (err)=>{
        error = err;
        resolveStreamEndedPromise();
    });
    while(!ended || contents.length > 0){
        if (contents.length === 0) {
            stream.resume();
            // eslint-disable-next-line no-await-in-loop
            await Promise.race([
                once(stream, "data"),
                streamEndedPromise
            ]);
        } else {
            stream.pause();
            const data = contents.shift();
            yield data;
        }
        if (error) throw error;
    }
    resolveStreamEndedPromise();
};
function once(eventEmitter, type) {
    // TODO: Use require('events').once when node v10 is dropped
    return new Promise((resolve)=>{
        let fired = false;
        const handler = ()=>{
            if (!fired) {
                fired = true;
                eventEmitter.removeListener(type, handler);
                resolve();
            }
        };
        eventEmitter.addListener(type, handler);
    });
}


/***/ }),

/***/ 68595:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { SaxesParser } = __webpack_require__(60014);
const { PassThrough } = __webpack_require__(98323);
const { bufferToString } = __webpack_require__(13491);
module.exports = async function*(iterable) {
    // TODO: Remove once node v8 is deprecated
    // Detect and upgrade old streams
    if (iterable.pipe && !iterable[Symbol.asyncIterator]) {
        iterable = iterable.pipe(new PassThrough());
    }
    const saxesParser = new SaxesParser();
    let error;
    saxesParser.on("error", (err)=>{
        error = err;
    });
    let events = [];
    saxesParser.on("opentag", (value)=>events.push({
            eventType: "opentag",
            value
        }));
    saxesParser.on("text", (value)=>events.push({
            eventType: "text",
            value
        }));
    saxesParser.on("closetag", (value)=>events.push({
            eventType: "closetag",
            value
        }));
    for await (const chunk of iterable){
        saxesParser.write(bufferToString(chunk));
        // saxesParser.write and saxesParser.on() are synchronous,
        // so we can only reach the below line once all events have been emitted
        if (error) throw error;
        // As a performance optimization, we gather all events instead of passing
        // them one by one, which would cause each event to go through the event queue
        yield events;
        events = [];
    }
};


/***/ }),

/***/ 69939:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const colCache = __webpack_require__(90609);
// const cellRefRegex = /(([a-z_\-0-9]*)!)?[$]?([a-z]+)[$]?([1-9][0-9]*)/i;
const replacementCandidateRx = /(([a-z_\-0-9]*)!)?([a-z0-9_$]{2,})([(])?/gi;
const CRrx = /^([$])?([a-z]+)([$])?([1-9][0-9]*)$/i;
function slideFormula(formula, fromCell, toCell) {
    const offset = colCache.decode(fromCell);
    const to = colCache.decode(toCell);
    return formula.replace(replacementCandidateRx, (refMatch, sheet, sheetMaybe, addrPart, trailingParen)=>{
        if (trailingParen) {
            return refMatch;
        }
        const match = CRrx.exec(addrPart);
        if (match) {
            const colDollar = match[1];
            const colStr = match[2].toUpperCase();
            const rowDollar = match[3];
            const rowStr = match[4];
            if (colStr.length > 3 || colStr.length === 3 && colStr > "XFD") {
                // > XFD is the highest col number in excel 2007 and beyond, so this is a named range
                return refMatch;
            }
            let col = colCache.l2n(colStr);
            let row = parseInt(rowStr, 10);
            if (!colDollar) {
                col += to.col - offset.col;
            }
            if (!rowDollar) {
                row += to.row - offset.row;
            }
            const res = (sheet || "") + (colDollar || "") + colCache.n2l(col) + (rowDollar || "") + row;
            return res;
        }
        return refMatch;
    });
}
module.exports = {
    slideFormula
};


/***/ }),

/***/ 95925:
/***/ ((module) => {

"use strict";

class SharedStrings {
    constructor(){
        this._values = [];
        this._totalRefs = 0;
        this._hash = Object.create(null);
    }
    get count() {
        return this._values.length;
    }
    get values() {
        return this._values;
    }
    get totalRefs() {
        return this._totalRefs;
    }
    getString(index) {
        return this._values[index];
    }
    add(value) {
        let index = this._hash[value];
        if (index === undefined) {
            index = this._hash[value] = this._values.length;
            this._values.push(value);
        }
        this._totalRefs++;
        return index;
    }
}
module.exports = SharedStrings;


/***/ }),

/***/ 87273:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable max-classes-per-file */ 
const Stream = __webpack_require__(98323);
const utils = __webpack_require__(90778);
const StringBuf = __webpack_require__(53096);
// =============================================================================
// data chunks - encapsulating incoming data
class StringChunk {
    constructor(data, encoding){
        this._data = data;
        this._encoding = encoding;
    }
    get length() {
        return this.toBuffer().length;
    }
    // copy to target buffer
    copy(target, targetOffset, offset, length) {
        return this.toBuffer().copy(target, targetOffset, offset, length);
    }
    toBuffer() {
        if (!this._buffer) {
            this._buffer = Buffer.from(this._data, this._encoding);
        }
        return this._buffer;
    }
}
class StringBufChunk {
    constructor(data){
        this._data = data;
    }
    get length() {
        return this._data.length;
    }
    // copy to target buffer
    copy(target, targetOffset, offset, length) {
        // eslint-disable-next-line no-underscore-dangle
        return this._data._buf.copy(target, targetOffset, offset, length);
    }
    toBuffer() {
        return this._data.toBuffer();
    }
}
class BufferChunk {
    constructor(data){
        this._data = data;
    }
    get length() {
        return this._data.length;
    }
    // copy to target buffer
    copy(target, targetOffset, offset, length) {
        this._data.copy(target, targetOffset, offset, length);
    }
    toBuffer() {
        return this._data;
    }
}
// =============================================================================
// ReadWriteBuf - a single buffer supporting simple read-write
class ReadWriteBuf {
    constructor(size){
        this.size = size;
        // the buffer
        this.buffer = Buffer.alloc(size);
        // read index
        this.iRead = 0;
        // write index
        this.iWrite = 0;
    }
    toBuffer() {
        if (this.iRead === 0 && this.iWrite === this.size) {
            return this.buffer;
        }
        const buf = Buffer.alloc(this.iWrite - this.iRead);
        this.buffer.copy(buf, 0, this.iRead, this.iWrite);
        return buf;
    }
    get length() {
        return this.iWrite - this.iRead;
    }
    get eod() {
        return this.iRead === this.iWrite;
    }
    get full() {
        return this.iWrite === this.size;
    }
    read(size) {
        let buf;
        // read size bytes from buffer and return buffer
        if (size === 0) {
            // special case - return null if no data requested
            return null;
        }
        if (size === undefined || size >= this.length) {
            // if no size specified or size is at least what we have then return all of the bytes
            buf = this.toBuffer();
            this.iRead = this.iWrite;
            return buf;
        }
        // otherwise return a chunk
        buf = Buffer.alloc(size);
        this.buffer.copy(buf, 0, this.iRead, size);
        this.iRead += size;
        return buf;
    }
    write(chunk, offset, length) {
        // write as many bytes from data from optional source offset
        // and return number of bytes written
        const size = Math.min(length, this.size - this.iWrite);
        chunk.copy(this.buffer, this.iWrite, offset, offset + size);
        this.iWrite += size;
        return size;
    }
}
// =============================================================================
// StreamBuf - a multi-purpose read-write stream
//  As MemBuf - write as much data as you like. Then call toBuffer() to consolidate
//  As StreamHub - pipe to multiple writables
//  As readable stream - feed data into the writable part and have some other code read from it.
// Note: Not sure why but StreamBuf does not like JS "class" sugar. It fails the
// integration tests
const StreamBuf = function(options) {
    options = options || {};
    this.bufSize = options.bufSize || 1024 * 1024;
    this.buffers = [];
    // batch mode fills a buffer completely before passing the data on
    // to pipes or 'readable' event listeners
    this.batch = options.batch || false;
    this.corked = false;
    // where in the current writable buffer we're up to
    this.inPos = 0;
    // where in the current readable buffer we've read up to
    this.outPos = 0;
    // consuming pipe streams go here
    this.pipes = [];
    // controls emit('data')
    this.paused = false;
    this.encoding = null;
};
utils.inherits(StreamBuf, Stream.Duplex, {
    toBuffer () {
        switch(this.buffers.length){
            case 0:
                return null;
            case 1:
                return this.buffers[0].toBuffer();
            default:
                return Buffer.concat(this.buffers.map((rwBuf)=>rwBuf.toBuffer()));
        }
    },
    // writable
    // event drain - if write returns false (which it won't), indicates when safe to write again.
    // finish - end() has been called
    // pipe(src) - pipe() has been called on readable
    // unpipe(src) - unpipe() has been called on readable
    // error - duh
    _getWritableBuffer () {
        if (this.buffers.length) {
            const last = this.buffers[this.buffers.length - 1];
            if (!last.full) {
                return last;
            }
        }
        const buf = new ReadWriteBuf(this.bufSize);
        this.buffers.push(buf);
        return buf;
    },
    async _pipe (chunk) {
        const write = function(pipe) {
            return new Promise((resolve)=>{
                pipe.write(chunk.toBuffer(), ()=>{
                    resolve();
                });
            });
        };
        await Promise.all(this.pipes.map(write));
    },
    _writeToBuffers (chunk) {
        let inPos = 0;
        const inLen = chunk.length;
        while(inPos < inLen){
            // find writable buffer
            const buffer = this._getWritableBuffer();
            // write some data
            inPos += buffer.write(chunk, inPos, inLen - inPos);
        }
    },
    async write (data, encoding, callback) {
        if (encoding instanceof Function) {
            callback = encoding;
            encoding = "utf8";
        }
        callback = callback || utils.nop;
        // encapsulate data into a chunk
        let chunk;
        if (data instanceof StringBuf) {
            chunk = new StringBufChunk(data);
        } else if (data instanceof Buffer) {
            chunk = new BufferChunk(data);
        } else if (typeof data === "string" || data instanceof String || data instanceof ArrayBuffer) {
            chunk = new StringChunk(data, encoding);
        } else {
            throw new Error("Chunk must be one of type String, Buffer or StringBuf.");
        }
        // now, do something with the chunk
        if (this.pipes.length) {
            if (this.batch) {
                this._writeToBuffers(chunk);
                while(!this.corked && this.buffers.length > 1){
                    this._pipe(this.buffers.shift());
                }
            } else if (!this.corked) {
                await this._pipe(chunk);
                callback();
            } else {
                this._writeToBuffers(chunk);
                process.nextTick(callback);
            }
        } else {
            if (!this.paused) {
                this.emit("data", chunk.toBuffer());
            }
            this._writeToBuffers(chunk);
            this.emit("readable");
        }
        return true;
    },
    cork () {
        this.corked = true;
    },
    _flush () {
        // if we have comsumers...
        if (this.pipes.length) {
            // and there's stuff not written
            while(this.buffers.length){
                this._pipe(this.buffers.shift());
            }
        }
    },
    uncork () {
        this.corked = false;
        this._flush();
    },
    end (chunk, encoding, callback) {
        const writeComplete = (error)=>{
            if (error) {
                callback(error);
            } else {
                this._flush();
                this.pipes.forEach((pipe)=>{
                    pipe.end();
                });
                this.emit("finish");
            }
        };
        if (chunk) {
            this.write(chunk, encoding, writeComplete);
        } else {
            writeComplete();
        }
    },
    // readable
    // event readable - some data is now available
    // event data - switch to flowing mode - feeds chunks to handler
    // event end - no more data
    // event close - optional, indicates upstream close
    // event error - duh
    read (size) {
        let buffers;
        // read min(buffer, size || infinity)
        if (size) {
            buffers = [];
            while(size && this.buffers.length && !this.buffers[0].eod){
                const first = this.buffers[0];
                const buffer = first.read(size);
                size -= buffer.length;
                buffers.push(buffer);
                if (first.eod && first.full) {
                    this.buffers.shift();
                }
            }
            return Buffer.concat(buffers);
        }
        buffers = this.buffers.map((buf)=>buf.toBuffer()).filter(Boolean);
        this.buffers = [];
        return Buffer.concat(buffers);
    },
    setEncoding (encoding) {
        // causes stream.read or stream.on('data) to return strings of encoding instead of Buffer objects
        this.encoding = encoding;
    },
    pause () {
        this.paused = true;
    },
    resume () {
        this.paused = false;
    },
    isPaused () {
        return !!this.paused;
    },
    pipe (destination) {
        // add destination to pipe list & write current buffer
        this.pipes.push(destination);
        if (!this.paused && this.buffers.length) {
            this.end();
        }
    },
    unpipe (destination) {
        // remove destination from pipe list
        this.pipes = this.pipes.filter((pipe)=>pipe !== destination);
    },
    unshift () {
        // some numpty has read some data that's not for them and they want to put it back!
        // Might implement this some day
        throw new Error("Not Implemented");
    },
    wrap () {
        // not implemented
        throw new Error("Not Implemented");
    }
});
module.exports = StreamBuf;


/***/ }),

/***/ 53096:
/***/ ((module) => {

"use strict";
// StringBuf - a way to keep string memory operations to a minimum
// while building the strings for the xml files

class StringBuf {
    constructor(options){
        this._buf = Buffer.alloc(options && options.size || 16384);
        this._encoding = options && options.encoding || "utf8";
        // where in the buffer we are at
        this._inPos = 0;
        // for use by toBuffer()
        this._buffer = undefined;
    }
    get length() {
        return this._inPos;
    }
    get capacity() {
        return this._buf.length;
    }
    get buffer() {
        return this._buf;
    }
    toBuffer() {
        // return the current data as a single enclosing buffer
        if (!this._buffer) {
            this._buffer = Buffer.alloc(this.length);
            this._buf.copy(this._buffer, 0, 0, this.length);
        }
        return this._buffer;
    }
    reset(position) {
        position = position || 0;
        this._buffer = undefined;
        this._inPos = position;
    }
    _grow(min) {
        let size = this._buf.length * 2;
        while(size < min){
            size *= 2;
        }
        const buf = Buffer.alloc(size);
        this._buf.copy(buf, 0);
        this._buf = buf;
    }
    addText(text) {
        this._buffer = undefined;
        let inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);
        // if we've hit (or nearing capacity), grow the buf
        while(inPos >= this._buf.length - 4){
            this._grow(this._inPos + text.length);
            // keep trying to write until we've completely written the text
            inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);
        }
        this._inPos = inPos;
    }
    addStringBuf(inBuf) {
        if (inBuf.length) {
            this._buffer = undefined;
            if (this.length + inBuf.length > this.capacity) {
                this._grow(this.length + inBuf.length);
            }
            // eslint-disable-next-line no-underscore-dangle
            inBuf._buf.copy(this._buf, this._inPos, 0, inBuf.length);
            this._inPos += inBuf.length;
        }
    }
}
module.exports = StringBuf;


/***/ }),

/***/ 96910:
/***/ ((module) => {

"use strict";

const { toString } = Object.prototype;
const escapeHtmlRegex = /["&<>]/;
const _ = {
    each: function each(obj, cb) {
        if (obj) {
            if (Array.isArray(obj)) {
                obj.forEach(cb);
            } else {
                Object.keys(obj).forEach((key)=>{
                    cb(obj[key], key);
                });
            }
        }
    },
    some: function some(obj, cb) {
        if (obj) {
            if (Array.isArray(obj)) {
                return obj.some(cb);
            }
            return Object.keys(obj).some((key)=>cb(obj[key], key));
        }
        return false;
    },
    every: function every(obj, cb) {
        if (obj) {
            if (Array.isArray(obj)) {
                return obj.every(cb);
            }
            return Object.keys(obj).every((key)=>cb(obj[key], key));
        }
        return true;
    },
    map: function map(obj, cb) {
        if (obj) {
            if (Array.isArray(obj)) {
                return obj.map(cb);
            }
            return Object.keys(obj).map((key)=>cb(obj[key], key));
        }
        return [];
    },
    keyBy (a, p) {
        return a.reduce((o, v)=>{
            o[v[p]] = v;
            return o;
        }, {});
    },
    isEqual: function isEqual(a, b) {
        const aType = typeof a;
        const bType = typeof b;
        const aArray = Array.isArray(a);
        const bArray = Array.isArray(b);
        let keys;
        if (aType !== bType) {
            return false;
        }
        switch(typeof a){
            case "object":
                if (aArray || bArray) {
                    if (aArray && bArray) {
                        return a.length === b.length && a.every((aValue, index)=>{
                            const bValue = b[index];
                            return _.isEqual(aValue, bValue);
                        });
                    }
                    return false;
                }
                if (a === null || b === null) {
                    return a === b;
                }
                // Compare object keys and values
                keys = Object.keys(a);
                if (Object.keys(b).length !== keys.length) {
                    return false;
                }
                for (const key of keys){
                    if (!b.hasOwnProperty(key)) {
                        return false;
                    }
                }
                return _.every(a, (aValue, key)=>{
                    const bValue = b[key];
                    return _.isEqual(aValue, bValue);
                });
            default:
                return a === b;
        }
    },
    escapeHtml (html) {
        const regexResult = escapeHtmlRegex.exec(html);
        if (!regexResult) return html;
        let result = "";
        let escape = "";
        let lastIndex = 0;
        let i = regexResult.index;
        for(; i < html.length; i++){
            switch(html.charAt(i)){
                case '"':
                    escape = "&quot;";
                    break;
                case "&":
                    escape = "&amp;";
                    break;
                case "'":
                    escape = "&apos;";
                    break;
                case "<":
                    escape = "&lt;";
                    break;
                case ">":
                    escape = "&gt;";
                    break;
                default:
                    continue;
            }
            if (lastIndex !== i) result += html.substring(lastIndex, i);
            lastIndex = i + 1;
            result += escape;
        }
        if (lastIndex !== i) return result + html.substring(lastIndex, i);
        return result;
    },
    strcmp (a, b) {
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
    },
    isUndefined (val) {
        return toString.call(val) === "[object Undefined]";
    },
    isObject (val) {
        return toString.call(val) === "[object Object]";
    },
    deepMerge () {
        const target = arguments[0] || {};
        const { length } = arguments;
        // eslint-disable-next-line one-var
        let src, clone, copyIsArray;
        function assignValue(val, key) {
            src = target[key];
            copyIsArray = Array.isArray(val);
            if (_.isObject(val) || copyIsArray) {
                if (copyIsArray) {
                    copyIsArray = false;
                    clone = src && Array.isArray(src) ? src : [];
                } else {
                    clone = src && _.isObject(src) ? src : {};
                }
                target[key] = _.deepMerge(clone, val);
            } else if (!_.isUndefined(val)) {
                target[key] = val;
            }
        }
        for(let i = 0; i < length; i++){
            _.each(arguments[i], assignValue);
        }
        return target;
    }
};
module.exports = _;


/***/ }),

/***/ 90778:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(57147);
// useful stuff
const inherits = function(cls, superCtor, statics, prototype) {
    // eslint-disable-next-line no-underscore-dangle
    cls.super_ = superCtor;
    if (!prototype) {
        prototype = statics;
        statics = null;
    }
    if (statics) {
        Object.keys(statics).forEach((i)=>{
            Object.defineProperty(cls, i, Object.getOwnPropertyDescriptor(statics, i));
        });
    }
    const properties = {
        constructor: {
            value: cls,
            enumerable: false,
            writable: false,
            configurable: true
        }
    };
    if (prototype) {
        Object.keys(prototype).forEach((i)=>{
            properties[i] = Object.getOwnPropertyDescriptor(prototype, i);
        });
    }
    cls.prototype = Object.create(superCtor.prototype, properties);
};
// eslint-disable-next-line no-control-regex
const xmlDecodeRegex = /[<>&'"\x7F\x00-\x08\x0B-\x0C\x0E-\x1F]/;
const utils = {
    nop () {},
    promiseImmediate (value) {
        return new Promise((resolve)=>{
            if (global.setImmediate) {
                setImmediate(()=>{
                    resolve(value);
                });
            } else {
                // poorman's setImmediate - must wait at least 1ms
                setTimeout(()=>{
                    resolve(value);
                }, 1);
            }
        });
    },
    inherits,
    dateToExcel (d, date1904) {
        return 25569 + d.getTime() / (24 * 3600 * 1000) - (date1904 ? 1462 : 0);
    },
    excelToDate (v, date1904) {
        const millisecondSinceEpoch = Math.round((v - 25569 + (date1904 ? 1462 : 0)) * 24 * 3600 * 1000);
        return new Date(millisecondSinceEpoch);
    },
    parsePath (filepath) {
        const last = filepath.lastIndexOf("/");
        return {
            path: filepath.substring(0, last),
            name: filepath.substring(last + 1)
        };
    },
    getRelsPath (filepath) {
        const path = utils.parsePath(filepath);
        return `${path.path}/_rels/${path.name}.rels`;
    },
    xmlEncode (text) {
        const regexResult = xmlDecodeRegex.exec(text);
        if (!regexResult) return text;
        let result = "";
        let escape = "";
        let lastIndex = 0;
        let i = regexResult.index;
        for(; i < text.length; i++){
            const charCode = text.charCodeAt(i);
            switch(charCode){
                case 34:
                    escape = "&quot;";
                    break;
                case 38:
                    escape = "&amp;";
                    break;
                case 39:
                    escape = "&apos;";
                    break;
                case 60:
                    escape = "&lt;";
                    break;
                case 62:
                    escape = "&gt;";
                    break;
                case 127:
                    escape = "";
                    break;
                default:
                    {
                        if (charCode <= 31 && (charCode <= 8 || charCode >= 11 && charCode !== 13)) {
                            escape = "";
                            break;
                        }
                        continue;
                    }
            }
            if (lastIndex !== i) result += text.substring(lastIndex, i);
            lastIndex = i + 1;
            if (escape) result += escape;
        }
        if (lastIndex !== i) return result + text.substring(lastIndex, i);
        return result;
    },
    xmlDecode (text) {
        return text.replace(/&([a-z]*);/g, (c)=>{
            switch(c){
                case "&lt;":
                    return "<";
                case "&gt;":
                    return ">";
                case "&amp;":
                    return "&";
                case "&apos;":
                    return "'";
                case "&quot;":
                    return '"';
                default:
                    return c;
            }
        });
    },
    validInt (value) {
        const i = parseInt(value, 10);
        return !Number.isNaN(i) ? i : 0;
    },
    isDateFmt (fmt) {
        if (!fmt) {
            return false;
        }
        // must remove all chars inside quotes and []
        fmt = fmt.replace(/\[[^\]]*]/g, "");
        fmt = fmt.replace(/"[^"]*"/g, "");
        // then check for date formatting chars
        const result = fmt.match(/[ymdhMsb]+/) !== null;
        return result;
    },
    fs: {
        exists (path) {
            return new Promise((resolve)=>{
                fs.access(path, fs.constants.F_OK, (err)=>{
                    resolve(!err);
                });
            });
        }
    },
    toIsoDateString (dt) {
        return dt.toIsoString().subsstr(0, 10);
    },
    parseBoolean (value) {
        return value === true || value === "true" || value === 1 || value === "1";
    }
};
module.exports = utils;


/***/ }),

/***/ 18749:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
const utils = __webpack_require__(90778);
// constants
const OPEN_ANGLE = "<";
const CLOSE_ANGLE = ">";
const OPEN_ANGLE_SLASH = "</";
const CLOSE_SLASH_ANGLE = "/>";
function pushAttribute(xml, name, value) {
    xml.push(` ${name}="${utils.xmlEncode(value.toString())}"`);
}
function pushAttributes(xml, attributes) {
    if (attributes) {
        const tmp = [];
        _.each(attributes, (value, name)=>{
            if (value !== undefined) {
                pushAttribute(tmp, name, value);
            }
        });
        xml.push(tmp.join(""));
    }
}
class XmlStream {
    constructor(){
        this._xml = [];
        this._stack = [];
        this._rollbacks = [];
    }
    get tos() {
        return this._stack.length ? this._stack[this._stack.length - 1] : undefined;
    }
    get cursor() {
        // handy way to track whether anything has been added
        return this._xml.length;
    }
    openXml(docAttributes) {
        const xml = this._xml;
        // <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
        xml.push("<?xml");
        pushAttributes(xml, docAttributes);
        xml.push("?>\n");
    }
    openNode(name, attributes) {
        const parent = this.tos;
        const xml = this._xml;
        if (parent && this.open) {
            xml.push(CLOSE_ANGLE);
        }
        this._stack.push(name);
        // start streaming node
        xml.push(OPEN_ANGLE);
        xml.push(name);
        pushAttributes(xml, attributes);
        this.leaf = true;
        this.open = true;
    }
    addAttribute(name, value) {
        if (!this.open) {
            throw new Error("Cannot write attributes to node if it is not open");
        }
        if (value !== undefined) {
            pushAttribute(this._xml, name, value);
        }
    }
    addAttributes(attrs) {
        if (!this.open) {
            throw new Error("Cannot write attributes to node if it is not open");
        }
        pushAttributes(this._xml, attrs);
    }
    writeText(text) {
        const xml = this._xml;
        if (this.open) {
            xml.push(CLOSE_ANGLE);
            this.open = false;
        }
        this.leaf = false;
        xml.push(utils.xmlEncode(text.toString()));
    }
    writeXml(xml) {
        if (this.open) {
            this._xml.push(CLOSE_ANGLE);
            this.open = false;
        }
        this.leaf = false;
        this._xml.push(xml);
    }
    closeNode() {
        const node = this._stack.pop();
        const xml = this._xml;
        if (this.leaf) {
            xml.push(CLOSE_SLASH_ANGLE);
        } else {
            xml.push(OPEN_ANGLE_SLASH);
            xml.push(node);
            xml.push(CLOSE_ANGLE);
        }
        this.open = false;
        this.leaf = false;
    }
    leafNode(name, attributes, text) {
        this.openNode(name, attributes);
        if (text !== undefined) {
            // zeros need to be written
            this.writeText(text);
        }
        this.closeNode();
    }
    closeAll() {
        while(this._stack.length){
            this.closeNode();
        }
    }
    addRollback() {
        this._rollbacks.push({
            xml: this._xml.length,
            stack: this._stack.length,
            leaf: this.leaf,
            open: this.open
        });
        return this.cursor;
    }
    commit() {
        this._rollbacks.pop();
    }
    rollback() {
        const r = this._rollbacks.pop();
        if (this._xml.length > r.xml) {
            this._xml.splice(r.xml, this._xml.length - r.xml);
        }
        if (this._stack.length > r.stack) {
            this._stack.splice(r.stack, this._stack.length - r.stack);
        }
        this.leaf = r.leaf;
        this.open = r.open;
    }
    get xml() {
        this.closeAll();
        return this._xml.join("");
    }
}
XmlStream.StdDocAttributes = {
    version: "1.0",
    encoding: "UTF-8",
    standalone: "yes"
};
module.exports = XmlStream;


/***/ }),

/***/ 16362:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const events = __webpack_require__(82361);
const JSZip = __webpack_require__(3189);
const StreamBuf = __webpack_require__(87273);
const { stringToBuffer } = __webpack_require__(27615);
// =============================================================================
// The ZipWriter class
// Packs streamed data into an output zip stream
class ZipWriter extends events.EventEmitter {
    constructor(options){
        super();
        this.options = Object.assign({
            type: "nodebuffer",
            compression: "DEFLATE"
        }, options);
        this.zip = new JSZip();
        this.stream = new StreamBuf();
    }
    append(data, options) {
        if (options.hasOwnProperty("base64") && options.base64) {
            this.zip.file(options.name, data, {
                base64: true
            });
        } else {
            // https://www.npmjs.com/package/process
            if (false) {}
            this.zip.file(options.name, data);
        }
    }
    async finalize() {
        const content = await this.zip.generateAsync(this.options);
        this.stream.end(content);
        this.emit("finish");
    }
    // ==========================================================================
    // Stream.Readable interface
    read(size) {
        return this.stream.read(size);
    }
    setEncoding(encoding) {
        return this.stream.setEncoding(encoding);
    }
    pause() {
        return this.stream.pause();
    }
    resume() {
        return this.stream.resume();
    }
    isPaused() {
        return this.stream.isPaused();
    }
    pipe(destination, options) {
        return this.stream.pipe(destination, options);
    }
    unpipe(destination) {
        return this.stream.unpipe(destination);
    }
    unshift(chunk) {
        return this.stream.unshift(chunk);
    }
    wrap(stream) {
        return this.stream.wrap(stream);
    }
}
// =============================================================================
module.exports = {
    ZipWriter
};


/***/ }),

/***/ 9420:
/***/ ((module) => {

"use strict";

module.exports = {
    0: {
        f: "General"
    },
    1: {
        f: "0"
    },
    2: {
        f: "0.00"
    },
    3: {
        f: "#,##0"
    },
    4: {
        f: "#,##0.00"
    },
    9: {
        f: "0%"
    },
    10: {
        f: "0.00%"
    },
    11: {
        f: "0.00E+00"
    },
    12: {
        f: "# ?/?"
    },
    13: {
        f: "# ??/??"
    },
    14: {
        f: "mm-dd-yy"
    },
    15: {
        f: "d-mmm-yy"
    },
    16: {
        f: "d-mmm"
    },
    17: {
        f: "mmm-yy"
    },
    18: {
        f: "h:mm AM/PM"
    },
    19: {
        f: "h:mm:ss AM/PM"
    },
    20: {
        f: "h:mm"
    },
    21: {
        f: "h:mm:ss"
    },
    22: {
        f: 'm/d/yy "h":mm'
    },
    27: {
        "zh-tw": "[$-404]e/m/d",
        "zh-cn": 'yyyy""m""',
        "ja-jp": "[$-411]ge.m.d",
        "ko-kr": 'yyyy"" mm"" dd""'
    },
    28: {
        "zh-tw": '[$-404]e""m""d""',
        "zh-cn": 'm""d""',
        "ja-jp": '[$-411]ggge""m""d""',
        "ko-kr": "mm-dd"
    },
    29: {
        "zh-tw": '[$-404]e""m""d""',
        "zh-cn": 'm""d""',
        "ja-jp": '[$-411]ggge""m""d""',
        "ko-kr": "mm-dd"
    },
    30: {
        "zh-tw": "m/d/yy ",
        "zh-cn": "m-d-yy",
        "ja-jp": "m/d/yy",
        "ko-kr": "mm-dd-yy"
    },
    31: {
        "zh-tw": 'yyyy""m""d""',
        "zh-cn": 'yyyy""m""d""',
        "ja-jp": 'yyyy""m""d""',
        "ko-kr": 'yyyy"" mm"" dd""'
    },
    32: {
        "zh-tw": 'hh""mm""',
        "zh-cn": 'h""mm""',
        "ja-jp": 'h""mm""',
        "ko-kr": 'h"" mm""'
    },
    33: {
        "zh-tw": 'hh""mm""ss""',
        "zh-cn": 'h""mm""ss""',
        "ja-jp": 'h""mm""ss""',
        "ko-kr": 'h"" mm"" ss""'
    },
    34: {
        "zh-tw": '/ hh""mm""',
        "zh-cn": '/ h""mm""',
        "ja-jp": 'yyyy""m""',
        "ko-kr": "yyyy-mm-dd"
    },
    35: {
        "zh-tw": '/ hh""mm""ss""',
        "zh-cn": '/ h""mm""ss""',
        "ja-jp": 'm""d""',
        "ko-kr": "yyyy-mm-dd"
    },
    36: {
        "zh-tw": "[$-404]e/m/d",
        "zh-cn": 'yyyy""m""',
        "ja-jp": "[$-411]ge.m.d",
        "ko-kr": 'yyyy"" mm"" dd""'
    },
    37: {
        f: "#,##0 ;(#,##0)"
    },
    38: {
        f: "#,##0 ;[Red](#,##0)"
    },
    39: {
        f: "#,##0.00 ;(#,##0.00)"
    },
    40: {
        f: "#,##0.00 ;[Red](#,##0.00)"
    },
    45: {
        f: "mm:ss"
    },
    46: {
        f: "[h]:mm:ss"
    },
    47: {
        f: "mmss.0"
    },
    48: {
        f: "##0.0E+0"
    },
    49: {
        f: "@"
    },
    50: {
        "zh-tw": "[$-404]e/m/d",
        "zh-cn": 'yyyy""m""',
        "ja-jp": "[$-411]ge.m.d",
        "ko-kr": 'yyyy"" mm"" dd""'
    },
    51: {
        "zh-tw": '[$-404]e""m""d""',
        "zh-cn": 'm""d""',
        "ja-jp": '[$-411]ggge""m""d""',
        "ko-kr": "mm-dd"
    },
    52: {
        "zh-tw": '/ hh""mm""',
        "zh-cn": 'yyyy""m""',
        "ja-jp": 'yyyy""m""',
        "ko-kr": "yyyy-mm-dd"
    },
    53: {
        "zh-tw": '/ hh""mm""ss""',
        "zh-cn": 'm""d""',
        "ja-jp": 'm""d""',
        "ko-kr": "yyyy-mm-dd"
    },
    54: {
        "zh-tw": '[$-404]e""m""d""',
        "zh-cn": 'm""d""',
        "ja-jp": '[$-411]ggge""m""d""',
        "ko-kr": "mm-dd"
    },
    55: {
        "zh-tw": '/ hh""mm""',
        "zh-cn": '/ h""mm""',
        "ja-jp": 'yyyy""m""',
        "ko-kr": "yyyy-mm-dd"
    },
    56: {
        "zh-tw": '/ hh""mm""ss""',
        "zh-cn": '/ h""mm""ss""',
        "ja-jp": 'm""d""',
        "ko-kr": "yyyy-mm-dd"
    },
    57: {
        "zh-tw": "[$-404]e/m/d",
        "zh-cn": 'yyyy""m""',
        "ja-jp": "[$-411]ge.m.d",
        "ko-kr": 'yyyy"" mm"" dd""'
    },
    58: {
        "zh-tw": '[$-404]e""m""d""',
        "zh-cn": 'm""d""',
        "ja-jp": '[$-411]ggge""m""d""',
        "ko-kr": "mm-dd"
    },
    59: {
        "th-th": "t0"
    },
    60: {
        "th-th": "t0.00"
    },
    61: {
        "th-th": "t#,##0"
    },
    62: {
        "th-th": "t#,##0.00"
    },
    67: {
        "th-th": "t0%"
    },
    68: {
        "th-th": "t0.00%"
    },
    69: {
        "th-th": "t# ?/?"
    },
    70: {
        "th-th": "t# ??/??"
    },
    81: {
        "th-th": "d/m/bb"
    }
};


/***/ }),

/***/ 39982:
/***/ ((module) => {

"use strict";

module.exports = {
    OfficeDocument: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
    Worksheet: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
    CalcChain: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/calcChain",
    SharedStrings: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
    Styles: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
    Theme: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
    Hyperlink: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
    Image: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
    CoreProperties: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
    ExtenderProperties: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
    Comments: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
    VmlDrawing: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
    Table: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/table"
};


/***/ }),

/***/ 90884:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const parseSax = __webpack_require__(68595);
const XmlStream = __webpack_require__(18749);
/* 'virtual' methods used as a form of documentation */ /* eslint-disable class-methods-use-this */ // Base class for Xforms
class BaseXform {
    // constructor(/* model, name */) {}
    // ============================================================
    // Virtual Interface
    prepare() {
    // optional preparation (mutation) of model so it is ready for write
    }
    render() {
    // convert model to xml
    }
    parseOpen(node) {
    // XML node opened
    }
    parseText(text) {
    // chunk of text encountered for current node
    }
    parseClose(name) {
    // XML node closed
    }
    reconcile(model, options) {
    // optional post-parse step (opposite to prepare)
    }
    // ============================================================
    reset() {
        // to make sure parses don't bleed to next iteration
        this.model = null;
        // if we have a map - reset them too
        if (this.map) {
            Object.values(this.map).forEach((xform)=>{
                if (xform instanceof BaseXform) {
                    xform.reset();
                } else if (xform.xform) {
                    xform.xform.reset();
                }
            });
        }
    }
    mergeModel(obj) {
        // set obj's props to this.model
        this.model = Object.assign(this.model || {}, obj);
    }
    async parse(saxParser) {
        for await (const events of saxParser){
            for (const { eventType, value } of events){
                if (eventType === "opentag") {
                    this.parseOpen(value);
                } else if (eventType === "text") {
                    this.parseText(value);
                } else if (eventType === "closetag") {
                    if (!this.parseClose(value.name)) {
                        return this.model;
                    }
                }
            }
        }
        return this.model;
    }
    async parseStream(stream) {
        return this.parse(parseSax(stream));
    }
    get xml() {
        // convenience function to get the xml of this.model
        // useful for manager types that are built during the prepare phase
        return this.toXml(this.model);
    }
    toXml(model) {
        const xmlStream = new XmlStream();
        this.render(xmlStream, model);
        return xmlStream.xml;
    }
    // ============================================================
    // Useful Utilities
    static toAttribute(value, dflt, always = false) {
        if (value === undefined) {
            if (always) {
                return dflt;
            }
        } else if (always || value !== dflt) {
            return value.toString();
        }
        return undefined;
    }
    static toStringAttribute(value, dflt, always = false) {
        return BaseXform.toAttribute(value, dflt, always);
    }
    static toStringValue(attr, dflt) {
        return attr === undefined ? dflt : attr;
    }
    static toBoolAttribute(value, dflt, always = false) {
        if (value === undefined) {
            if (always) {
                return dflt;
            }
        } else if (always || value !== dflt) {
            return value ? "1" : "0";
        }
        return undefined;
    }
    static toBoolValue(attr, dflt) {
        return attr === undefined ? dflt : attr === "1";
    }
    static toIntAttribute(value, dflt, always = false) {
        return BaseXform.toAttribute(value, dflt, always);
    }
    static toIntValue(attr, dflt) {
        return attr === undefined ? dflt : parseInt(attr, 10);
    }
    static toFloatAttribute(value, dflt, always = false) {
        return BaseXform.toAttribute(value, dflt, always);
    }
    static toFloatValue(attr, dflt) {
        return attr === undefined ? dflt : parseFloat(attr);
    }
}
module.exports = BaseXform;


/***/ }),

/***/ 37609:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const colCache = __webpack_require__(90609);
class DefinedNamesXform extends BaseXform {
    render(xmlStream, model) {
        // <definedNames>
        //   <definedName name="name">name.ranges.join(',')</definedName>
        //   <definedName name="_xlnm.Print_Area" localSheetId="0">name.ranges.join(',')</definedName>
        // </definedNames>
        xmlStream.openNode("definedName", {
            name: model.name,
            localSheetId: model.localSheetId
        });
        xmlStream.writeText(model.ranges.join(","));
        xmlStream.closeNode();
    }
    parseOpen(node) {
        switch(node.name){
            case "definedName":
                this._parsedName = node.attributes.name;
                this._parsedLocalSheetId = node.attributes.localSheetId;
                this._parsedText = [];
                return true;
            default:
                return false;
        }
    }
    parseText(text) {
        this._parsedText.push(text);
    }
    parseClose() {
        this.model = {
            name: this._parsedName,
            ranges: extractRanges(this._parsedText.join(""))
        };
        if (this._parsedLocalSheetId !== undefined) {
            this.model.localSheetId = parseInt(this._parsedLocalSheetId, 10);
        }
        return false;
    }
}
function isValidRange(range) {
    try {
        colCache.decodeEx(range);
        return true;
    } catch (err) {
        return false;
    }
}
function extractRanges(parsedText) {
    const ranges = [];
    let quotesOpened = false;
    let last = "";
    parsedText.split(",").forEach((item)=>{
        if (!item) {
            return;
        }
        const quotes = (item.match(/'/g) || []).length;
        if (!quotes) {
            if (quotesOpened) {
                last += `${item},`;
            } else if (isValidRange(item)) {
                ranges.push(item);
            }
            return;
        }
        const quotesEven = quotes % 2 === 0;
        if (!quotesOpened && quotesEven && isValidRange(item)) {
            ranges.push(item);
        } else if (quotesOpened && !quotesEven) {
            quotesOpened = false;
            if (isValidRange(last + item)) {
                ranges.push(last + item);
            }
            last = "";
        } else {
            quotesOpened = true;
            last += `${item},`;
        }
    });
    return ranges;
}
module.exports = DefinedNamesXform;


/***/ }),

/***/ 84305:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const utils = __webpack_require__(90778);
const BaseXform = __webpack_require__(90884);
class WorksheetXform extends BaseXform {
    render(xmlStream, model) {
        xmlStream.leafNode("sheet", {
            sheetId: model.id,
            name: model.name,
            state: model.state,
            "r:id": model.rId
        });
    }
    parseOpen(node) {
        if (node.name === "sheet") {
            this.model = {
                name: utils.xmlDecode(node.attributes.name),
                id: parseInt(node.attributes.sheetId, 10),
                state: node.attributes.state,
                rId: node.attributes["r:id"]
            };
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = WorksheetXform;


/***/ }),

/***/ 74556:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class WorkbookCalcPropertiesXform extends BaseXform {
    render(xmlStream, model) {
        xmlStream.leafNode("calcPr", {
            calcId: 171027,
            fullCalcOnLoad: model.fullCalcOnLoad ? 1 : undefined
        });
    }
    parseOpen(node) {
        if (node.name === "calcPr") {
            this.model = {};
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = WorkbookCalcPropertiesXform;


/***/ }),

/***/ 35276:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class WorksheetPropertiesXform extends BaseXform {
    render(xmlStream, model) {
        xmlStream.leafNode("workbookPr", {
            date1904: model.date1904 ? 1 : undefined,
            defaultThemeVersion: 164011,
            filterPrivacy: 1
        });
    }
    parseOpen(node) {
        if (node.name === "workbookPr") {
            this.model = {
                date1904: node.attributes.date1904 === "1"
            };
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = WorksheetPropertiesXform;


/***/ }),

/***/ 60215:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class WorkbookViewXform extends BaseXform {
    render(xmlStream, model) {
        const attributes = {
            xWindow: model.x || 0,
            yWindow: model.y || 0,
            windowWidth: model.width || 12000,
            windowHeight: model.height || 24000,
            firstSheet: model.firstSheet,
            activeTab: model.activeTab
        };
        if (model.visibility && model.visibility !== "visible") {
            attributes.visibility = model.visibility;
        }
        xmlStream.leafNode("workbookView", attributes);
    }
    parseOpen(node) {
        if (node.name === "workbookView") {
            const model = this.model = {};
            const addS = function(name, value, dflt) {
                const s = value !== undefined ? model[name] = value : dflt;
                if (s !== undefined) {
                    model[name] = s;
                }
            };
            const addN = function(name, value, dflt) {
                const n = value !== undefined ? model[name] = parseInt(value, 10) : dflt;
                if (n !== undefined) {
                    model[name] = n;
                }
            };
            addN("x", node.attributes.xWindow, 0);
            addN("y", node.attributes.yWindow, 0);
            addN("width", node.attributes.windowWidth, 25000);
            addN("height", node.attributes.windowHeight, 10000);
            addS("visibility", node.attributes.visibility, "visible");
            addN("activeTab", node.attributes.activeTab, undefined);
            addN("firstSheet", node.attributes.firstSheet, undefined);
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = WorkbookViewXform;


/***/ }),

/***/ 89297:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
const colCache = __webpack_require__(90609);
const XmlStream = __webpack_require__(18749);
const BaseXform = __webpack_require__(90884);
const StaticXform = __webpack_require__(76949);
const ListXform = __webpack_require__(34397);
const DefinedNameXform = __webpack_require__(37609);
const SheetXform = __webpack_require__(84305);
const WorkbookViewXform = __webpack_require__(60215);
const WorkbookPropertiesXform = __webpack_require__(35276);
const WorkbookCalcPropertiesXform = __webpack_require__(74556);
class WorkbookXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            fileVersion: WorkbookXform.STATIC_XFORMS.fileVersion,
            workbookPr: new WorkbookPropertiesXform(),
            bookViews: new ListXform({
                tag: "bookViews",
                count: false,
                childXform: new WorkbookViewXform()
            }),
            sheets: new ListXform({
                tag: "sheets",
                count: false,
                childXform: new SheetXform()
            }),
            definedNames: new ListXform({
                tag: "definedNames",
                count: false,
                childXform: new DefinedNameXform()
            }),
            calcPr: new WorkbookCalcPropertiesXform()
        };
    }
    prepare(model) {
        model.sheets = model.worksheets;
        // collate all the print areas from all of the sheets and add them to the defined names
        const printAreas = [];
        let index = 0; // sheets is sparse array - calc index manually
        model.sheets.forEach((sheet)=>{
            if (sheet.pageSetup && sheet.pageSetup.printArea) {
                sheet.pageSetup.printArea.split("&&").forEach((printArea)=>{
                    const printAreaComponents = printArea.split(":");
                    const definedName = {
                        name: "_xlnm.Print_Area",
                        ranges: [
                            `'${sheet.name}'!$${printAreaComponents[0]}:$${printAreaComponents[1]}`
                        ],
                        localSheetId: index
                    };
                    printAreas.push(definedName);
                });
            }
            if (sheet.pageSetup && (sheet.pageSetup.printTitlesRow || sheet.pageSetup.printTitlesColumn)) {
                const ranges = [];
                if (sheet.pageSetup.printTitlesColumn) {
                    const titlesColumns = sheet.pageSetup.printTitlesColumn.split(":");
                    ranges.push(`'${sheet.name}'!$${titlesColumns[0]}:$${titlesColumns[1]}`);
                }
                if (sheet.pageSetup.printTitlesRow) {
                    const titlesRows = sheet.pageSetup.printTitlesRow.split(":");
                    ranges.push(`'${sheet.name}'!$${titlesRows[0]}:$${titlesRows[1]}`);
                }
                const definedName = {
                    name: "_xlnm.Print_Titles",
                    ranges,
                    localSheetId: index
                };
                printAreas.push(definedName);
            }
            index++;
        });
        if (printAreas.length) {
            model.definedNames = model.definedNames.concat(printAreas);
        }
        (model.media || []).forEach((medium, i)=>{
            // assign name
            medium.name = medium.type + (i + 1);
        });
    }
    render(xmlStream, model) {
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("workbook", WorkbookXform.WORKBOOK_ATTRIBUTES);
        this.map.fileVersion.render(xmlStream);
        this.map.workbookPr.render(xmlStream, model.properties);
        this.map.bookViews.render(xmlStream, model.views);
        this.map.sheets.render(xmlStream, model.sheets);
        this.map.definedNames.render(xmlStream, model.definedNames);
        this.map.calcPr.render(xmlStream, model.calcProperties);
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case "workbook":
                return true;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                }
                return true;
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case "workbook":
                this.model = {
                    sheets: this.map.sheets.model,
                    properties: this.map.workbookPr.model || {},
                    views: this.map.bookViews.model,
                    calcProperties: {}
                };
                if (this.map.definedNames.model) {
                    this.model.definedNames = this.map.definedNames.model;
                }
                return false;
            default:
                // not quite sure how we get here!
                return true;
        }
    }
    reconcile(model) {
        const rels = (model.workbookRels || []).reduce((map, rel)=>{
            map[rel.Id] = rel;
            return map;
        }, {});
        // reconcile sheet ids, rIds and names
        const worksheets = [];
        let worksheet;
        let index = 0;
        (model.sheets || []).forEach((sheet)=>{
            const rel = rels[sheet.rId];
            if (!rel) {
                return;
            }
            // if rel.Target start with `[space]/xl/` or `/xl/` , then it will be replaced with `''` and spliced behind `xl/`,
            // otherwise it will be spliced directly behind `xl/`. i.g.
            worksheet = model.worksheetHash[`xl/${rel.Target.replace(/^(\s|\/xl\/)+/, "")}`];
            // If there are "chartsheets" in the file, rel.Target will
            // come out as chartsheets/sheet1.xml or similar here, and
            // that won't be in model.worksheetHash.
            // As we don't have the infrastructure to support chartsheets,
            // we will ignore them for now:
            if (worksheet) {
                worksheet.name = sheet.name;
                worksheet.id = sheet.id;
                worksheet.state = sheet.state;
                worksheets[index++] = worksheet;
            }
        });
        // reconcile print areas
        const definedNames = [];
        _.each(model.definedNames, (definedName)=>{
            if (definedName.name === "_xlnm.Print_Area") {
                worksheet = worksheets[definedName.localSheetId];
                if (worksheet) {
                    if (!worksheet.pageSetup) {
                        worksheet.pageSetup = {};
                    }
                    const range = colCache.decodeEx(definedName.ranges[0]);
                    worksheet.pageSetup.printArea = worksheet.pageSetup.printArea ? `${worksheet.pageSetup.printArea}&&${range.dimensions}` : range.dimensions;
                }
            } else if (definedName.name === "_xlnm.Print_Titles") {
                worksheet = worksheets[definedName.localSheetId];
                if (worksheet) {
                    if (!worksheet.pageSetup) {
                        worksheet.pageSetup = {};
                    }
                    const rangeString = definedName.ranges.join(",");
                    const dollarRegex = /\$/g;
                    const rowRangeRegex = /\$\d+:\$\d+/;
                    const rowRangeMatches = rangeString.match(rowRangeRegex);
                    if (rowRangeMatches && rowRangeMatches.length) {
                        const range = rowRangeMatches[0];
                        worksheet.pageSetup.printTitlesRow = range.replace(dollarRegex, "");
                    }
                    const columnRangeRegex = /\$[A-Z]+:\$[A-Z]+/;
                    const columnRangeMatches = rangeString.match(columnRangeRegex);
                    if (columnRangeMatches && columnRangeMatches.length) {
                        const range = columnRangeMatches[0];
                        worksheet.pageSetup.printTitlesColumn = range.replace(dollarRegex, "");
                    }
                }
            } else {
                definedNames.push(definedName);
            }
        });
        model.definedNames = definedNames;
        // used by sheets to build their image models
        model.media.forEach((media, i)=>{
            media.index = i;
        });
    }
}
WorkbookXform.WORKBOOK_ATTRIBUTES = {
    xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
    "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
    "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
    "mc:Ignorable": "x15",
    "xmlns:x15": "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"
};
WorkbookXform.STATIC_XFORMS = {
    fileVersion: new StaticXform({
        tag: "fileVersion",
        $: {
            appName: "xl",
            lastEdited: 5,
            lowestEdited: 5,
            rupBuild: 9303
        }
    })
};
module.exports = WorkbookXform;


/***/ }),

/***/ 32977:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const RichTextXform = __webpack_require__(9367);
const utils = __webpack_require__(90778);
const BaseXform = __webpack_require__(90884);
/**
  <comment ref="B1" authorId="0">
    <text>
      <r>
        <rPr>
          <b/>
          <sz val="9"/>
          <rFont val=""/>
          <charset val="134"/>
        </rPr>
        <t>51422:</t>
      </r>
      <r>
        <rPr>
          <sz val="9"/>
          <rFont val=""/>
          <charset val="134"/>
        </rPr>
        <t xml:space="preserve">&#10;test</t>
      </r>
    </text>
  </comment>
 */ const CommentXform = module.exports = function(model) {
    this.model = model;
};
utils.inherits(CommentXform, BaseXform, {
    get tag () {
        return "r";
    },
    get richTextXform () {
        if (!this._richTextXform) {
            this._richTextXform = new RichTextXform();
        }
        return this._richTextXform;
    },
    render (xmlStream, model) {
        model = model || this.model;
        xmlStream.openNode("comment", {
            ref: model.ref,
            authorId: 0
        });
        xmlStream.openNode("text");
        if (model && model.note && model.note.texts) {
            model.note.texts.forEach((text)=>{
                this.richTextXform.render(xmlStream, text);
            });
        }
        xmlStream.closeNode();
        xmlStream.closeNode();
    },
    parseOpen (node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case "comment":
                this.model = {
                    type: "note",
                    note: {
                        texts: []
                    },
                    ...node.attributes
                };
                return true;
            case "r":
                this.parser = this.richTextXform;
                this.parser.parseOpen(node);
                return true;
            default:
                return false;
        }
    },
    parseText (text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    },
    parseClose (name) {
        switch(name){
            case "comment":
                return false;
            case "r":
                this.model.note.texts.push(this.parser.model);
                this.parser = undefined;
                return true;
            default:
                if (this.parser) {
                    this.parser.parseClose(name);
                }
                return true;
        }
    }
});


/***/ }),

/***/ 21859:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const XmlStream = __webpack_require__(18749);
const utils = __webpack_require__(90778);
const BaseXform = __webpack_require__(90884);
const CommentXform = __webpack_require__(32977);
const CommentsXform = module.exports = function() {
    this.map = {
        comment: new CommentXform()
    };
};
utils.inherits(CommentsXform, BaseXform, {
    COMMENTS_ATTRIBUTES: {
        xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main"
    }
}, {
    render (xmlStream, model) {
        model = model || this.model;
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("comments", CommentsXform.COMMENTS_ATTRIBUTES);
        // authors
        // TODO: support authors properly
        xmlStream.openNode("authors");
        xmlStream.leafNode("author", null, "Author");
        xmlStream.closeNode();
        // comments
        xmlStream.openNode("commentList");
        model.comments.forEach((comment)=>{
            this.map.comment.render(xmlStream, comment);
        });
        xmlStream.closeNode();
        xmlStream.closeNode();
    },
    parseOpen (node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case "commentList":
                this.model = {
                    comments: []
                };
                return true;
            case "comment":
                this.parser = this.map.comment;
                this.parser.parseOpen(node);
                return true;
            default:
                return false;
        }
    },
    parseText (text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    },
    parseClose (name) {
        switch(name){
            case "commentList":
                return false;
            case "comment":
                this.model.comments.push(this.parser.model);
                this.parser = undefined;
                return true;
            default:
                if (this.parser) {
                    this.parser.parseClose(name);
                }
                return true;
        }
    }
});


/***/ }),

/***/ 36976:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class VmlPositionXform extends BaseXform {
    constructor(model){
        super();
        this._model = model;
    }
    get tag() {
        return this._model && this._model.tag;
    }
    render(xmlStream, model, type) {
        if (model === type[2]) {
            xmlStream.leafNode(this.tag);
        } else if (this.tag === "x:SizeWithCells" && model === type[1]) {
            xmlStream.leafNode(this.tag);
        }
    }
    parseOpen(node) {
        switch(node.name){
            case this.tag:
                this.model = {};
                this.model[this.tag] = true;
                return true;
            default:
                return false;
        }
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = VmlPositionXform;


/***/ }),

/***/ 6951:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class VmlProtectionXform extends BaseXform {
    constructor(model){
        super();
        this._model = model;
    }
    get tag() {
        return this._model && this._model.tag;
    }
    render(xmlStream, model) {
        xmlStream.leafNode(this.tag, null, model);
    }
    parseOpen(node) {
        switch(node.name){
            case this.tag:
                this.text = "";
                return true;
            default:
                return false;
        }
    }
    parseText(text) {
        this.text = text;
    }
    parseClose() {
        return false;
    }
}
module.exports = VmlProtectionXform;


/***/ }),

/***/ 41069:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
// render the triangle in the cell for the comment
class VmlAnchorXform extends BaseXform {
    get tag() {
        return "x:Anchor";
    }
    getAnchorRect(anchor) {
        const l = Math.floor(anchor.left);
        const lf = Math.floor((anchor.left - l) * 68);
        const t = Math.floor(anchor.top);
        const tf = Math.floor((anchor.top - t) * 18);
        const r = Math.floor(anchor.right);
        const rf = Math.floor((anchor.right - r) * 68);
        const b = Math.floor(anchor.bottom);
        const bf = Math.floor((anchor.bottom - b) * 18);
        return [
            l,
            lf,
            t,
            tf,
            r,
            rf,
            b,
            bf
        ];
    }
    getDefaultRect(ref) {
        const l = ref.col;
        const lf = 6;
        const t = Math.max(ref.row - 2, 0);
        const tf = 14;
        const r = l + 2;
        const rf = 2;
        const b = t + 4;
        const bf = 16;
        return [
            l,
            lf,
            t,
            tf,
            r,
            rf,
            b,
            bf
        ];
    }
    render(xmlStream, model) {
        const rect = model.anchor ? this.getAnchorRect(model.anchor) : this.getDefaultRect(model.refAddress);
        xmlStream.leafNode("x:Anchor", null, rect.join(", "));
    }
    parseOpen(node) {
        switch(node.name){
            case this.tag:
                this.text = "";
                return true;
            default:
                return false;
        }
    }
    parseText(text) {
        this.text = text;
    }
    parseClose() {
        return false;
    }
}
module.exports = VmlAnchorXform;


/***/ }),

/***/ 57262:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const VmlAnchorXform = __webpack_require__(41069);
const VmlProtectionXform = __webpack_require__(6951);
const VmlPositionXform = __webpack_require__(36976);
const POSITION_TYPE = [
    "twoCells",
    "oneCells",
    "absolute"
];
class VmlClientDataXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            "x:Anchor": new VmlAnchorXform(),
            "x:Locked": new VmlProtectionXform({
                tag: "x:Locked"
            }),
            "x:LockText": new VmlProtectionXform({
                tag: "x:LockText"
            }),
            "x:SizeWithCells": new VmlPositionXform({
                tag: "x:SizeWithCells"
            }),
            "x:MoveWithCells": new VmlPositionXform({
                tag: "x:MoveWithCells"
            })
        };
    }
    get tag() {
        return "x:ClientData";
    }
    render(xmlStream, model) {
        const { protection, editAs } = model.note;
        xmlStream.openNode(this.tag, {
            ObjectType: "Note"
        });
        this.map["x:MoveWithCells"].render(xmlStream, editAs, POSITION_TYPE);
        this.map["x:SizeWithCells"].render(xmlStream, editAs, POSITION_TYPE);
        this.map["x:Anchor"].render(xmlStream, model);
        this.map["x:Locked"].render(xmlStream, protection.locked);
        xmlStream.leafNode("x:AutoFill", null, "False");
        this.map["x:LockText"].render(xmlStream, protection.lockText);
        xmlStream.leafNode("x:Row", null, model.refAddress.row - 1);
        xmlStream.leafNode("x:Column", null, model.refAddress.col - 1);
        xmlStream.closeNode();
    }
    parseOpen(node) {
        switch(node.name){
            case this.tag:
                this.reset();
                this.model = {
                    anchor: [],
                    protection: {},
                    editAs: ""
                };
                break;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                }
                break;
        }
        return true;
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case this.tag:
                this.normalizeModel();
                return false;
            default:
                return true;
        }
    }
    normalizeModel() {
        const position = Object.assign({}, this.map["x:MoveWithCells"].model, this.map["x:SizeWithCells"].model);
        const len = Object.keys(position).length;
        this.model.editAs = POSITION_TYPE[len];
        this.model.anchor = this.map["x:Anchor"].text;
        this.model.protection.locked = this.map["x:Locked"].text;
        this.model.protection.lockText = this.map["x:LockText"].text;
    }
}
module.exports = VmlClientDataXform;


/***/ }),

/***/ 52365:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const XmlStream = __webpack_require__(18749);
const BaseXform = __webpack_require__(90884);
const VmlShapeXform = __webpack_require__(15343);
// This class is (currently) single purposed to insert the triangle
// drawing icons on commented cells
class VmlNotesXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            "v:shape": new VmlShapeXform()
        };
    }
    get tag() {
        return "xml";
    }
    render(xmlStream, model) {
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode(this.tag, VmlNotesXform.DRAWING_ATTRIBUTES);
        xmlStream.openNode("o:shapelayout", {
            "v:ext": "edit"
        });
        xmlStream.leafNode("o:idmap", {
            "v:ext": "edit",
            data: 1
        });
        xmlStream.closeNode();
        xmlStream.openNode("v:shapetype", {
            id: "_x0000_t202",
            coordsize: "21600,21600",
            "o:spt": 202,
            path: "m,l,21600r21600,l21600,xe"
        });
        xmlStream.leafNode("v:stroke", {
            joinstyle: "miter"
        });
        xmlStream.leafNode("v:path", {
            gradientshapeok: "t",
            "o:connecttype": "rect"
        });
        xmlStream.closeNode();
        model.comments.forEach((item, index)=>{
            this.map["v:shape"].render(xmlStream, item, index);
        });
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case this.tag:
                this.reset();
                this.model = {
                    comments: []
                };
                break;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                }
                break;
        }
        return true;
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.model.comments.push(this.parser.model);
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case this.tag:
                return false;
            default:
                // could be some unrecognised tags
                return true;
        }
    }
    reconcile(model, options) {
        model.anchors.forEach((anchor)=>{
            if (anchor.br) {
                this.map["xdr:twoCellAnchor"].reconcile(anchor, options);
            } else {
                this.map["xdr:oneCellAnchor"].reconcile(anchor, options);
            }
        });
    }
}
VmlNotesXform.DRAWING_ATTRIBUTES = {
    "xmlns:v": "urn:schemas-microsoft-com:vml",
    "xmlns:o": "urn:schemas-microsoft-com:office:office",
    "xmlns:x": "urn:schemas-microsoft-com:office:excel"
};
module.exports = VmlNotesXform;


/***/ }),

/***/ 15343:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const VmlTextboxXform = __webpack_require__(86430);
const VmlClientDataXform = __webpack_require__(57262);
class VmlShapeXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            "v:textbox": new VmlTextboxXform(),
            "x:ClientData": new VmlClientDataXform()
        };
    }
    get tag() {
        return "v:shape";
    }
    render(xmlStream, model, index) {
        xmlStream.openNode("v:shape", VmlShapeXform.V_SHAPE_ATTRIBUTES(model, index));
        xmlStream.leafNode("v:fill", {
            color2: "infoBackground [80]"
        });
        xmlStream.leafNode("v:shadow", {
            color: "none [81]",
            obscured: "t"
        });
        xmlStream.leafNode("v:path", {
            "o:connecttype": "none"
        });
        this.map["v:textbox"].render(xmlStream, model);
        this.map["x:ClientData"].render(xmlStream, model);
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case this.tag:
                this.reset();
                this.model = {
                    margins: {
                        insetmode: node.attributes["o:insetmode"]
                    },
                    anchor: "",
                    editAs: "",
                    protection: {}
                };
                break;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                }
                break;
        }
        return true;
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case this.tag:
                this.model.margins.inset = this.map["v:textbox"].model && this.map["v:textbox"].model.inset;
                this.model.protection = this.map["x:ClientData"].model && this.map["x:ClientData"].model.protection;
                this.model.anchor = this.map["x:ClientData"].model && this.map["x:ClientData"].model.anchor;
                this.model.editAs = this.map["x:ClientData"].model && this.map["x:ClientData"].model.editAs;
                return false;
            default:
                return true;
        }
    }
}
VmlShapeXform.V_SHAPE_ATTRIBUTES = (model, index)=>({
        id: `_x0000_s${1025 + index}`,
        type: "#_x0000_t202",
        style: "position:absolute; margin-left:105.3pt;margin-top:10.5pt;width:97.8pt;height:59.1pt;z-index:1;visibility:hidden",
        fillcolor: "infoBackground [80]",
        strokecolor: "none [81]",
        "o:insetmode": model.note.margins && model.note.margins.insetmode
    });
module.exports = VmlShapeXform;


/***/ }),

/***/ 86430:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class VmlTextboxXform extends BaseXform {
    get tag() {
        return "v:textbox";
    }
    conversionUnit(value, multiple, unit) {
        return `${parseFloat(value) * multiple.toFixed(2)}${unit}`;
    }
    reverseConversionUnit(inset) {
        return (inset || "").split(",").map((margin)=>{
            return Number(parseFloat(this.conversionUnit(parseFloat(margin), 0.1, "")).toFixed(2));
        });
    }
    render(xmlStream, model) {
        const attributes = {
            style: "mso-direction-alt:auto"
        };
        if (model && model.note) {
            let { inset } = model.note && model.note.margins;
            if (Array.isArray(inset)) {
                inset = inset.map((margin)=>{
                    return this.conversionUnit(margin, 10, "mm");
                }).join(",");
            }
            if (inset) {
                attributes.inset = inset;
            }
        }
        xmlStream.openNode("v:textbox", attributes);
        xmlStream.leafNode("div", {
            style: "text-align:left"
        });
        xmlStream.closeNode();
    }
    parseOpen(node) {
        switch(node.name){
            case this.tag:
                this.model = {
                    inset: this.reverseConversionUnit(node.attributes.inset)
                };
                return true;
            default:
                return true;
        }
    }
    parseText() {}
    parseClose(name) {
        switch(name){
            case this.tag:
                return false;
            default:
                return true;
        }
    }
}
module.exports = VmlTextboxXform;


/***/ }),

/***/ 9239:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
/* 'virtual' methods used as a form of documentation */ /* eslint-disable class-methods-use-this */ // base class for xforms that are composed of other xforms
// offers some default implementations
class CompositeXform extends BaseXform {
    createNewModel(node) {
        return {};
    }
    parseOpen(node) {
        // Typical pattern for composite xform
        this.parser = this.parser || this.map[node.name];
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        if (node.name === this.tag) {
            this.model = this.createNewModel(node);
            return true;
        }
        return false;
    }
    parseText(text) {
        // Default implementation. Send text to child parser
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    onParserClose(name, parser) {
        // parseClose has seen a child parser close
        // now need to incorporate into this.model somehow
        this.model[name] = parser.model;
    }
    parseClose(name) {
        // Default implementation
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.onParserClose(name, this.parser);
                this.parser = undefined;
            }
            return true;
        }
        return name !== this.tag;
    }
}
module.exports = CompositeXform;


/***/ }),

/***/ 71068:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class AppHeadingPairsXform extends BaseXform {
    render(xmlStream, model) {
        xmlStream.openNode("HeadingPairs");
        xmlStream.openNode("vt:vector", {
            size: 2,
            baseType: "variant"
        });
        xmlStream.openNode("vt:variant");
        xmlStream.leafNode("vt:lpstr", undefined, "Worksheets");
        xmlStream.closeNode();
        xmlStream.openNode("vt:variant");
        xmlStream.leafNode("vt:i4", undefined, model.length);
        xmlStream.closeNode();
        xmlStream.closeNode();
        xmlStream.closeNode();
    }
    parseOpen(node) {
        // no parsing
        return node.name === "HeadingPairs";
    }
    parseText() {}
    parseClose(name) {
        return name !== "HeadingPairs";
    }
}
module.exports = AppHeadingPairsXform;


/***/ }),

/***/ 1647:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class AppTitlesOfPartsXform extends BaseXform {
    render(xmlStream, model) {
        xmlStream.openNode("TitlesOfParts");
        xmlStream.openNode("vt:vector", {
            size: model.length,
            baseType: "lpstr"
        });
        model.forEach((sheet)=>{
            xmlStream.leafNode("vt:lpstr", undefined, sheet.name);
        });
        xmlStream.closeNode();
        xmlStream.closeNode();
    }
    parseOpen(node) {
        // no parsing
        return node.name === "TitlesOfParts";
    }
    parseText() {}
    parseClose(name) {
        return name !== "TitlesOfParts";
    }
}
module.exports = AppTitlesOfPartsXform;


/***/ }),

/***/ 15081:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const XmlStream = __webpack_require__(18749);
const BaseXform = __webpack_require__(90884);
const StringXform = __webpack_require__(15510);
const AppHeadingPairsXform = __webpack_require__(71068);
const AppTitleOfPartsXform = __webpack_require__(1647);
class AppXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            Company: new StringXform({
                tag: "Company"
            }),
            Manager: new StringXform({
                tag: "Manager"
            }),
            HeadingPairs: new AppHeadingPairsXform(),
            TitleOfParts: new AppTitleOfPartsXform()
        };
    }
    render(xmlStream, model) {
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("Properties", AppXform.PROPERTY_ATTRIBUTES);
        xmlStream.leafNode("Application", undefined, "Microsoft Excel");
        xmlStream.leafNode("DocSecurity", undefined, "0");
        xmlStream.leafNode("ScaleCrop", undefined, "false");
        this.map.HeadingPairs.render(xmlStream, model.worksheets);
        this.map.TitleOfParts.render(xmlStream, model.worksheets);
        this.map.Company.render(xmlStream, model.company || "");
        this.map.Manager.render(xmlStream, model.manager);
        xmlStream.leafNode("LinksUpToDate", undefined, "false");
        xmlStream.leafNode("SharedDoc", undefined, "false");
        xmlStream.leafNode("HyperlinksChanged", undefined, "false");
        xmlStream.leafNode("AppVersion", undefined, "16.0300");
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case "Properties":
                return true;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                    return true;
                }
                // there's a lot we don't bother to parse
                return false;
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case "Properties":
                this.model = {
                    worksheets: this.map.TitleOfParts.model,
                    company: this.map.Company.model,
                    manager: this.map.Manager.model
                };
                return false;
            default:
                return true;
        }
    }
}
AppXform.DateFormat = function(dt) {
    return dt.toISOString().replace(/[.]\d{3,6}/, "");
};
AppXform.DateAttrs = {
    "xsi:type": "dcterms:W3CDTF"
};
AppXform.PROPERTY_ATTRIBUTES = {
    xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
    "xmlns:vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
};
module.exports = AppXform;


/***/ }),

/***/ 13518:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const XmlStream = __webpack_require__(18749);
const BaseXform = __webpack_require__(90884);
// used for rendering the [Content_Types].xml file
// not used for parsing
class ContentTypesXform extends BaseXform {
    render(xmlStream, model) {
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("Types", ContentTypesXform.PROPERTY_ATTRIBUTES);
        const mediaHash = {};
        (model.media || []).forEach((medium)=>{
            if (medium.type === "image") {
                const imageType = medium.extension;
                if (!mediaHash[imageType]) {
                    mediaHash[imageType] = true;
                    xmlStream.leafNode("Default", {
                        Extension: imageType,
                        ContentType: `image/${imageType}`
                    });
                }
            }
        });
        xmlStream.leafNode("Default", {
            Extension: "rels",
            ContentType: "application/vnd.openxmlformats-package.relationships+xml"
        });
        xmlStream.leafNode("Default", {
            Extension: "xml",
            ContentType: "application/xml"
        });
        xmlStream.leafNode("Override", {
            PartName: "/xl/workbook.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"
        });
        model.worksheets.forEach((worksheet)=>{
            const name = `/xl/worksheets/sheet${worksheet.id}.xml`;
            xmlStream.leafNode("Override", {
                PartName: name,
                ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"
            });
        });
        xmlStream.leafNode("Override", {
            PartName: "/xl/theme/theme1.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.theme+xml"
        });
        xmlStream.leafNode("Override", {
            PartName: "/xl/styles.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"
        });
        const hasSharedStrings = model.sharedStrings && model.sharedStrings.count;
        if (hasSharedStrings) {
            xmlStream.leafNode("Override", {
                PartName: "/xl/sharedStrings.xml",
                ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"
            });
        }
        if (model.tables) {
            model.tables.forEach((table)=>{
                xmlStream.leafNode("Override", {
                    PartName: `/xl/tables/${table.target}`,
                    ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"
                });
            });
        }
        if (model.drawings) {
            model.drawings.forEach((drawing)=>{
                xmlStream.leafNode("Override", {
                    PartName: `/xl/drawings/${drawing.name}.xml`,
                    ContentType: "application/vnd.openxmlformats-officedocument.drawing+xml"
                });
            });
        }
        if (model.commentRefs) {
            xmlStream.leafNode("Default", {
                Extension: "vml",
                ContentType: "application/vnd.openxmlformats-officedocument.vmlDrawing"
            });
            model.commentRefs.forEach(({ commentName })=>{
                xmlStream.leafNode("Override", {
                    PartName: `/xl/${commentName}.xml`,
                    ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml"
                });
            });
        }
        xmlStream.leafNode("Override", {
            PartName: "/docProps/core.xml",
            ContentType: "application/vnd.openxmlformats-package.core-properties+xml"
        });
        xmlStream.leafNode("Override", {
            PartName: "/docProps/app.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.extended-properties+xml"
        });
        xmlStream.closeNode();
    }
    parseOpen() {
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
ContentTypesXform.PROPERTY_ATTRIBUTES = {
    xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
};
module.exports = ContentTypesXform;


/***/ }),

/***/ 81637:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const XmlStream = __webpack_require__(18749);
const BaseXform = __webpack_require__(90884);
const DateXform = __webpack_require__(16245);
const StringXform = __webpack_require__(15510);
const IntegerXform = __webpack_require__(51377);
class CoreXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            "dc:creator": new StringXform({
                tag: "dc:creator"
            }),
            "dc:title": new StringXform({
                tag: "dc:title"
            }),
            "dc:subject": new StringXform({
                tag: "dc:subject"
            }),
            "dc:description": new StringXform({
                tag: "dc:description"
            }),
            "dc:identifier": new StringXform({
                tag: "dc:identifier"
            }),
            "dc:language": new StringXform({
                tag: "dc:language"
            }),
            "cp:keywords": new StringXform({
                tag: "cp:keywords"
            }),
            "cp:category": new StringXform({
                tag: "cp:category"
            }),
            "cp:lastModifiedBy": new StringXform({
                tag: "cp:lastModifiedBy"
            }),
            "cp:lastPrinted": new DateXform({
                tag: "cp:lastPrinted",
                format: CoreXform.DateFormat
            }),
            "cp:revision": new IntegerXform({
                tag: "cp:revision"
            }),
            "cp:version": new StringXform({
                tag: "cp:version"
            }),
            "cp:contentStatus": new StringXform({
                tag: "cp:contentStatus"
            }),
            "cp:contentType": new StringXform({
                tag: "cp:contentType"
            }),
            "dcterms:created": new DateXform({
                tag: "dcterms:created",
                attrs: CoreXform.DateAttrs,
                format: CoreXform.DateFormat
            }),
            "dcterms:modified": new DateXform({
                tag: "dcterms:modified",
                attrs: CoreXform.DateAttrs,
                format: CoreXform.DateFormat
            })
        };
    }
    render(xmlStream, model) {
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("cp:coreProperties", CoreXform.CORE_PROPERTY_ATTRIBUTES);
        this.map["dc:creator"].render(xmlStream, model.creator);
        this.map["dc:title"].render(xmlStream, model.title);
        this.map["dc:subject"].render(xmlStream, model.subject);
        this.map["dc:description"].render(xmlStream, model.description);
        this.map["dc:identifier"].render(xmlStream, model.identifier);
        this.map["dc:language"].render(xmlStream, model.language);
        this.map["cp:keywords"].render(xmlStream, model.keywords);
        this.map["cp:category"].render(xmlStream, model.category);
        this.map["cp:lastModifiedBy"].render(xmlStream, model.lastModifiedBy);
        this.map["cp:lastPrinted"].render(xmlStream, model.lastPrinted);
        this.map["cp:revision"].render(xmlStream, model.revision);
        this.map["cp:version"].render(xmlStream, model.version);
        this.map["cp:contentStatus"].render(xmlStream, model.contentStatus);
        this.map["cp:contentType"].render(xmlStream, model.contentType);
        this.map["dcterms:created"].render(xmlStream, model.created);
        this.map["dcterms:modified"].render(xmlStream, model.modified);
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case "cp:coreProperties":
            case "coreProperties":
                return true;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                    return true;
                }
                throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case "cp:coreProperties":
            case "coreProperties":
                this.model = {
                    creator: this.map["dc:creator"].model,
                    title: this.map["dc:title"].model,
                    subject: this.map["dc:subject"].model,
                    description: this.map["dc:description"].model,
                    identifier: this.map["dc:identifier"].model,
                    language: this.map["dc:language"].model,
                    keywords: this.map["cp:keywords"].model,
                    category: this.map["cp:category"].model,
                    lastModifiedBy: this.map["cp:lastModifiedBy"].model,
                    lastPrinted: this.map["cp:lastPrinted"].model,
                    revision: this.map["cp:revision"].model,
                    contentStatus: this.map["cp:contentStatus"].model,
                    contentType: this.map["cp:contentType"].model,
                    created: this.map["dcterms:created"].model,
                    modified: this.map["dcterms:modified"].model
                };
                return false;
            default:
                throw new Error(`Unexpected xml node in parseClose: ${name}`);
        }
    }
}
CoreXform.DateFormat = function(dt) {
    return dt.toISOString().replace(/[.]\d{3}/, "");
};
CoreXform.DateAttrs = {
    "xsi:type": "dcterms:W3CDTF"
};
CoreXform.CORE_PROPERTY_ATTRIBUTES = {
    "xmlns:cp": "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
    "xmlns:dc": "http://purl.org/dc/elements/1.1/",
    "xmlns:dcterms": "http://purl.org/dc/terms/",
    "xmlns:dcmitype": "http://purl.org/dc/dcmitype/",
    "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance"
};
module.exports = CoreXform;


/***/ }),

/***/ 17687:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class RelationshipXform extends BaseXform {
    render(xmlStream, model) {
        xmlStream.leafNode("Relationship", model);
    }
    parseOpen(node) {
        switch(node.name){
            case "Relationship":
                this.model = node.attributes;
                return true;
            default:
                return false;
        }
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = RelationshipXform;


/***/ }),

/***/ 6849:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const XmlStream = __webpack_require__(18749);
const BaseXform = __webpack_require__(90884);
const RelationshipXform = __webpack_require__(17687);
class RelationshipsXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            Relationship: new RelationshipXform()
        };
    }
    render(xmlStream, model) {
        model = model || this._values;
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("Relationships", RelationshipsXform.RELATIONSHIPS_ATTRIBUTES);
        model.forEach((relationship)=>{
            this.map.Relationship.render(xmlStream, relationship);
        });
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case "Relationships":
                this.model = [];
                return true;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                    return true;
                }
                throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.model.push(this.parser.model);
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case "Relationships":
                return false;
            default:
                throw new Error(`Unexpected xml node in parseClose: ${name}`);
        }
    }
}
RelationshipsXform.RELATIONSHIPS_ATTRIBUTES = {
    xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
};
module.exports = RelationshipsXform;


/***/ }),

/***/ 10347:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class BaseCellAnchorXform extends BaseXform {
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case this.tag:
                this.reset();
                this.model = {
                    range: {
                        editAs: node.attributes.editAs || "oneCell"
                    }
                };
                break;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                }
                break;
        }
        return true;
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    reconcilePicture(model, options) {
        if (model && model.rId) {
            const rel = options.rels[model.rId];
            const match = rel.Target.match(/.*\/media\/(.+[.][a-zA-Z]{3,4})/);
            if (match) {
                const name = match[1];
                const mediaId = options.mediaIndex[name];
                return options.media[mediaId];
            }
        }
        return undefined;
    }
}
module.exports = BaseCellAnchorXform;


/***/ }),

/***/ 408:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const BlipXform = __webpack_require__(61749);
class BlipFillXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            "a:blip": new BlipXform()
        };
    }
    get tag() {
        return "xdr:blipFill";
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        this.map["a:blip"].render(xmlStream, model);
        // TODO: options for this + parsing
        xmlStream.openNode("a:stretch");
        xmlStream.leafNode("a:fillRect");
        xmlStream.closeNode();
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case this.tag:
                this.reset();
                break;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                }
                break;
        }
        return true;
    }
    parseText() {}
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case this.tag:
                this.model = this.map["a:blip"].model;
                return false;
            default:
                return true;
        }
    }
}
module.exports = BlipFillXform;


/***/ }),

/***/ 61749:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class BlipXform extends BaseXform {
    get tag() {
        return "a:blip";
    }
    render(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
            "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
            "r:embed": model.rId,
            cstate: "print"
        });
    // TODO: handle children (e.g. a:extLst=>a:ext=>a14:useLocalDpi
    }
    parseOpen(node) {
        switch(node.name){
            case this.tag:
                this.model = {
                    rId: node.attributes["r:embed"]
                };
                return true;
            default:
                return true;
        }
    }
    parseText() {}
    parseClose(name) {
        switch(name){
            case this.tag:
                return false;
            default:
                // unprocessed internal nodes
                return true;
        }
    }
}
module.exports = BlipXform;


/***/ }),

/***/ 96555:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class CNvPicPrXform extends BaseXform {
    get tag() {
        return "xdr:cNvPicPr";
    }
    render(xmlStream) {
        xmlStream.openNode(this.tag);
        xmlStream.leafNode("a:picLocks", {
            noChangeAspect: "1"
        });
        xmlStream.closeNode();
    }
    parseOpen(node) {
        switch(node.name){
            case this.tag:
                return true;
            default:
                return true;
        }
    }
    parseText() {}
    parseClose(name) {
        switch(name){
            case this.tag:
                return false;
            default:
                // unprocessed internal nodes
                return true;
        }
    }
}
module.exports = CNvPicPrXform;


/***/ }),

/***/ 10223:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const HlickClickXform = __webpack_require__(48759);
const ExtLstXform = __webpack_require__(74921);
class CNvPrXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            "a:hlinkClick": new HlickClickXform(),
            "a:extLst": new ExtLstXform()
        };
    }
    get tag() {
        return "xdr:cNvPr";
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            id: model.index,
            name: `Picture ${model.index}`
        });
        this.map["a:hlinkClick"].render(xmlStream, model);
        this.map["a:extLst"].render(xmlStream, model);
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case this.tag:
                this.reset();
                break;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                }
                break;
        }
        return true;
    }
    parseText() {}
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case this.tag:
                this.model = this.map["a:hlinkClick"].model;
                return false;
            default:
                return true;
        }
    }
}
module.exports = CNvPrXform;


/***/ }),

/***/ 73044:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const IntegerXform = __webpack_require__(51377);
class CellPositionXform extends BaseXform {
    constructor(options){
        super();
        this.tag = options.tag;
        this.map = {
            "xdr:col": new IntegerXform({
                tag: "xdr:col",
                zero: true
            }),
            "xdr:colOff": new IntegerXform({
                tag: "xdr:colOff",
                zero: true
            }),
            "xdr:row": new IntegerXform({
                tag: "xdr:row",
                zero: true
            }),
            "xdr:rowOff": new IntegerXform({
                tag: "xdr:rowOff",
                zero: true
            })
        };
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        this.map["xdr:col"].render(xmlStream, model.nativeCol);
        this.map["xdr:colOff"].render(xmlStream, model.nativeColOff);
        this.map["xdr:row"].render(xmlStream, model.nativeRow);
        this.map["xdr:rowOff"].render(xmlStream, model.nativeRowOff);
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case this.tag:
                this.reset();
                break;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                }
                break;
        }
        return true;
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case this.tag:
                this.model = {
                    nativeCol: this.map["xdr:col"].model,
                    nativeColOff: this.map["xdr:colOff"].model,
                    nativeRow: this.map["xdr:row"].model,
                    nativeRowOff: this.map["xdr:rowOff"].model
                };
                return false;
            default:
                // not quite sure how we get here!
                return true;
        }
    }
}
module.exports = CellPositionXform;


/***/ }),

/***/ 56130:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const colCache = __webpack_require__(90609);
const XmlStream = __webpack_require__(18749);
const BaseXform = __webpack_require__(90884);
const TwoCellAnchorXform = __webpack_require__(1663);
const OneCellAnchorXform = __webpack_require__(37363);
function getAnchorType(model) {
    const range = typeof model.range === "string" ? colCache.decode(model.range) : model.range;
    return range.br ? "xdr:twoCellAnchor" : "xdr:oneCellAnchor";
}
class DrawingXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            "xdr:twoCellAnchor": new TwoCellAnchorXform(),
            "xdr:oneCellAnchor": new OneCellAnchorXform()
        };
    }
    prepare(model) {
        model.anchors.forEach((item, index)=>{
            item.anchorType = getAnchorType(item);
            const anchor = this.map[item.anchorType];
            anchor.prepare(item, {
                index
            });
        });
    }
    get tag() {
        return "xdr:wsDr";
    }
    render(xmlStream, model) {
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode(this.tag, DrawingXform.DRAWING_ATTRIBUTES);
        model.anchors.forEach((item)=>{
            const anchor = this.map[item.anchorType];
            anchor.render(xmlStream, item);
        });
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case this.tag:
                this.reset();
                this.model = {
                    anchors: []
                };
                break;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                }
                break;
        }
        return true;
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.model.anchors.push(this.parser.model);
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case this.tag:
                return false;
            default:
                // could be some unrecognised tags
                return true;
        }
    }
    reconcile(model, options) {
        model.anchors.forEach((anchor)=>{
            if (anchor.br) {
                this.map["xdr:twoCellAnchor"].reconcile(anchor, options);
            } else {
                this.map["xdr:oneCellAnchor"].reconcile(anchor, options);
            }
        });
    }
}
DrawingXform.DRAWING_ATTRIBUTES = {
    "xmlns:xdr": "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing",
    "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main"
};
module.exports = DrawingXform;


/***/ }),

/***/ 74921:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class ExtLstXform extends BaseXform {
    get tag() {
        return "a:extLst";
    }
    render(xmlStream) {
        xmlStream.openNode(this.tag);
        xmlStream.openNode("a:ext", {
            uri: "{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}"
        });
        xmlStream.leafNode("a16:creationId", {
            "xmlns:a16": "http://schemas.microsoft.com/office/drawing/2014/main",
            id: "{00000000-0008-0000-0000-000002000000}"
        });
        xmlStream.closeNode();
        xmlStream.closeNode();
    }
    parseOpen(node) {
        switch(node.name){
            case this.tag:
                return true;
            default:
                return true;
        }
    }
    parseText() {}
    parseClose(name) {
        switch(name){
            case this.tag:
                return false;
            default:
                // unprocessed internal nodes
                return true;
        }
    }
}
module.exports = ExtLstXform;


/***/ }),

/***/ 81805:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
/** https://en.wikipedia.org/wiki/Office_Open_XML_file_formats#DrawingML */ const EMU_PER_PIXEL_AT_96_DPI = 9525;
class ExtXform extends BaseXform {
    constructor(options){
        super();
        this.tag = options.tag;
        this.map = {};
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        const width = Math.floor(model.width * EMU_PER_PIXEL_AT_96_DPI);
        const height = Math.floor(model.height * EMU_PER_PIXEL_AT_96_DPI);
        xmlStream.addAttribute("cx", width);
        xmlStream.addAttribute("cy", height);
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (node.name === this.tag) {
            this.model = {
                width: parseInt(node.attributes.cx || "0", 10) / EMU_PER_PIXEL_AT_96_DPI,
                height: parseInt(node.attributes.cy || "0", 10) / EMU_PER_PIXEL_AT_96_DPI
            };
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = ExtXform;


/***/ }),

/***/ 48759:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class HLinkClickXform extends BaseXform {
    get tag() {
        return "a:hlinkClick";
    }
    render(xmlStream, model) {
        if (!(model.hyperlinks && model.hyperlinks.rId)) {
            return;
        }
        xmlStream.leafNode(this.tag, {
            "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
            "r:id": model.hyperlinks.rId,
            tooltip: model.hyperlinks.tooltip
        });
    }
    parseOpen(node) {
        switch(node.name){
            case this.tag:
                this.model = {
                    hyperlinks: {
                        rId: node.attributes["r:id"],
                        tooltip: node.attributes.tooltip
                    }
                };
                return true;
            default:
                return true;
        }
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = HLinkClickXform;


/***/ }),

/***/ 95431:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const CNvPrXform = __webpack_require__(10223);
const CNvPicPrXform = __webpack_require__(96555);
class NvPicPrXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            "xdr:cNvPr": new CNvPrXform(),
            "xdr:cNvPicPr": new CNvPicPrXform()
        };
    }
    get tag() {
        return "xdr:nvPicPr";
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        this.map["xdr:cNvPr"].render(xmlStream, model);
        this.map["xdr:cNvPicPr"].render(xmlStream, model);
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case this.tag:
                this.reset();
                break;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                }
                break;
        }
        return true;
    }
    parseText() {}
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case this.tag:
                this.model = this.map["xdr:cNvPr"].model;
                return false;
            default:
                return true;
        }
    }
}
module.exports = NvPicPrXform;


/***/ }),

/***/ 37363:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseCellAnchorXform = __webpack_require__(10347);
const StaticXform = __webpack_require__(76949);
const CellPositionXform = __webpack_require__(73044);
const ExtXform = __webpack_require__(81805);
const PicXform = __webpack_require__(63527);
class OneCellAnchorXform extends BaseCellAnchorXform {
    constructor(){
        super();
        this.map = {
            "xdr:from": new CellPositionXform({
                tag: "xdr:from"
            }),
            "xdr:ext": new ExtXform({
                tag: "xdr:ext"
            }),
            "xdr:pic": new PicXform(),
            "xdr:clientData": new StaticXform({
                tag: "xdr:clientData"
            })
        };
    }
    get tag() {
        return "xdr:oneCellAnchor";
    }
    prepare(model, options) {
        this.map["xdr:pic"].prepare(model.picture, options);
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            editAs: model.range.editAs || "oneCell"
        });
        this.map["xdr:from"].render(xmlStream, model.range.tl);
        this.map["xdr:ext"].render(xmlStream, model.range.ext);
        this.map["xdr:pic"].render(xmlStream, model.picture);
        this.map["xdr:clientData"].render(xmlStream, {});
        xmlStream.closeNode();
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case this.tag:
                this.model.range.tl = this.map["xdr:from"].model;
                this.model.range.ext = this.map["xdr:ext"].model;
                this.model.picture = this.map["xdr:pic"].model;
                return false;
            default:
                // could be some unrecognised tags
                return true;
        }
    }
    reconcile(model, options) {
        model.medium = this.reconcilePicture(model.picture, options);
    }
}
module.exports = OneCellAnchorXform;


/***/ }),

/***/ 63527:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const StaticXform = __webpack_require__(76949);
const BlipFillXform = __webpack_require__(408);
const NvPicPrXform = __webpack_require__(95431);
const spPrJSON = __webpack_require__(25689);
class PicXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            "xdr:nvPicPr": new NvPicPrXform(),
            "xdr:blipFill": new BlipFillXform(),
            "xdr:spPr": new StaticXform(spPrJSON)
        };
    }
    get tag() {
        return "xdr:pic";
    }
    prepare(model, options) {
        model.index = options.index + 1;
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        this.map["xdr:nvPicPr"].render(xmlStream, model);
        this.map["xdr:blipFill"].render(xmlStream, model);
        this.map["xdr:spPr"].render(xmlStream, model);
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case this.tag:
                this.reset();
                break;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                }
                break;
        }
        return true;
    }
    parseText() {}
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.mergeModel(this.parser.model);
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case this.tag:
                return false;
            default:
                // not quite sure how we get here!
                return true;
        }
    }
}
module.exports = PicXform;


/***/ }),

/***/ 25689:
/***/ ((module) => {

"use strict";

module.exports = {
    tag: "xdr:spPr",
    c: [
        {
            tag: "a:xfrm",
            c: [
                {
                    tag: "a:off",
                    $: {
                        x: "0",
                        y: "0"
                    }
                },
                {
                    tag: "a:ext",
                    $: {
                        cx: "0",
                        cy: "0"
                    }
                }
            ]
        },
        {
            tag: "a:prstGeom",
            $: {
                prst: "rect"
            },
            c: [
                {
                    tag: "a:avLst"
                }
            ]
        }
    ]
};


/***/ }),

/***/ 1663:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseCellAnchorXform = __webpack_require__(10347);
const StaticXform = __webpack_require__(76949);
const CellPositionXform = __webpack_require__(73044);
const PicXform = __webpack_require__(63527);
class TwoCellAnchorXform extends BaseCellAnchorXform {
    constructor(){
        super();
        this.map = {
            "xdr:from": new CellPositionXform({
                tag: "xdr:from"
            }),
            "xdr:to": new CellPositionXform({
                tag: "xdr:to"
            }),
            "xdr:pic": new PicXform(),
            "xdr:clientData": new StaticXform({
                tag: "xdr:clientData"
            })
        };
    }
    get tag() {
        return "xdr:twoCellAnchor";
    }
    prepare(model, options) {
        this.map["xdr:pic"].prepare(model.picture, options);
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            editAs: model.range.editAs || "oneCell"
        });
        this.map["xdr:from"].render(xmlStream, model.range.tl);
        this.map["xdr:to"].render(xmlStream, model.range.br);
        this.map["xdr:pic"].render(xmlStream, model.picture);
        this.map["xdr:clientData"].render(xmlStream, {});
        xmlStream.closeNode();
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case this.tag:
                this.model.range.tl = this.map["xdr:from"].model;
                this.model.range.br = this.map["xdr:to"].model;
                this.model.picture = this.map["xdr:pic"].model;
                return false;
            default:
                // could be some unrecognised tags
                return true;
        }
    }
    reconcile(model, options) {
        model.medium = this.reconcilePicture(model.picture, options);
    }
}
module.exports = TwoCellAnchorXform;


/***/ }),

/***/ 34397:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class ListXform extends BaseXform {
    constructor(options){
        super();
        this.tag = options.tag;
        this.always = !!options.always;
        this.count = options.count;
        this.empty = options.empty;
        this.$count = options.$count || "count";
        this.$ = options.$;
        this.childXform = options.childXform;
        this.maxItems = options.maxItems;
    }
    prepare(model, options) {
        const { childXform } = this;
        if (model) {
            model.forEach((childModel, index)=>{
                options.index = index;
                childXform.prepare(childModel, options);
            });
        }
    }
    render(xmlStream, model) {
        if (this.always || model && model.length) {
            xmlStream.openNode(this.tag, this.$);
            if (this.count) {
                xmlStream.addAttribute(this.$count, model && model.length || 0);
            }
            const { childXform } = this;
            (model || []).forEach((childModel, index)=>{
                childXform.render(xmlStream, childModel, index);
            });
            xmlStream.closeNode();
        } else if (this.empty) {
            xmlStream.leafNode(this.tag);
        }
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case this.tag:
                this.model = [];
                return true;
            default:
                if (this.childXform.parseOpen(node)) {
                    this.parser = this.childXform;
                    return true;
                }
                return false;
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.model.push(this.parser.model);
                this.parser = undefined;
                if (this.maxItems && this.model.length > this.maxItems) {
                    throw new Error(`Max ${this.childXform.tag} count (${this.maxItems}) exceeded`);
                }
            }
            return true;
        }
        return false;
    }
    reconcile(model, options) {
        if (model) {
            const { childXform } = this;
            model.forEach((childModel)=>{
                childXform.reconcile(childModel, options);
            });
        }
    }
}
module.exports = ListXform;


/***/ }),

/***/ 44353:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const colCache = __webpack_require__(90609);
const BaseXform = __webpack_require__(90884);
class AutoFilterXform extends BaseXform {
    get tag() {
        return "autoFilter";
    }
    render(xmlStream, model) {
        if (model) {
            if (typeof model === "string") {
                // assume range
                xmlStream.leafNode("autoFilter", {
                    ref: model
                });
            } else {
                const getAddress = function(addr) {
                    if (typeof addr === "string") {
                        return addr;
                    }
                    return colCache.getAddress(addr.row, addr.column).address;
                };
                const firstAddress = getAddress(model.from);
                const secondAddress = getAddress(model.to);
                if (firstAddress && secondAddress) {
                    xmlStream.leafNode("autoFilter", {
                        ref: `${firstAddress}:${secondAddress}`
                    });
                }
            }
        }
    }
    parseOpen(node) {
        if (node.name === "autoFilter") {
            this.model = node.attributes.ref;
        }
    }
}
module.exports = AutoFilterXform;


/***/ }),

/***/ 95309:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const utils = __webpack_require__(90778);
const BaseXform = __webpack_require__(90884);
const Range = __webpack_require__(77010);
const Enums = __webpack_require__(48688);
const RichTextXform = __webpack_require__(9367);
function getValueType(v) {
    if (v === null || v === undefined) {
        return Enums.ValueType.Null;
    }
    if (v instanceof String || typeof v === "string") {
        return Enums.ValueType.String;
    }
    if (typeof v === "number") {
        return Enums.ValueType.Number;
    }
    if (typeof v === "boolean") {
        return Enums.ValueType.Boolean;
    }
    if (v instanceof Date) {
        return Enums.ValueType.Date;
    }
    if (v.text && v.hyperlink) {
        return Enums.ValueType.Hyperlink;
    }
    if (v.formula) {
        return Enums.ValueType.Formula;
    }
    if (v.error) {
        return Enums.ValueType.Error;
    }
    throw new Error("I could not understand type of value");
}
function getEffectiveCellType(cell) {
    switch(cell.type){
        case Enums.ValueType.Formula:
            return getValueType(cell.result);
        default:
            return cell.type;
    }
}
class CellXform extends BaseXform {
    constructor(){
        super();
        this.richTextXForm = new RichTextXform();
    }
    get tag() {
        return "c";
    }
    prepare(model, options) {
        const styleId = options.styles.addStyleModel(model.style || {}, getEffectiveCellType(model));
        if (styleId) {
            model.styleId = styleId;
        }
        if (model.comment) {
            options.comments.push({
                ...model.comment,
                ref: model.address
            });
        }
        switch(model.type){
            case Enums.ValueType.String:
            case Enums.ValueType.RichText:
                if (options.sharedStrings) {
                    model.ssId = options.sharedStrings.add(model.value);
                }
                break;
            case Enums.ValueType.Date:
                if (options.date1904) {
                    model.date1904 = true;
                }
                break;
            case Enums.ValueType.Hyperlink:
                if (options.sharedStrings && model.text !== undefined && model.text !== null) {
                    model.ssId = options.sharedStrings.add(model.text);
                }
                options.hyperlinks.push({
                    address: model.address,
                    target: model.hyperlink,
                    tooltip: model.tooltip
                });
                break;
            case Enums.ValueType.Merge:
                options.merges.add(model);
                break;
            case Enums.ValueType.Formula:
                if (options.date1904) {
                    // in case valueType is date
                    model.date1904 = true;
                }
                if (model.shareType === "shared") {
                    model.si = options.siFormulae++;
                }
                if (model.formula) {
                    options.formulae[model.address] = model;
                } else if (model.sharedFormula) {
                    const master = options.formulae[model.sharedFormula];
                    if (!master) {
                        throw new Error(`Shared Formula master must exist above and or left of clone for cell ${model.address}`);
                    }
                    if (master.si === undefined) {
                        master.shareType = "shared";
                        master.si = options.siFormulae++;
                        master.range = new Range(master.address, model.address);
                    } else if (master.range) {
                        master.range.expandToAddress(model.address);
                    }
                    model.si = master.si;
                }
                break;
            default:
                break;
        }
    }
    renderFormula(xmlStream, model) {
        let attrs = null;
        switch(model.shareType){
            case "shared":
                attrs = {
                    t: "shared",
                    ref: model.ref || model.range.range,
                    si: model.si
                };
                break;
            case "array":
                attrs = {
                    t: "array",
                    ref: model.ref
                };
                break;
            default:
                if (model.si !== undefined) {
                    attrs = {
                        t: "shared",
                        si: model.si
                    };
                }
                break;
        }
        switch(getValueType(model.result)){
            case Enums.ValueType.Null:
                xmlStream.leafNode("f", attrs, model.formula);
                break;
            case Enums.ValueType.String:
                // oddly, formula results don't ever use shared strings
                xmlStream.addAttribute("t", "str");
                xmlStream.leafNode("f", attrs, model.formula);
                xmlStream.leafNode("v", null, model.result);
                break;
            case Enums.ValueType.Number:
                xmlStream.leafNode("f", attrs, model.formula);
                xmlStream.leafNode("v", null, model.result);
                break;
            case Enums.ValueType.Boolean:
                xmlStream.addAttribute("t", "b");
                xmlStream.leafNode("f", attrs, model.formula);
                xmlStream.leafNode("v", null, model.result ? 1 : 0);
                break;
            case Enums.ValueType.Error:
                xmlStream.addAttribute("t", "e");
                xmlStream.leafNode("f", attrs, model.formula);
                xmlStream.leafNode("v", null, model.result.error);
                break;
            case Enums.ValueType.Date:
                xmlStream.leafNode("f", attrs, model.formula);
                xmlStream.leafNode("v", null, utils.dateToExcel(model.result, model.date1904));
                break;
            // case Enums.ValueType.Hyperlink: // ??
            // case Enums.ValueType.Formula:
            default:
                throw new Error("I could not understand type of value");
        }
    }
    render(xmlStream, model) {
        if (model.type === Enums.ValueType.Null && !model.styleId) {
            // if null and no style, exit
            return;
        }
        xmlStream.openNode("c");
        xmlStream.addAttribute("r", model.address);
        if (model.styleId) {
            xmlStream.addAttribute("s", model.styleId);
        }
        switch(model.type){
            case Enums.ValueType.Null:
                break;
            case Enums.ValueType.Number:
                xmlStream.leafNode("v", null, model.value);
                break;
            case Enums.ValueType.Boolean:
                xmlStream.addAttribute("t", "b");
                xmlStream.leafNode("v", null, model.value ? "1" : "0");
                break;
            case Enums.ValueType.Error:
                xmlStream.addAttribute("t", "e");
                xmlStream.leafNode("v", null, model.value.error);
                break;
            case Enums.ValueType.String:
            case Enums.ValueType.RichText:
                if (model.ssId !== undefined) {
                    xmlStream.addAttribute("t", "s");
                    xmlStream.leafNode("v", null, model.ssId);
                } else if (model.value && model.value.richText) {
                    xmlStream.addAttribute("t", "inlineStr");
                    xmlStream.openNode("is");
                    model.value.richText.forEach((text)=>{
                        this.richTextXForm.render(xmlStream, text);
                    });
                    xmlStream.closeNode("is");
                } else {
                    xmlStream.addAttribute("t", "str");
                    xmlStream.leafNode("v", null, model.value);
                }
                break;
            case Enums.ValueType.Date:
                xmlStream.leafNode("v", null, utils.dateToExcel(model.value, model.date1904));
                break;
            case Enums.ValueType.Hyperlink:
                if (model.ssId !== undefined) {
                    xmlStream.addAttribute("t", "s");
                    xmlStream.leafNode("v", null, model.ssId);
                } else {
                    xmlStream.addAttribute("t", "str");
                    xmlStream.leafNode("v", null, model.text);
                }
                break;
            case Enums.ValueType.Formula:
                this.renderFormula(xmlStream, model);
                break;
            case Enums.ValueType.Merge:
                break;
            default:
                break;
        }
        xmlStream.closeNode(); // </c>
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case "c":
                // const address = colCache.decodeAddress(node.attributes.r);
                this.model = {
                    address: node.attributes.r
                };
                this.t = node.attributes.t;
                if (node.attributes.s) {
                    this.model.styleId = parseInt(node.attributes.s, 10);
                }
                return true;
            case "f":
                this.currentNode = "f";
                this.model.si = node.attributes.si;
                this.model.shareType = node.attributes.t;
                this.model.ref = node.attributes.ref;
                return true;
            case "v":
                this.currentNode = "v";
                return true;
            case "t":
                this.currentNode = "t";
                return true;
            case "r":
                this.parser = this.richTextXForm;
                this.parser.parseOpen(node);
                return true;
            default:
                return false;
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
            return;
        }
        switch(this.currentNode){
            case "f":
                this.model.formula = this.model.formula ? this.model.formula + text : text;
                break;
            case "v":
            case "t":
                if (this.model.value && this.model.value.richText) {
                    this.model.value.richText.text = this.model.value.richText.text ? this.model.value.richText.text + text : text;
                } else {
                    this.model.value = this.model.value ? this.model.value + text : text;
                }
                break;
            default:
                break;
        }
    }
    parseClose(name) {
        switch(name){
            case "c":
                {
                    const { model } = this;
                    // first guess on cell type
                    if (model.formula || model.shareType) {
                        model.type = Enums.ValueType.Formula;
                        if (model.value) {
                            if (this.t === "str") {
                                model.result = utils.xmlDecode(model.value);
                            } else if (this.t === "b") {
                                model.result = parseInt(model.value, 10) !== 0;
                            } else if (this.t === "e") {
                                model.result = {
                                    error: model.value
                                };
                            } else {
                                model.result = parseFloat(model.value);
                            }
                            model.value = undefined;
                        }
                    } else if (model.value !== undefined) {
                        switch(this.t){
                            case "s":
                                model.type = Enums.ValueType.String;
                                model.value = parseInt(model.value, 10);
                                break;
                            case "str":
                                model.type = Enums.ValueType.String;
                                model.value = utils.xmlDecode(model.value);
                                break;
                            case "inlineStr":
                                model.type = Enums.ValueType.String;
                                break;
                            case "b":
                                model.type = Enums.ValueType.Boolean;
                                model.value = parseInt(model.value, 10) !== 0;
                                break;
                            case "e":
                                model.type = Enums.ValueType.Error;
                                model.value = {
                                    error: model.value
                                };
                                break;
                            default:
                                model.type = Enums.ValueType.Number;
                                model.value = parseFloat(model.value);
                                break;
                        }
                    } else if (model.styleId) {
                        model.type = Enums.ValueType.Null;
                    } else {
                        model.type = Enums.ValueType.Merge;
                    }
                    return false;
                }
            case "f":
            case "v":
            case "is":
                this.currentNode = undefined;
                return true;
            case "t":
                if (this.parser) {
                    this.parser.parseClose(name);
                    return true;
                }
                this.currentNode = undefined;
                return true;
            case "r":
                this.model.value = this.model.value || {};
                this.model.value.richText = this.model.value.richText || [];
                this.model.value.richText.push(this.parser.model);
                this.parser = undefined;
                this.currentNode = undefined;
                return true;
            default:
                if (this.parser) {
                    this.parser.parseClose(name);
                    return true;
                }
                return false;
        }
    }
    reconcile(model, options) {
        const style = model.styleId && options.styles && options.styles.getStyleModel(model.styleId);
        if (style) {
            model.style = style;
        }
        if (model.styleId !== undefined) {
            model.styleId = undefined;
        }
        switch(model.type){
            case Enums.ValueType.String:
                if (typeof model.value === "number") {
                    if (options.sharedStrings) {
                        model.value = options.sharedStrings.getString(model.value);
                    }
                }
                if (model.value.richText) {
                    model.type = Enums.ValueType.RichText;
                }
                break;
            case Enums.ValueType.Number:
                if (style && utils.isDateFmt(style.numFmt)) {
                    model.type = Enums.ValueType.Date;
                    model.value = utils.excelToDate(model.value, options.date1904);
                }
                break;
            case Enums.ValueType.Formula:
                if (model.result !== undefined && style && utils.isDateFmt(style.numFmt)) {
                    model.result = utils.excelToDate(model.result, options.date1904);
                }
                if (model.shareType === "shared") {
                    if (model.ref) {
                        // master
                        options.formulae[model.si] = model.address;
                    } else {
                        // slave
                        model.sharedFormula = options.formulae[model.si];
                        delete model.shareType;
                    }
                    delete model.si;
                }
                break;
            default:
                break;
        }
        // look for hyperlink
        const hyperlink = options.hyperlinkMap[model.address];
        if (hyperlink) {
            if (model.type === Enums.ValueType.Formula) {
                model.text = model.result;
                model.result = undefined;
            } else {
                model.text = model.value;
                model.value = undefined;
            }
            model.type = Enums.ValueType.Hyperlink;
            model.hyperlink = hyperlink;
        }
        const comment = options.commentsMap && options.commentsMap[model.address];
        if (comment) {
            model.comment = comment;
        }
    }
}
module.exports = CellXform;


/***/ }),

/***/ 49400:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class CfIconExtXform extends BaseXform {
    get tag() {
        return "x14:cfIcon";
    }
    render(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
            iconSet: model.iconSet,
            iconId: model.iconId
        });
    }
    parseOpen({ attributes }) {
        this.model = {
            iconSet: attributes.iconSet,
            iconId: BaseXform.toIntValue(attributes.iconId)
        };
    }
    parseClose(name) {
        return name !== this.tag;
    }
}
module.exports = CfIconExtXform;


/***/ }),

/***/ 55488:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { v4: uuidv4 } = __webpack_require__(6622);
const BaseXform = __webpack_require__(90884);
const CompositeXform = __webpack_require__(9239);
const DatabarExtXform = __webpack_require__(68650);
const IconSetExtXform = __webpack_require__(84208);
const extIcons = {
    "3Triangles": true,
    "3Stars": true,
    "5Boxes": true
};
class CfRuleExtXform extends CompositeXform {
    constructor(){
        super();
        this.map = {
            "x14:dataBar": this.databarXform = new DatabarExtXform(),
            "x14:iconSet": this.iconSetXform = new IconSetExtXform()
        };
    }
    get tag() {
        return "x14:cfRule";
    }
    static isExt(rule) {
        // is this rule primitive?
        if (rule.type === "dataBar") {
            return DatabarExtXform.isExt(rule);
        }
        if (rule.type === "iconSet") {
            if (rule.custom || extIcons[rule.iconSet]) {
                return true;
            }
        }
        return false;
    }
    prepare(model) {
        if (CfRuleExtXform.isExt(model)) {
            model.x14Id = `{${uuidv4()}}`.toUpperCase();
        }
    }
    render(xmlStream, model) {
        if (!CfRuleExtXform.isExt(model)) {
            return;
        }
        switch(model.type){
            case "dataBar":
                this.renderDataBar(xmlStream, model);
                break;
            case "iconSet":
                this.renderIconSet(xmlStream, model);
                break;
        }
    }
    renderDataBar(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            type: "dataBar",
            id: model.x14Id
        });
        this.databarXform.render(xmlStream, model);
        xmlStream.closeNode();
    }
    renderIconSet(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            type: "iconSet",
            priority: model.priority,
            id: model.x14Id || `{${uuidv4()}}`
        });
        this.iconSetXform.render(xmlStream, model);
        xmlStream.closeNode();
    }
    createNewModel({ attributes }) {
        return {
            type: attributes.type,
            x14Id: attributes.id,
            priority: BaseXform.toIntValue(attributes.priority)
        };
    }
    onParserClose(name, parser) {
        Object.assign(this.model, parser.model);
    }
}
module.exports = CfRuleExtXform;


/***/ }),

/***/ 32767:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const CompositeXform = __webpack_require__(9239);
const FExtXform = __webpack_require__(51593);
class CfvoExtXform extends CompositeXform {
    constructor(){
        super();
        this.map = {
            "xm:f": this.fExtXform = new FExtXform()
        };
    }
    get tag() {
        return "x14:cfvo";
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            type: model.type
        });
        if (model.value !== undefined) {
            this.fExtXform.render(xmlStream, model.value);
        }
        xmlStream.closeNode();
    }
    createNewModel(node) {
        return {
            type: node.attributes.type
        };
    }
    onParserClose(name, parser) {
        switch(name){
            case "xm:f":
                this.model.value = parser.model ? parseFloat(parser.model) : 0;
                break;
        }
    }
}
module.exports = CfvoExtXform;


/***/ }),

/***/ 35265:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const CompositeXform = __webpack_require__(9239);
const SqRefExtXform = __webpack_require__(83712);
const CfRuleExtXform = __webpack_require__(55488);
class ConditionalFormattingExtXform extends CompositeXform {
    constructor(){
        super();
        this.map = {
            "xm:sqref": this.sqRef = new SqRefExtXform(),
            "x14:cfRule": this.cfRule = new CfRuleExtXform()
        };
    }
    get tag() {
        return "x14:conditionalFormatting";
    }
    prepare(model, options) {
        model.rules.forEach((rule)=>{
            this.cfRule.prepare(rule, options);
        });
    }
    render(xmlStream, model) {
        if (!model.rules.some(CfRuleExtXform.isExt)) {
            return;
        }
        xmlStream.openNode(this.tag, {
            "xmlns:xm": "http://schemas.microsoft.com/office/excel/2006/main"
        });
        model.rules.filter(CfRuleExtXform.isExt).forEach((rule)=>this.cfRule.render(xmlStream, rule));
        // for some odd reason, Excel needs the <xm:sqref> node to be after the rules
        this.sqRef.render(xmlStream, model.ref);
        xmlStream.closeNode();
    }
    createNewModel() {
        return {
            rules: []
        };
    }
    onParserClose(name, parser) {
        switch(name){
            case "xm:sqref":
                this.model.ref = parser.model;
                break;
            case "x14:cfRule":
                this.model.rules.push(parser.model);
                break;
        }
    }
}
module.exports = ConditionalFormattingExtXform;


/***/ }),

/***/ 56925:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const CompositeXform = __webpack_require__(9239);
const CfRuleExtXform = __webpack_require__(55488);
const ConditionalFormattingExtXform = __webpack_require__(35265);
class ConditionalFormattingsExtXform extends CompositeXform {
    constructor(){
        super();
        this.map = {
            "x14:conditionalFormatting": this.cfXform = new ConditionalFormattingExtXform()
        };
    }
    get tag() {
        return "x14:conditionalFormattings";
    }
    hasContent(model) {
        if (model.hasExtContent === undefined) {
            model.hasExtContent = model.some((cf)=>cf.rules.some(CfRuleExtXform.isExt));
        }
        return model.hasExtContent;
    }
    prepare(model, options) {
        model.forEach((cf)=>{
            this.cfXform.prepare(cf, options);
        });
    }
    render(xmlStream, model) {
        if (this.hasContent(model)) {
            xmlStream.openNode(this.tag);
            model.forEach((cf)=>this.cfXform.render(xmlStream, cf));
            xmlStream.closeNode();
        }
    }
    createNewModel() {
        return [];
    }
    onParserClose(name, parser) {
        // model is array of conditional formatting objects
        this.model.push(parser.model);
    }
}
module.exports = ConditionalFormattingsExtXform;


/***/ }),

/***/ 68650:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const CompositeXform = __webpack_require__(9239);
const ColorXform = __webpack_require__(47287);
const CfvoExtXform = __webpack_require__(32767);
class DatabarExtXform extends CompositeXform {
    constructor(){
        super();
        this.map = {
            "x14:cfvo": this.cfvoXform = new CfvoExtXform(),
            "x14:borderColor": this.borderColorXform = new ColorXform("x14:borderColor"),
            "x14:negativeBorderColor": this.negativeBorderColorXform = new ColorXform("x14:negativeBorderColor"),
            "x14:negativeFillColor": this.negativeFillColorXform = new ColorXform("x14:negativeFillColor"),
            "x14:axisColor": this.axisColorXform = new ColorXform("x14:axisColor")
        };
    }
    static isExt(rule) {
        // not all databars need ext
        // TODO: refine this
        return !rule.gradient;
    }
    get tag() {
        return "x14:dataBar";
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            minLength: BaseXform.toIntAttribute(model.minLength, 0, true),
            maxLength: BaseXform.toIntAttribute(model.maxLength, 100, true),
            border: BaseXform.toBoolAttribute(model.border, false),
            gradient: BaseXform.toBoolAttribute(model.gradient, true),
            negativeBarColorSameAsPositive: BaseXform.toBoolAttribute(model.negativeBarColorSameAsPositive, true),
            negativeBarBorderColorSameAsPositive: BaseXform.toBoolAttribute(model.negativeBarBorderColorSameAsPositive, true),
            axisPosition: BaseXform.toAttribute(model.axisPosition, "auto"),
            direction: BaseXform.toAttribute(model.direction, "leftToRight")
        });
        model.cfvo.forEach((cfvo)=>{
            this.cfvoXform.render(xmlStream, cfvo);
        });
        this.borderColorXform.render(xmlStream, model.borderColor);
        this.negativeBorderColorXform.render(xmlStream, model.negativeBorderColor);
        this.negativeFillColorXform.render(xmlStream, model.negativeFillColor);
        this.axisColorXform.render(xmlStream, model.axisColor);
        xmlStream.closeNode();
    }
    createNewModel({ attributes }) {
        return {
            cfvo: [],
            minLength: BaseXform.toIntValue(attributes.minLength, 0),
            maxLength: BaseXform.toIntValue(attributes.maxLength, 100),
            border: BaseXform.toBoolValue(attributes.border, false),
            gradient: BaseXform.toBoolValue(attributes.gradient, true),
            negativeBarColorSameAsPositive: BaseXform.toBoolValue(attributes.negativeBarColorSameAsPositive, true),
            negativeBarBorderColorSameAsPositive: BaseXform.toBoolValue(attributes.negativeBarBorderColorSameAsPositive, true),
            axisPosition: BaseXform.toStringValue(attributes.axisPosition, "auto"),
            direction: BaseXform.toStringValue(attributes.direction, "leftToRight")
        };
    }
    onParserClose(name, parser) {
        const [, prop] = name.split(":");
        switch(prop){
            case "cfvo":
                this.model.cfvo.push(parser.model);
                break;
            default:
                this.model[prop] = parser.model;
                break;
        }
    }
}
module.exports = DatabarExtXform;


/***/ }),

/***/ 51593:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class FExtXform extends BaseXform {
    get tag() {
        return "xm:f";
    }
    render(xmlStream, model) {
        xmlStream.leafNode(this.tag, null, model);
    }
    parseOpen() {
        this.model = "";
    }
    parseText(text) {
        this.model += text;
    }
    parseClose(name) {
        return name !== this.tag;
    }
}
module.exports = FExtXform;


/***/ }),

/***/ 84208:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const CompositeXform = __webpack_require__(9239);
const CfvoExtXform = __webpack_require__(32767);
const CfIconExtXform = __webpack_require__(49400);
class IconSetExtXform extends CompositeXform {
    constructor(){
        super();
        this.map = {
            "x14:cfvo": this.cfvoXform = new CfvoExtXform(),
            "x14:cfIcon": this.cfIconXform = new CfIconExtXform()
        };
    }
    get tag() {
        return "x14:iconSet";
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            iconSet: BaseXform.toStringAttribute(model.iconSet),
            reverse: BaseXform.toBoolAttribute(model.reverse, false),
            showValue: BaseXform.toBoolAttribute(model.showValue, true),
            custom: BaseXform.toBoolAttribute(model.icons, false)
        });
        model.cfvo.forEach((cfvo)=>{
            this.cfvoXform.render(xmlStream, cfvo);
        });
        if (model.icons) {
            model.icons.forEach((icon, i)=>{
                icon.iconId = i;
                this.cfIconXform.render(xmlStream, icon);
            });
        }
        xmlStream.closeNode();
    }
    createNewModel({ attributes }) {
        return {
            cfvo: [],
            iconSet: BaseXform.toStringValue(attributes.iconSet, "3TrafficLights"),
            reverse: BaseXform.toBoolValue(attributes.reverse, false),
            showValue: BaseXform.toBoolValue(attributes.showValue, true)
        };
    }
    onParserClose(name, parser) {
        const [, prop] = name.split(":");
        switch(prop){
            case "cfvo":
                this.model.cfvo.push(parser.model);
                break;
            case "cfIcon":
                if (!this.model.icons) {
                    this.model.icons = [];
                }
                this.model.icons.push(parser.model);
                break;
            default:
                this.model[prop] = parser.model;
                break;
        }
    }
}
module.exports = IconSetExtXform;


/***/ }),

/***/ 83712:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class SqrefExtXform extends BaseXform {
    get tag() {
        return "xm:sqref";
    }
    render(xmlStream, model) {
        xmlStream.leafNode(this.tag, null, model);
    }
    parseOpen() {
        this.model = "";
    }
    parseText(text) {
        this.model += text;
    }
    parseClose(name) {
        return name !== this.tag;
    }
}
module.exports = SqrefExtXform;


/***/ }),

/***/ 25476:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const CompositeXform = __webpack_require__(9239);
const Range = __webpack_require__(77010);
const DatabarXform = __webpack_require__(95147);
const ExtLstRefXform = __webpack_require__(16484);
const FormulaXform = __webpack_require__(49998);
const ColorScaleXform = __webpack_require__(30882);
const IconSetXform = __webpack_require__(80012);
const extIcons = {
    "3Triangles": true,
    "3Stars": true,
    "5Boxes": true
};
const getTextFormula = (model)=>{
    if (model.formulae && model.formulae[0]) {
        return model.formulae[0];
    }
    const range = new Range(model.ref);
    const { tl } = range;
    switch(model.operator){
        case "containsText":
            return `NOT(ISERROR(SEARCH("${model.text}",${tl})))`;
        case "containsBlanks":
            return `LEN(TRIM(${tl}))=0`;
        case "notContainsBlanks":
            return `LEN(TRIM(${tl}))>0`;
        case "containsErrors":
            return `ISERROR(${tl})`;
        case "notContainsErrors":
            return `NOT(ISERROR(${tl}))`;
        default:
            return undefined;
    }
};
const getTimePeriodFormula = (model)=>{
    if (model.formulae && model.formulae[0]) {
        return model.formulae[0];
    }
    const range = new Range(model.ref);
    const { tl } = range;
    switch(model.timePeriod){
        case "thisWeek":
            return `AND(TODAY()-ROUNDDOWN(${tl},0)<=WEEKDAY(TODAY())-1,ROUNDDOWN(${tl},0)-TODAY()<=7-WEEKDAY(TODAY()))`;
        case "lastWeek":
            return `AND(TODAY()-ROUNDDOWN(${tl},0)>=(WEEKDAY(TODAY())),TODAY()-ROUNDDOWN(${tl},0)<(WEEKDAY(TODAY())+7))`;
        case "nextWeek":
            return `AND(ROUNDDOWN(${tl},0)-TODAY()>(7-WEEKDAY(TODAY())),ROUNDDOWN(${tl},0)-TODAY()<(15-WEEKDAY(TODAY())))`;
        case "yesterday":
            return `FLOOR(${tl},1)=TODAY()-1`;
        case "today":
            return `FLOOR(${tl},1)=TODAY()`;
        case "tomorrow":
            return `FLOOR(${tl},1)=TODAY()+1`;
        case "last7Days":
            return `AND(TODAY()-FLOOR(${tl},1)<=6,FLOOR(${tl},1)<=TODAY())`;
        case "lastMonth":
            return `AND(MONTH(${tl})=MONTH(EDATE(TODAY(),0-1)),YEAR(${tl})=YEAR(EDATE(TODAY(),0-1)))`;
        case "thisMonth":
            return `AND(MONTH(${tl})=MONTH(TODAY()),YEAR(${tl})=YEAR(TODAY()))`;
        case "nextMonth":
            return `AND(MONTH(${tl})=MONTH(EDATE(TODAY(),0+1)),YEAR(${tl})=YEAR(EDATE(TODAY(),0+1)))`;
        default:
            return undefined;
    }
};
const opType = (attributes)=>{
    const { type, operator } = attributes;
    switch(type){
        case "containsText":
        case "containsBlanks":
        case "notContainsBlanks":
        case "containsErrors":
        case "notContainsErrors":
            return {
                type: "containsText",
                operator: type
            };
        default:
            return {
                type,
                operator
            };
    }
};
class CfRuleXform extends CompositeXform {
    constructor(){
        super();
        this.map = {
            dataBar: this.databarXform = new DatabarXform(),
            extLst: this.extLstRefXform = new ExtLstRefXform(),
            formula: this.formulaXform = new FormulaXform(),
            colorScale: this.colorScaleXform = new ColorScaleXform(),
            iconSet: this.iconSetXform = new IconSetXform()
        };
    }
    get tag() {
        return "cfRule";
    }
    static isPrimitive(rule) {
        // is this rule primitive?
        if (rule.type === "iconSet") {
            if (rule.custom || extIcons[rule.iconSet]) {
                return false;
            }
        }
        return true;
    }
    render(xmlStream, model) {
        switch(model.type){
            case "expression":
                this.renderExpression(xmlStream, model);
                break;
            case "cellIs":
                this.renderCellIs(xmlStream, model);
                break;
            case "top10":
                this.renderTop10(xmlStream, model);
                break;
            case "aboveAverage":
                this.renderAboveAverage(xmlStream, model);
                break;
            case "dataBar":
                this.renderDataBar(xmlStream, model);
                break;
            case "colorScale":
                this.renderColorScale(xmlStream, model);
                break;
            case "iconSet":
                this.renderIconSet(xmlStream, model);
                break;
            case "containsText":
                this.renderText(xmlStream, model);
                break;
            case "timePeriod":
                this.renderTimePeriod(xmlStream, model);
                break;
        }
    }
    renderExpression(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            type: "expression",
            dxfId: model.dxfId,
            priority: model.priority
        });
        this.formulaXform.render(xmlStream, model.formulae[0]);
        xmlStream.closeNode();
    }
    renderCellIs(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            type: "cellIs",
            dxfId: model.dxfId,
            priority: model.priority,
            operator: model.operator
        });
        model.formulae.forEach((formula)=>{
            this.formulaXform.render(xmlStream, formula);
        });
        xmlStream.closeNode();
    }
    renderTop10(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
            type: "top10",
            dxfId: model.dxfId,
            priority: model.priority,
            percent: BaseXform.toBoolAttribute(model.percent, false),
            bottom: BaseXform.toBoolAttribute(model.bottom, false),
            rank: BaseXform.toIntValue(model.rank, 10, true)
        });
    }
    renderAboveAverage(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
            type: "aboveAverage",
            dxfId: model.dxfId,
            priority: model.priority,
            aboveAverage: BaseXform.toBoolAttribute(model.aboveAverage, true)
        });
    }
    renderDataBar(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            type: "dataBar",
            priority: model.priority
        });
        this.databarXform.render(xmlStream, model);
        this.extLstRefXform.render(xmlStream, model);
        xmlStream.closeNode();
    }
    renderColorScale(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            type: "colorScale",
            priority: model.priority
        });
        this.colorScaleXform.render(xmlStream, model);
        xmlStream.closeNode();
    }
    renderIconSet(xmlStream, model) {
        // iconset is all primitive or all extLst
        if (!CfRuleXform.isPrimitive(model)) {
            return;
        }
        xmlStream.openNode(this.tag, {
            type: "iconSet",
            priority: model.priority
        });
        this.iconSetXform.render(xmlStream, model);
        xmlStream.closeNode();
    }
    renderText(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            type: model.operator,
            dxfId: model.dxfId,
            priority: model.priority,
            operator: BaseXform.toStringAttribute(model.operator, "containsText")
        });
        const formula = getTextFormula(model);
        if (formula) {
            this.formulaXform.render(xmlStream, formula);
        }
        xmlStream.closeNode();
    }
    renderTimePeriod(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            type: "timePeriod",
            dxfId: model.dxfId,
            priority: model.priority,
            timePeriod: model.timePeriod
        });
        const formula = getTimePeriodFormula(model);
        if (formula) {
            this.formulaXform.render(xmlStream, formula);
        }
        xmlStream.closeNode();
    }
    createNewModel({ attributes }) {
        return {
            ...opType(attributes),
            dxfId: BaseXform.toIntValue(attributes.dxfId),
            priority: BaseXform.toIntValue(attributes.priority),
            timePeriod: attributes.timePeriod,
            percent: BaseXform.toBoolValue(attributes.percent),
            bottom: BaseXform.toBoolValue(attributes.bottom),
            rank: BaseXform.toIntValue(attributes.rank),
            aboveAverage: BaseXform.toBoolValue(attributes.aboveAverage)
        };
    }
    onParserClose(name, parser) {
        switch(name){
            case "dataBar":
            case "extLst":
            case "colorScale":
            case "iconSet":
                // merge parser model with ours
                Object.assign(this.model, parser.model);
                break;
            case "formula":
                // except - formula is a string and appends to formulae
                this.model.formulae = this.model.formulae || [];
                this.model.formulae.push(parser.model);
                break;
        }
    }
}
module.exports = CfRuleXform;


/***/ }),

/***/ 29916:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class CfvoXform extends BaseXform {
    get tag() {
        return "cfvo";
    }
    render(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
            type: model.type,
            val: model.value
        });
    }
    parseOpen(node) {
        this.model = {
            type: node.attributes.type,
            value: BaseXform.toFloatValue(node.attributes.val)
        };
    }
    parseClose(name) {
        return name !== this.tag;
    }
}
module.exports = CfvoXform;


/***/ }),

/***/ 30882:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const CompositeXform = __webpack_require__(9239);
const ColorXform = __webpack_require__(47287);
const CfvoXform = __webpack_require__(29916);
class ColorScaleXform extends CompositeXform {
    constructor(){
        super();
        this.map = {
            cfvo: this.cfvoXform = new CfvoXform(),
            color: this.colorXform = new ColorXform()
        };
    }
    get tag() {
        return "colorScale";
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        model.cfvo.forEach((cfvo)=>{
            this.cfvoXform.render(xmlStream, cfvo);
        });
        model.color.forEach((color)=>{
            this.colorXform.render(xmlStream, color);
        });
        xmlStream.closeNode();
    }
    createNewModel(node) {
        return {
            cfvo: [],
            color: []
        };
    }
    onParserClose(name, parser) {
        this.model[name].push(parser.model);
    }
}
module.exports = ColorScaleXform;


/***/ }),

/***/ 99887:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const CompositeXform = __webpack_require__(9239);
const CfRuleXform = __webpack_require__(25476);
class ConditionalFormattingXform extends CompositeXform {
    constructor(){
        super();
        this.map = {
            cfRule: new CfRuleXform()
        };
    }
    get tag() {
        return "conditionalFormatting";
    }
    render(xmlStream, model) {
        // if there are no primitive rules, exit now
        if (!model.rules.some(CfRuleXform.isPrimitive)) {
            return;
        }
        xmlStream.openNode(this.tag, {
            sqref: model.ref
        });
        model.rules.forEach((rule)=>{
            if (CfRuleXform.isPrimitive(rule)) {
                rule.ref = model.ref;
                this.map.cfRule.render(xmlStream, rule);
            }
        });
        xmlStream.closeNode();
    }
    createNewModel({ attributes }) {
        return {
            ref: attributes.sqref,
            rules: []
        };
    }
    onParserClose(name, parser) {
        this.model.rules.push(parser.model);
    }
}
module.exports = ConditionalFormattingXform;


/***/ }),

/***/ 88312:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const ConditionalFormattingXform = __webpack_require__(99887);
class ConditionalFormattingsXform extends BaseXform {
    constructor(){
        super();
        this.cfXform = new ConditionalFormattingXform();
    }
    get tag() {
        return "conditionalFormatting";
    }
    reset() {
        this.model = [];
    }
    prepare(model, options) {
        // ensure each rule has a priority value
        let nextPriority = model.reduce((p, cf)=>Math.max(p, ...cf.rules.map((rule)=>rule.priority || 0)), 1);
        model.forEach((cf)=>{
            cf.rules.forEach((rule)=>{
                if (!rule.priority) {
                    rule.priority = nextPriority++;
                }
                if (rule.style) {
                    rule.dxfId = options.styles.addDxfStyle(rule.style);
                }
            });
        });
    }
    render(xmlStream, model) {
        model.forEach((cf)=>{
            this.cfXform.render(xmlStream, cf);
        });
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case "conditionalFormatting":
                this.parser = this.cfXform;
                this.parser.parseOpen(node);
                return true;
            default:
                return false;
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.model.push(this.parser.model);
                this.parser = undefined;
                return false;
            }
            return true;
        }
        return false;
    }
    reconcile(model, options) {
        model.forEach((cf)=>{
            cf.rules.forEach((rule)=>{
                if (rule.dxfId !== undefined) {
                    rule.style = options.styles.getDxfStyle(rule.dxfId);
                    delete rule.dxfId;
                }
            });
        });
    }
}
module.exports = ConditionalFormattingsXform;


/***/ }),

/***/ 95147:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const CompositeXform = __webpack_require__(9239);
const ColorXform = __webpack_require__(47287);
const CfvoXform = __webpack_require__(29916);
class DatabarXform extends CompositeXform {
    constructor(){
        super();
        this.map = {
            cfvo: this.cfvoXform = new CfvoXform(),
            color: this.colorXform = new ColorXform()
        };
    }
    get tag() {
        return "dataBar";
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        model.cfvo.forEach((cfvo)=>{
            this.cfvoXform.render(xmlStream, cfvo);
        });
        this.colorXform.render(xmlStream, model.color);
        xmlStream.closeNode();
    }
    createNewModel() {
        return {
            cfvo: []
        };
    }
    onParserClose(name, parser) {
        switch(name){
            case "cfvo":
                this.model.cfvo.push(parser.model);
                break;
            case "color":
                this.model.color = parser.model;
                break;
        }
    }
}
module.exports = DatabarXform;


/***/ }),

/***/ 16484:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable max-classes-per-file */ 
const BaseXform = __webpack_require__(90884);
const CompositeXform = __webpack_require__(9239);
class X14IdXform extends BaseXform {
    get tag() {
        return "x14:id";
    }
    render(xmlStream, model) {
        xmlStream.leafNode(this.tag, null, model);
    }
    parseOpen() {
        this.model = "";
    }
    parseText(text) {
        this.model += text;
    }
    parseClose(name) {
        return name !== this.tag;
    }
}
class ExtXform extends CompositeXform {
    constructor(){
        super();
        this.map = {
            "x14:id": this.idXform = new X14IdXform()
        };
    }
    get tag() {
        return "ext";
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            uri: "{B025F937-C7B1-47D3-B67F-A62EFF666E3E}",
            "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"
        });
        this.idXform.render(xmlStream, model.x14Id);
        xmlStream.closeNode();
    }
    createNewModel() {
        return {};
    }
    onParserClose(name, parser) {
        this.model.x14Id = parser.model;
    }
}
class ExtLstRefXform extends CompositeXform {
    constructor(){
        super();
        this.map = {
            ext: new ExtXform()
        };
    }
    get tag() {
        return "extLst";
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        this.map.ext.render(xmlStream, model);
        xmlStream.closeNode();
    }
    createNewModel() {
        return {};
    }
    onParserClose(name, parser) {
        Object.assign(this.model, parser.model);
    }
}
module.exports = ExtLstRefXform;


/***/ }),

/***/ 49998:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class FormulaXform extends BaseXform {
    get tag() {
        return "formula";
    }
    render(xmlStream, model) {
        xmlStream.leafNode(this.tag, null, model);
    }
    parseOpen() {
        this.model = "";
    }
    parseText(text) {
        this.model += text;
    }
    parseClose(name) {
        return name !== this.tag;
    }
}
module.exports = FormulaXform;


/***/ }),

/***/ 80012:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const CompositeXform = __webpack_require__(9239);
const CfvoXform = __webpack_require__(29916);
class IconSetXform extends CompositeXform {
    constructor(){
        super();
        this.map = {
            cfvo: this.cfvoXform = new CfvoXform()
        };
    }
    get tag() {
        return "iconSet";
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            iconSet: BaseXform.toStringAttribute(model.iconSet, "3TrafficLights"),
            reverse: BaseXform.toBoolAttribute(model.reverse, false),
            showValue: BaseXform.toBoolAttribute(model.showValue, true)
        });
        model.cfvo.forEach((cfvo)=>{
            this.cfvoXform.render(xmlStream, cfvo);
        });
        xmlStream.closeNode();
    }
    createNewModel({ attributes }) {
        return {
            iconSet: BaseXform.toStringValue(attributes.iconSet, "3TrafficLights"),
            reverse: BaseXform.toBoolValue(attributes.reverse),
            showValue: BaseXform.toBoolValue(attributes.showValue),
            cfvo: []
        };
    }
    onParserClose(name, parser) {
        this.model[name].push(parser.model);
    }
}
module.exports = IconSetXform;


/***/ }),

/***/ 57950:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const utils = __webpack_require__(90778);
const BaseXform = __webpack_require__(90884);
class ColXform extends BaseXform {
    get tag() {
        return "col";
    }
    prepare(model, options) {
        const styleId = options.styles.addStyleModel(model.style || {});
        if (styleId) {
            model.styleId = styleId;
        }
    }
    render(xmlStream, model) {
        xmlStream.openNode("col");
        xmlStream.addAttribute("min", model.min);
        xmlStream.addAttribute("max", model.max);
        if (model.width) {
            xmlStream.addAttribute("width", model.width);
        }
        if (model.styleId) {
            xmlStream.addAttribute("style", model.styleId);
        }
        if (model.hidden) {
            xmlStream.addAttribute("hidden", "1");
        }
        if (model.bestFit) {
            xmlStream.addAttribute("bestFit", "1");
        }
        if (model.outlineLevel) {
            xmlStream.addAttribute("outlineLevel", model.outlineLevel);
        }
        if (model.collapsed) {
            xmlStream.addAttribute("collapsed", "1");
        }
        xmlStream.addAttribute("customWidth", "1");
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (node.name === "col") {
            const model = this.model = {
                min: parseInt(node.attributes.min || "0", 10),
                max: parseInt(node.attributes.max || "0", 10),
                width: node.attributes.width === undefined ? undefined : parseFloat(node.attributes.width || "0")
            };
            if (node.attributes.style) {
                model.styleId = parseInt(node.attributes.style, 10);
            }
            if (utils.parseBoolean(node.attributes.hidden)) {
                model.hidden = true;
            }
            if (utils.parseBoolean(node.attributes.bestFit)) {
                model.bestFit = true;
            }
            if (node.attributes.outlineLevel) {
                model.outlineLevel = parseInt(node.attributes.outlineLevel, 10);
            }
            if (utils.parseBoolean(node.attributes.collapsed)) {
                model.collapsed = true;
            }
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
    reconcile(model, options) {
        // reconcile column styles
        if (model.styleId) {
            model.style = options.styles.getStyleModel(model.styleId);
        }
    }
}
module.exports = ColXform;


/***/ }),

/***/ 23303:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
const utils = __webpack_require__(90778);
const colCache = __webpack_require__(90609);
const BaseXform = __webpack_require__(90884);
const Range = __webpack_require__(77010);
function assign(definedName, attributes, name, defaultValue) {
    const value = attributes[name];
    if (value !== undefined) {
        definedName[name] = value;
    } else if (defaultValue !== undefined) {
        definedName[name] = defaultValue;
    }
}
function assignBool(definedName, attributes, name, defaultValue) {
    const value = attributes[name];
    if (value !== undefined) {
        definedName[name] = utils.parseBoolean(value);
    } else if (defaultValue !== undefined) {
        definedName[name] = defaultValue;
    }
}
function optimiseDataValidations(model) {
    // Squeeze alike data validations together into rectangular ranges
    // to reduce file size and speed up Excel load time
    const dvList = _.map(model, (dataValidation, address)=>({
            address,
            dataValidation,
            marked: false
        })).sort((a, b)=>_.strcmp(a.address, b.address));
    const dvMap = _.keyBy(dvList, "address");
    const matchCol = (addr, height, col)=>{
        for(let i = 0; i < height; i++){
            const otherAddress = colCache.encodeAddress(addr.row + i, col);
            if (!model[otherAddress] || !_.isEqual(model[addr.address], model[otherAddress])) {
                return false;
            }
        }
        return true;
    };
    return dvList.map((dv)=>{
        if (!dv.marked) {
            const addr = colCache.decodeEx(dv.address);
            if (addr.dimensions) {
                dvMap[addr.dimensions].marked = true;
                return {
                    ...dv.dataValidation,
                    sqref: dv.address
                };
            }
            // iterate downwards - finding matching cells
            let height = 1;
            let otherAddress = colCache.encodeAddress(addr.row + height, addr.col);
            while(model[otherAddress] && _.isEqual(dv.dataValidation, model[otherAddress])){
                height++;
                otherAddress = colCache.encodeAddress(addr.row + height, addr.col);
            }
            // iterate rightwards...
            let width = 1;
            while(matchCol(addr, height, addr.col + width)){
                width++;
            }
            // mark all included addresses
            for(let i = 0; i < height; i++){
                for(let j = 0; j < width; j++){
                    otherAddress = colCache.encodeAddress(addr.row + i, addr.col + j);
                    dvMap[otherAddress].marked = true;
                }
            }
            if (height > 1 || width > 1) {
                const bottom = addr.row + (height - 1);
                const right = addr.col + (width - 1);
                return {
                    ...dv.dataValidation,
                    sqref: `${dv.address}:${colCache.encodeAddress(bottom, right)}`
                };
            }
            return {
                ...dv.dataValidation,
                sqref: dv.address
            };
        }
        return null;
    }).filter(Boolean);
}
class DataValidationsXform extends BaseXform {
    get tag() {
        return "dataValidations";
    }
    render(xmlStream, model) {
        const optimizedModel = optimiseDataValidations(model);
        if (optimizedModel.length) {
            xmlStream.openNode("dataValidations", {
                count: optimizedModel.length
            });
            optimizedModel.forEach((value)=>{
                xmlStream.openNode("dataValidation");
                if (value.type !== "any") {
                    xmlStream.addAttribute("type", value.type);
                    if (value.operator && value.type !== "list" && value.operator !== "between") {
                        xmlStream.addAttribute("operator", value.operator);
                    }
                    if (value.allowBlank) {
                        xmlStream.addAttribute("allowBlank", "1");
                    }
                }
                if (value.showInputMessage) {
                    xmlStream.addAttribute("showInputMessage", "1");
                }
                if (value.promptTitle) {
                    xmlStream.addAttribute("promptTitle", value.promptTitle);
                }
                if (value.prompt) {
                    xmlStream.addAttribute("prompt", value.prompt);
                }
                if (value.showErrorMessage) {
                    xmlStream.addAttribute("showErrorMessage", "1");
                }
                if (value.errorStyle) {
                    xmlStream.addAttribute("errorStyle", value.errorStyle);
                }
                if (value.errorTitle) {
                    xmlStream.addAttribute("errorTitle", value.errorTitle);
                }
                if (value.error) {
                    xmlStream.addAttribute("error", value.error);
                }
                xmlStream.addAttribute("sqref", value.sqref);
                (value.formulae || []).forEach((formula, index)=>{
                    xmlStream.openNode(`formula${index + 1}`);
                    if (value.type === "date") {
                        xmlStream.writeText(utils.dateToExcel(new Date(formula)));
                    } else {
                        xmlStream.writeText(formula);
                    }
                    xmlStream.closeNode();
                });
                xmlStream.closeNode();
            });
            xmlStream.closeNode();
        }
    }
    parseOpen(node) {
        switch(node.name){
            case "dataValidations":
                this.model = {};
                return true;
            case "dataValidation":
                {
                    this._address = node.attributes.sqref;
                    const dataValidation = {
                        type: node.attributes.type || "any",
                        formulae: []
                    };
                    if (node.attributes.type) {
                        assignBool(dataValidation, node.attributes, "allowBlank");
                    }
                    assignBool(dataValidation, node.attributes, "showInputMessage");
                    assignBool(dataValidation, node.attributes, "showErrorMessage");
                    switch(dataValidation.type){
                        case "any":
                        case "list":
                        case "custom":
                            break;
                        default:
                            assign(dataValidation, node.attributes, "operator", "between");
                            break;
                    }
                    assign(dataValidation, node.attributes, "promptTitle");
                    assign(dataValidation, node.attributes, "prompt");
                    assign(dataValidation, node.attributes, "errorStyle");
                    assign(dataValidation, node.attributes, "errorTitle");
                    assign(dataValidation, node.attributes, "error");
                    this._dataValidation = dataValidation;
                    return true;
                }
            case "formula1":
            case "formula2":
                this._formula = [];
                return true;
            default:
                return false;
        }
    }
    parseText(text) {
        if (this._formula) {
            this._formula.push(text);
        }
    }
    parseClose(name) {
        switch(name){
            case "dataValidations":
                return false;
            case "dataValidation":
                {
                    if (!this._dataValidation.formulae || !this._dataValidation.formulae.length) {
                        delete this._dataValidation.formulae;
                        delete this._dataValidation.operator;
                    }
                    // The four known cases: 1. E4:L9 N4:U9  2.E4 L9  3. N4:U9  4. E4
                    const list = this._address.split(/\s+/g) || [];
                    list.forEach((addr)=>{
                        if (addr.includes(":")) {
                            const range = new Range(addr);
                            range.forEachAddress((address)=>{
                                this.model[address] = this._dataValidation;
                            });
                        } else {
                            this.model[addr] = this._dataValidation;
                        }
                    });
                    return true;
                }
            case "formula1":
            case "formula2":
                {
                    let formula = this._formula.join("");
                    switch(this._dataValidation.type){
                        case "whole":
                        case "textLength":
                            formula = parseInt(formula, 10);
                            break;
                        case "decimal":
                            formula = parseFloat(formula);
                            break;
                        case "date":
                            formula = utils.excelToDate(parseFloat(formula));
                            break;
                        default:
                            break;
                    }
                    this._dataValidation.formulae.push(formula);
                    this._formula = undefined;
                    return true;
                }
            default:
                return true;
        }
    }
}
module.exports = DataValidationsXform;


/***/ }),

/***/ 90752:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class DimensionXform extends BaseXform {
    get tag() {
        return "dimension";
    }
    render(xmlStream, model) {
        if (model) {
            xmlStream.leafNode("dimension", {
                ref: model
            });
        }
    }
    parseOpen(node) {
        if (node.name === "dimension") {
            this.model = node.attributes.ref;
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = DimensionXform;


/***/ }),

/***/ 54972:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class DrawingXform extends BaseXform {
    get tag() {
        return "drawing";
    }
    render(xmlStream, model) {
        if (model) {
            xmlStream.leafNode(this.tag, {
                "r:id": model.rId
            });
        }
    }
    parseOpen(node) {
        switch(node.name){
            case this.tag:
                this.model = {
                    rId: node.attributes["r:id"]
                };
                return true;
            default:
                return false;
        }
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = DrawingXform;


/***/ }),

/***/ 34910:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable max-classes-per-file */ 
const CompositeXform = __webpack_require__(9239);
const ConditionalFormattingsExt = __webpack_require__(56925);
class ExtXform extends CompositeXform {
    constructor(){
        super();
        this.map = {
            "x14:conditionalFormattings": this.conditionalFormattings = new ConditionalFormattingsExt()
        };
    }
    get tag() {
        return "ext";
    }
    hasContent(model) {
        return this.conditionalFormattings.hasContent(model.conditionalFormattings);
    }
    prepare(model, options) {
        this.conditionalFormattings.prepare(model.conditionalFormattings, options);
    }
    render(xmlStream, model) {
        xmlStream.openNode("ext", {
            uri: "{78C0D931-6437-407d-A8EE-F0AAD7539E65}",
            "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"
        });
        this.conditionalFormattings.render(xmlStream, model.conditionalFormattings);
        xmlStream.closeNode();
    }
    createNewModel() {
        return {};
    }
    onParserClose(name, parser) {
        this.model[name] = parser.model;
    }
}
class ExtLstXform extends CompositeXform {
    constructor(){
        super();
        this.map = {
            ext: this.ext = new ExtXform()
        };
    }
    get tag() {
        return "extLst";
    }
    prepare(model, options) {
        this.ext.prepare(model, options);
    }
    hasContent(model) {
        return this.ext.hasContent(model);
    }
    render(xmlStream, model) {
        if (!this.hasContent(model)) {
            return;
        }
        xmlStream.openNode("extLst");
        this.ext.render(xmlStream, model);
        xmlStream.closeNode();
    }
    createNewModel() {
        return {};
    }
    onParserClose(name, parser) {
        Object.assign(this.model, parser.model);
    }
}
module.exports = ExtLstXform;


/***/ }),

/***/ 28086:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class HeaderFooterXform extends BaseXform {
    get tag() {
        return "headerFooter";
    }
    render(xmlStream, model) {
        if (model) {
            xmlStream.addRollback();
            let createTag = false;
            xmlStream.openNode("headerFooter");
            if (model.differentFirst) {
                xmlStream.addAttribute("differentFirst", "1");
                createTag = true;
            }
            if (model.differentOddEven) {
                xmlStream.addAttribute("differentOddEven", "1");
                createTag = true;
            }
            if (model.oddHeader && typeof model.oddHeader === "string") {
                xmlStream.leafNode("oddHeader", null, model.oddHeader);
                createTag = true;
            }
            if (model.oddFooter && typeof model.oddFooter === "string") {
                xmlStream.leafNode("oddFooter", null, model.oddFooter);
                createTag = true;
            }
            if (model.evenHeader && typeof model.evenHeader === "string") {
                xmlStream.leafNode("evenHeader", null, model.evenHeader);
                createTag = true;
            }
            if (model.evenFooter && typeof model.evenFooter === "string") {
                xmlStream.leafNode("evenFooter", null, model.evenFooter);
                createTag = true;
            }
            if (model.firstHeader && typeof model.firstHeader === "string") {
                xmlStream.leafNode("firstHeader", null, model.firstHeader);
                createTag = true;
            }
            if (model.firstFooter && typeof model.firstFooter === "string") {
                xmlStream.leafNode("firstFooter", null, model.firstFooter);
                createTag = true;
            }
            if (createTag) {
                xmlStream.closeNode();
                xmlStream.commit();
            } else {
                xmlStream.rollback();
            }
        }
    }
    parseOpen(node) {
        switch(node.name){
            case "headerFooter":
                this.model = {};
                if (node.attributes.differentFirst) {
                    this.model.differentFirst = parseInt(node.attributes.differentFirst, 0) === 1;
                }
                if (node.attributes.differentOddEven) {
                    this.model.differentOddEven = parseInt(node.attributes.differentOddEven, 0) === 1;
                }
                return true;
            case "oddHeader":
                this.currentNode = "oddHeader";
                return true;
            case "oddFooter":
                this.currentNode = "oddFooter";
                return true;
            case "evenHeader":
                this.currentNode = "evenHeader";
                return true;
            case "evenFooter":
                this.currentNode = "evenFooter";
                return true;
            case "firstHeader":
                this.currentNode = "firstHeader";
                return true;
            case "firstFooter":
                this.currentNode = "firstFooter";
                return true;
            default:
                return false;
        }
    }
    parseText(text) {
        switch(this.currentNode){
            case "oddHeader":
                this.model.oddHeader = text;
                break;
            case "oddFooter":
                this.model.oddFooter = text;
                break;
            case "evenHeader":
                this.model.evenHeader = text;
                break;
            case "evenFooter":
                this.model.evenFooter = text;
                break;
            case "firstHeader":
                this.model.firstHeader = text;
                break;
            case "firstFooter":
                this.model.firstFooter = text;
                break;
            default:
                break;
        }
    }
    parseClose() {
        switch(this.currentNode){
            case "oddHeader":
            case "oddFooter":
            case "evenHeader":
            case "evenFooter":
            case "firstHeader":
            case "firstFooter":
                this.currentNode = undefined;
                return true;
            default:
                return false;
        }
    }
}
module.exports = HeaderFooterXform;


/***/ }),

/***/ 83942:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class HyperlinkXform extends BaseXform {
    get tag() {
        return "hyperlink";
    }
    render(xmlStream, model) {
        if (this.isInternalLink(model)) {
            xmlStream.leafNode("hyperlink", {
                ref: model.address,
                "r:id": model.rId,
                tooltip: model.tooltip,
                location: model.target
            });
        } else {
            xmlStream.leafNode("hyperlink", {
                ref: model.address,
                "r:id": model.rId,
                tooltip: model.tooltip
            });
        }
    }
    parseOpen(node) {
        if (node.name === "hyperlink") {
            this.model = {
                address: node.attributes.ref,
                rId: node.attributes["r:id"],
                tooltip: node.attributes.tooltip
            };
            // This is an internal link
            if (node.attributes.location) {
                this.model.target = node.attributes.location;
            }
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
    isInternalLink(model) {
        // @example: Sheet2!D3, return true
        return model.target && /^[^!]+![a-zA-Z]+[\d]+$/.test(model.target);
    }
}
module.exports = HyperlinkXform;


/***/ }),

/***/ 40388:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class MergeCellXform extends BaseXform {
    get tag() {
        return "mergeCell";
    }
    render(xmlStream, model) {
        xmlStream.leafNode("mergeCell", {
            ref: model
        });
    }
    parseOpen(node) {
        if (node.name === "mergeCell") {
            this.model = node.attributes.ref;
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = MergeCellXform;


/***/ }),

/***/ 76404:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
const Range = __webpack_require__(77010);
const colCache = __webpack_require__(90609);
const Enums = __webpack_require__(48688);
class Merges {
    constructor(){
        // optional mergeCells is array of ranges (like the xml)
        this.merges = {};
    }
    add(merge) {
        // merge is {address, master}
        if (this.merges[merge.master]) {
            this.merges[merge.master].expandToAddress(merge.address);
        } else {
            const range = `${merge.master}:${merge.address}`;
            this.merges[merge.master] = new Range(range);
        }
    }
    get mergeCells() {
        return _.map(this.merges, (merge)=>merge.range);
    }
    reconcile(mergeCells, rows) {
        // reconcile merge list with merge cells
        _.each(mergeCells, (merge)=>{
            const dimensions = colCache.decode(merge);
            for(let i = dimensions.top; i <= dimensions.bottom; i++){
                const row = rows[i - 1];
                for(let j = dimensions.left; j <= dimensions.right; j++){
                    const cell = row.cells[j - 1];
                    if (!cell) {
                        // nulls are not included in document - so if master cell has no value - add a null one here
                        row.cells[j] = {
                            type: Enums.ValueType.Null,
                            address: colCache.encodeAddress(i, j)
                        };
                    } else if (cell.type === Enums.ValueType.Merge) {
                        cell.master = dimensions.tl;
                    }
                }
            }
        });
    }
    getMasterAddress(address) {
        // if address has been merged, return its master's address. Assumes reconcile has been called
        const range = this.hash[address];
        return range && range.tl;
    }
}
module.exports = Merges;


/***/ }),

/***/ 96107:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const isDefined = (attr)=>typeof attr !== "undefined";
class OutlinePropertiesXform extends BaseXform {
    get tag() {
        return "outlinePr";
    }
    render(xmlStream, model) {
        if (model && (isDefined(model.summaryBelow) || isDefined(model.summaryRight))) {
            xmlStream.leafNode(this.tag, {
                summaryBelow: isDefined(model.summaryBelow) ? Number(model.summaryBelow) : undefined,
                summaryRight: isDefined(model.summaryRight) ? Number(model.summaryRight) : undefined
            });
            return true;
        }
        return false;
    }
    parseOpen(node) {
        if (node.name === this.tag) {
            this.model = {
                summaryBelow: isDefined(node.attributes.summaryBelow) ? Boolean(Number(node.attributes.summaryBelow)) : undefined,
                summaryRight: isDefined(node.attributes.summaryRight) ? Boolean(Number(node.attributes.summaryRight)) : undefined
            };
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = OutlinePropertiesXform;


/***/ }),

/***/ 61321:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class PageBreaksXform extends BaseXform {
    get tag() {
        return "brk";
    }
    render(xmlStream, model) {
        xmlStream.leafNode("brk", model);
    }
    parseOpen(node) {
        if (node.name === "brk") {
            this.model = node.attributes.ref;
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = PageBreaksXform;


/***/ }),

/***/ 27674:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
const BaseXform = __webpack_require__(90884);
class PageMarginsXform extends BaseXform {
    get tag() {
        return "pageMargins";
    }
    render(xmlStream, model) {
        if (model) {
            const attributes = {
                left: model.left,
                right: model.right,
                top: model.top,
                bottom: model.bottom,
                header: model.header,
                footer: model.footer
            };
            if (_.some(attributes, (value)=>value !== undefined)) {
                xmlStream.leafNode(this.tag, attributes);
            }
        }
    }
    parseOpen(node) {
        switch(node.name){
            case this.tag:
                this.model = {
                    left: parseFloat(node.attributes.left || 0.7),
                    right: parseFloat(node.attributes.right || 0.7),
                    top: parseFloat(node.attributes.top || 0.75),
                    bottom: parseFloat(node.attributes.bottom || 0.75),
                    header: parseFloat(node.attributes.header || 0.3),
                    footer: parseFloat(node.attributes.footer || 0.3)
                };
                return true;
            default:
                return false;
        }
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = PageMarginsXform;


/***/ }),

/***/ 59512:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class PageSetupPropertiesXform extends BaseXform {
    get tag() {
        return "pageSetUpPr";
    }
    render(xmlStream, model) {
        if (model && model.fitToPage) {
            xmlStream.leafNode(this.tag, {
                fitToPage: model.fitToPage ? "1" : undefined
            });
            return true;
        }
        return false;
    }
    parseOpen(node) {
        if (node.name === this.tag) {
            this.model = {
                fitToPage: node.attributes.fitToPage === "1"
            };
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = PageSetupPropertiesXform;


/***/ }),

/***/ 20358:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
const BaseXform = __webpack_require__(90884);
function booleanToXml(model) {
    return model ? "1" : undefined;
}
function pageOrderToXml(model) {
    switch(model){
        case "overThenDown":
            return model;
        default:
            return undefined;
    }
}
function cellCommentsToXml(model) {
    switch(model){
        case "atEnd":
        case "asDisplyed":
            return model;
        default:
            return undefined;
    }
}
function errorsToXml(model) {
    switch(model){
        case "dash":
        case "blank":
        case "NA":
            return model;
        default:
            return undefined;
    }
}
function pageSizeToModel(value) {
    return value !== undefined ? parseInt(value, 10) : undefined;
}
class PageSetupXform extends BaseXform {
    get tag() {
        return "pageSetup";
    }
    render(xmlStream, model) {
        if (model) {
            const attributes = {
                paperSize: model.paperSize,
                orientation: model.orientation,
                horizontalDpi: model.horizontalDpi,
                verticalDpi: model.verticalDpi,
                pageOrder: pageOrderToXml(model.pageOrder),
                blackAndWhite: booleanToXml(model.blackAndWhite),
                draft: booleanToXml(model.draft),
                cellComments: cellCommentsToXml(model.cellComments),
                errors: errorsToXml(model.errors),
                scale: model.scale,
                fitToWidth: model.fitToWidth,
                fitToHeight: model.fitToHeight,
                firstPageNumber: model.firstPageNumber,
                useFirstPageNumber: booleanToXml(model.firstPageNumber),
                usePrinterDefaults: booleanToXml(model.usePrinterDefaults),
                copies: model.copies
            };
            if (_.some(attributes, (value)=>value !== undefined)) {
                xmlStream.leafNode(this.tag, attributes);
            }
        }
    }
    parseOpen(node) {
        switch(node.name){
            case this.tag:
                this.model = {
                    paperSize: pageSizeToModel(node.attributes.paperSize),
                    orientation: node.attributes.orientation || "portrait",
                    horizontalDpi: parseInt(node.attributes.horizontalDpi || "4294967295", 10),
                    verticalDpi: parseInt(node.attributes.verticalDpi || "4294967295", 10),
                    pageOrder: node.attributes.pageOrder || "downThenOver",
                    blackAndWhite: node.attributes.blackAndWhite === "1",
                    draft: node.attributes.draft === "1",
                    cellComments: node.attributes.cellComments || "None",
                    errors: node.attributes.errors || "displayed",
                    scale: parseInt(node.attributes.scale || "100", 10),
                    fitToWidth: parseInt(node.attributes.fitToWidth || "1", 10),
                    fitToHeight: parseInt(node.attributes.fitToHeight || "1", 10),
                    firstPageNumber: parseInt(node.attributes.firstPageNumber || "1", 10),
                    useFirstPageNumber: node.attributes.useFirstPageNumber === "1",
                    usePrinterDefaults: node.attributes.usePrinterDefaults === "1",
                    copies: parseInt(node.attributes.copies || "1", 10)
                };
                return true;
            default:
                return false;
        }
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = PageSetupXform;


/***/ }),

/***/ 718:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class PictureXform extends BaseXform {
    get tag() {
        return "picture";
    }
    render(xmlStream, model) {
        if (model) {
            xmlStream.leafNode(this.tag, {
                "r:id": model.rId
            });
        }
    }
    parseOpen(node) {
        switch(node.name){
            case this.tag:
                this.model = {
                    rId: node.attributes["r:id"]
                };
                return true;
            default:
                return false;
        }
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = PictureXform;


/***/ }),

/***/ 44519:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
const BaseXform = __webpack_require__(90884);
function booleanToXml(model) {
    return model ? "1" : undefined;
}
class PrintOptionsXform extends BaseXform {
    get tag() {
        return "printOptions";
    }
    render(xmlStream, model) {
        if (model) {
            const attributes = {
                headings: booleanToXml(model.showRowColHeaders),
                gridLines: booleanToXml(model.showGridLines),
                horizontalCentered: booleanToXml(model.horizontalCentered),
                verticalCentered: booleanToXml(model.verticalCentered)
            };
            if (_.some(attributes, (value)=>value !== undefined)) {
                xmlStream.leafNode(this.tag, attributes);
            }
        }
    }
    parseOpen(node) {
        switch(node.name){
            case this.tag:
                this.model = {
                    showRowColHeaders: node.attributes.headings === "1",
                    showGridLines: node.attributes.gridLines === "1",
                    horizontalCentered: node.attributes.horizontalCentered === "1",
                    verticalCentered: node.attributes.verticalCentered === "1"
                };
                return true;
            default:
                return false;
        }
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = PrintOptionsXform;


/***/ }),

/***/ 7077:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const PageBreaksXform = __webpack_require__(61321);
const ListXform = __webpack_require__(34397);
class RowBreaksXform extends ListXform {
    constructor(){
        const options = {
            tag: "rowBreaks",
            count: true,
            childXform: new PageBreaksXform()
        };
        super(options);
    }
    // get tag() { return 'rowBreaks'; }
    render(xmlStream, model) {
        if (model && model.length) {
            xmlStream.openNode(this.tag, this.$);
            if (this.count) {
                xmlStream.addAttribute(this.$count, model.length);
                xmlStream.addAttribute("manualBreakCount", model.length);
            }
            const { childXform } = this;
            model.forEach((childModel)=>{
                childXform.render(xmlStream, childModel);
            });
            xmlStream.closeNode();
        } else if (this.empty) {
            xmlStream.leafNode(this.tag);
        }
    }
}
module.exports = RowBreaksXform;


/***/ }),

/***/ 39285:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const utils = __webpack_require__(90778);
const CellXform = __webpack_require__(95309);
class RowXform extends BaseXform {
    constructor(options){
        super();
        this.maxItems = options && options.maxItems;
        this.map = {
            c: new CellXform()
        };
    }
    get tag() {
        return "row";
    }
    prepare(model, options) {
        const styleId = options.styles.addStyleModel(model.style);
        if (styleId) {
            model.styleId = styleId;
        }
        const cellXform = this.map.c;
        model.cells.forEach((cellModel)=>{
            cellXform.prepare(cellModel, options);
        });
    }
    render(xmlStream, model, options) {
        xmlStream.openNode("row");
        xmlStream.addAttribute("r", model.number);
        if (model.height) {
            xmlStream.addAttribute("ht", model.height);
            xmlStream.addAttribute("customHeight", "1");
        }
        if (model.hidden) {
            xmlStream.addAttribute("hidden", "1");
        }
        if (model.min > 0 && model.max > 0 && model.min <= model.max) {
            xmlStream.addAttribute("spans", `${model.min}:${model.max}`);
        }
        if (model.styleId) {
            xmlStream.addAttribute("s", model.styleId);
            xmlStream.addAttribute("customFormat", "1");
        }
        xmlStream.addAttribute("x14ac:dyDescent", "0.25");
        if (model.outlineLevel) {
            xmlStream.addAttribute("outlineLevel", model.outlineLevel);
        }
        if (model.collapsed) {
            xmlStream.addAttribute("collapsed", "1");
        }
        const cellXform = this.map.c;
        model.cells.forEach((cellModel)=>{
            cellXform.render(xmlStream, cellModel, options);
        });
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        if (node.name === "row") {
            this.numRowsSeen += 1;
            const spans = node.attributes.spans ? node.attributes.spans.split(":").map((span)=>parseInt(span, 10)) : [
                undefined,
                undefined
            ];
            const model = this.model = {
                number: parseInt(node.attributes.r, 10),
                min: spans[0],
                max: spans[1],
                cells: []
            };
            if (node.attributes.s) {
                model.styleId = parseInt(node.attributes.s, 10);
            }
            if (utils.parseBoolean(node.attributes.hidden)) {
                model.hidden = true;
            }
            if (utils.parseBoolean(node.attributes.bestFit)) {
                model.bestFit = true;
            }
            if (node.attributes.ht) {
                model.height = parseFloat(node.attributes.ht);
            }
            if (node.attributes.outlineLevel) {
                model.outlineLevel = parseInt(node.attributes.outlineLevel, 10);
            }
            if (utils.parseBoolean(node.attributes.collapsed)) {
                model.collapsed = true;
            }
            return true;
        }
        this.parser = this.map[node.name];
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        return false;
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.model.cells.push(this.parser.model);
                if (this.maxItems && this.model.cells.length > this.maxItems) {
                    throw new Error(`Max column count (${this.maxItems}) exceeded`);
                }
                this.parser = undefined;
            }
            return true;
        }
        return false;
    }
    reconcile(model, options) {
        model.style = model.styleId ? options.styles.getStyleModel(model.styleId) : {};
        if (model.styleId !== undefined) {
            model.styleId = undefined;
        }
        const cellXform = this.map.c;
        model.cells.forEach((cellModel)=>{
            cellXform.reconcile(cellModel, options);
        });
    }
}
module.exports = RowXform;


/***/ }),

/***/ 79682:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
const BaseXform = __webpack_require__(90884);
class SheetFormatPropertiesXform extends BaseXform {
    get tag() {
        return "sheetFormatPr";
    }
    render(xmlStream, model) {
        if (model) {
            const attributes = {
                defaultRowHeight: model.defaultRowHeight,
                outlineLevelRow: model.outlineLevelRow,
                outlineLevelCol: model.outlineLevelCol,
                "x14ac:dyDescent": model.dyDescent
            };
            if (model.defaultColWidth) {
                attributes.defaultColWidth = model.defaultColWidth;
            }
            // default value for 'defaultRowHeight' is 15, this should not be 'custom'
            if (!model.defaultRowHeight || model.defaultRowHeight !== 15) {
                attributes.customHeight = "1";
            }
            if (_.some(attributes, (value)=>value !== undefined)) {
                xmlStream.leafNode("sheetFormatPr", attributes);
            }
        }
    }
    parseOpen(node) {
        if (node.name === "sheetFormatPr") {
            this.model = {
                defaultRowHeight: parseFloat(node.attributes.defaultRowHeight || "0"),
                dyDescent: parseFloat(node.attributes["x14ac:dyDescent"] || "0"),
                outlineLevelRow: parseInt(node.attributes.outlineLevelRow || "0", 10),
                outlineLevelCol: parseInt(node.attributes.outlineLevelCol || "0", 10)
            };
            if (node.attributes.defaultColWidth) {
                this.model.defaultColWidth = parseFloat(node.attributes.defaultColWidth);
            }
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = SheetFormatPropertiesXform;


/***/ }),

/***/ 83050:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const ColorXform = __webpack_require__(47287);
const PageSetupPropertiesXform = __webpack_require__(59512);
const OutlinePropertiesXform = __webpack_require__(96107);
class SheetPropertiesXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            tabColor: new ColorXform("tabColor"),
            pageSetUpPr: new PageSetupPropertiesXform(),
            outlinePr: new OutlinePropertiesXform()
        };
    }
    get tag() {
        return "sheetPr";
    }
    render(xmlStream, model) {
        if (model) {
            xmlStream.addRollback();
            xmlStream.openNode("sheetPr");
            let inner = false;
            inner = this.map.tabColor.render(xmlStream, model.tabColor) || inner;
            inner = this.map.pageSetUpPr.render(xmlStream, model.pageSetup) || inner;
            inner = this.map.outlinePr.render(xmlStream, model.outlineProperties) || inner;
            if (inner) {
                xmlStream.closeNode();
                xmlStream.commit();
            } else {
                xmlStream.rollback();
            }
        }
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        if (node.name === this.tag) {
            this.reset();
            return true;
        }
        if (this.map[node.name]) {
            this.parser = this.map[node.name];
            this.parser.parseOpen(node);
            return true;
        }
        return false;
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
            return true;
        }
        return false;
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        if (this.map.tabColor.model || this.map.pageSetUpPr.model || this.map.outlinePr.model) {
            this.model = {};
            if (this.map.tabColor.model) {
                this.model.tabColor = this.map.tabColor.model;
            }
            if (this.map.pageSetUpPr.model) {
                this.model.pageSetup = this.map.pageSetUpPr.model;
            }
            if (this.map.outlinePr.model) {
                this.model.outlineProperties = this.map.outlinePr.model;
            }
        } else {
            this.model = null;
        }
        return false;
    }
}
module.exports = SheetPropertiesXform;


/***/ }),

/***/ 59438:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
const BaseXform = __webpack_require__(90884);
function booleanToXml(model, value) {
    return model ? value : undefined;
}
function xmlToBoolean(value, equals) {
    return value === equals ? true : undefined;
}
class SheetProtectionXform extends BaseXform {
    get tag() {
        return "sheetProtection";
    }
    render(xmlStream, model) {
        if (model) {
            const attributes = {
                sheet: booleanToXml(model.sheet, "1"),
                selectLockedCells: model.selectLockedCells === false ? "1" : undefined,
                selectUnlockedCells: model.selectUnlockedCells === false ? "1" : undefined,
                formatCells: booleanToXml(model.formatCells, "0"),
                formatColumns: booleanToXml(model.formatColumns, "0"),
                formatRows: booleanToXml(model.formatRows, "0"),
                insertColumns: booleanToXml(model.insertColumns, "0"),
                insertRows: booleanToXml(model.insertRows, "0"),
                insertHyperlinks: booleanToXml(model.insertHyperlinks, "0"),
                deleteColumns: booleanToXml(model.deleteColumns, "0"),
                deleteRows: booleanToXml(model.deleteRows, "0"),
                sort: booleanToXml(model.sort, "0"),
                autoFilter: booleanToXml(model.autoFilter, "0"),
                pivotTables: booleanToXml(model.pivotTables, "0")
            };
            if (model.sheet) {
                attributes.algorithmName = model.algorithmName;
                attributes.hashValue = model.hashValue;
                attributes.saltValue = model.saltValue;
                attributes.spinCount = model.spinCount;
                attributes.objects = booleanToXml(model.objects === false, "1");
                attributes.scenarios = booleanToXml(model.scenarios === false, "1");
            }
            if (_.some(attributes, (value)=>value !== undefined)) {
                xmlStream.leafNode(this.tag, attributes);
            }
        }
    }
    parseOpen(node) {
        switch(node.name){
            case this.tag:
                this.model = {
                    sheet: xmlToBoolean(node.attributes.sheet, "1"),
                    objects: node.attributes.objects === "1" ? false : undefined,
                    scenarios: node.attributes.scenarios === "1" ? false : undefined,
                    selectLockedCells: node.attributes.selectLockedCells === "1" ? false : undefined,
                    selectUnlockedCells: node.attributes.selectUnlockedCells === "1" ? false : undefined,
                    formatCells: xmlToBoolean(node.attributes.formatCells, "0"),
                    formatColumns: xmlToBoolean(node.attributes.formatColumns, "0"),
                    formatRows: xmlToBoolean(node.attributes.formatRows, "0"),
                    insertColumns: xmlToBoolean(node.attributes.insertColumns, "0"),
                    insertRows: xmlToBoolean(node.attributes.insertRows, "0"),
                    insertHyperlinks: xmlToBoolean(node.attributes.insertHyperlinks, "0"),
                    deleteColumns: xmlToBoolean(node.attributes.deleteColumns, "0"),
                    deleteRows: xmlToBoolean(node.attributes.deleteRows, "0"),
                    sort: xmlToBoolean(node.attributes.sort, "0"),
                    autoFilter: xmlToBoolean(node.attributes.autoFilter, "0"),
                    pivotTables: xmlToBoolean(node.attributes.pivotTables, "0")
                };
                if (node.attributes.algorithmName) {
                    this.model.algorithmName = node.attributes.algorithmName;
                    this.model.hashValue = node.attributes.hashValue;
                    this.model.saltValue = node.attributes.saltValue;
                    this.model.spinCount = parseInt(node.attributes.spinCount, 10);
                }
                return true;
            default:
                return false;
        }
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = SheetProtectionXform;


/***/ }),

/***/ 94120:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const colCache = __webpack_require__(90609);
const BaseXform = __webpack_require__(90884);
const VIEW_STATES = {
    frozen: "frozen",
    frozenSplit: "frozen",
    split: "split"
};
class SheetViewXform extends BaseXform {
    get tag() {
        return "sheetView";
    }
    prepare(model) {
        switch(model.state){
            case "frozen":
            case "split":
                break;
            default:
                model.state = "normal";
                break;
        }
    }
    render(xmlStream, model) {
        xmlStream.openNode("sheetView", {
            workbookViewId: model.workbookViewId || 0
        });
        const add = function(name, value, included) {
            if (included) {
                xmlStream.addAttribute(name, value);
            }
        };
        add("rightToLeft", "1", model.rightToLeft === true);
        add("tabSelected", "1", model.tabSelected);
        add("showRuler", "0", model.showRuler === false);
        add("showRowColHeaders", "0", model.showRowColHeaders === false);
        add("showGridLines", "0", model.showGridLines === false);
        add("zoomScale", model.zoomScale, model.zoomScale);
        add("zoomScaleNormal", model.zoomScaleNormal, model.zoomScaleNormal);
        add("view", model.style, model.style);
        let topLeftCell;
        let xSplit;
        let ySplit;
        let activePane;
        switch(model.state){
            case "frozen":
                xSplit = model.xSplit || 0;
                ySplit = model.ySplit || 0;
                topLeftCell = model.topLeftCell || colCache.getAddress(ySplit + 1, xSplit + 1).address;
                activePane = model.xSplit && model.ySplit && "bottomRight" || model.xSplit && "topRight" || "bottomLeft";
                xmlStream.leafNode("pane", {
                    xSplit: model.xSplit || undefined,
                    ySplit: model.ySplit || undefined,
                    topLeftCell,
                    activePane,
                    state: "frozen"
                });
                xmlStream.leafNode("selection", {
                    pane: activePane,
                    activeCell: model.activeCell,
                    sqref: model.activeCell
                });
                break;
            case "split":
                if (model.activePane === "topLeft") {
                    model.activePane = undefined;
                }
                xmlStream.leafNode("pane", {
                    xSplit: model.xSplit || undefined,
                    ySplit: model.ySplit || undefined,
                    topLeftCell: model.topLeftCell,
                    activePane: model.activePane
                });
                xmlStream.leafNode("selection", {
                    pane: model.activePane,
                    activeCell: model.activeCell,
                    sqref: model.activeCell
                });
                break;
            case "normal":
                if (model.activeCell) {
                    xmlStream.leafNode("selection", {
                        activeCell: model.activeCell,
                        sqref: model.activeCell
                    });
                }
                break;
            default:
                break;
        }
        xmlStream.closeNode();
    }
    parseOpen(node) {
        switch(node.name){
            case "sheetView":
                this.sheetView = {
                    workbookViewId: parseInt(node.attributes.workbookViewId, 10),
                    rightToLeft: node.attributes.rightToLeft === "1",
                    tabSelected: node.attributes.tabSelected === "1",
                    showRuler: !(node.attributes.showRuler === "0"),
                    showRowColHeaders: !(node.attributes.showRowColHeaders === "0"),
                    showGridLines: !(node.attributes.showGridLines === "0"),
                    zoomScale: parseInt(node.attributes.zoomScale || "100", 10),
                    zoomScaleNormal: parseInt(node.attributes.zoomScaleNormal || "100", 10),
                    style: node.attributes.view
                };
                this.pane = undefined;
                this.selections = {};
                return true;
            case "pane":
                this.pane = {
                    xSplit: parseInt(node.attributes.xSplit || "0", 10),
                    ySplit: parseInt(node.attributes.ySplit || "0", 10),
                    topLeftCell: node.attributes.topLeftCell,
                    activePane: node.attributes.activePane || "topLeft",
                    state: node.attributes.state
                };
                return true;
            case "selection":
                {
                    const name = node.attributes.pane || "topLeft";
                    this.selections[name] = {
                        pane: name,
                        activeCell: node.attributes.activeCell
                    };
                    return true;
                }
            default:
                return false;
        }
    }
    parseText() {}
    parseClose(name) {
        let model;
        let selection;
        switch(name){
            case "sheetView":
                if (this.sheetView && this.pane) {
                    model = this.model = {
                        workbookViewId: this.sheetView.workbookViewId,
                        rightToLeft: this.sheetView.rightToLeft,
                        state: VIEW_STATES[this.pane.state] || "split",
                        xSplit: this.pane.xSplit,
                        ySplit: this.pane.ySplit,
                        topLeftCell: this.pane.topLeftCell,
                        showRuler: this.sheetView.showRuler,
                        showRowColHeaders: this.sheetView.showRowColHeaders,
                        showGridLines: this.sheetView.showGridLines,
                        zoomScale: this.sheetView.zoomScale,
                        zoomScaleNormal: this.sheetView.zoomScaleNormal
                    };
                    if (this.model.state === "split") {
                        model.activePane = this.pane.activePane;
                    }
                    selection = this.selections[this.pane.activePane];
                    if (selection && selection.activeCell) {
                        model.activeCell = selection.activeCell;
                    }
                    if (this.sheetView.style) {
                        model.style = this.sheetView.style;
                    }
                } else {
                    model = this.model = {
                        workbookViewId: this.sheetView.workbookViewId,
                        rightToLeft: this.sheetView.rightToLeft,
                        state: "normal",
                        showRuler: this.sheetView.showRuler,
                        showRowColHeaders: this.sheetView.showRowColHeaders,
                        showGridLines: this.sheetView.showGridLines,
                        zoomScale: this.sheetView.zoomScale,
                        zoomScaleNormal: this.sheetView.zoomScaleNormal
                    };
                    selection = this.selections.topLeft;
                    if (selection && selection.activeCell) {
                        model.activeCell = selection.activeCell;
                    }
                    if (this.sheetView.style) {
                        model.style = this.sheetView.style;
                    }
                }
                return false;
            default:
                return true;
        }
    }
    reconcile() {}
}
module.exports = SheetViewXform;


/***/ }),

/***/ 60002:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class TablePartXform extends BaseXform {
    get tag() {
        return "tablePart";
    }
    render(xmlStream, model) {
        if (model) {
            xmlStream.leafNode(this.tag, {
                "r:id": model.rId
            });
        }
    }
    parseOpen(node) {
        switch(node.name){
            case this.tag:
                this.model = {
                    rId: node.attributes["r:id"]
                };
                return true;
            default:
                return false;
        }
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = TablePartXform;


/***/ }),

/***/ 71373:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
const colCache = __webpack_require__(90609);
const XmlStream = __webpack_require__(18749);
const RelType = __webpack_require__(39982);
const Merges = __webpack_require__(76404);
const BaseXform = __webpack_require__(90884);
const ListXform = __webpack_require__(34397);
const RowXform = __webpack_require__(39285);
const ColXform = __webpack_require__(57950);
const DimensionXform = __webpack_require__(90752);
const HyperlinkXform = __webpack_require__(83942);
const MergeCellXform = __webpack_require__(40388);
const DataValidationsXform = __webpack_require__(23303);
const SheetPropertiesXform = __webpack_require__(83050);
const SheetFormatPropertiesXform = __webpack_require__(79682);
const SheetViewXform = __webpack_require__(94120);
const SheetProtectionXform = __webpack_require__(59438);
const PageMarginsXform = __webpack_require__(27674);
const PageSetupXform = __webpack_require__(20358);
const PrintOptionsXform = __webpack_require__(44519);
const AutoFilterXform = __webpack_require__(44353);
const PictureXform = __webpack_require__(718);
const DrawingXform = __webpack_require__(54972);
const TablePartXform = __webpack_require__(60002);
const RowBreaksXform = __webpack_require__(7077);
const HeaderFooterXform = __webpack_require__(28086);
const ConditionalFormattingsXform = __webpack_require__(88312);
const ExtListXform = __webpack_require__(34910);
const mergeRule = (rule, extRule)=>{
    Object.keys(extRule).forEach((key)=>{
        const value = rule[key];
        const extValue = extRule[key];
        if (value === undefined && extValue !== undefined) {
            rule[key] = extValue;
        }
    });
};
const mergeConditionalFormattings = (model, extModel)=>{
    // conditional formattings are rendered in worksheet.conditionalFormatting and also in
    // worksheet.extLst.ext.x14:conditionalFormattings
    // some (e.g. dataBar) are even spread across both!
    if (!extModel || !extModel.length) {
        return model;
    }
    if (!model || !model.length) {
        return extModel;
    }
    // index model rules by x14Id
    const cfMap = {};
    const ruleMap = {};
    model.forEach((cf)=>{
        cfMap[cf.ref] = cf;
        cf.rules.forEach((rule)=>{
            const { x14Id } = rule;
            if (x14Id) {
                ruleMap[x14Id] = rule;
            }
        });
    });
    extModel.forEach((extCf)=>{
        extCf.rules.forEach((extRule)=>{
            const rule = ruleMap[extRule.x14Id];
            if (rule) {
                // merge with matching rule
                mergeRule(rule, extRule);
            } else if (cfMap[extCf.ref]) {
                // reuse existing cf ref
                cfMap[extCf.ref].rules.push(extRule);
            } else {
                // create new cf
                model.push({
                    ref: extCf.ref,
                    rules: [
                        extRule
                    ]
                });
            }
        });
    });
    // need to cope with rules in extModel that don't exist in model
    return model;
};
class WorkSheetXform extends BaseXform {
    constructor(options){
        super();
        const { maxRows, maxCols, ignoreNodes } = options || {};
        this.ignoreNodes = ignoreNodes || [];
        this.map = {
            sheetPr: new SheetPropertiesXform(),
            dimension: new DimensionXform(),
            sheetViews: new ListXform({
                tag: "sheetViews",
                count: false,
                childXform: new SheetViewXform()
            }),
            sheetFormatPr: new SheetFormatPropertiesXform(),
            cols: new ListXform({
                tag: "cols",
                count: false,
                childXform: new ColXform()
            }),
            sheetData: new ListXform({
                tag: "sheetData",
                count: false,
                empty: true,
                childXform: new RowXform({
                    maxItems: maxCols
                }),
                maxItems: maxRows
            }),
            autoFilter: new AutoFilterXform(),
            mergeCells: new ListXform({
                tag: "mergeCells",
                count: true,
                childXform: new MergeCellXform()
            }),
            rowBreaks: new RowBreaksXform(),
            hyperlinks: new ListXform({
                tag: "hyperlinks",
                count: false,
                childXform: new HyperlinkXform()
            }),
            pageMargins: new PageMarginsXform(),
            dataValidations: new DataValidationsXform(),
            pageSetup: new PageSetupXform(),
            headerFooter: new HeaderFooterXform(),
            printOptions: new PrintOptionsXform(),
            picture: new PictureXform(),
            drawing: new DrawingXform(),
            sheetProtection: new SheetProtectionXform(),
            tableParts: new ListXform({
                tag: "tableParts",
                count: true,
                childXform: new TablePartXform()
            }),
            conditionalFormatting: new ConditionalFormattingsXform(),
            extLst: new ExtListXform()
        };
    }
    prepare(model, options) {
        options.merges = new Merges();
        model.hyperlinks = options.hyperlinks = [];
        model.comments = options.comments = [];
        options.formulae = {};
        options.siFormulae = 0;
        this.map.cols.prepare(model.cols, options);
        this.map.sheetData.prepare(model.rows, options);
        this.map.conditionalFormatting.prepare(model.conditionalFormattings, options);
        model.mergeCells = options.merges.mergeCells;
        // prepare relationships
        const rels = model.rels = [];
        function nextRid(r) {
            return `rId${r.length + 1}`;
        }
        model.hyperlinks.forEach((hyperlink)=>{
            const rId = nextRid(rels);
            hyperlink.rId = rId;
            rels.push({
                Id: rId,
                Type: RelType.Hyperlink,
                Target: hyperlink.target,
                TargetMode: "External"
            });
        });
        // prepare comment relationships
        if (model.comments.length > 0) {
            const comment = {
                Id: nextRid(rels),
                Type: RelType.Comments,
                Target: `../comments${model.id}.xml`
            };
            rels.push(comment);
            const vmlDrawing = {
                Id: nextRid(rels),
                Type: RelType.VmlDrawing,
                Target: `../drawings/vmlDrawing${model.id}.vml`
            };
            rels.push(vmlDrawing);
            model.comments.forEach((item)=>{
                item.refAddress = colCache.decodeAddress(item.ref);
            });
            options.commentRefs.push({
                commentName: `comments${model.id}`,
                vmlDrawing: `vmlDrawing${model.id}`
            });
        }
        const drawingRelsHash = [];
        let bookImage;
        model.media.forEach((medium)=>{
            if (medium.type === "background") {
                const rId = nextRid(rels);
                bookImage = options.media[medium.imageId];
                rels.push({
                    Id: rId,
                    Type: RelType.Image,
                    Target: `../media/${bookImage.name}.${bookImage.extension}`
                });
                model.background = {
                    rId
                };
                model.image = options.media[medium.imageId];
            } else if (medium.type === "image") {
                let { drawing } = model;
                bookImage = options.media[medium.imageId];
                if (!drawing) {
                    drawing = model.drawing = {
                        rId: nextRid(rels),
                        name: `drawing${++options.drawingsCount}`,
                        anchors: [],
                        rels: []
                    };
                    options.drawings.push(drawing);
                    rels.push({
                        Id: drawing.rId,
                        Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
                        Target: `../drawings/${drawing.name}.xml`
                    });
                }
                let rIdImage = this.preImageId === medium.imageId ? drawingRelsHash[medium.imageId] : drawingRelsHash[drawing.rels.length];
                if (!rIdImage) {
                    rIdImage = nextRid(drawing.rels);
                    drawingRelsHash[drawing.rels.length] = rIdImage;
                    drawing.rels.push({
                        Id: rIdImage,
                        Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
                        Target: `../media/${bookImage.name}.${bookImage.extension}`
                    });
                }
                const anchor = {
                    picture: {
                        rId: rIdImage
                    },
                    range: medium.range
                };
                if (medium.hyperlinks && medium.hyperlinks.hyperlink) {
                    const rIdHyperLink = nextRid(drawing.rels);
                    drawingRelsHash[drawing.rels.length] = rIdHyperLink;
                    anchor.picture.hyperlinks = {
                        tooltip: medium.hyperlinks.tooltip,
                        rId: rIdHyperLink
                    };
                    drawing.rels.push({
                        Id: rIdHyperLink,
                        Type: RelType.Hyperlink,
                        Target: medium.hyperlinks.hyperlink,
                        TargetMode: "External"
                    });
                }
                this.preImageId = medium.imageId;
                drawing.anchors.push(anchor);
            }
        });
        // prepare tables
        model.tables.forEach((table)=>{
            // relationships
            const rId = nextRid(rels);
            table.rId = rId;
            rels.push({
                Id: rId,
                Type: RelType.Table,
                Target: `../tables/${table.target}`
            });
            // dynamic styles
            table.columns.forEach((column)=>{
                const { style } = column;
                if (style) {
                    column.dxfId = options.styles.addDxfStyle(style);
                }
            });
        });
        // prepare ext items
        this.map.extLst.prepare(model, options);
    }
    render(xmlStream, model) {
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("worksheet", WorkSheetXform.WORKSHEET_ATTRIBUTES);
        const sheetFormatPropertiesModel = model.properties ? {
            defaultRowHeight: model.properties.defaultRowHeight,
            dyDescent: model.properties.dyDescent,
            outlineLevelCol: model.properties.outlineLevelCol,
            outlineLevelRow: model.properties.outlineLevelRow
        } : undefined;
        if (model.properties && model.properties.defaultColWidth) {
            sheetFormatPropertiesModel.defaultColWidth = model.properties.defaultColWidth;
        }
        const sheetPropertiesModel = {
            outlineProperties: model.properties && model.properties.outlineProperties,
            tabColor: model.properties && model.properties.tabColor,
            pageSetup: model.pageSetup && model.pageSetup.fitToPage ? {
                fitToPage: model.pageSetup.fitToPage
            } : undefined
        };
        const pageMarginsModel = model.pageSetup && model.pageSetup.margins;
        const printOptionsModel = {
            showRowColHeaders: model.pageSetup && model.pageSetup.showRowColHeaders,
            showGridLines: model.pageSetup && model.pageSetup.showGridLines,
            horizontalCentered: model.pageSetup && model.pageSetup.horizontalCentered,
            verticalCentered: model.pageSetup && model.pageSetup.verticalCentered
        };
        const sheetProtectionModel = model.sheetProtection;
        this.map.sheetPr.render(xmlStream, sheetPropertiesModel);
        this.map.dimension.render(xmlStream, model.dimensions);
        this.map.sheetViews.render(xmlStream, model.views);
        this.map.sheetFormatPr.render(xmlStream, sheetFormatPropertiesModel);
        this.map.cols.render(xmlStream, model.cols);
        this.map.sheetData.render(xmlStream, model.rows);
        this.map.sheetProtection.render(xmlStream, sheetProtectionModel); // Note: must be after sheetData and before autoFilter
        this.map.autoFilter.render(xmlStream, model.autoFilter);
        this.map.mergeCells.render(xmlStream, model.mergeCells);
        this.map.conditionalFormatting.render(xmlStream, model.conditionalFormattings); // Note: must be before dataValidations
        this.map.dataValidations.render(xmlStream, model.dataValidations);
        // For some reason hyperlinks have to be after the data validations
        this.map.hyperlinks.render(xmlStream, model.hyperlinks);
        this.map.printOptions.render(xmlStream, printOptionsModel); // Note: must be before pageMargins
        this.map.pageMargins.render(xmlStream, pageMarginsModel);
        this.map.pageSetup.render(xmlStream, model.pageSetup);
        this.map.headerFooter.render(xmlStream, model.headerFooter);
        this.map.rowBreaks.render(xmlStream, model.rowBreaks);
        this.map.drawing.render(xmlStream, model.drawing); // Note: must be after rowBreaks
        this.map.picture.render(xmlStream, model.background); // Note: must be after drawing
        this.map.tableParts.render(xmlStream, model.tables);
        this.map.extLst.render(xmlStream, model);
        if (model.rels) {
            // add a <legacyDrawing /> node for each comment
            model.rels.forEach((rel)=>{
                if (rel.Type === RelType.VmlDrawing) {
                    xmlStream.leafNode("legacyDrawing", {
                        "r:id": rel.Id
                    });
                }
            });
        }
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        if (node.name === "worksheet") {
            _.each(this.map, (xform)=>{
                xform.reset();
            });
            return true;
        }
        if (this.map[node.name] && !this.ignoreNodes.includes(node.name)) {
            this.parser = this.map[node.name];
            this.parser.parseOpen(node);
        }
        return true;
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case "worksheet":
                {
                    const properties = this.map.sheetFormatPr.model || {};
                    if (this.map.sheetPr.model && this.map.sheetPr.model.tabColor) {
                        properties.tabColor = this.map.sheetPr.model.tabColor;
                    }
                    if (this.map.sheetPr.model && this.map.sheetPr.model.outlineProperties) {
                        properties.outlineProperties = this.map.sheetPr.model.outlineProperties;
                    }
                    const sheetProperties = {
                        fitToPage: this.map.sheetPr.model && this.map.sheetPr.model.pageSetup && this.map.sheetPr.model.pageSetup.fitToPage || false,
                        margins: this.map.pageMargins.model
                    };
                    const pageSetup = Object.assign(sheetProperties, this.map.pageSetup.model, this.map.printOptions.model);
                    const conditionalFormattings = mergeConditionalFormattings(this.map.conditionalFormatting.model, this.map.extLst.model && this.map.extLst.model["x14:conditionalFormattings"]);
                    this.model = {
                        dimensions: this.map.dimension.model,
                        cols: this.map.cols.model,
                        rows: this.map.sheetData.model,
                        mergeCells: this.map.mergeCells.model,
                        hyperlinks: this.map.hyperlinks.model,
                        dataValidations: this.map.dataValidations.model,
                        properties,
                        views: this.map.sheetViews.model,
                        pageSetup,
                        headerFooter: this.map.headerFooter.model,
                        background: this.map.picture.model,
                        drawing: this.map.drawing.model,
                        tables: this.map.tableParts.model,
                        conditionalFormattings
                    };
                    if (this.map.autoFilter.model) {
                        this.model.autoFilter = this.map.autoFilter.model;
                    }
                    if (this.map.sheetProtection.model) {
                        this.model.sheetProtection = this.map.sheetProtection.model;
                    }
                    return false;
                }
            default:
                // not quite sure how we get here!
                return true;
        }
    }
    reconcile(model, options) {
        // options.merges = new Merges();
        // options.merges.reconcile(model.mergeCells, model.rows);
        const rels = (model.relationships || []).reduce((h, rel)=>{
            h[rel.Id] = rel;
            if (rel.Type === RelType.Comments) {
                model.comments = options.comments[rel.Target].comments;
            }
            if (rel.Type === RelType.VmlDrawing && model.comments && model.comments.length) {
                const vmlComment = options.vmlDrawings[rel.Target].comments;
                model.comments.forEach((comment, index)=>{
                    comment.note = Object.assign({}, comment.note, vmlComment[index]);
                });
            }
            return h;
        }, {});
        options.commentsMap = (model.comments || []).reduce((h, comment)=>{
            if (comment.ref) {
                h[comment.ref] = comment;
            }
            return h;
        }, {});
        options.hyperlinkMap = (model.hyperlinks || []).reduce((h, hyperlink)=>{
            if (hyperlink.rId) {
                h[hyperlink.address] = rels[hyperlink.rId].Target;
            }
            return h;
        }, {});
        options.formulae = {};
        // compact the rows and cells
        model.rows = model.rows && model.rows.filter(Boolean) || [];
        model.rows.forEach((row)=>{
            row.cells = row.cells && row.cells.filter(Boolean) || [];
        });
        this.map.cols.reconcile(model.cols, options);
        this.map.sheetData.reconcile(model.rows, options);
        this.map.conditionalFormatting.reconcile(model.conditionalFormattings, options);
        model.media = [];
        if (model.drawing) {
            const drawingRel = rels[model.drawing.rId];
            const match = drawingRel.Target.match(/\/drawings\/([a-zA-Z0-9]+)[.][a-zA-Z]{3,4}$/);
            if (match) {
                const drawingName = match[1];
                const drawing = options.drawings[drawingName];
                drawing.anchors.forEach((anchor)=>{
                    if (anchor.medium) {
                        const image = {
                            type: "image",
                            imageId: anchor.medium.index,
                            range: anchor.range,
                            hyperlinks: anchor.picture.hyperlinks
                        };
                        model.media.push(image);
                    }
                });
            }
        }
        const backgroundRel = model.background && rels[model.background.rId];
        if (backgroundRel) {
            const target = backgroundRel.Target.split("/media/")[1];
            const imageId = options.mediaIndex && options.mediaIndex[target];
            if (imageId !== undefined) {
                model.media.push({
                    type: "background",
                    imageId
                });
            }
        }
        model.tables = (model.tables || []).map((tablePart)=>{
            const rel = rels[tablePart.rId];
            return options.tables[rel.Target];
        });
        delete model.relationships;
        delete model.hyperlinks;
        delete model.comments;
    }
}
WorkSheetXform.WORKSHEET_ATTRIBUTES = {
    xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
    "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
    "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
    "mc:Ignorable": "x14ac",
    "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac"
};
module.exports = WorkSheetXform;


/***/ }),

/***/ 90990:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class BooleanXform extends BaseXform {
    constructor(options){
        super();
        this.tag = options.tag;
        this.attr = options.attr;
    }
    render(xmlStream, model) {
        if (model) {
            xmlStream.openNode(this.tag);
            xmlStream.closeNode();
        }
    }
    parseOpen(node) {
        if (node.name === this.tag) {
            this.model = true;
        }
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = BooleanXform;


/***/ }),

/***/ 16245:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class DateXform extends BaseXform {
    constructor(options){
        super();
        this.tag = options.tag;
        this.attr = options.attr;
        this.attrs = options.attrs;
        this._format = options.format || function(dt) {
            try {
                if (Number.isNaN(dt.getTime())) return "";
                return dt.toISOString();
            } catch (e) {
                return "";
            }
        };
        this._parse = options.parse || function(str) {
            return new Date(str);
        };
    }
    render(xmlStream, model) {
        if (model) {
            xmlStream.openNode(this.tag);
            if (this.attrs) {
                xmlStream.addAttributes(this.attrs);
            }
            if (this.attr) {
                xmlStream.addAttribute(this.attr, this._format(model));
            } else {
                xmlStream.writeText(this._format(model));
            }
            xmlStream.closeNode();
        }
    }
    parseOpen(node) {
        if (node.name === this.tag) {
            if (this.attr) {
                this.model = this._parse(node.attributes[this.attr]);
            } else {
                this.text = [];
            }
        }
    }
    parseText(text) {
        if (!this.attr) {
            this.text.push(text);
        }
    }
    parseClose() {
        if (!this.attr) {
            this.model = this._parse(this.text.join(""));
        }
        return false;
    }
}
module.exports = DateXform;


/***/ }),

/***/ 51377:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class IntegerXform extends BaseXform {
    constructor(options){
        super();
        this.tag = options.tag;
        this.attr = options.attr;
        this.attrs = options.attrs;
        // option to render zero
        this.zero = options.zero;
    }
    render(xmlStream, model) {
        // int is different to float in that zero is not rendered
        if (model || this.zero) {
            xmlStream.openNode(this.tag);
            if (this.attrs) {
                xmlStream.addAttributes(this.attrs);
            }
            if (this.attr) {
                xmlStream.addAttribute(this.attr, model);
            } else {
                xmlStream.writeText(model);
            }
            xmlStream.closeNode();
        }
    }
    parseOpen(node) {
        if (node.name === this.tag) {
            if (this.attr) {
                this.model = parseInt(node.attributes[this.attr], 10);
            } else {
                this.text = [];
            }
            return true;
        }
        return false;
    }
    parseText(text) {
        if (!this.attr) {
            this.text.push(text);
        }
    }
    parseClose() {
        if (!this.attr) {
            this.model = parseInt(this.text.join("") || 0, 10);
        }
        return false;
    }
}
module.exports = IntegerXform;


/***/ }),

/***/ 15510:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class StringXform extends BaseXform {
    constructor(options){
        super();
        this.tag = options.tag;
        this.attr = options.attr;
        this.attrs = options.attrs;
    }
    render(xmlStream, model) {
        if (model !== undefined) {
            xmlStream.openNode(this.tag);
            if (this.attrs) {
                xmlStream.addAttributes(this.attrs);
            }
            if (this.attr) {
                xmlStream.addAttribute(this.attr, model);
            } else {
                xmlStream.writeText(model);
            }
            xmlStream.closeNode();
        }
    }
    parseOpen(node) {
        if (node.name === this.tag) {
            if (this.attr) {
                this.model = node.attributes[this.attr];
            } else {
                this.text = [];
            }
        }
    }
    parseText(text) {
        if (!this.attr) {
            this.text.push(text);
        }
    }
    parseClose() {
        if (!this.attr) {
            this.model = this.text.join("");
        }
        return false;
    }
}
module.exports = StringXform;


/***/ }),

/***/ 76949:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const XmlStream = __webpack_require__(18749);
// const model = {
//   tag: 'name',
//   $: {attr: 'value'},
//   c: [
//     { tag: 'child' }
//   ],
//   t: 'some text'
// };
function build(xmlStream, model) {
    xmlStream.openNode(model.tag, model.$);
    if (model.c) {
        model.c.forEach((child)=>{
            build(xmlStream, child);
        });
    }
    if (model.t) {
        xmlStream.writeText(model.t);
    }
    xmlStream.closeNode();
}
class StaticXform extends BaseXform {
    constructor(model){
        super();
        // This class is an optimisation for static (unimportant and unchanging) xml
        // It is stateless - apart from its static model and so can be used as a singleton
        // Being stateless - it will only track entry to and exit from it's root xml tag during parsing and nothing else
        // Known issues:
        //    since stateless - parseOpen always returns true. Parent xform must know when to start using this xform
        //    if the root tag is recursive, the parsing will behave unpredictably
        this._model = model;
    }
    render(xmlStream) {
        if (!this._xml) {
            const stream = new XmlStream();
            build(stream, this._model);
            this._xml = stream.xml;
        }
        xmlStream.writeXml(this._xml);
    }
    parseOpen() {
        return true;
    }
    parseText() {}
    parseClose(name) {
        switch(name){
            case this._model.tag:
                return false;
            default:
                return true;
        }
    }
}
module.exports = StaticXform;


/***/ }),

/***/ 47561:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const TextXform = __webpack_require__(28426);
const RichTextXform = __webpack_require__(9367);
const BaseXform = __webpack_require__(90884);
// <rPh sb="0" eb="1">
//   <t>(its pronounciation in KATAKANA)</t>
// </rPh>
class PhoneticTextXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            r: new RichTextXform(),
            t: new TextXform()
        };
    }
    get tag() {
        return "rPh";
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            sb: model.sb || 0,
            eb: model.eb || 0
        });
        if (model && model.hasOwnProperty("richText") && model.richText) {
            const { r } = this.map;
            model.richText.forEach((text)=>{
                r.render(xmlStream, text);
            });
        } else if (model) {
            this.map.t.render(xmlStream, model.text);
        }
        xmlStream.closeNode();
    }
    parseOpen(node) {
        const { name } = node;
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        if (name === this.tag) {
            this.model = {
                sb: parseInt(node.attributes.sb, 10),
                eb: parseInt(node.attributes.eb, 10)
            };
            return true;
        }
        this.parser = this.map[name];
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        return false;
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                switch(name){
                    case "r":
                        {
                            let rt = this.model.richText;
                            if (!rt) {
                                rt = this.model.richText = [];
                            }
                            rt.push(this.parser.model);
                            break;
                        }
                    case "t":
                        this.model.text = this.parser.model;
                        break;
                    default:
                        break;
                }
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case this.tag:
                return false;
            default:
                return true;
        }
    }
}
module.exports = PhoneticTextXform;


/***/ }),

/***/ 9367:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const TextXform = __webpack_require__(28426);
const FontXform = __webpack_require__(60812);
const BaseXform = __webpack_require__(90884);
// <r>
//   <rPr>
//     <sz val="11"/>
//     <color theme="1" tint="5"/>
//     <rFont val="Calibri"/>
//     <family val="2"/>
//     <scheme val="minor"/>
//   </rPr>
//   <t xml:space="preserve"> is </t>
// </r>
class RichTextXform extends BaseXform {
    constructor(model){
        super();
        this.model = model;
    }
    get tag() {
        return "r";
    }
    get textXform() {
        return this._textXform || (this._textXform = new TextXform());
    }
    get fontXform() {
        return this._fontXform || (this._fontXform = new FontXform(RichTextXform.FONT_OPTIONS));
    }
    render(xmlStream, model) {
        model = model || this.model;
        xmlStream.openNode("r");
        if (model.font) {
            this.fontXform.render(xmlStream, model.font);
        }
        this.textXform.render(xmlStream, model.text);
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case "r":
                this.model = {};
                return true;
            case "t":
                this.parser = this.textXform;
                this.parser.parseOpen(node);
                return true;
            case "rPr":
                this.parser = this.fontXform;
                this.parser.parseOpen(node);
                return true;
            default:
                return false;
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        switch(name){
            case "r":
                return false;
            case "t":
                this.model.text = this.parser.model;
                this.parser = undefined;
                return true;
            case "rPr":
                this.model.font = this.parser.model;
                this.parser = undefined;
                return true;
            default:
                if (this.parser) {
                    this.parser.parseClose(name);
                }
                return true;
        }
    }
}
RichTextXform.FONT_OPTIONS = {
    tagName: "rPr",
    fontNameTag: "rFont"
};
module.exports = RichTextXform;


/***/ }),

/***/ 6202:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const TextXform = __webpack_require__(28426);
const RichTextXform = __webpack_require__(9367);
const PhoneticTextXform = __webpack_require__(47561);
const BaseXform = __webpack_require__(90884);
// <si>
//   <r></r><r></r>...
// </si>
// <si>
//   <t></t>
// </si>
class SharedStringXform extends BaseXform {
    constructor(model){
        super();
        this.model = model;
        this.map = {
            r: new RichTextXform(),
            t: new TextXform(),
            rPh: new PhoneticTextXform()
        };
    }
    get tag() {
        return "si";
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        if (model && model.hasOwnProperty("richText") && model.richText) {
            if (model.richText.length) {
                model.richText.forEach((text)=>{
                    this.map.r.render(xmlStream, text);
                });
            } else {
                this.map.t.render(xmlStream, "");
            }
        } else if (model !== undefined && model !== null) {
            this.map.t.render(xmlStream, model);
        }
        xmlStream.closeNode();
    }
    parseOpen(node) {
        const { name } = node;
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        if (name === this.tag) {
            this.model = {};
            return true;
        }
        this.parser = this.map[name];
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        return false;
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                switch(name){
                    case "r":
                        {
                            let rt = this.model.richText;
                            if (!rt) {
                                rt = this.model.richText = [];
                            }
                            rt.push(this.parser.model);
                            break;
                        }
                    case "t":
                        this.model = this.parser.model;
                        break;
                    default:
                        break;
                }
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case this.tag:
                return false;
            default:
                return true;
        }
    }
}
module.exports = SharedStringXform;


/***/ }),

/***/ 99582:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const XmlStream = __webpack_require__(18749);
const BaseXform = __webpack_require__(90884);
const SharedStringXform = __webpack_require__(6202);
class SharedStringsXform extends BaseXform {
    constructor(model){
        super();
        this.model = model || {
            values: [],
            count: 0
        };
        this.hash = Object.create(null);
        this.rich = Object.create(null);
    }
    get sharedStringXform() {
        return this._sharedStringXform || (this._sharedStringXform = new SharedStringXform());
    }
    get values() {
        return this.model.values;
    }
    get uniqueCount() {
        return this.model.values.length;
    }
    get count() {
        return this.model.count;
    }
    getString(index) {
        return this.model.values[index];
    }
    add(value) {
        return value.richText ? this.addRichText(value) : this.addText(value);
    }
    addText(value) {
        let index = this.hash[value];
        if (index === undefined) {
            index = this.hash[value] = this.model.values.length;
            this.model.values.push(value);
        }
        this.model.count++;
        return index;
    }
    addRichText(value) {
        // TODO: add WeakMap here
        const xml = this.sharedStringXform.toXml(value);
        let index = this.rich[xml];
        if (index === undefined) {
            index = this.rich[xml] = this.model.values.length;
            this.model.values.push(value);
        }
        this.model.count++;
        return index;
    }
    // <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    // <sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="<%=totalRefs%>" uniqueCount="<%=count%>">
    //   <si><t><%=text%></t></si>
    //   <si><r><rPr></rPr><t></t></r></si>
    // </sst>
    render(xmlStream, model) {
        model = model || this._values;
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("sst", {
            xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
            count: model.count,
            uniqueCount: model.values.length
        });
        const sx = this.sharedStringXform;
        model.values.forEach((sharedString)=>{
            sx.render(xmlStream, sharedString);
        });
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case "sst":
                return true;
            case "si":
                this.parser = this.sharedStringXform;
                this.parser.parseOpen(node);
                return true;
            default:
                throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.model.values.push(this.parser.model);
                this.model.count++;
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case "sst":
                return false;
            default:
                throw new Error(`Unexpected xml node in parseClose: ${name}`);
        }
    }
}
module.exports = SharedStringsXform;


/***/ }),

/***/ 28426:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
//   <t xml:space="preserve"> is </t>
class TextXform extends BaseXform {
    get tag() {
        return "t";
    }
    render(xmlStream, model) {
        xmlStream.openNode("t");
        if (/^\s|\n|\s$/.test(model)) {
            xmlStream.addAttribute("xml:space", "preserve");
        }
        xmlStream.writeText(model);
        xmlStream.closeNode();
    }
    get model() {
        return this._text.join("").replace(/_x([0-9A-F]{4})_/g, ($0, $1)=>String.fromCharCode(parseInt($1, 16)));
    }
    parseOpen(node) {
        switch(node.name){
            case "t":
                this._text = [];
                return true;
            default:
                return false;
        }
    }
    parseText(text) {
        this._text.push(text);
    }
    parseClose() {
        return false;
    }
}
module.exports = TextXform;


/***/ }),

/***/ 15759:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Enums = __webpack_require__(48688);
const utils = __webpack_require__(90778);
const BaseXform = __webpack_require__(90884);
const validation = {
    horizontalValues: [
        "left",
        "center",
        "right",
        "fill",
        "centerContinuous",
        "distributed",
        "justify"
    ].reduce((p, v)=>{
        p[v] = true;
        return p;
    }, {}),
    horizontal (value) {
        return this.horizontalValues[value] ? value : undefined;
    },
    verticalValues: [
        "top",
        "middle",
        "bottom",
        "distributed",
        "justify"
    ].reduce((p, v)=>{
        p[v] = true;
        return p;
    }, {}),
    vertical (value) {
        if (value === "middle") return "center";
        return this.verticalValues[value] ? value : undefined;
    },
    wrapText (value) {
        return value ? true : undefined;
    },
    shrinkToFit (value) {
        return value ? true : undefined;
    },
    textRotation (value) {
        switch(value){
            case "vertical":
                return value;
            default:
                value = utils.validInt(value);
                return value >= -90 && value <= 90 ? value : undefined;
        }
    },
    indent (value) {
        value = utils.validInt(value);
        return Math.max(0, value);
    },
    readingOrder (value) {
        switch(value){
            case "ltr":
                return Enums.ReadingOrder.LeftToRight;
            case "rtl":
                return Enums.ReadingOrder.RightToLeft;
            default:
                return undefined;
        }
    }
};
const textRotationXform = {
    toXml (textRotation) {
        textRotation = validation.textRotation(textRotation);
        if (textRotation) {
            if (textRotation === "vertical") {
                return 255;
            }
            const tr = Math.round(textRotation);
            if (tr >= 0 && tr <= 90) {
                return tr;
            }
            if (tr < 0 && tr >= -90) {
                return 90 - tr;
            }
        }
        return undefined;
    },
    toModel (textRotation) {
        const tr = utils.validInt(textRotation);
        if (tr !== undefined) {
            if (tr === 255) {
                return "vertical";
            }
            if (tr >= 0 && tr <= 90) {
                return tr;
            }
            if (tr > 90 && tr <= 180) {
                return 90 - tr;
            }
        }
        return undefined;
    }
};
// Alignment encapsulates translation from style.alignment model to/from xlsx
class AlignmentXform extends BaseXform {
    get tag() {
        return "alignment";
    }
    render(xmlStream, model) {
        xmlStream.addRollback();
        xmlStream.openNode("alignment");
        let isValid = false;
        function add(name, value) {
            if (value) {
                xmlStream.addAttribute(name, value);
                isValid = true;
            }
        }
        add("horizontal", validation.horizontal(model.horizontal));
        add("vertical", validation.vertical(model.vertical));
        add("wrapText", validation.wrapText(model.wrapText) ? "1" : false);
        add("shrinkToFit", validation.shrinkToFit(model.shrinkToFit) ? "1" : false);
        add("indent", validation.indent(model.indent));
        add("textRotation", textRotationXform.toXml(model.textRotation));
        add("readingOrder", validation.readingOrder(model.readingOrder));
        xmlStream.closeNode();
        if (isValid) {
            xmlStream.commit();
        } else {
            xmlStream.rollback();
        }
    }
    parseOpen(node) {
        const model = {};
        let valid = false;
        function add(truthy, name, value) {
            if (truthy) {
                model[name] = value;
                valid = true;
            }
        }
        add(node.attributes.horizontal, "horizontal", node.attributes.horizontal);
        add(node.attributes.vertical, "vertical", node.attributes.vertical === "center" ? "middle" : node.attributes.vertical);
        add(node.attributes.wrapText, "wrapText", utils.parseBoolean(node.attributes.wrapText));
        add(node.attributes.shrinkToFit, "shrinkToFit", utils.parseBoolean(node.attributes.shrinkToFit));
        add(node.attributes.indent, "indent", parseInt(node.attributes.indent, 10));
        add(node.attributes.textRotation, "textRotation", textRotationXform.toModel(node.attributes.textRotation));
        add(node.attributes.readingOrder, "readingOrder", node.attributes.readingOrder === "2" ? "rtl" : "ltr");
        this.model = valid ? model : null;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = AlignmentXform;


/***/ }),

/***/ 93694:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable max-classes-per-file */ 
const BaseXform = __webpack_require__(90884);
const utils = __webpack_require__(90778);
const ColorXform = __webpack_require__(47287);
class EdgeXform extends BaseXform {
    constructor(name){
        super();
        this.name = name;
        this.map = {
            color: new ColorXform()
        };
    }
    get tag() {
        return this.name;
    }
    render(xmlStream, model, defaultColor) {
        const color = model && model.color || defaultColor || this.defaultColor;
        xmlStream.openNode(this.name);
        if (model && model.style) {
            xmlStream.addAttribute("style", model.style);
            if (color) {
                this.map.color.render(xmlStream, color);
            }
        }
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case this.name:
                {
                    const { style } = node.attributes;
                    if (style) {
                        this.model = {
                            style
                        };
                    } else {
                        this.model = undefined;
                    }
                    return true;
                }
            case "color":
                this.parser = this.map.color;
                this.parser.parseOpen(node);
                return true;
            default:
                return false;
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        if (name === this.name) {
            if (this.map.color.model) {
                if (!this.model) {
                    this.model = {};
                }
                this.model.color = this.map.color.model;
            }
        }
        return false;
    }
    validStyle(value) {
        return EdgeXform.validStyleValues[value];
    }
}
EdgeXform.validStyleValues = [
    "thin",
    "dashed",
    "dotted",
    "dashDot",
    "hair",
    "dashDotDot",
    "slantDashDot",
    "mediumDashed",
    "mediumDashDotDot",
    "mediumDashDot",
    "medium",
    "double",
    "thick"
].reduce((p, v)=>{
    p[v] = true;
    return p;
}, {});
// Border encapsulates translation from border model to/from xlsx
class BorderXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            top: new EdgeXform("top"),
            left: new EdgeXform("left"),
            bottom: new EdgeXform("bottom"),
            right: new EdgeXform("right"),
            diagonal: new EdgeXform("diagonal")
        };
    }
    render(xmlStream, model) {
        const { color } = model;
        xmlStream.openNode("border");
        if (model.diagonal && model.diagonal.style) {
            if (model.diagonal.up) {
                xmlStream.addAttribute("diagonalUp", "1");
            }
            if (model.diagonal.down) {
                xmlStream.addAttribute("diagonalDown", "1");
            }
        }
        function add(edgeModel, edgeXform) {
            if (edgeModel && !edgeModel.color && model.color) {
                // don't mess with incoming models
                edgeModel = {
                    ...edgeModel,
                    color: model.color
                };
            }
            edgeXform.render(xmlStream, edgeModel, color);
        }
        add(model.left, this.map.left);
        add(model.right, this.map.right);
        add(model.top, this.map.top);
        add(model.bottom, this.map.bottom);
        add(model.diagonal, this.map.diagonal);
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case "border":
                this.reset();
                this.diagonalUp = utils.parseBoolean(node.attributes.diagonalUp);
                this.diagonalDown = utils.parseBoolean(node.attributes.diagonalDown);
                return true;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                    return true;
                }
                return false;
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        if (name === "border") {
            const model = this.model = {};
            const add = function(key, edgeModel, extensions) {
                if (edgeModel) {
                    if (extensions) {
                        Object.assign(edgeModel, extensions);
                    }
                    model[key] = edgeModel;
                }
            };
            add("left", this.map.left.model);
            add("right", this.map.right.model);
            add("top", this.map.top.model);
            add("bottom", this.map.bottom.model);
            add("diagonal", this.map.diagonal.model, {
                up: this.diagonalUp,
                down: this.diagonalDown
            });
        }
        return false;
    }
}
module.exports = BorderXform;


/***/ }),

/***/ 47287:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
// Color encapsulates translation from color model to/from xlsx
class ColorXform extends BaseXform {
    constructor(name){
        super();
        // this.name controls the xm node name
        this.name = name || "color";
    }
    get tag() {
        return this.name;
    }
    render(xmlStream, model) {
        if (model) {
            xmlStream.openNode(this.name);
            if (model.argb) {
                xmlStream.addAttribute("rgb", model.argb);
            } else if (model.theme !== undefined) {
                xmlStream.addAttribute("theme", model.theme);
                if (model.tint !== undefined) {
                    xmlStream.addAttribute("tint", model.tint);
                }
            } else if (model.indexed !== undefined) {
                xmlStream.addAttribute("indexed", model.indexed);
            } else {
                xmlStream.addAttribute("auto", "1");
            }
            xmlStream.closeNode();
            return true;
        }
        return false;
    }
    parseOpen(node) {
        if (node.name === this.name) {
            if (node.attributes.rgb) {
                this.model = {
                    argb: node.attributes.rgb
                };
            } else if (node.attributes.theme) {
                this.model = {
                    theme: parseInt(node.attributes.theme, 10)
                };
                if (node.attributes.tint) {
                    this.model.tint = parseFloat(node.attributes.tint);
                }
            } else if (node.attributes.indexed) {
                this.model = {
                    indexed: parseInt(node.attributes.indexed, 10)
                };
            } else {
                this.model = undefined;
            }
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = ColorXform;


/***/ }),

/***/ 77277:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const AlignmentXform = __webpack_require__(15759);
const BorderXform = __webpack_require__(93694);
const FillXform = __webpack_require__(95030);
const FontXform = __webpack_require__(60812);
const NumFmtXform = __webpack_require__(62792);
const ProtectionXform = __webpack_require__(59680);
// <xf numFmtId="[numFmtId]" fontId="[fontId]" fillId="[fillId]" borderId="[xf.borderId]" xfId="[xfId]">
//   Optional <alignment>
//   Optional <protection>
// </xf>
// Style assists translation from style model to/from xlsx
class DxfXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            alignment: new AlignmentXform(),
            border: new BorderXform(),
            fill: new FillXform(),
            font: new FontXform(),
            numFmt: new NumFmtXform(),
            protection: new ProtectionXform()
        };
    }
    get tag() {
        return "dxf";
    }
    // how do we generate dxfid?
    render(xmlStream, model) {
        xmlStream.openNode(this.tag);
        if (model.font) {
            this.map.font.render(xmlStream, model.font);
        }
        if (model.numFmt && model.numFmtId) {
            const numFmtModel = {
                id: model.numFmtId,
                formatCode: model.numFmt
            };
            this.map.numFmt.render(xmlStream, numFmtModel);
        }
        if (model.fill) {
            this.map.fill.render(xmlStream, model.fill);
        }
        if (model.alignment) {
            this.map.alignment.render(xmlStream, model.alignment);
        }
        if (model.border) {
            this.map.border.render(xmlStream, model.border);
        }
        if (model.protection) {
            this.map.protection.render(xmlStream, model.protection);
        }
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case this.tag:
                // this node is often repeated. Need to reset children
                this.reset();
                return true;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                }
                return true;
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        if (name === this.tag) {
            this.model = {
                alignment: this.map.alignment.model,
                border: this.map.border.model,
                fill: this.map.fill.model,
                font: this.map.font.model,
                numFmt: this.map.numFmt.model,
                protection: this.map.protection.model
            };
            return false;
        }
        return true;
    }
}
module.exports = DxfXform;


/***/ }),

/***/ 95030:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable max-classes-per-file */ 
const BaseXform = __webpack_require__(90884);
const ColorXform = __webpack_require__(47287);
class StopXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            color: new ColorXform()
        };
    }
    get tag() {
        return "stop";
    }
    render(xmlStream, model) {
        xmlStream.openNode("stop");
        xmlStream.addAttribute("position", model.position);
        this.map.color.render(xmlStream, model.color);
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case "stop":
                this.model = {
                    position: parseFloat(node.attributes.position)
                };
                return true;
            case "color":
                this.parser = this.map.color;
                this.parser.parseOpen(node);
                return true;
            default:
                return false;
        }
    }
    parseText() {}
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.model.color = this.parser.model;
                this.parser = undefined;
            }
            return true;
        }
        return false;
    }
}
class PatternFillXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            fgColor: new ColorXform("fgColor"),
            bgColor: new ColorXform("bgColor")
        };
    }
    get name() {
        return "pattern";
    }
    get tag() {
        return "patternFill";
    }
    render(xmlStream, model) {
        xmlStream.openNode("patternFill");
        xmlStream.addAttribute("patternType", model.pattern);
        if (model.fgColor) {
            this.map.fgColor.render(xmlStream, model.fgColor);
        }
        if (model.bgColor) {
            this.map.bgColor.render(xmlStream, model.bgColor);
        }
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case "patternFill":
                this.model = {
                    type: "pattern",
                    pattern: node.attributes.patternType
                };
                return true;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                    return true;
                }
                return false;
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                if (this.parser.model) {
                    this.model[name] = this.parser.model;
                }
                this.parser = undefined;
            }
            return true;
        }
        return false;
    }
}
class GradientFillXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            stop: new StopXform()
        };
    // if (model) {
    //   this.gradient = model.gradient;
    //   if (model.center) {
    //     this.center = model.center;
    //   }
    //   if (model.degree !== undefined) {
    //     this.degree = model.degree;
    //   }
    //   this.stops = model.stops.map(function(stop) { return new StopXform(stop); });
    // } else {
    //   this.stops = [];
    // }
    }
    get name() {
        return "gradient";
    }
    get tag() {
        return "gradientFill";
    }
    render(xmlStream, model) {
        xmlStream.openNode("gradientFill");
        switch(model.gradient){
            case "angle":
                xmlStream.addAttribute("degree", model.degree);
                break;
            case "path":
                xmlStream.addAttribute("type", "path");
                if (model.center.left) {
                    xmlStream.addAttribute("left", model.center.left);
                    if (model.center.right === undefined) {
                        xmlStream.addAttribute("right", model.center.left);
                    }
                }
                if (model.center.right) {
                    xmlStream.addAttribute("right", model.center.right);
                }
                if (model.center.top) {
                    xmlStream.addAttribute("top", model.center.top);
                    if (model.center.bottom === undefined) {
                        xmlStream.addAttribute("bottom", model.center.top);
                    }
                }
                if (model.center.bottom) {
                    xmlStream.addAttribute("bottom", model.center.bottom);
                }
                break;
            default:
                break;
        }
        const stopXform = this.map.stop;
        model.stops.forEach((stopModel)=>{
            stopXform.render(xmlStream, stopModel);
        });
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case "gradientFill":
                {
                    const model = this.model = {
                        stops: []
                    };
                    if (node.attributes.degree) {
                        model.gradient = "angle";
                        model.degree = parseInt(node.attributes.degree, 10);
                    } else if (node.attributes.type === "path") {
                        model.gradient = "path";
                        model.center = {
                            left: node.attributes.left ? parseFloat(node.attributes.left) : 0,
                            top: node.attributes.top ? parseFloat(node.attributes.top) : 0
                        };
                        if (node.attributes.right !== node.attributes.left) {
                            model.center.right = node.attributes.right ? parseFloat(node.attributes.right) : 0;
                        }
                        if (node.attributes.bottom !== node.attributes.top) {
                            model.center.bottom = node.attributes.bottom ? parseFloat(node.attributes.bottom) : 0;
                        }
                    }
                    return true;
                }
            case "stop":
                this.parser = this.map.stop;
                this.parser.parseOpen(node);
                return true;
            default:
                return false;
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.model.stops.push(this.parser.model);
                this.parser = undefined;
            }
            return true;
        }
        return false;
    }
}
// Fill encapsulates translation from fill model to/from xlsx
class FillXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            patternFill: new PatternFillXform(),
            gradientFill: new GradientFillXform()
        };
    }
    get tag() {
        return "fill";
    }
    render(xmlStream, model) {
        xmlStream.addRollback();
        xmlStream.openNode("fill");
        switch(model.type){
            case "pattern":
                this.map.patternFill.render(xmlStream, model);
                break;
            case "gradient":
                this.map.gradientFill.render(xmlStream, model);
                break;
            default:
                xmlStream.rollback();
                return;
        }
        xmlStream.closeNode();
        xmlStream.commit();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case "fill":
                this.model = {};
                return true;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                    return true;
                }
                return false;
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.model = this.parser.model;
                this.model.type = this.parser.name;
                this.parser = undefined;
            }
            return true;
        }
        return false;
    }
    validStyle(value) {
        return FillXform.validPatternValues[value];
    }
}
FillXform.validPatternValues = [
    "none",
    "solid",
    "darkVertical",
    "darkGray",
    "mediumGray",
    "lightGray",
    "gray125",
    "gray0625",
    "darkHorizontal",
    "darkVertical",
    "darkDown",
    "darkUp",
    "darkGrid",
    "darkTrellis",
    "lightHorizontal",
    "lightVertical",
    "lightDown",
    "lightUp",
    "lightGrid",
    "lightTrellis",
    "lightGrid"
].reduce((p, v)=>{
    p[v] = true;
    return p;
}, {});
FillXform.StopXform = StopXform;
FillXform.PatternFillXform = PatternFillXform;
FillXform.GradientFillXform = GradientFillXform;
module.exports = FillXform;


/***/ }),

/***/ 60812:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ColorXform = __webpack_require__(47287);
const BooleanXform = __webpack_require__(90990);
const IntegerXform = __webpack_require__(51377);
const StringXform = __webpack_require__(15510);
const UnderlineXform = __webpack_require__(75245);
const _ = __webpack_require__(96910);
const BaseXform = __webpack_require__(90884);
// Font encapsulates translation from font model to xlsx
class FontXform extends BaseXform {
    constructor(options){
        super();
        this.options = options || FontXform.OPTIONS;
        this.map = {
            b: {
                prop: "bold",
                xform: new BooleanXform({
                    tag: "b",
                    attr: "val"
                })
            },
            i: {
                prop: "italic",
                xform: new BooleanXform({
                    tag: "i",
                    attr: "val"
                })
            },
            u: {
                prop: "underline",
                xform: new UnderlineXform()
            },
            charset: {
                prop: "charset",
                xform: new IntegerXform({
                    tag: "charset",
                    attr: "val"
                })
            },
            color: {
                prop: "color",
                xform: new ColorXform()
            },
            condense: {
                prop: "condense",
                xform: new BooleanXform({
                    tag: "condense",
                    attr: "val"
                })
            },
            extend: {
                prop: "extend",
                xform: new BooleanXform({
                    tag: "extend",
                    attr: "val"
                })
            },
            family: {
                prop: "family",
                xform: new IntegerXform({
                    tag: "family",
                    attr: "val"
                })
            },
            outline: {
                prop: "outline",
                xform: new BooleanXform({
                    tag: "outline",
                    attr: "val"
                })
            },
            vertAlign: {
                prop: "vertAlign",
                xform: new StringXform({
                    tag: "vertAlign",
                    attr: "val"
                })
            },
            scheme: {
                prop: "scheme",
                xform: new StringXform({
                    tag: "scheme",
                    attr: "val"
                })
            },
            shadow: {
                prop: "shadow",
                xform: new BooleanXform({
                    tag: "shadow",
                    attr: "val"
                })
            },
            strike: {
                prop: "strike",
                xform: new BooleanXform({
                    tag: "strike",
                    attr: "val"
                })
            },
            sz: {
                prop: "size",
                xform: new IntegerXform({
                    tag: "sz",
                    attr: "val"
                })
            }
        };
        this.map[this.options.fontNameTag] = {
            prop: "name",
            xform: new StringXform({
                tag: this.options.fontNameTag,
                attr: "val"
            })
        };
    }
    get tag() {
        return this.options.tagName;
    }
    render(xmlStream, model) {
        const { map } = this;
        xmlStream.openNode(this.options.tagName);
        _.each(this.map, (defn, tag)=>{
            map[tag].xform.render(xmlStream, model[defn.prop]);
        });
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        if (this.map[node.name]) {
            this.parser = this.map[node.name].xform;
            return this.parser.parseOpen(node);
        }
        switch(node.name){
            case this.options.tagName:
                this.model = {};
                return true;
            default:
                return false;
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser && !this.parser.parseClose(name)) {
            const item = this.map[name];
            if (this.parser.model) {
                this.model[item.prop] = this.parser.model;
            }
            this.parser = undefined;
            return true;
        }
        switch(name){
            case this.options.tagName:
                return false;
            default:
                return true;
        }
    }
}
FontXform.OPTIONS = {
    tagName: "font",
    fontNameTag: "name"
};
module.exports = FontXform;


/***/ }),

/***/ 62792:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const _ = __webpack_require__(96910);
const defaultNumFormats = __webpack_require__(9420);
const BaseXform = __webpack_require__(90884);
function hashDefaultFormats() {
    const hash = {};
    _.each(defaultNumFormats, (dnf, id)=>{
        if (dnf.f) {
            hash[dnf.f] = parseInt(id, 10);
        }
    // at some point, add the other cultures here...
    });
    return hash;
}
const defaultFmtHash = hashDefaultFormats();
// NumFmt encapsulates translation between number format and xlsx
class NumFmtXform extends BaseXform {
    constructor(id, formatCode){
        super();
        this.id = id;
        this.formatCode = formatCode;
    }
    get tag() {
        return "numFmt";
    }
    render(xmlStream, model) {
        xmlStream.leafNode("numFmt", {
            numFmtId: model.id,
            formatCode: model.formatCode
        });
    }
    parseOpen(node) {
        switch(node.name){
            case "numFmt":
                this.model = {
                    id: parseInt(node.attributes.numFmtId, 10),
                    formatCode: node.attributes.formatCode.replace(/[\\](.)/g, "$1")
                };
                return true;
            default:
                return false;
        }
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
NumFmtXform.getDefaultFmtId = function getDefaultFmtId(formatCode) {
    return defaultFmtHash[formatCode];
};
NumFmtXform.getDefaultFmtCode = function getDefaultFmtCode(numFmtId) {
    return defaultNumFormats[numFmtId] && defaultNumFormats[numFmtId].f;
};
module.exports = NumFmtXform;


/***/ }),

/***/ 59680:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const validation = {
    boolean (value, dflt) {
        if (value === undefined) {
            return dflt;
        }
        return value;
    }
};
// Protection encapsulates translation from style.protection model to/from xlsx
class ProtectionXform extends BaseXform {
    get tag() {
        return "protection";
    }
    render(xmlStream, model) {
        xmlStream.addRollback();
        xmlStream.openNode("protection");
        let isValid = false;
        function add(name, value) {
            if (value !== undefined) {
                xmlStream.addAttribute(name, value);
                isValid = true;
            }
        }
        add("locked", validation.boolean(model.locked, true) ? undefined : "0");
        add("hidden", validation.boolean(model.hidden, false) ? "1" : undefined);
        xmlStream.closeNode();
        if (isValid) {
            xmlStream.commit();
        } else {
            xmlStream.rollback();
        }
    }
    parseOpen(node) {
        const model = {
            locked: !(node.attributes.locked === "0"),
            hidden: node.attributes.hidden === "1"
        };
        // only want to record models that differ from defaults
        const isSignificant = !model.locked || model.hidden;
        this.model = isSignificant ? model : null;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = ProtectionXform;


/***/ }),

/***/ 2965:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const AlignmentXform = __webpack_require__(15759);
const ProtectionXform = __webpack_require__(59680);
// <xf numFmtId="[numFmtId]" fontId="[fontId]" fillId="[fillId]" borderId="[xf.borderId]" xfId="[xfId]">
//   Optional <alignment>
//   Optional <protection>
// </xf>
// Style assists translation from style model to/from xlsx
class StyleXform extends BaseXform {
    constructor(options){
        super();
        this.xfId = !!(options && options.xfId);
        this.map = {
            alignment: new AlignmentXform(),
            protection: new ProtectionXform()
        };
    }
    get tag() {
        return "xf";
    }
    render(xmlStream, model) {
        xmlStream.openNode("xf", {
            numFmtId: model.numFmtId || 0,
            fontId: model.fontId || 0,
            fillId: model.fillId || 0,
            borderId: model.borderId || 0
        });
        if (this.xfId) {
            xmlStream.addAttribute("xfId", model.xfId || 0);
        }
        if (model.numFmtId) {
            xmlStream.addAttribute("applyNumberFormat", "1");
        }
        if (model.fontId) {
            xmlStream.addAttribute("applyFont", "1");
        }
        if (model.fillId) {
            xmlStream.addAttribute("applyFill", "1");
        }
        if (model.borderId) {
            xmlStream.addAttribute("applyBorder", "1");
        }
        if (model.alignment) {
            xmlStream.addAttribute("applyAlignment", "1");
        }
        if (model.protection) {
            xmlStream.addAttribute("applyProtection", "1");
        }
        /**
     * Rendering tags causes close of XML stream.
     * Therefore adding attributes must be done before rendering tags.
     */ if (model.alignment) {
            this.map.alignment.render(xmlStream, model.alignment);
        }
        if (model.protection) {
            this.map.protection.render(xmlStream, model.protection);
        }
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        // used during sax parsing of xml to build font object
        switch(node.name){
            case "xf":
                this.model = {
                    numFmtId: parseInt(node.attributes.numFmtId, 10),
                    fontId: parseInt(node.attributes.fontId, 10),
                    fillId: parseInt(node.attributes.fillId, 10),
                    borderId: parseInt(node.attributes.borderId, 10)
                };
                if (this.xfId) {
                    this.model.xfId = parseInt(node.attributes.xfId, 10);
                }
                return true;
            case "alignment":
                this.parser = this.map.alignment;
                this.parser.parseOpen(node);
                return true;
            case "protection":
                this.parser = this.map.protection;
                this.parser.parseOpen(node);
                return true;
            default:
                return false;
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                if (this.map.protection === this.parser) {
                    this.model.protection = this.parser.model;
                } else {
                    this.model.alignment = this.parser.model;
                }
                this.parser = undefined;
            }
            return true;
        }
        return name !== "xf";
    }
}
module.exports = StyleXform;


/***/ }),

/***/ 20429:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint-disable max-classes-per-file */ 
const Enums = __webpack_require__(48688);
const XmlStream = __webpack_require__(18749);
const BaseXform = __webpack_require__(90884);
const StaticXform = __webpack_require__(76949);
const ListXform = __webpack_require__(34397);
const FontXform = __webpack_require__(60812);
const FillXform = __webpack_require__(95030);
const BorderXform = __webpack_require__(93694);
const NumFmtXform = __webpack_require__(62792);
const StyleXform = __webpack_require__(2965);
const DxfXform = __webpack_require__(77277);
// custom numfmt ids start here
const NUMFMT_BASE = 164;
// =============================================================================
// StylesXform is used to generate and parse the styles.xml file
// it manages the collections of fonts, number formats, alignments, etc
class StylesXform extends BaseXform {
    constructor(initialise){
        super();
        this.map = {
            numFmts: new ListXform({
                tag: "numFmts",
                count: true,
                childXform: new NumFmtXform()
            }),
            fonts: new ListXform({
                tag: "fonts",
                count: true,
                childXform: new FontXform(),
                $: {
                    "x14ac:knownFonts": 1
                }
            }),
            fills: new ListXform({
                tag: "fills",
                count: true,
                childXform: new FillXform()
            }),
            borders: new ListXform({
                tag: "borders",
                count: true,
                childXform: new BorderXform()
            }),
            cellStyleXfs: new ListXform({
                tag: "cellStyleXfs",
                count: true,
                childXform: new StyleXform()
            }),
            cellXfs: new ListXform({
                tag: "cellXfs",
                count: true,
                childXform: new StyleXform({
                    xfId: true
                })
            }),
            dxfs: new ListXform({
                tag: "dxfs",
                always: true,
                count: true,
                childXform: new DxfXform()
            }),
            // for style manager
            numFmt: new NumFmtXform(),
            font: new FontXform(),
            fill: new FillXform(),
            border: new BorderXform(),
            style: new StyleXform({
                xfId: true
            }),
            cellStyles: StylesXform.STATIC_XFORMS.cellStyles,
            tableStyles: StylesXform.STATIC_XFORMS.tableStyles,
            extLst: StylesXform.STATIC_XFORMS.extLst
        };
        if (initialise) {
            // StylesXform also acts as style manager and is used to build up styles-model during worksheet processing
            this.init();
        }
    }
    initIndex() {
        this.index = {
            style: {},
            numFmt: {},
            numFmtNextId: 164,
            font: {},
            border: {},
            fill: {}
        };
    }
    init() {
        // Prepare for Style Manager role
        this.model = {
            styles: [],
            numFmts: [],
            fonts: [],
            borders: [],
            fills: [],
            dxfs: []
        };
        this.initIndex();
        // default (zero) border
        this._addBorder({});
        // add default (all zero) style
        this._addStyle({
            numFmtId: 0,
            fontId: 0,
            fillId: 0,
            borderId: 0,
            xfId: 0
        });
        // add default fills
        this._addFill({
            type: "pattern",
            pattern: "none"
        });
        this._addFill({
            type: "pattern",
            pattern: "gray125"
        });
        this.weakMap = new WeakMap();
    }
    render(xmlStream, model) {
        model = model || this.model;
        //
        //   <fonts count="2" x14ac:knownFonts="1">
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("styleSheet", StylesXform.STYLESHEET_ATTRIBUTES);
        if (this.index) {
            // model has been built by style manager role (contains xml)
            if (model.numFmts && model.numFmts.length) {
                xmlStream.openNode("numFmts", {
                    count: model.numFmts.length
                });
                model.numFmts.forEach((numFmtXml)=>{
                    xmlStream.writeXml(numFmtXml);
                });
                xmlStream.closeNode();
            }
            if (!model.fonts.length) {
                // default (zero) font
                this._addFont({
                    size: 11,
                    color: {
                        theme: 1
                    },
                    name: "Calibri",
                    family: 2,
                    scheme: "minor"
                });
            }
            xmlStream.openNode("fonts", {
                count: model.fonts.length,
                "x14ac:knownFonts": 1
            });
            model.fonts.forEach((fontXml)=>{
                xmlStream.writeXml(fontXml);
            });
            xmlStream.closeNode();
            xmlStream.openNode("fills", {
                count: model.fills.length
            });
            model.fills.forEach((fillXml)=>{
                xmlStream.writeXml(fillXml);
            });
            xmlStream.closeNode();
            xmlStream.openNode("borders", {
                count: model.borders.length
            });
            model.borders.forEach((borderXml)=>{
                xmlStream.writeXml(borderXml);
            });
            xmlStream.closeNode();
            this.map.cellStyleXfs.render(xmlStream, [
                {
                    numFmtId: 0,
                    fontId: 0,
                    fillId: 0,
                    borderId: 0,
                    xfId: 0
                }
            ]);
            xmlStream.openNode("cellXfs", {
                count: model.styles.length
            });
            model.styles.forEach((styleXml)=>{
                xmlStream.writeXml(styleXml);
            });
            xmlStream.closeNode();
        } else {
            // model is plain JSON and needs to be xformed
            this.map.numFmts.render(xmlStream, model.numFmts);
            this.map.fonts.render(xmlStream, model.fonts);
            this.map.fills.render(xmlStream, model.fills);
            this.map.borders.render(xmlStream, model.borders);
            this.map.cellStyleXfs.render(xmlStream, [
                {
                    numFmtId: 0,
                    fontId: 0,
                    fillId: 0,
                    borderId: 0,
                    xfId: 0
                }
            ]);
            this.map.cellXfs.render(xmlStream, model.styles);
        }
        StylesXform.STATIC_XFORMS.cellStyles.render(xmlStream);
        this.map.dxfs.render(xmlStream, model.dxfs);
        StylesXform.STATIC_XFORMS.tableStyles.render(xmlStream);
        StylesXform.STATIC_XFORMS.extLst.render(xmlStream);
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case "styleSheet":
                this.initIndex();
                return true;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                }
                return true;
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case "styleSheet":
                {
                    this.model = {};
                    const add = (propName, xform)=>{
                        if (xform.model && xform.model.length) {
                            this.model[propName] = xform.model;
                        }
                    };
                    add("numFmts", this.map.numFmts);
                    add("fonts", this.map.fonts);
                    add("fills", this.map.fills);
                    add("borders", this.map.borders);
                    add("styles", this.map.cellXfs);
                    add("dxfs", this.map.dxfs);
                    // index numFmts
                    this.index = {
                        model: [],
                        numFmt: []
                    };
                    if (this.model.numFmts) {
                        const numFmtIndex = this.index.numFmt;
                        this.model.numFmts.forEach((numFmt)=>{
                            numFmtIndex[numFmt.id] = numFmt.formatCode;
                        });
                    }
                    return false;
                }
            default:
                // not quite sure how we get here!
                return true;
        }
    }
    // add a cell's style model to the collection
    // each style property is processed and cross-referenced, etc.
    // the styleId is returned. Note: cellType is used when numFmt not defined
    addStyleModel(model, cellType) {
        if (!model) {
            return 0;
        }
        // if we have no default font, add it here now
        if (!this.model.fonts.length) {
            // default (zero) font
            this._addFont({
                size: 11,
                color: {
                    theme: 1
                },
                name: "Calibri",
                family: 2,
                scheme: "minor"
            });
        }
        // if we have seen this style object before, assume it has the same styleId
        if (this.weakMap && this.weakMap.has(model)) {
            return this.weakMap.get(model);
        }
        const style = {};
        cellType = cellType || Enums.ValueType.Number;
        if (model.numFmt) {
            style.numFmtId = this._addNumFmtStr(model.numFmt);
        } else {
            switch(cellType){
                case Enums.ValueType.Number:
                    style.numFmtId = this._addNumFmtStr("General");
                    break;
                case Enums.ValueType.Date:
                    style.numFmtId = this._addNumFmtStr("mm-dd-yy");
                    break;
                default:
                    break;
            }
        }
        if (model.font) {
            style.fontId = this._addFont(model.font);
        }
        if (model.border) {
            style.borderId = this._addBorder(model.border);
        }
        if (model.fill) {
            style.fillId = this._addFill(model.fill);
        }
        if (model.alignment) {
            style.alignment = model.alignment;
        }
        if (model.protection) {
            style.protection = model.protection;
        }
        const styleId = this._addStyle(style);
        if (this.weakMap) {
            this.weakMap.set(model, styleId);
        }
        return styleId;
    }
    // given a styleId (i.e. s="n"), get the cell's style model
    // objects are shared where possible.
    getStyleModel(id) {
        // if the style doesn't exist return null
        const style = this.model.styles[id];
        if (!style) return null;
        // have we built this model before?
        let model = this.index.model[id];
        if (model) return model;
        // build a new model
        model = this.index.model[id] = {};
        // -------------------------------------------------------
        // number format
        if (style.numFmtId) {
            const numFmt = this.index.numFmt[style.numFmtId] || NumFmtXform.getDefaultFmtCode(style.numFmtId);
            if (numFmt) {
                model.numFmt = numFmt;
            }
        }
        function addStyle(name, group, styleId) {
            if (styleId || styleId === 0) {
                const part = group[styleId];
                if (part) {
                    model[name] = part;
                }
            }
        }
        addStyle("font", this.model.fonts, style.fontId);
        addStyle("border", this.model.borders, style.borderId);
        addStyle("fill", this.model.fills, style.fillId);
        // -------------------------------------------------------
        // alignment
        if (style.alignment) {
            model.alignment = style.alignment;
        }
        // -------------------------------------------------------
        // protection
        if (style.protection) {
            model.protection = style.protection;
        }
        return model;
    }
    addDxfStyle(style) {
        if (style.numFmt) {
            // register numFmtId to use it during dxf-xform rendering
            style.numFmtId = this._addNumFmtStr(style.numFmt);
        }
        this.model.dxfs.push(style);
        return this.model.dxfs.length - 1;
    }
    getDxfStyle(id) {
        return this.model.dxfs[id];
    }
    // =========================================================================
    // Private Interface
    _addStyle(style) {
        const xml = this.map.style.toXml(style);
        let index = this.index.style[xml];
        if (index === undefined) {
            index = this.index.style[xml] = this.model.styles.length;
            this.model.styles.push(xml);
        }
        return index;
    }
    // =========================================================================
    // Number Formats
    _addNumFmtStr(formatCode) {
        // check if default format
        let index = NumFmtXform.getDefaultFmtId(formatCode);
        if (index !== undefined) return index;
        // check if already in
        index = this.index.numFmt[formatCode];
        if (index !== undefined) return index;
        index = this.index.numFmt[formatCode] = NUMFMT_BASE + this.model.numFmts.length;
        const xml = this.map.numFmt.toXml({
            id: index,
            formatCode
        });
        this.model.numFmts.push(xml);
        return index;
    }
    // =========================================================================
    // Fonts
    _addFont(font) {
        const xml = this.map.font.toXml(font);
        let index = this.index.font[xml];
        if (index === undefined) {
            index = this.index.font[xml] = this.model.fonts.length;
            this.model.fonts.push(xml);
        }
        return index;
    }
    // =========================================================================
    // Borders
    _addBorder(border) {
        const xml = this.map.border.toXml(border);
        let index = this.index.border[xml];
        if (index === undefined) {
            index = this.index.border[xml] = this.model.borders.length;
            this.model.borders.push(xml);
        }
        return index;
    }
    // =========================================================================
    // Fills
    _addFill(fill) {
        const xml = this.map.fill.toXml(fill);
        let index = this.index.fill[xml];
        if (index === undefined) {
            index = this.index.fill[xml] = this.model.fills.length;
            this.model.fills.push(xml);
        }
        return index;
    }
}
StylesXform.STYLESHEET_ATTRIBUTES = {
    xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
    "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
    "mc:Ignorable": "x14ac x16r2",
    "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac",
    "xmlns:x16r2": "http://schemas.microsoft.com/office/spreadsheetml/2015/02/main"
};
StylesXform.STATIC_XFORMS = {
    cellStyles: new StaticXform({
        tag: "cellStyles",
        $: {
            count: 1
        },
        c: [
            {
                tag: "cellStyle",
                $: {
                    name: "Normal",
                    xfId: 0,
                    builtinId: 0
                }
            }
        ]
    }),
    dxfs: new StaticXform({
        tag: "dxfs",
        $: {
            count: 0
        }
    }),
    tableStyles: new StaticXform({
        tag: "tableStyles",
        $: {
            count: 0,
            defaultTableStyle: "TableStyleMedium2",
            defaultPivotStyle: "PivotStyleLight16"
        }
    }),
    extLst: new StaticXform({
        tag: "extLst",
        c: [
            {
                tag: "ext",
                $: {
                    uri: "{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}",
                    "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"
                },
                c: [
                    {
                        tag: "x14:slicerStyles",
                        $: {
                            defaultSlicerStyle: "SlicerStyleLight1"
                        }
                    }
                ]
            },
            {
                tag: "ext",
                $: {
                    uri: "{9260A510-F301-46a8-8635-F512D64BE5F5}",
                    "xmlns:x15": "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"
                },
                c: [
                    {
                        tag: "x15:timelineStyles",
                        $: {
                            defaultTimelineStyle: "TimeSlicerStyleLight1"
                        }
                    }
                ]
            }
        ]
    })
};
// the stylemanager mock acts like StyleManager except that it always returns 0 or {}
class StylesXformMock extends StylesXform {
    constructor(){
        super();
        this.model = {
            styles: [
                {
                    numFmtId: 0,
                    fontId: 0,
                    fillId: 0,
                    borderId: 0,
                    xfId: 0
                }
            ],
            numFmts: [],
            fonts: [
                {
                    size: 11,
                    color: {
                        theme: 1
                    },
                    name: "Calibri",
                    family: 2,
                    scheme: "minor"
                }
            ],
            borders: [
                {}
            ],
            fills: [
                {
                    type: "pattern",
                    pattern: "none"
                },
                {
                    type: "pattern",
                    pattern: "gray125"
                }
            ]
        };
    }
    // =========================================================================
    // Style Manager Interface
    // override normal behaviour - consume and dispose
    parseStream(stream) {
        stream.autodrain();
        return Promise.resolve();
    }
    // add a cell's style model to the collection
    // each style property is processed and cross-referenced, etc.
    // the styleId is returned. Note: cellType is used when numFmt not defined
    addStyleModel(model, cellType) {
        switch(cellType){
            case Enums.ValueType.Date:
                return this.dateStyleId;
            default:
                return 0;
        }
    }
    get dateStyleId() {
        if (!this._dateStyleId) {
            const dateStyle = {
                numFmtId: NumFmtXform.getDefaultFmtId("mm-dd-yy")
            };
            this._dateStyleId = this.model.styles.length;
            this.model.styles.push(dateStyle);
        }
        return this._dateStyleId;
    }
    // given a styleId (i.e. s="n"), get the cell's style model
    // objects are shared where possible.
    getStyleModel() {
        return {};
    }
}
StylesXform.Mock = StylesXformMock;
module.exports = StylesXform;


/***/ }),

/***/ 75245:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class UnderlineXform extends BaseXform {
    constructor(model){
        super();
        this.model = model;
    }
    get tag() {
        return "u";
    }
    render(xmlStream, model) {
        model = model || this.model;
        if (model === true) {
            xmlStream.leafNode("u");
        } else {
            const attr = UnderlineXform.Attributes[model];
            if (attr) {
                xmlStream.leafNode("u", attr);
            }
        }
    }
    parseOpen(node) {
        if (node.name === "u") {
            this.model = node.attributes.val || true;
        }
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
UnderlineXform.Attributes = {
    single: {},
    double: {
        val: "double"
    },
    singleAccounting: {
        val: "singleAccounting"
    },
    doubleAccounting: {
        val: "doubleAccounting"
    }
};
module.exports = UnderlineXform;


/***/ }),

/***/ 55061:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const FilterColumnXform = __webpack_require__(51236);
class AutoFilterXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            filterColumn: new FilterColumnXform()
        };
    }
    get tag() {
        return "autoFilter";
    }
    prepare(model) {
        model.columns.forEach((column, index)=>{
            this.map.filterColumn.prepare(column, {
                index
            });
        });
    }
    render(xmlStream, model) {
        xmlStream.openNode(this.tag, {
            ref: model.autoFilterRef
        });
        model.columns.forEach((column)=>{
            this.map.filterColumn.render(xmlStream, column);
        });
        xmlStream.closeNode();
        return true;
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        switch(node.name){
            case this.tag:
                this.model = {
                    autoFilterRef: node.attributes.ref,
                    columns: []
                };
                return true;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parseOpen(node);
                    return true;
                }
                throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);
        }
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.model.columns.push(this.parser.model);
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case this.tag:
                return false;
            default:
                throw new Error(`Unexpected xml node in parseClose: ${name}`);
        }
    }
}
module.exports = AutoFilterXform;


/***/ }),

/***/ 39119:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class CustomFilterXform extends BaseXform {
    get tag() {
        return "customFilter";
    }
    render(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
            val: model.val,
            operator: model.operator
        });
    }
    parseOpen(node) {
        if (node.name === this.tag) {
            this.model = {
                val: node.attributes.val,
                operator: node.attributes.operator
            };
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = CustomFilterXform;


/***/ }),

/***/ 51236:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
const ListXform = __webpack_require__(34397);
const CustomFilterXform = __webpack_require__(39119);
const FilterXform = __webpack_require__(9598);
class FilterColumnXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            customFilters: new ListXform({
                tag: "customFilters",
                count: false,
                empty: true,
                childXform: new CustomFilterXform()
            }),
            filters: new ListXform({
                tag: "filters",
                count: false,
                empty: true,
                childXform: new FilterXform()
            })
        };
    }
    get tag() {
        return "filterColumn";
    }
    prepare(model, options) {
        model.colId = options.index.toString();
    }
    render(xmlStream, model) {
        if (model.customFilters) {
            xmlStream.openNode(this.tag, {
                colId: model.colId,
                hiddenButton: model.filterButton ? "0" : "1"
            });
            this.map.customFilters.render(xmlStream, model.customFilters);
            xmlStream.closeNode();
            return true;
        }
        xmlStream.leafNode(this.tag, {
            colId: model.colId,
            hiddenButton: model.filterButton ? "0" : "1"
        });
        return true;
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        const { attributes } = node;
        switch(node.name){
            case this.tag:
                this.model = {
                    filterButton: attributes.hiddenButton === "0"
                };
                return true;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parseOpen(node);
                    return true;
                }
                throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node)}`);
        }
    }
    parseText() {}
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case this.tag:
                this.model.customFilters = this.map.customFilters.model;
                return false;
            default:
                // could be some unrecognised tags
                return true;
        }
    }
}
module.exports = FilterColumnXform;


/***/ }),

/***/ 9598:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class FilterXform extends BaseXform {
    get tag() {
        return "filter";
    }
    render(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
            val: model.val
        });
    }
    parseOpen(node) {
        if (node.name === this.tag) {
            this.model = {
                val: node.attributes.val
            };
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = FilterXform;


/***/ }),

/***/ 73617:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class TableColumnXform extends BaseXform {
    get tag() {
        return "tableColumn";
    }
    prepare(model, options) {
        model.id = options.index + 1;
    }
    render(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
            id: model.id.toString(),
            name: model.name,
            totalsRowLabel: model.totalsRowLabel,
            totalsRowFunction: model.totalsRowFunction,
            dxfId: model.dxfId
        });
        return true;
    }
    parseOpen(node) {
        if (node.name === this.tag) {
            const { attributes } = node;
            this.model = {
                name: attributes.name,
                totalsRowLabel: attributes.totalsRowLabel,
                totalsRowFunction: attributes.totalsRowFunction,
                dxfId: attributes.dxfId
            };
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = TableColumnXform;


/***/ }),

/***/ 79354:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const BaseXform = __webpack_require__(90884);
class TableStyleInfoXform extends BaseXform {
    get tag() {
        return "tableStyleInfo";
    }
    render(xmlStream, model) {
        xmlStream.leafNode(this.tag, {
            name: model.theme ? model.theme : undefined,
            showFirstColumn: model.showFirstColumn ? "1" : "0",
            showLastColumn: model.showLastColumn ? "1" : "0",
            showRowStripes: model.showRowStripes ? "1" : "0",
            showColumnStripes: model.showColumnStripes ? "1" : "0"
        });
        return true;
    }
    parseOpen(node) {
        if (node.name === this.tag) {
            const { attributes } = node;
            this.model = {
                theme: attributes.name ? attributes.name : null,
                showFirstColumn: attributes.showFirstColumn === "1",
                showLastColumn: attributes.showLastColumn === "1",
                showRowStripes: attributes.showRowStripes === "1",
                showColumnStripes: attributes.showColumnStripes === "1"
            };
            return true;
        }
        return false;
    }
    parseText() {}
    parseClose() {
        return false;
    }
}
module.exports = TableStyleInfoXform;


/***/ }),

/***/ 14234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const XmlStream = __webpack_require__(18749);
const BaseXform = __webpack_require__(90884);
const ListXform = __webpack_require__(34397);
const AutoFilterXform = __webpack_require__(55061);
const TableColumnXform = __webpack_require__(73617);
const TableStyleInfoXform = __webpack_require__(79354);
class TableXform extends BaseXform {
    constructor(){
        super();
        this.map = {
            autoFilter: new AutoFilterXform(),
            tableColumns: new ListXform({
                tag: "tableColumns",
                count: true,
                empty: true,
                childXform: new TableColumnXform()
            }),
            tableStyleInfo: new TableStyleInfoXform()
        };
    }
    prepare(model, options) {
        this.map.autoFilter.prepare(model);
        this.map.tableColumns.prepare(model.columns, options);
    }
    get tag() {
        return "table";
    }
    render(xmlStream, model) {
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode(this.tag, {
            ...TableXform.TABLE_ATTRIBUTES,
            id: model.id,
            name: model.name,
            displayName: model.displayName || model.name,
            ref: model.tableRef,
            totalsRowCount: model.totalsRow ? "1" : undefined,
            totalsRowShown: model.totalsRow ? undefined : "1",
            headerRowCount: model.headerRow ? "1" : "0"
        });
        this.map.autoFilter.render(xmlStream, model);
        this.map.tableColumns.render(xmlStream, model.columns);
        this.map.tableStyleInfo.render(xmlStream, model.style);
        xmlStream.closeNode();
    }
    parseOpen(node) {
        if (this.parser) {
            this.parser.parseOpen(node);
            return true;
        }
        const { name, attributes } = node;
        switch(name){
            case this.tag:
                this.reset();
                this.model = {
                    name: attributes.name,
                    displayName: attributes.displayName || attributes.name,
                    tableRef: attributes.ref,
                    totalsRow: attributes.totalsRowCount === "1",
                    headerRow: attributes.headerRowCount === "1"
                };
                break;
            default:
                this.parser = this.map[node.name];
                if (this.parser) {
                    this.parser.parseOpen(node);
                }
                break;
        }
        return true;
    }
    parseText(text) {
        if (this.parser) {
            this.parser.parseText(text);
        }
    }
    parseClose(name) {
        if (this.parser) {
            if (!this.parser.parseClose(name)) {
                this.parser = undefined;
            }
            return true;
        }
        switch(name){
            case this.tag:
                this.model.columns = this.map.tableColumns.model;
                if (this.map.autoFilter.model) {
                    this.model.autoFilterRef = this.map.autoFilter.model.autoFilterRef;
                    this.map.autoFilter.model.columns.forEach((column, index)=>{
                        this.model.columns[index].filterButton = column.filterButton;
                    });
                }
                this.model.style = this.map.tableStyleInfo.model;
                return false;
            default:
                // could be some unrecognised tags
                return true;
        }
    }
    reconcile(model, options) {
        // fetch the dfxs from styles
        model.columns.forEach((column)=>{
            if (column.dxfId !== undefined) {
                column.style = options.styles.getDxfStyle(column.dxfId);
            }
        });
    }
}
TableXform.TABLE_ATTRIBUTES = {
    xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
    "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
    "mc:Ignorable": "xr xr3",
    "xmlns:xr": "http://schemas.microsoft.com/office/spreadsheetml/2014/revision",
    "xmlns:xr3": "http://schemas.microsoft.com/office/spreadsheetml/2016/revision3"
};
module.exports = TableXform;


/***/ }),

/***/ 22008:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(57147);
const JSZip = __webpack_require__(3189);
const { PassThrough } = __webpack_require__(98323);
const ZipStream = __webpack_require__(16362);
const StreamBuf = __webpack_require__(87273);
const utils = __webpack_require__(90778);
const XmlStream = __webpack_require__(18749);
const { bufferToString } = __webpack_require__(13491);
const StylesXform = __webpack_require__(20429);
const CoreXform = __webpack_require__(81637);
const SharedStringsXform = __webpack_require__(99582);
const RelationshipsXform = __webpack_require__(6849);
const ContentTypesXform = __webpack_require__(13518);
const AppXform = __webpack_require__(15081);
const WorkbookXform = __webpack_require__(89297);
const WorksheetXform = __webpack_require__(71373);
const DrawingXform = __webpack_require__(56130);
const TableXform = __webpack_require__(14234);
const CommentsXform = __webpack_require__(21859);
const VmlNotesXform = __webpack_require__(52365);
const theme1Xml = __webpack_require__(90530);
function fsReadFileAsync(filename, options) {
    return new Promise((resolve, reject)=>{
        fs.readFile(filename, options, (error, data)=>{
            if (error) {
                reject(error);
            } else {
                resolve(data);
            }
        });
    });
}
class XLSX {
    constructor(workbook){
        this.workbook = workbook;
    }
    // ===============================================================================
    // Workbook
    // =========================================================================
    // Read
    async readFile(filename, options) {
        if (!await utils.fs.exists(filename)) {
            throw new Error(`File not found: ${filename}`);
        }
        const stream = fs.createReadStream(filename);
        try {
            const workbook = await this.read(stream, options);
            stream.close();
            return workbook;
        } catch (error) {
            stream.close();
            throw error;
        }
    }
    parseRels(stream) {
        const xform = new RelationshipsXform();
        return xform.parseStream(stream);
    }
    parseWorkbook(stream) {
        const xform = new WorkbookXform();
        return xform.parseStream(stream);
    }
    parseSharedStrings(stream) {
        const xform = new SharedStringsXform();
        return xform.parseStream(stream);
    }
    reconcile(model, options) {
        const workbookXform = new WorkbookXform();
        const worksheetXform = new WorksheetXform(options);
        const drawingXform = new DrawingXform();
        const tableXform = new TableXform();
        workbookXform.reconcile(model);
        // reconcile drawings with their rels
        const drawingOptions = {
            media: model.media,
            mediaIndex: model.mediaIndex
        };
        Object.keys(model.drawings).forEach((name)=>{
            const drawing = model.drawings[name];
            const drawingRel = model.drawingRels[name];
            if (drawingRel) {
                drawingOptions.rels = drawingRel.reduce((o, rel)=>{
                    o[rel.Id] = rel;
                    return o;
                }, {});
                (drawing.anchors || []).forEach((anchor)=>{
                    const hyperlinks = anchor.picture && anchor.picture.hyperlinks;
                    if (hyperlinks && drawingOptions.rels[hyperlinks.rId]) {
                        hyperlinks.hyperlink = drawingOptions.rels[hyperlinks.rId].Target;
                        delete hyperlinks.rId;
                    }
                });
                drawingXform.reconcile(drawing, drawingOptions);
            }
        });
        // reconcile tables with the default styles
        const tableOptions = {
            styles: model.styles
        };
        Object.values(model.tables).forEach((table)=>{
            tableXform.reconcile(table, tableOptions);
        });
        const sheetOptions = {
            styles: model.styles,
            sharedStrings: model.sharedStrings,
            media: model.media,
            mediaIndex: model.mediaIndex,
            date1904: model.properties && model.properties.date1904,
            drawings: model.drawings,
            comments: model.comments,
            tables: model.tables,
            vmlDrawings: model.vmlDrawings
        };
        model.worksheets.forEach((worksheet)=>{
            worksheet.relationships = model.worksheetRels[worksheet.sheetNo];
            worksheetXform.reconcile(worksheet, sheetOptions);
        });
        // delete unnecessary parts
        delete model.worksheetHash;
        delete model.worksheetRels;
        delete model.globalRels;
        delete model.sharedStrings;
        delete model.workbookRels;
        delete model.sheetDefs;
        delete model.styles;
        delete model.mediaIndex;
        delete model.drawings;
        delete model.drawingRels;
        delete model.vmlDrawings;
    }
    async _processWorksheetEntry(stream, model, sheetNo, options, path) {
        const xform = new WorksheetXform(options);
        const worksheet = await xform.parseStream(stream);
        worksheet.sheetNo = sheetNo;
        model.worksheetHash[path] = worksheet;
        model.worksheets.push(worksheet);
    }
    async _processCommentEntry(stream, model, name) {
        const xform = new CommentsXform();
        const comments = await xform.parseStream(stream);
        model.comments[`../${name}.xml`] = comments;
    }
    async _processTableEntry(stream, model, name) {
        const xform = new TableXform();
        const table = await xform.parseStream(stream);
        model.tables[`../tables/${name}.xml`] = table;
    }
    async _processWorksheetRelsEntry(stream, model, sheetNo) {
        const xform = new RelationshipsXform();
        const relationships = await xform.parseStream(stream);
        model.worksheetRels[sheetNo] = relationships;
    }
    async _processMediaEntry(entry, model, filename) {
        const lastDot = filename.lastIndexOf(".");
        // if we can't determine extension, ignore it
        if (lastDot >= 1) {
            const extension = filename.substr(lastDot + 1);
            const name = filename.substr(0, lastDot);
            await new Promise((resolve, reject)=>{
                const streamBuf = new StreamBuf();
                streamBuf.on("finish", ()=>{
                    model.mediaIndex[filename] = model.media.length;
                    model.mediaIndex[name] = model.media.length;
                    const medium = {
                        type: "image",
                        name,
                        extension,
                        buffer: streamBuf.toBuffer()
                    };
                    model.media.push(medium);
                    resolve();
                });
                entry.on("error", (error)=>{
                    reject(error);
                });
                entry.pipe(streamBuf);
            });
        }
    }
    async _processDrawingEntry(entry, model, name) {
        const xform = new DrawingXform();
        const drawing = await xform.parseStream(entry);
        model.drawings[name] = drawing;
    }
    async _processDrawingRelsEntry(entry, model, name) {
        const xform = new RelationshipsXform();
        const relationships = await xform.parseStream(entry);
        model.drawingRels[name] = relationships;
    }
    async _processVmlDrawingEntry(entry, model, name) {
        const xform = new VmlNotesXform();
        const vmlDrawing = await xform.parseStream(entry);
        model.vmlDrawings[`../drawings/${name}.vml`] = vmlDrawing;
    }
    async _processThemeEntry(entry, model, name) {
        await new Promise((resolve, reject)=>{
            // TODO: stream entry into buffer and store the xml in the model.themes[]
            const stream = new StreamBuf();
            entry.on("error", reject);
            stream.on("error", reject);
            stream.on("finish", ()=>{
                model.themes[name] = stream.read().toString();
                resolve();
            });
            entry.pipe(stream);
        });
    }
    /**
   * @deprecated since version 4.0. You should use `#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md
   */ createInputStream() {
        throw new Error("`XLSX#createInputStream` is deprecated. You should use `XLSX#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md");
    }
    async read(stream, options) {
        // TODO: Remove once node v8 is deprecated
        // Detect and upgrade old streams
        if (!stream[Symbol.asyncIterator] && stream.pipe) {
            stream = stream.pipe(new PassThrough());
        }
        const chunks = [];
        for await (const chunk of stream){
            chunks.push(chunk);
        }
        return this.load(Buffer.concat(chunks), options);
    }
    async load(data, options) {
        let buffer;
        if (options && options.base64) {
            buffer = Buffer.from(data.toString(), "base64");
        } else {
            buffer = data;
        }
        const model = {
            worksheets: [],
            worksheetHash: {},
            worksheetRels: [],
            themes: {},
            media: [],
            mediaIndex: {},
            drawings: {},
            drawingRels: {},
            comments: {},
            tables: {},
            vmlDrawings: {}
        };
        const zip = await JSZip.loadAsync(buffer);
        for (const entry of Object.values(zip.files)){
            /* eslint-disable no-await-in-loop */ if (!entry.dir) {
                let entryName = entry.name;
                if (entryName[0] === "/") {
                    entryName = entryName.substr(1);
                }
                let stream;
                if (entryName.match(/xl\/media\//) || // themes are not parsed as stream
                entryName.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/)) {
                    stream = new PassThrough();
                    stream.write(await entry.async("nodebuffer"));
                } else {
                    // use object mode to avoid buffer-string convention
                    stream = new PassThrough({
                        writableObjectMode: true,
                        readableObjectMode: true
                    });
                    let content;
                    // https://www.npmjs.com/package/process
                    if (false) {} else {
                        // running in node.js
                        content = await entry.async("string");
                    }
                    const chunkSize = 16 * 1024;
                    for(let i = 0; i < content.length; i += chunkSize){
                        stream.write(content.substring(i, i + chunkSize));
                    }
                }
                stream.end();
                switch(entryName){
                    case "_rels/.rels":
                        model.globalRels = await this.parseRels(stream);
                        break;
                    case "xl/workbook.xml":
                        {
                            const workbook = await this.parseWorkbook(stream);
                            model.sheets = workbook.sheets;
                            model.definedNames = workbook.definedNames;
                            model.views = workbook.views;
                            model.properties = workbook.properties;
                            model.calcProperties = workbook.calcProperties;
                            break;
                        }
                    case "xl/_rels/workbook.xml.rels":
                        model.workbookRels = await this.parseRels(stream);
                        break;
                    case "xl/sharedStrings.xml":
                        model.sharedStrings = new SharedStringsXform();
                        await model.sharedStrings.parseStream(stream);
                        break;
                    case "xl/styles.xml":
                        model.styles = new StylesXform();
                        await model.styles.parseStream(stream);
                        break;
                    case "docProps/app.xml":
                        {
                            const appXform = new AppXform();
                            const appProperties = await appXform.parseStream(stream);
                            model.company = appProperties.company;
                            model.manager = appProperties.manager;
                            break;
                        }
                    case "docProps/core.xml":
                        {
                            const coreXform = new CoreXform();
                            const coreProperties = await coreXform.parseStream(stream);
                            Object.assign(model, coreProperties);
                            break;
                        }
                    default:
                        {
                            let match = entryName.match(/xl\/worksheets\/sheet(\d+)[.]xml/);
                            if (match) {
                                await this._processWorksheetEntry(stream, model, match[1], options, entryName);
                                break;
                            }
                            match = entryName.match(/xl\/worksheets\/_rels\/sheet(\d+)[.]xml.rels/);
                            if (match) {
                                await this._processWorksheetRelsEntry(stream, model, match[1]);
                                break;
                            }
                            match = entryName.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/);
                            if (match) {
                                await this._processThemeEntry(stream, model, match[1]);
                                break;
                            }
                            match = entryName.match(/xl\/media\/([a-zA-Z0-9]+[.][a-zA-Z0-9]{3,4})$/);
                            if (match) {
                                await this._processMediaEntry(stream, model, match[1]);
                                break;
                            }
                            match = entryName.match(/xl\/drawings\/([a-zA-Z0-9]+)[.]xml/);
                            if (match) {
                                await this._processDrawingEntry(stream, model, match[1]);
                                break;
                            }
                            match = entryName.match(/xl\/(comments\d+)[.]xml/);
                            if (match) {
                                await this._processCommentEntry(stream, model, match[1]);
                                break;
                            }
                            match = entryName.match(/xl\/tables\/(table\d+)[.]xml/);
                            if (match) {
                                await this._processTableEntry(stream, model, match[1]);
                                break;
                            }
                            match = entryName.match(/xl\/drawings\/_rels\/([a-zA-Z0-9]+)[.]xml[.]rels/);
                            if (match) {
                                await this._processDrawingRelsEntry(stream, model, match[1]);
                                break;
                            }
                            match = entryName.match(/xl\/drawings\/(vmlDrawing\d+)[.]vml/);
                            if (match) {
                                await this._processVmlDrawingEntry(stream, model, match[1]);
                                break;
                            }
                        }
                }
            }
        }
        this.reconcile(model, options);
        // apply model
        this.workbook.model = model;
        return this.workbook;
    }
    // =========================================================================
    // Write
    async addMedia(zip, model) {
        await Promise.all(model.media.map(async (medium)=>{
            if (medium.type === "image") {
                const filename = `xl/media/${medium.name}.${medium.extension}`;
                if (medium.filename) {
                    const data = await fsReadFileAsync(medium.filename);
                    return zip.append(data, {
                        name: filename
                    });
                }
                if (medium.buffer) {
                    return zip.append(medium.buffer, {
                        name: filename
                    });
                }
                if (medium.base64) {
                    const dataimg64 = medium.base64;
                    const content = dataimg64.substring(dataimg64.indexOf(",") + 1);
                    return zip.append(content, {
                        name: filename,
                        base64: true
                    });
                }
            }
            throw new Error("Unsupported media");
        }));
    }
    addDrawings(zip, model) {
        const drawingXform = new DrawingXform();
        const relsXform = new RelationshipsXform();
        model.worksheets.forEach((worksheet)=>{
            const { drawing } = worksheet;
            if (drawing) {
                drawingXform.prepare(drawing, {});
                let xml = drawingXform.toXml(drawing);
                zip.append(xml, {
                    name: `xl/drawings/${drawing.name}.xml`
                });
                xml = relsXform.toXml(drawing.rels);
                zip.append(xml, {
                    name: `xl/drawings/_rels/${drawing.name}.xml.rels`
                });
            }
        });
    }
    addTables(zip, model) {
        const tableXform = new TableXform();
        model.worksheets.forEach((worksheet)=>{
            const { tables } = worksheet;
            tables.forEach((table)=>{
                tableXform.prepare(table, {});
                const tableXml = tableXform.toXml(table);
                zip.append(tableXml, {
                    name: `xl/tables/${table.target}`
                });
            });
        });
    }
    async addContentTypes(zip, model) {
        const xform = new ContentTypesXform();
        const xml = xform.toXml(model);
        zip.append(xml, {
            name: "[Content_Types].xml"
        });
    }
    async addApp(zip, model) {
        const xform = new AppXform();
        const xml = xform.toXml(model);
        zip.append(xml, {
            name: "docProps/app.xml"
        });
    }
    async addCore(zip, model) {
        const coreXform = new CoreXform();
        zip.append(coreXform.toXml(model), {
            name: "docProps/core.xml"
        });
    }
    async addThemes(zip, model) {
        const themes = model.themes || {
            theme1: theme1Xml
        };
        Object.keys(themes).forEach((name)=>{
            const xml = themes[name];
            const path = `xl/theme/${name}.xml`;
            zip.append(xml, {
                name: path
            });
        });
    }
    async addOfficeRels(zip) {
        const xform = new RelationshipsXform();
        const xml = xform.toXml([
            {
                Id: "rId1",
                Type: XLSX.RelType.OfficeDocument,
                Target: "xl/workbook.xml"
            },
            {
                Id: "rId2",
                Type: XLSX.RelType.CoreProperties,
                Target: "docProps/core.xml"
            },
            {
                Id: "rId3",
                Type: XLSX.RelType.ExtenderProperties,
                Target: "docProps/app.xml"
            }
        ]);
        zip.append(xml, {
            name: "_rels/.rels"
        });
    }
    async addWorkbookRels(zip, model) {
        let count = 1;
        const relationships = [
            {
                Id: `rId${count++}`,
                Type: XLSX.RelType.Styles,
                Target: "styles.xml"
            },
            {
                Id: `rId${count++}`,
                Type: XLSX.RelType.Theme,
                Target: "theme/theme1.xml"
            }
        ];
        if (model.sharedStrings.count) {
            relationships.push({
                Id: `rId${count++}`,
                Type: XLSX.RelType.SharedStrings,
                Target: "sharedStrings.xml"
            });
        }
        model.worksheets.forEach((worksheet)=>{
            worksheet.rId = `rId${count++}`;
            relationships.push({
                Id: worksheet.rId,
                Type: XLSX.RelType.Worksheet,
                Target: `worksheets/sheet${worksheet.id}.xml`
            });
        });
        const xform = new RelationshipsXform();
        const xml = xform.toXml(relationships);
        zip.append(xml, {
            name: "xl/_rels/workbook.xml.rels"
        });
    }
    async addSharedStrings(zip, model) {
        if (model.sharedStrings && model.sharedStrings.count) {
            zip.append(model.sharedStrings.xml, {
                name: "xl/sharedStrings.xml"
            });
        }
    }
    async addStyles(zip, model) {
        const { xml } = model.styles;
        if (xml) {
            zip.append(xml, {
                name: "xl/styles.xml"
            });
        }
    }
    async addWorkbook(zip, model) {
        const xform = new WorkbookXform();
        zip.append(xform.toXml(model), {
            name: "xl/workbook.xml"
        });
    }
    async addWorksheets(zip, model) {
        // preparation phase
        const worksheetXform = new WorksheetXform();
        const relationshipsXform = new RelationshipsXform();
        const commentsXform = new CommentsXform();
        const vmlNotesXform = new VmlNotesXform();
        // write sheets
        model.worksheets.forEach((worksheet)=>{
            let xmlStream = new XmlStream();
            worksheetXform.render(xmlStream, worksheet);
            zip.append(xmlStream.xml, {
                name: `xl/worksheets/sheet${worksheet.id}.xml`
            });
            if (worksheet.rels && worksheet.rels.length) {
                xmlStream = new XmlStream();
                relationshipsXform.render(xmlStream, worksheet.rels);
                zip.append(xmlStream.xml, {
                    name: `xl/worksheets/_rels/sheet${worksheet.id}.xml.rels`
                });
            }
            if (worksheet.comments.length > 0) {
                xmlStream = new XmlStream();
                commentsXform.render(xmlStream, worksheet);
                zip.append(xmlStream.xml, {
                    name: `xl/comments${worksheet.id}.xml`
                });
                xmlStream = new XmlStream();
                vmlNotesXform.render(xmlStream, worksheet);
                zip.append(xmlStream.xml, {
                    name: `xl/drawings/vmlDrawing${worksheet.id}.vml`
                });
            }
        });
    }
    _finalize(zip) {
        return new Promise((resolve, reject)=>{
            zip.on("finish", ()=>{
                resolve(this);
            });
            zip.on("error", reject);
            zip.finalize();
        });
    }
    prepareModel(model, options) {
        // ensure following properties have sane values
        model.creator = model.creator || "ExcelJS";
        model.lastModifiedBy = model.lastModifiedBy || "ExcelJS";
        model.created = model.created || new Date();
        model.modified = model.modified || new Date();
        model.useSharedStrings = options.useSharedStrings !== undefined ? options.useSharedStrings : true;
        model.useStyles = options.useStyles !== undefined ? options.useStyles : true;
        // Manage the shared strings
        model.sharedStrings = new SharedStringsXform();
        // add a style manager to handle cell formats, fonts, etc.
        model.styles = model.useStyles ? new StylesXform(true) : new StylesXform.Mock();
        // prepare all of the things before the render
        const workbookXform = new WorkbookXform();
        const worksheetXform = new WorksheetXform();
        workbookXform.prepare(model);
        const worksheetOptions = {
            sharedStrings: model.sharedStrings,
            styles: model.styles,
            date1904: model.properties.date1904,
            drawingsCount: 0,
            media: model.media
        };
        worksheetOptions.drawings = model.drawings = [];
        worksheetOptions.commentRefs = model.commentRefs = [];
        let tableCount = 0;
        model.tables = [];
        model.worksheets.forEach((worksheet)=>{
            // assign unique filenames to tables
            worksheet.tables.forEach((table)=>{
                tableCount++;
                table.target = `table${tableCount}.xml`;
                table.id = tableCount;
                model.tables.push(table);
            });
            worksheetXform.prepare(worksheet, worksheetOptions);
        });
    // TODO: workbook drawing list
    }
    async write(stream, options) {
        options = options || {};
        const { model } = this.workbook;
        const zip = new ZipStream.ZipWriter(options.zip);
        zip.pipe(stream);
        this.prepareModel(model, options);
        // render
        await this.addContentTypes(zip, model);
        await this.addOfficeRels(zip, model);
        await this.addWorkbookRels(zip, model);
        await this.addWorksheets(zip, model);
        await this.addSharedStrings(zip, model); // always after worksheets
        await this.addDrawings(zip, model);
        await this.addTables(zip, model);
        await Promise.all([
            this.addThemes(zip, model),
            this.addStyles(zip, model)
        ]);
        await this.addMedia(zip, model);
        await Promise.all([
            this.addApp(zip, model),
            this.addCore(zip, model)
        ]);
        await this.addWorkbook(zip, model);
        return this._finalize(zip);
    }
    writeFile(filename, options) {
        const stream = fs.createWriteStream(filename);
        return new Promise((resolve, reject)=>{
            stream.on("finish", ()=>{
                resolve();
            });
            stream.on("error", (error)=>{
                reject(error);
            });
            this.write(stream, options).then(()=>{
                stream.end();
            }).catch((err)=>{
                reject(err);
            });
        });
    }
    async writeBuffer(options) {
        const stream = new StreamBuf();
        await this.write(stream, options);
        return stream.read();
    }
}
XLSX.RelType = __webpack_require__(39982);
module.exports = XLSX;


/***/ }),

/***/ 90530:
/***/ ((module) => {

"use strict";
/* eslint-disable */ 
module.exports = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"> <a:themeElements> <a:clrScheme name="Office"> <a:dk1> <a:sysClr val="windowText" lastClr="000000"/> </a:dk1> <a:lt1> <a:sysClr val="window" lastClr="FFFFFF"/> </a:lt1> <a:dk2> <a:srgbClr val="1F497D"/> </a:dk2> <a:lt2> <a:srgbClr val="EEECE1"/> </a:lt2> <a:accent1> <a:srgbClr val="4F81BD"/> </a:accent1> <a:accent2> <a:srgbClr val="C0504D"/> </a:accent2> <a:accent3> <a:srgbClr val="9BBB59"/> </a:accent3> <a:accent4> <a:srgbClr val="8064A2"/> </a:accent4> <a:accent5> <a:srgbClr val="4BACC6"/> </a:accent5> <a:accent6> <a:srgbClr val="F79646"/> </a:accent6> <a:hlink> <a:srgbClr val="0000FF"/> </a:hlink> <a:folHlink> <a:srgbClr val="800080"/> </a:folHlink> </a:clrScheme> <a:fontScheme name="Office"> <a:majorFont> <a:latin typeface="Cambria"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface=" "/> <a:font script="Hang" typeface=" "/> <a:font script="Hans" typeface=""/> <a:font script="Hant" typeface=""/> <a:font script="Arab" typeface="Times New Roman"/> <a:font script="Hebr" typeface="Times New Roman"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="MoolBoran"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Times New Roman"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:majorFont> <a:minorFont> <a:latin typeface="Calibri"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface=" "/> <a:font script="Hang" typeface=" "/> <a:font script="Hans" typeface=""/> <a:font script="Hant" typeface=""/> <a:font script="Arab" typeface="Arial"/> <a:font script="Hebr" typeface="Arial"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="DaunPenh"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Arial"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:minorFont> </a:fontScheme> <a:fmtScheme name="Office"> <a:fillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="35000"> <a:schemeClr val="phClr"> <a:tint val="37000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="15000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="1"/> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="100000"/> <a:shade val="100000"/> <a:satMod val="130000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:shade val="100000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="0"/> </a:gradFill> </a:fillStyleLst> <a:lnStyleLst> <a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"> <a:shade val="95000"/> <a:satMod val="105000"/> </a:schemeClr> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> </a:lnStyleLst> <a:effectStyleLst> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="38000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> <a:scene3d> <a:camera prst="orthographicFront"> <a:rot lat="0" lon="0" rev="0"/> </a:camera> <a:lightRig rig="threePt" dir="t"> <a:rot lat="0" lon="0" rev="1200000"/> </a:lightRig> </a:scene3d> <a:sp3d> <a:bevelT w="63500" h="25400"/> </a:sp3d> </a:effectStyle> </a:effectStyleLst> <a:bgFillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="40000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="40000"> <a:schemeClr val="phClr"> <a:tint val="45000"/> <a:shade val="99000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="20000"/> <a:satMod val="255000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="-80000" r="50000" b="180000"/> </a:path> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="80000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="30000"/> <a:satMod val="200000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="50000" r="50000" b="50000"/> </a:path> </a:gradFill> </a:bgFillStyleLst> </a:fmtScheme> </a:themeElements> <a:objectDefaults> <a:spDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="1"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="3"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="2"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="lt1"/> </a:fontRef> </a:style> </a:spDef> <a:lnDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="2"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="0"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="1"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="tx1"/> </a:fontRef> </a:style> </a:lnDef> </a:objectDefaults> <a:extraClrSchemeLst/> </a:theme>';


/***/ }),

/***/ 6622:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  NIL: () => (/* reexport */ nil),
  parse: () => (/* reexport */ esm_node_parse),
  stringify: () => (/* reexport */ esm_node_stringify),
  v1: () => (/* reexport */ esm_node_v1),
  v3: () => (/* reexport */ esm_node_v3),
  v4: () => (/* reexport */ esm_node_v4),
  v5: () => (/* reexport */ esm_node_v5),
  validate: () => (/* reexport */ esm_node_validate),
  version: () => (/* reexport */ esm_node_version)
});

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6113);
var external_crypto_default = /*#__PURE__*/__webpack_require__.n(external_crypto_);
;// CONCATENATED MODULE: ./node_modules/exceljs/node_modules/uuid/dist/esm-node/rng.js

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate
let poolPtr = rnds8Pool.length;
function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
        external_crypto_default().randomFillSync(rnds8Pool);
        poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

;// CONCATENATED MODULE: ./node_modules/exceljs/node_modules/uuid/dist/esm-node/regex.js
/* harmony default export */ const regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

;// CONCATENATED MODULE: ./node_modules/exceljs/node_modules/uuid/dist/esm-node/validate.js

function validate(uuid) {
    return typeof uuid === "string" && regex.test(uuid);
}
/* harmony default export */ const esm_node_validate = (validate);

;// CONCATENATED MODULE: ./node_modules/exceljs/node_modules/uuid/dist/esm-node/stringify.js

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ const byteToHex = [];
for(let i = 0; i < 256; ++i){
    byteToHex.push((i + 0x100).toString(16).substr(1));
}
function stringify(arr, offset = 0) {
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!esm_node_validate(uuid)) {
        throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
}
/* harmony default export */ const esm_node_stringify = (stringify);

;// CONCATENATED MODULE: ./node_modules/exceljs/node_modules/uuid/dist/esm-node/v1.js

 // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;
let _clockseq; // Previous uuid creation time
let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
    // specified.  We do this lazily to minimize issues related to insufficient
    // system entropy.  See #189
    if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || rng)();
        if (node == null) {
            // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
            node = _nodeId = [
                seedBytes[0] | 0x01,
                seedBytes[1],
                seedBytes[2],
                seedBytes[3],
                seedBytes[4],
                seedBytes[5]
            ];
        }
        if (clockseq == null) {
            // Per 4.2.2, randomize (14 bit) clockseq
            clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
        }
    } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq === undefined) {
        clockseq = clockseq + 1 & 0x3fff;
    } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
        nsecs = 0;
    } // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000; // `time_low`
    const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff; // `time_mid`
    const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff; // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`
    b[i++] = clockseq & 0xff; // `node`
    for(let n = 0; n < 6; ++n){
        b[i + n] = node[n];
    }
    return buf || esm_node_stringify(b);
}
/* harmony default export */ const esm_node_v1 = (v1);

;// CONCATENATED MODULE: ./node_modules/exceljs/node_modules/uuid/dist/esm-node/parse.js

function parse(uuid) {
    if (!esm_node_validate(uuid)) {
        throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16); // Parse ########-....-....-....-............
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 0xff;
    arr[2] = v >>> 8 & 0xff;
    arr[3] = v & 0xff; // Parse ........-####-....-....-............
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 0xff; // Parse ........-....-####-....-............
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 0xff; // Parse ........-....-....-####-............
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 0xff; // Parse ........-....-....-....-############
    // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
    arr[11] = v / 0x100000000 & 0xff;
    arr[12] = v >>> 24 & 0xff;
    arr[13] = v >>> 16 & 0xff;
    arr[14] = v >>> 8 & 0xff;
    arr[15] = v & 0xff;
    return arr;
}
/* harmony default export */ const esm_node_parse = (parse);

;// CONCATENATED MODULE: ./node_modules/exceljs/node_modules/uuid/dist/esm-node/v35.js


function stringToBytes(str) {
    str = unescape(encodeURIComponent(str)); // UTF8 escape
    const bytes = [];
    for(let i = 0; i < str.length; ++i){
        bytes.push(str.charCodeAt(i));
    }
    return bytes;
}
const DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
const URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
/* harmony default export */ function v35(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
        if (typeof value === "string") {
            value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
            namespace = esm_node_parse(namespace);
        }
        if (namespace.length !== 16) {
            throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        } // Compute hash of namespace and value, Per 4.3
        // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
        // hashfunc([...namespace, ... value])`
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 0x0f | version;
        bytes[8] = bytes[8] & 0x3f | 0x80;
        if (buf) {
            offset = offset || 0;
            for(let i = 0; i < 16; ++i){
                buf[offset + i] = bytes[i];
            }
            return buf;
        }
        return esm_node_stringify(bytes);
    } // Function#name is not settable on some platforms (#270)
    try {
        generateUUID.name = name; // eslint-disable-next-line no-empty
    } catch (err) {} // For CommonJS default export support
    generateUUID.DNS = DNS;
    generateUUID.URL = URL;
    return generateUUID;
}

;// CONCATENATED MODULE: ./node_modules/exceljs/node_modules/uuid/dist/esm-node/md5.js

function md5(bytes) {
    if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
    }
    return external_crypto_default().createHash("md5").update(bytes).digest();
}
/* harmony default export */ const esm_node_md5 = (md5);

;// CONCATENATED MODULE: ./node_modules/exceljs/node_modules/uuid/dist/esm-node/v3.js


const v3 = v35("v3", 0x30, esm_node_md5);
/* harmony default export */ const esm_node_v3 = (v3);

;// CONCATENATED MODULE: ./node_modules/exceljs/node_modules/uuid/dist/esm-node/v4.js


function v4(options, buf, offset) {
    options = options || {};
    const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(let i = 0; i < 16; ++i){
            buf[offset + i] = rnds[i];
        }
        return buf;
    }
    return esm_node_stringify(rnds);
}
/* harmony default export */ const esm_node_v4 = (v4);

;// CONCATENATED MODULE: ./node_modules/exceljs/node_modules/uuid/dist/esm-node/sha1.js

function sha1(bytes) {
    if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
    }
    return external_crypto_default().createHash("sha1").update(bytes).digest();
}
/* harmony default export */ const esm_node_sha1 = (sha1);

;// CONCATENATED MODULE: ./node_modules/exceljs/node_modules/uuid/dist/esm-node/v5.js


const v5 = v35("v5", 0x50, esm_node_sha1);
/* harmony default export */ const esm_node_v5 = (v5);

;// CONCATENATED MODULE: ./node_modules/exceljs/node_modules/uuid/dist/esm-node/nil.js
/* harmony default export */ const nil = ("00000000-0000-0000-0000-000000000000");

;// CONCATENATED MODULE: ./node_modules/exceljs/node_modules/uuid/dist/esm-node/version.js

function version(uuid) {
    if (!esm_node_validate(uuid)) {
        throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.substr(14, 1), 16);
}
/* harmony default export */ const esm_node_version = (version);

;// CONCATENATED MODULE: ./node_modules/exceljs/node_modules/uuid/dist/esm-node/index.js











/***/ }),

/***/ 58029:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CsvParserStream = exports.ParserOptions = exports.parseFile = exports.parseStream = exports.parseString = exports.parse = exports.FormatterOptions = exports.CsvFormatterStream = exports.writeToPath = exports.writeToString = exports.writeToBuffer = exports.writeToStream = exports.write = exports.format = void 0;
var format_1 = __webpack_require__(29321);
Object.defineProperty(exports, "format", ({
    enumerable: true,
    get: function() {
        return format_1.format;
    }
}));
Object.defineProperty(exports, "write", ({
    enumerable: true,
    get: function() {
        return format_1.write;
    }
}));
Object.defineProperty(exports, "writeToStream", ({
    enumerable: true,
    get: function() {
        return format_1.writeToStream;
    }
}));
Object.defineProperty(exports, "writeToBuffer", ({
    enumerable: true,
    get: function() {
        return format_1.writeToBuffer;
    }
}));
Object.defineProperty(exports, "writeToString", ({
    enumerable: true,
    get: function() {
        return format_1.writeToString;
    }
}));
Object.defineProperty(exports, "writeToPath", ({
    enumerable: true,
    get: function() {
        return format_1.writeToPath;
    }
}));
Object.defineProperty(exports, "CsvFormatterStream", ({
    enumerable: true,
    get: function() {
        return format_1.CsvFormatterStream;
    }
}));
Object.defineProperty(exports, "FormatterOptions", ({
    enumerable: true,
    get: function() {
        return format_1.FormatterOptions;
    }
}));
var parse_1 = __webpack_require__(27108);
Object.defineProperty(exports, "parse", ({
    enumerable: true,
    get: function() {
        return parse_1.parse;
    }
}));
Object.defineProperty(exports, "parseString", ({
    enumerable: true,
    get: function() {
        return parse_1.parseString;
    }
}));
Object.defineProperty(exports, "parseStream", ({
    enumerable: true,
    get: function() {
        return parse_1.parseStream;
    }
}));
Object.defineProperty(exports, "parseFile", ({
    enumerable: true,
    get: function() {
        return parse_1.parseFile;
    }
}));
Object.defineProperty(exports, "ParserOptions", ({
    enumerable: true,
    get: function() {
        return parse_1.ParserOptions;
    }
}));
Object.defineProperty(exports, "CsvParserStream", ({
    enumerable: true,
    get: function() {
        return parse_1.CsvParserStream;
    }
})); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 56399:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = (__webpack_require__(57147).constants) || __webpack_require__(22057);


/***/ }),

/***/ 5426:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = realpath;
realpath.realpath = realpath;
realpath.sync = realpathSync;
realpath.realpathSync = realpathSync;
realpath.monkeypatch = monkeypatch;
realpath.unmonkeypatch = unmonkeypatch;
var fs = __webpack_require__(57147);
var origRealpath = fs.realpath;
var origRealpathSync = fs.realpathSync;
var version = process.version;
var ok = /^v[0-5]\./.test(version);
var old = __webpack_require__(91312);
function newError(er) {
    return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
}
function realpath(p, cache, cb) {
    if (ok) {
        return origRealpath(p, cache, cb);
    }
    if (typeof cache === "function") {
        cb = cache;
        cache = null;
    }
    origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
            old.realpath(p, cache, cb);
        } else {
            cb(er, result);
        }
    });
}
function realpathSync(p, cache) {
    if (ok) {
        return origRealpathSync(p, cache);
    }
    try {
        return origRealpathSync(p, cache);
    } catch (er) {
        if (newError(er)) {
            return old.realpathSync(p, cache);
        } else {
            throw er;
        }
    }
}
function monkeypatch() {
    fs.realpath = realpath;
    fs.realpathSync = realpathSync;
}
function unmonkeypatch() {
    fs.realpath = origRealpath;
    fs.realpathSync = origRealpathSync;
}


/***/ }),

/***/ 91312:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var pathModule = __webpack_require__(71017);
var isWindows = process.platform === "win32";
var fs = __webpack_require__(57147);
// JavaScript implementation of realpath, ported from node pre-v6
var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
function rethrow() {
    // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
    // is fairly slow to generate.
    var callback;
    if (DEBUG) {
        var backtrace = new Error;
        callback = debugCallback;
    } else callback = missingCallback;
    return callback;
    function debugCallback(err) {
        if (err) {
            backtrace.message = err.message;
            err = backtrace;
            missingCallback(err);
        }
    }
    function missingCallback(err) {
        if (err) {
            if (process.throwDeprecation) throw err; // Forgot a callback but don't know where? Use NODE_DEBUG=fs
            else if (!process.noDeprecation) {
                var msg = "fs: missing callback " + (err.stack || err.message);
                if (process.traceDeprecation) console.trace(msg);
                else console.error(msg);
            }
        }
    }
}
function maybeCallback(cb) {
    return typeof cb === "function" ? cb : rethrow();
}
var normalize = pathModule.normalize;
// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (isWindows) {
    var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
    var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}
// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (isWindows) {
    var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
    var splitRootRe = /^[\/]*/;
}
exports.realpathSync = function realpathSync(p, cache) {
    // make p is absolute
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
    }
    var original = p, seenLinks = {}, knownHard = {};
    // current character position in p
    var pos;
    // the partial path so far, including a trailing slash if any
    var current;
    // the partial path without a trailing slash (except when pointing at a root)
    var base;
    // the partial path scanned in the previous round, with slash
    var previous;
    start();
    function start() {
        // Skip over roots
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        // On windows, check that the root exists. On unix there is no need.
        if (isWindows && !knownHard[base]) {
            fs.lstatSync(base);
            knownHard[base] = true;
        }
    }
    // walk down the path, swapping out linked pathparts for their real
    // values
    // NB: p.length changes.
    while(pos < p.length){
        // find the next part
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        // continue if not a symlink
        if (knownHard[base] || cache && cache[base] === base) {
            continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
            // some known symbolic link.  no need to stat again.
            resolvedLink = cache[base];
        } else {
            var stat = fs.lstatSync(base);
            if (!stat.isSymbolicLink()) {
                knownHard[base] = true;
                if (cache) cache[base] = base;
                continue;
            }
            // read the link if it wasn't read before
            // dev/ino always return 0 on windows, so skip the check.
            var linkTarget = null;
            if (!isWindows) {
                var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
                if (seenLinks.hasOwnProperty(id)) {
                    linkTarget = seenLinks[id];
                }
            }
            if (linkTarget === null) {
                fs.statSync(base);
                linkTarget = fs.readlinkSync(base);
            }
            resolvedLink = pathModule.resolve(previous, linkTarget);
            // track this, if given a cache.
            if (cache) cache[base] = resolvedLink;
            if (!isWindows) seenLinks[id] = linkTarget;
        }
        // resolve the link, then start over
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
    }
    if (cache) cache[original] = p;
    return p;
};
exports.realpath = function realpath(p, cache, cb) {
    if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
    }
    // make p is absolute
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
    }
    var original = p, seenLinks = {}, knownHard = {};
    // current character position in p
    var pos;
    // the partial path so far, including a trailing slash if any
    var current;
    // the partial path without a trailing slash (except when pointing at a root)
    var base;
    // the partial path scanned in the previous round, with slash
    var previous;
    start();
    function start() {
        // Skip over roots
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        // On windows, check that the root exists. On unix there is no need.
        if (isWindows && !knownHard[base]) {
            fs.lstat(base, function(err) {
                if (err) return cb(err);
                knownHard[base] = true;
                LOOP();
            });
        } else {
            process.nextTick(LOOP);
        }
    }
    // walk down the path, swapping out linked pathparts for their real
    // values
    function LOOP() {
        // stop if scanned past end of path
        if (pos >= p.length) {
            if (cache) cache[original] = p;
            return cb(null, p);
        }
        // find the next part
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        // continue if not a symlink
        if (knownHard[base] || cache && cache[base] === base) {
            return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
            // known symbolic link.  no need to stat again.
            return gotResolvedLink(cache[base]);
        }
        return fs.lstat(base, gotStat);
    }
    function gotStat(err, stat) {
        if (err) return cb(err);
        // if not a symlink, skip to the next path part
        if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache) cache[base] = base;
            return process.nextTick(LOOP);
        }
        // stat & read the link if not read before
        // call gotTarget as soon as the link target is known
        // dev/ino always return 0 on windows, so skip the check.
        if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
                return gotTarget(null, seenLinks[id], base);
            }
        }
        fs.stat(base, function(err) {
            if (err) return cb(err);
            fs.readlink(base, function(err, target) {
                if (!isWindows) seenLinks[id] = target;
                gotTarget(err, target);
            });
        });
    }
    function gotTarget(err, target, base) {
        if (err) return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache) cache[base] = resolvedLink;
        gotResolvedLink(resolvedLink);
    }
    function gotResolvedLink(resolvedLink) {
        // resolve the link, then start over
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
    }
};


/***/ }),

/***/ 63693:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var __webpack_unused_export__;
/* unused reexport */ __webpack_require__(29554);
/* unused reexport */ __webpack_require__(54579);
exports.Writer = __webpack_require__(29000);
exports.$B = {
    Reader: __webpack_require__(17000),
    Writer: __webpack_require__(29742)
};
exports.Lv = {
    Reader: __webpack_require__(37990),
    Writer: __webpack_require__(15697)
};
exports.rU = {
    Reader: __webpack_require__(43456),
    Writer: __webpack_require__(8396)
};
exports._S = {
    Reader: __webpack_require__(92339),
    Writer: __webpack_require__(27604)
};
__webpack_unused_export__ = __webpack_unused_export__ = exports.Lv.Reader;
__webpack_unused_export__ = __webpack_unused_export__ = exports.$B.Reader;
__webpack_unused_export__ = __webpack_unused_export__ = exports.rU.Reader;
__webpack_unused_export__ = __webpack_unused_export__ = exports._S.Reader;
exports.Writer.Dir = __webpack_unused_export__ = exports.Lv.Writer;
exports.Writer.File = __webpack_unused_export__ = exports.$B.Writer;
exports.Writer.Link = __webpack_unused_export__ = exports.rU.Writer;
exports.Writer.Proxy = __webpack_unused_export__ = exports._S.Writer;
/* unused reexport */ __webpack_require__(89454);


/***/ }),

/***/ 29554:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// the parent class for all fstreams.

module.exports = Abstract;
var Stream = (__webpack_require__(12781).Stream);
var inherits = __webpack_require__(33834);
function Abstract() {
    Stream.call(this);
}
inherits(Abstract, Stream);
Abstract.prototype.on = function(ev, fn) {
    if (ev === "ready" && this.ready) {
        process.nextTick(fn.bind(this));
    } else {
        Stream.prototype.on.call(this, ev, fn);
    }
    return this;
};
Abstract.prototype.abort = function() {
    this._aborted = true;
    this.emit("abort");
};
Abstract.prototype.destroy = function() {};
Abstract.prototype.warn = function(msg, code) {
    var self = this;
    var er = decorate(msg, code, self);
    if (!self.listeners("warn")) {
        console.error("%s %s\n" + "path = %s\n" + "syscall = %s\n" + "fstream_type = %s\n" + "fstream_path = %s\n" + "fstream_unc_path = %s\n" + "fstream_class = %s\n" + "fstream_stack =\n%s\n", code || "UNKNOWN", er.stack, er.path, er.syscall, er.fstream_type, er.fstream_path, er.fstream_unc_path, er.fstream_class, er.fstream_stack.join("\n"));
    } else {
        self.emit("warn", er);
    }
};
Abstract.prototype.info = function(msg, code) {
    this.emit("info", msg, code);
};
Abstract.prototype.error = function(msg, code, th) {
    var er = decorate(msg, code, this);
    if (th) throw er;
    else this.emit("error", er);
};
function decorate(er, code, self) {
    if (!(er instanceof Error)) er = new Error(er);
    er.code = er.code || code;
    er.path = er.path || self.path;
    er.fstream_type = er.fstream_type || self.type;
    er.fstream_path = er.fstream_path || self.path;
    if (self._path !== self.path) {
        er.fstream_unc_path = er.fstream_unc_path || self._path;
    }
    if (self.linkpath) {
        er.fstream_linkpath = er.fstream_linkpath || self.linkpath;
    }
    er.fstream_class = er.fstream_class || self.constructor.name;
    er.fstream_stack = er.fstream_stack || new Error().stack.split(/\n/).slice(3).map(function(s) {
        return s.replace(/^ {4}at /, "");
    });
    return er;
}


/***/ }),

/***/ 89454:
/***/ ((module) => {

"use strict";

module.exports = collect;
function collect(stream) {
    if (stream._collected) return;
    if (stream._paused) return stream.on("resume", collect.bind(null, stream));
    stream._collected = true;
    stream.pause();
    stream.on("data", save);
    stream.on("end", save);
    var buf = [];
    function save(b) {
        if (typeof b === "string") b = new Buffer(b);
        if (Buffer.isBuffer(b) && !b.length) return;
        buf.push(b);
    }
    stream.on("entry", saveEntry);
    var entryBuffer = [];
    function saveEntry(e) {
        collect(e);
        entryBuffer.push(e);
    }
    stream.on("proxy", proxyPause);
    function proxyPause(p) {
        p.pause();
    }
    // replace the pipe method with a new version that will
    // unlock the buffered stuff.  if you just call .pipe()
    // without a destination, then it'll re-play the events.
    stream.pipe = function(orig) {
        return function(dest) {
            // console.error(' === open the pipes', dest && dest.path)
            // let the entries flow through one at a time.
            // Once they're all done, then we can resume completely.
            var e = 0;
            (function unblockEntry() {
                var entry = entryBuffer[e++];
                // console.error(" ==== unblock entry", entry && entry.path)
                if (!entry) return resume();
                entry.on("end", unblockEntry);
                if (dest) dest.add(entry);
                else stream.emit("entry", entry);
            })();
            function resume() {
                stream.removeListener("entry", saveEntry);
                stream.removeListener("data", save);
                stream.removeListener("end", save);
                stream.pipe = orig;
                if (dest) stream.pipe(dest);
                buf.forEach(function(b) {
                    if (b) stream.emit("data", b);
                    else stream.emit("end");
                });
                stream.resume();
            }
            return dest;
        };
    }(stream.pipe);
}


/***/ }),

/***/ 37990:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// A thing that emits "entry" events with Reader objects
// Pausing it causes it to stop emitting entry events, and also
// pauses the current entry if there is one.

module.exports = DirReader;
var fs = __webpack_require__(33362);
var inherits = __webpack_require__(33834);
var path = __webpack_require__(71017);
var Reader = __webpack_require__(54579);
var assert = (__webpack_require__(39491).ok);
inherits(DirReader, Reader);
function DirReader(props) {
    var self = this;
    if (!(self instanceof DirReader)) {
        throw new Error("DirReader must be called as constructor.");
    }
    // should already be established as a Directory type
    if (props.type !== "Directory" || !props.Directory) {
        throw new Error("Non-directory type " + props.type);
    }
    self.entries = null;
    self._index = -1;
    self._paused = false;
    self._length = -1;
    if (props.sort) {
        this.sort = props.sort;
    }
    Reader.call(this, props);
}
DirReader.prototype._getEntries = function() {
    var self = this;
    // race condition.  might pause() before calling _getEntries,
    // and then resume, and try to get them a second time.
    if (self._gotEntries) return;
    self._gotEntries = true;
    fs.readdir(self._path, function(er, entries) {
        if (er) return self.error(er);
        self.entries = entries;
        self.emit("entries", entries);
        if (self._paused) self.once("resume", processEntries);
        else processEntries();
        function processEntries() {
            self._length = self.entries.length;
            if (typeof self.sort === "function") {
                self.entries = self.entries.sort(self.sort.bind(self));
            }
            self._read();
        }
    });
};
// start walking the dir, and emit an "entry" event for each one.
DirReader.prototype._read = function() {
    var self = this;
    if (!self.entries) return self._getEntries();
    if (self._paused || self._currentEntry || self._aborted) {
        // console.error('DR paused=%j, current=%j, aborted=%j', self._paused, !!self._currentEntry, self._aborted)
        return;
    }
    self._index++;
    if (self._index >= self.entries.length) {
        if (!self._ended) {
            self._ended = true;
            self.emit("end");
            self.emit("close");
        }
        return;
    }
    // ok, handle this one, then.
    // save creating a proxy, by stat'ing the thing now.
    var p = path.resolve(self._path, self.entries[self._index]);
    assert(p !== self._path);
    assert(self.entries[self._index]);
    // set this to prevent trying to _read() again in the stat time.
    self._currentEntry = p;
    fs[self.props.follow ? "stat" : "lstat"](p, function(er, stat) {
        if (er) return self.error(er);
        var who = self._proxy || self;
        stat.path = p;
        stat.basename = path.basename(p);
        stat.dirname = path.dirname(p);
        var childProps = self.getChildProps.call(who, stat);
        childProps.path = p;
        childProps.basename = path.basename(p);
        childProps.dirname = path.dirname(p);
        var entry = Reader(childProps, stat);
        // console.error("DR Entry", p, stat.size)
        self._currentEntry = entry;
        // "entry" events are for direct entries in a specific dir.
        // "child" events are for any and all children at all levels.
        // This nomenclature is not completely final.
        entry.on("pause", function(who) {
            if (!self._paused && !entry._disowned) {
                self.pause(who);
            }
        });
        entry.on("resume", function(who) {
            if (self._paused && !entry._disowned) {
                self.resume(who);
            }
        });
        entry.on("stat", function(props) {
            self.emit("_entryStat", entry, props);
            if (entry._aborted) return;
            if (entry._paused) {
                entry.once("resume", function() {
                    self.emit("entryStat", entry, props);
                });
            } else self.emit("entryStat", entry, props);
        });
        entry.on("ready", function EMITCHILD() {
            // console.error("DR emit child", entry._path)
            if (self._paused) {
                // console.error("  DR emit child - try again later")
                // pause the child, and emit the "entry" event once we drain.
                // console.error("DR pausing child entry")
                entry.pause(self);
                return self.once("resume", EMITCHILD);
            }
            // skip over sockets.  they can't be piped around properly,
            // so there's really no sense even acknowledging them.
            // if someone really wants to see them, they can listen to
            // the "socket" events.
            if (entry.type === "Socket") {
                self.emit("socket", entry);
            } else {
                self.emitEntry(entry);
            }
        });
        var ended = false;
        entry.on("close", onend);
        entry.on("disown", onend);
        function onend() {
            if (ended) return;
            ended = true;
            self.emit("childEnd", entry);
            self.emit("entryEnd", entry);
            self._currentEntry = null;
            if (!self._paused) {
                self._read();
            }
        }
        // XXX Remove this.  Works in node as of 0.6.2 or so.
        // Long filenames should not break stuff.
        entry.on("error", function(er) {
            if (entry._swallowErrors) {
                self.warn(er);
                entry.emit("end");
                entry.emit("close");
            } else {
                self.emit("error", er);
            }
        });
        [
            "child",
            "childEnd",
            "warn"
        ].forEach(function(ev) {
            entry.on(ev, self.emit.bind(self, ev));
        });
    });
};
DirReader.prototype.disown = function(entry) {
    entry.emit("beforeDisown");
    entry._disowned = true;
    entry.parent = entry.root = null;
    if (entry === this._currentEntry) {
        this._currentEntry = null;
    }
    entry.emit("disown");
};
DirReader.prototype.getChildProps = function() {
    return {
        depth: this.depth + 1,
        root: this.root || this,
        parent: this,
        follow: this.follow,
        filter: this.filter,
        sort: this.props.sort,
        hardlinks: this.props.hardlinks
    };
};
DirReader.prototype.pause = function(who) {
    var self = this;
    if (self._paused) return;
    who = who || self;
    self._paused = true;
    if (self._currentEntry && self._currentEntry.pause) {
        self._currentEntry.pause(who);
    }
    self.emit("pause", who);
};
DirReader.prototype.resume = function(who) {
    var self = this;
    if (!self._paused) return;
    who = who || self;
    self._paused = false;
    // console.error('DR Emit Resume', self._path)
    self.emit("resume", who);
    if (self._paused) {
        // console.error('DR Re-paused', self._path)
        return;
    }
    if (self._currentEntry) {
        if (self._currentEntry.resume) self._currentEntry.resume(who);
    } else self._read();
};
DirReader.prototype.emitEntry = function(entry) {
    this.emit("entry", entry);
    this.emit("child", entry);
};


/***/ }),

/***/ 15697:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// It is expected that, when .add() returns false, the consumer
// of the DirWriter will pause until a "drain" event occurs. Note
// that this is *almost always going to be the case*, unless the
// thing being written is some sort of unsupported type, and thus
// skipped over.

module.exports = DirWriter;
var Writer = __webpack_require__(29000);
var inherits = __webpack_require__(33834);
var mkdir = __webpack_require__(31196);
var path = __webpack_require__(71017);
var collect = __webpack_require__(89454);
inherits(DirWriter, Writer);
function DirWriter(props) {
    var self = this;
    if (!(self instanceof DirWriter)) {
        self.error("DirWriter must be called as constructor.", null, true);
    }
    // should already be established as a Directory type
    if (props.type !== "Directory" || !props.Directory) {
        self.error("Non-directory type " + props.type + " " + JSON.stringify(props), null, true);
    }
    Writer.call(this, props);
}
DirWriter.prototype._create = function() {
    var self = this;
    mkdir(self._path, Writer.dirmode, function(er) {
        if (er) return self.error(er);
        // ready to start getting entries!
        self.ready = true;
        self.emit("ready");
        self._process();
    });
};
// a DirWriter has an add(entry) method, but its .write() doesn't
// do anything.  Why a no-op rather than a throw?  Because this
// leaves open the door for writing directory metadata for
// gnu/solaris style dumpdirs.
DirWriter.prototype.write = function() {
    return true;
};
DirWriter.prototype.end = function() {
    this._ended = true;
    this._process();
};
DirWriter.prototype.add = function(entry) {
    var self = this;
    // console.error('\tadd', entry._path, '->', self._path)
    collect(entry);
    if (!self.ready || self._currentEntry) {
        self._buffer.push(entry);
        return false;
    }
    // create a new writer, and pipe the incoming entry into it.
    if (self._ended) {
        return self.error("add after end");
    }
    self._buffer.push(entry);
    self._process();
    return this._buffer.length === 0;
};
DirWriter.prototype._process = function() {
    var self = this;
    // console.error('DW Process p=%j', self._processing, self.basename)
    if (self._processing) return;
    var entry = self._buffer.shift();
    if (!entry) {
        // console.error("DW Drain")
        self.emit("drain");
        if (self._ended) self._finish();
        return;
    }
    self._processing = true;
    // console.error("DW Entry", entry._path)
    self.emit("entry", entry);
    // ok, add this entry
    //
    // don't allow recursive copying
    var p = entry;
    var pp;
    do {
        pp = p._path || p.path;
        if (pp === self.root._path || pp === self._path || pp && pp.indexOf(self._path) === 0) {
            // console.error('DW Exit (recursive)', entry.basename, self._path)
            self._processing = false;
            if (entry._collected) entry.pipe();
            return self._process();
        }
        p = p.parent;
    }while (p);
    // console.error("DW not recursive")
    // chop off the entry's root dir, replace with ours
    var props = {
        parent: self,
        root: self.root || self,
        type: entry.type,
        depth: self.depth + 1
    };
    pp = entry._path || entry.path || entry.props.path;
    if (entry.parent) {
        pp = pp.substr(entry.parent._path.length + 1);
    }
    // get rid of any ../../ shenanigans
    props.path = path.join(self.path, path.join("/", pp));
    // if i have a filter, the child should inherit it.
    props.filter = self.filter;
    // all the rest of the stuff, copy over from the source.
    Object.keys(entry.props).forEach(function(k) {
        if (!props.hasOwnProperty(k)) {
            props[k] = entry.props[k];
        }
    });
    // not sure at this point what kind of writer this is.
    var child = self._currentChild = new Writer(props);
    child.on("ready", function() {
        // console.error("DW Child Ready", child.type, child._path)
        // console.error("  resuming", entry._path)
        entry.pipe(child);
        entry.resume();
    });
    // XXX Make this work in node.
    // Long filenames should not break stuff.
    child.on("error", function(er) {
        if (child._swallowErrors) {
            self.warn(er);
            child.emit("end");
            child.emit("close");
        } else {
            self.emit("error", er);
        }
    });
    // we fire _end internally *after* end, so that we don't move on
    // until any "end" listeners have had their chance to do stuff.
    child.on("close", onend);
    var ended = false;
    function onend() {
        if (ended) return;
        ended = true;
        // console.error("* DW Child end", child.basename)
        self._currentChild = null;
        self._processing = false;
        self._process();
    }
};


/***/ }),

/***/ 17000:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Basically just a wrapper around an fs.ReadStream

module.exports = FileReader;
var fs = __webpack_require__(33362);
var inherits = __webpack_require__(33834);
var Reader = __webpack_require__(54579);
var EOF = {
    EOF: true
};
var CLOSE = {
    CLOSE: true
};
inherits(FileReader, Reader);
function FileReader(props) {
    // console.error("    FR create", props.path, props.size, new Error().stack)
    var self = this;
    if (!(self instanceof FileReader)) {
        throw new Error("FileReader must be called as constructor.");
    }
    // should already be established as a File type
    // XXX Todo: preserve hardlinks by tracking dev+inode+nlink,
    // with a HardLinkReader class.
    if (!(props.type === "Link" && props.Link || props.type === "File" && props.File)) {
        throw new Error("Non-file type " + props.type);
    }
    self._buffer = [];
    self._bytesEmitted = 0;
    Reader.call(self, props);
}
FileReader.prototype._getStream = function() {
    var self = this;
    var stream = self._stream = fs.createReadStream(self._path, self.props);
    if (self.props.blksize) {
        stream.bufferSize = self.props.blksize;
    }
    stream.on("open", self.emit.bind(self, "open"));
    stream.on("data", function(c) {
        // console.error('\t\t%d %s', c.length, self.basename)
        self._bytesEmitted += c.length;
        // no point saving empty chunks
        if (!c.length) {
            return;
        } else if (self._paused || self._buffer.length) {
            self._buffer.push(c);
            self._read();
        } else self.emit("data", c);
    });
    stream.on("end", function() {
        if (self._paused || self._buffer.length) {
            // console.error('FR Buffering End', self._path)
            self._buffer.push(EOF);
            self._read();
        } else {
            self.emit("end");
        }
        if (self._bytesEmitted !== self.props.size) {
            self.error("Didn't get expected byte count\n" + "expect: " + self.props.size + "\n" + "actual: " + self._bytesEmitted);
        }
    });
    stream.on("close", function() {
        if (self._paused || self._buffer.length) {
            // console.error('FR Buffering Close', self._path)
            self._buffer.push(CLOSE);
            self._read();
        } else {
            // console.error('FR close 1', self._path)
            self.emit("close");
        }
    });
    stream.on("error", function(e) {
        self.emit("error", e);
    });
    self._read();
};
FileReader.prototype._read = function() {
    var self = this;
    // console.error('FR _read', self._path)
    if (self._paused) {
        // console.error('FR _read paused', self._path)
        return;
    }
    if (!self._stream) {
        // console.error('FR _getStream calling', self._path)
        return self._getStream();
    }
    // clear out the buffer, if there is one.
    if (self._buffer.length) {
        // console.error('FR _read has buffer', self._buffer.length, self._path)
        var buf = self._buffer;
        for(var i = 0, l = buf.length; i < l; i++){
            var c = buf[i];
            if (c === EOF) {
                // console.error('FR Read emitting buffered end', self._path)
                self.emit("end");
            } else if (c === CLOSE) {
                // console.error('FR Read emitting buffered close', self._path)
                self.emit("close");
            } else {
                // console.error('FR Read emitting buffered data', self._path)
                self.emit("data", c);
            }
            if (self._paused) {
                // console.error('FR Read Re-pausing at '+i, self._path)
                self._buffer = buf.slice(i);
                return;
            }
        }
        self._buffer.length = 0;
    }
// console.error("FR _read done")
// that's about all there is to it.
};
FileReader.prototype.pause = function(who) {
    var self = this;
    // console.error('FR Pause', self._path)
    if (self._paused) return;
    who = who || self;
    self._paused = true;
    if (self._stream) self._stream.pause();
    self.emit("pause", who);
};
FileReader.prototype.resume = function(who) {
    var self = this;
    // console.error('FR Resume', self._path)
    if (!self._paused) return;
    who = who || self;
    self.emit("resume", who);
    self._paused = false;
    if (self._stream) self._stream.resume();
    self._read();
};


/***/ }),

/***/ 29742:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = FileWriter;
var fs = __webpack_require__(33362);
var Writer = __webpack_require__(29000);
var inherits = __webpack_require__(33834);
var EOF = {};
inherits(FileWriter, Writer);
function FileWriter(props) {
    var self = this;
    if (!(self instanceof FileWriter)) {
        throw new Error("FileWriter must be called as constructor.");
    }
    // should already be established as a File type
    if (props.type !== "File" || !props.File) {
        throw new Error("Non-file type " + props.type);
    }
    self._buffer = [];
    self._bytesWritten = 0;
    Writer.call(this, props);
}
FileWriter.prototype._create = function() {
    var self = this;
    if (self._stream) return;
    var so = {};
    if (self.props.flags) so.flags = self.props.flags;
    so.mode = Writer.filemode;
    if (self._old && self._old.blksize) so.bufferSize = self._old.blksize;
    self._stream = fs.createWriteStream(self._path, so);
    self._stream.on("open", function() {
        // console.error("FW open", self._buffer, self._path)
        self.ready = true;
        self._buffer.forEach(function(c) {
            if (c === EOF) self._stream.end();
            else self._stream.write(c);
        });
        self.emit("ready");
        // give this a kick just in case it needs it.
        self.emit("drain");
    });
    self._stream.on("error", function(er) {
        self.emit("error", er);
    });
    self._stream.on("drain", function() {
        self.emit("drain");
    });
    self._stream.on("close", function() {
        // console.error('\n\nFW Stream Close', self._path, self.size)
        self._finish();
    });
};
FileWriter.prototype.write = function(c) {
    var self = this;
    self._bytesWritten += c.length;
    if (!self.ready) {
        if (!Buffer.isBuffer(c) && typeof c !== "string") {
            throw new Error("invalid write data");
        }
        self._buffer.push(c);
        return false;
    }
    var ret = self._stream.write(c);
    // console.error('\t-- fw wrote, _stream says', ret, self._stream._queue.length)
    // allow 2 buffered writes, because otherwise there's just too
    // much stop and go bs.
    if (ret === false && self._stream._queue) {
        return self._stream._queue.length <= 2;
    } else {
        return ret;
    }
};
FileWriter.prototype.end = function(c) {
    var self = this;
    if (c) self.write(c);
    if (!self.ready) {
        self._buffer.push(EOF);
        return false;
    }
    return self._stream.end();
};
FileWriter.prototype._finish = function() {
    var self = this;
    if (typeof self.size === "number" && self._bytesWritten !== self.size) {
        self.error("Did not get expected byte count.\n" + "expect: " + self.size + "\n" + "actual: " + self._bytesWritten);
    }
    Writer.prototype._finish.call(self);
};


/***/ }),

/***/ 28582:
/***/ ((module) => {

"use strict";

module.exports = getType;
function getType(st) {
    var types = [
        "Directory",
        "File",
        "SymbolicLink",
        "Link",
        "BlockDevice",
        "CharacterDevice",
        "FIFO",
        "Socket"
    ];
    var type;
    if (st.type && types.indexOf(st.type) !== -1) {
        st[st.type] = true;
        return st.type;
    }
    for(var i = 0, l = types.length; i < l; i++){
        type = types[i];
        var is = st[type] || st["is" + type];
        if (typeof is === "function") is = is.call(st);
        if (is) {
            st[type] = true;
            st.type = type;
            return type;
        }
    }
    return null;
}


/***/ }),

/***/ 43456:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Basically just a wrapper around an fs.readlink
//
// XXX: Enhance this to support the Link type, by keeping
// a lookup table of {<dev+inode>:<path>}, so that hardlinks
// can be preserved in tarballs.

module.exports = LinkReader;
var fs = __webpack_require__(33362);
var inherits = __webpack_require__(33834);
var Reader = __webpack_require__(54579);
inherits(LinkReader, Reader);
function LinkReader(props) {
    var self = this;
    if (!(self instanceof LinkReader)) {
        throw new Error("LinkReader must be called as constructor.");
    }
    if (!(props.type === "Link" && props.Link || props.type === "SymbolicLink" && props.SymbolicLink)) {
        throw new Error("Non-link type " + props.type);
    }
    Reader.call(self, props);
}
// When piping a LinkReader into a LinkWriter, we have to
// already have the linkpath property set, so that has to
// happen *before* the "ready" event, which means we need to
// override the _stat method.
LinkReader.prototype._stat = function(currentStat) {
    var self = this;
    fs.readlink(self._path, function(er, linkpath) {
        if (er) return self.error(er);
        self.linkpath = self.props.linkpath = linkpath;
        self.emit("linkpath", linkpath);
        Reader.prototype._stat.call(self, currentStat);
    });
};
LinkReader.prototype._read = function() {
    var self = this;
    if (self._paused) return;
    // basically just a no-op, since we got all the info we need
    // from the _stat method
    if (!self._ended) {
        self.emit("end");
        self.emit("close");
        self._ended = true;
    }
};


/***/ }),

/***/ 8396:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = LinkWriter;
var fs = __webpack_require__(33362);
var Writer = __webpack_require__(29000);
var inherits = __webpack_require__(33834);
var path = __webpack_require__(71017);
var rimraf = __webpack_require__(96076);
inherits(LinkWriter, Writer);
function LinkWriter(props) {
    var self = this;
    if (!(self instanceof LinkWriter)) {
        throw new Error("LinkWriter must be called as constructor.");
    }
    // should already be established as a Link type
    if (!(props.type === "Link" && props.Link || props.type === "SymbolicLink" && props.SymbolicLink)) {
        throw new Error("Non-link type " + props.type);
    }
    if (props.linkpath === "") props.linkpath = ".";
    if (!props.linkpath) {
        self.error("Need linkpath property to create " + props.type);
    }
    Writer.call(this, props);
}
LinkWriter.prototype._create = function() {
    // console.error(" LW _create")
    var self = this;
    var hard = self.type === "Link" || process.platform === "win32";
    var link = hard ? "link" : "symlink";
    var lp = hard ? path.resolve(self.dirname, self.linkpath) : self.linkpath;
    // can only change the link path by clobbering
    // For hard links, let's just assume that's always the case, since
    // there's no good way to read them if we don't already know.
    if (hard) return clobber(self, lp, link);
    fs.readlink(self._path, function(er, p) {
        // only skip creation if it's exactly the same link
        if (p && p === lp) return finish(self);
        clobber(self, lp, link);
    });
};
function clobber(self, lp, link) {
    rimraf(self._path, function(er) {
        if (er) return self.error(er);
        create(self, lp, link);
    });
}
function create(self, lp, link) {
    fs[link](lp, self._path, function(er) {
        // if this is a hard link, and we're in the process of writing out a
        // directory, it's very possible that the thing we're linking to
        // doesn't exist yet (especially if it was intended as a symlink),
        // so swallow ENOENT errors here and just soldier in.
        // Additionally, an EPERM or EACCES can happen on win32 if it's trying
        // to make a link to a directory.  Again, just skip it.
        // A better solution would be to have fs.symlink be supported on
        // windows in some nice fashion.
        if (er) {
            if ((er.code === "ENOENT" || er.code === "EACCES" || er.code === "EPERM") && process.platform === "win32") {
                self.ready = true;
                self.emit("ready");
                self.emit("end");
                self.emit("close");
                self.end = self._finish = function() {};
            } else return self.error(er);
        }
        finish(self);
    });
}
function finish(self) {
    self.ready = true;
    self.emit("ready");
    if (self._ended && !self._finished) self._finish();
}
LinkWriter.prototype.end = function() {
    // console.error("LW finish in end")
    this._ended = true;
    if (this.ready) {
        this._finished = true;
        this._finish();
    }
};


/***/ }),

/***/ 92339:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// A reader for when we don't yet know what kind of thing
// the thing is.

module.exports = ProxyReader;
var Reader = __webpack_require__(54579);
var getType = __webpack_require__(28582);
var inherits = __webpack_require__(33834);
var fs = __webpack_require__(33362);
inherits(ProxyReader, Reader);
function ProxyReader(props) {
    var self = this;
    if (!(self instanceof ProxyReader)) {
        throw new Error("ProxyReader must be called as constructor.");
    }
    self.props = props;
    self._buffer = [];
    self.ready = false;
    Reader.call(self, props);
}
ProxyReader.prototype._stat = function() {
    var self = this;
    var props = self.props;
    // stat the thing to see what the proxy should be.
    var stat = props.follow ? "stat" : "lstat";
    fs[stat](props.path, function(er, current) {
        var type;
        if (er || !current) {
            type = "File";
        } else {
            type = getType(current);
        }
        props[type] = true;
        props.type = self.type = type;
        self._old = current;
        self._addProxy(Reader(props, current));
    });
};
ProxyReader.prototype._addProxy = function(proxy) {
    var self = this;
    if (self._proxyTarget) {
        return self.error("proxy already set");
    }
    self._proxyTarget = proxy;
    proxy._proxy = self;
    [
        "error",
        "data",
        "end",
        "close",
        "linkpath",
        "entry",
        "entryEnd",
        "child",
        "childEnd",
        "warn",
        "stat"
    ].forEach(function(ev) {
        // console.error('~~ proxy event', ev, self.path)
        proxy.on(ev, self.emit.bind(self, ev));
    });
    self.emit("proxy", proxy);
    proxy.on("ready", function() {
        // console.error("~~ proxy is ready!", self.path)
        self.ready = true;
        self.emit("ready");
    });
    var calls = self._buffer;
    self._buffer.length = 0;
    calls.forEach(function(c) {
        proxy[c[0]].apply(proxy, c[1]);
    });
};
ProxyReader.prototype.pause = function() {
    return this._proxyTarget ? this._proxyTarget.pause() : false;
};
ProxyReader.prototype.resume = function() {
    return this._proxyTarget ? this._proxyTarget.resume() : false;
};


/***/ }),

/***/ 27604:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// A writer for when we don't know what kind of thing
// the thing is.  That is, it's not explicitly set,
// so we're going to make it whatever the thing already
// is, or "File"
//
// Until then, collect all events.

module.exports = ProxyWriter;
var Writer = __webpack_require__(29000);
var getType = __webpack_require__(28582);
var inherits = __webpack_require__(33834);
var collect = __webpack_require__(89454);
var fs = __webpack_require__(57147);
inherits(ProxyWriter, Writer);
function ProxyWriter(props) {
    var self = this;
    if (!(self instanceof ProxyWriter)) {
        throw new Error("ProxyWriter must be called as constructor.");
    }
    self.props = props;
    self._needDrain = false;
    Writer.call(self, props);
}
ProxyWriter.prototype._stat = function() {
    var self = this;
    var props = self.props;
    // stat the thing to see what the proxy should be.
    var stat = props.follow ? "stat" : "lstat";
    fs[stat](props.path, function(er, current) {
        var type;
        if (er || !current) {
            type = "File";
        } else {
            type = getType(current);
        }
        props[type] = true;
        props.type = self.type = type;
        self._old = current;
        self._addProxy(Writer(props, current));
    });
};
ProxyWriter.prototype._addProxy = function(proxy) {
    // console.error("~~ set proxy", this.path)
    var self = this;
    if (self._proxy) {
        return self.error("proxy already set");
    }
    self._proxy = proxy;
    [
        "ready",
        "error",
        "close",
        "pipe",
        "drain",
        "warn"
    ].forEach(function(ev) {
        proxy.on(ev, self.emit.bind(self, ev));
    });
    self.emit("proxy", proxy);
    var calls = self._buffer;
    calls.forEach(function(c) {
        // console.error("~~ ~~ proxy buffered call", c[0], c[1])
        proxy[c[0]].apply(proxy, c[1]);
    });
    self._buffer.length = 0;
    if (self._needsDrain) self.emit("drain");
};
ProxyWriter.prototype.add = function(entry) {
    // console.error("~~ proxy add")
    collect(entry);
    if (!this._proxy) {
        this._buffer.push([
            "add",
            [
                entry
            ]
        ]);
        this._needDrain = true;
        return false;
    }
    return this._proxy.add(entry);
};
ProxyWriter.prototype.write = function(c) {
    // console.error('~~ proxy write')
    if (!this._proxy) {
        this._buffer.push([
            "write",
            [
                c
            ]
        ]);
        this._needDrain = true;
        return false;
    }
    return this._proxy.write(c);
};
ProxyWriter.prototype.end = function(c) {
    // console.error('~~ proxy end')
    if (!this._proxy) {
        this._buffer.push([
            "end",
            [
                c
            ]
        ]);
        return false;
    }
    return this._proxy.end(c);
};


/***/ }),

/***/ 54579:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Reader;
var fs = __webpack_require__(33362);
var Stream = (__webpack_require__(12781).Stream);
var inherits = __webpack_require__(33834);
var path = __webpack_require__(71017);
var getType = __webpack_require__(28582);
var hardLinks = Reader.hardLinks = {};
var Abstract = __webpack_require__(29554);
// Must do this *before* loading the child classes
inherits(Reader, Abstract);
var LinkReader = __webpack_require__(43456);
function Reader(props, currentStat) {
    var self = this;
    if (!(self instanceof Reader)) return new Reader(props, currentStat);
    if (typeof props === "string") {
        props = {
            path: props
        };
    }
    // polymorphism.
    // call fstream.Reader(dir) to get a DirReader object, etc.
    // Note that, unlike in the Writer case, ProxyReader is going
    // to be the *normal* state of affairs, since we rarely know
    // the type of a file prior to reading it.
    var type;
    var ClassType;
    if (props.type && typeof props.type === "function") {
        type = props.type;
        ClassType = type;
    } else {
        type = getType(props);
        ClassType = Reader;
    }
    if (currentStat && !type) {
        type = getType(currentStat);
        props[type] = true;
        props.type = type;
    }
    switch(type){
        case "Directory":
            ClassType = __webpack_require__(37990);
            break;
        case "Link":
        // XXX hard links are just files.
        // However, it would be good to keep track of files' dev+inode
        // and nlink values, and create a HardLinkReader that emits
        // a linkpath value of the original copy, so that the tar
        // writer can preserve them.
        // ClassType = HardLinkReader
        // break
        case "File":
            ClassType = __webpack_require__(17000);
            break;
        case "SymbolicLink":
            ClassType = LinkReader;
            break;
        case "Socket":
            ClassType = __webpack_require__(74704);
            break;
        case null:
            ClassType = __webpack_require__(92339);
            break;
    }
    if (!(self instanceof ClassType)) {
        return new ClassType(props);
    }
    Abstract.call(self);
    if (!props.path) {
        self.error("Must provide a path", null, true);
    }
    self.readable = true;
    self.writable = false;
    self.type = type;
    self.props = props;
    self.depth = props.depth = props.depth || 0;
    self.parent = props.parent || null;
    self.root = props.root || props.parent && props.parent.root || self;
    self._path = self.path = path.resolve(props.path);
    if (process.platform === "win32") {
        self.path = self._path = self.path.replace(/\?/g, "_");
        if (self._path.length >= 260) {
            // how DOES one create files on the moon?
            // if the path has spaces in it, then UNC will fail.
            self._swallowErrors = true;
            // if (self._path.indexOf(" ") === -1) {
            self._path = "\\\\?\\" + self.path.replace(/\//g, "\\");
        // }
        }
    }
    self.basename = props.basename = path.basename(self.path);
    self.dirname = props.dirname = path.dirname(self.path);
    // these have served their purpose, and are now just noisy clutter
    props.parent = props.root = null;
    // console.error("\n\n\n%s setting size to", props.path, props.size)
    self.size = props.size;
    self.filter = typeof props.filter === "function" ? props.filter : null;
    if (props.sort === "alpha") props.sort = alphasort;
    // start the ball rolling.
    // this will stat the thing, and then call self._read()
    // to start reading whatever it is.
    // console.error("calling stat", props.path, currentStat)
    self._stat(currentStat);
}
function alphasort(a, b) {
    return a === b ? 0 : a.toLowerCase() > b.toLowerCase() ? 1 : a.toLowerCase() < b.toLowerCase() ? -1 : a > b ? 1 : -1;
}
Reader.prototype._stat = function(currentStat) {
    var self = this;
    var props = self.props;
    var stat = props.follow ? "stat" : "lstat";
    // console.error("Reader._stat", self._path, currentStat)
    if (currentStat) process.nextTick(statCb.bind(null, null, currentStat));
    else fs[stat](self._path, statCb);
    function statCb(er, props_) {
        // console.error("Reader._stat, statCb", self._path, props_, props_.nlink)
        if (er) return self.error(er);
        Object.keys(props_).forEach(function(k) {
            props[k] = props_[k];
        });
        // if it's not the expected size, then abort here.
        if (undefined !== self.size && props.size !== self.size) {
            return self.error("incorrect size");
        }
        self.size = props.size;
        var type = getType(props);
        var handleHardlinks = props.hardlinks !== false;
        // special little thing for handling hardlinks.
        if (handleHardlinks && type !== "Directory" && props.nlink && props.nlink > 1) {
            var k = props.dev + ":" + props.ino;
            // console.error("Reader has nlink", self._path, k)
            if (hardLinks[k] === self._path || !hardLinks[k]) {
                hardLinks[k] = self._path;
            } else {
                // switch into hardlink mode.
                type = self.type = self.props.type = "Link";
                self.Link = self.props.Link = true;
                self.linkpath = self.props.linkpath = hardLinks[k];
                // console.error("Hardlink detected, switching mode", self._path, self.linkpath)
                // Setting __proto__ would arguably be the "correct"
                // approach here, but that just seems too wrong.
                self._stat = self._read = LinkReader.prototype._read;
            }
        }
        if (self.type && self.type !== type) {
            self.error("Unexpected type: " + type);
        }
        // if the filter doesn't pass, then just skip over this one.
        // still have to emit end so that dir-walking can move on.
        if (self.filter) {
            var who = self._proxy || self;
            // special handling for ProxyReaders
            if (!self.filter.call(who, who, props)) {
                if (!self._disowned) {
                    self.abort();
                    self.emit("end");
                    self.emit("close");
                }
                return;
            }
        }
        // last chance to abort or disown before the flow starts!
        var events = [
            "_stat",
            "stat",
            "ready"
        ];
        var e = 0;
        (function go() {
            if (self._aborted) {
                self.emit("end");
                self.emit("close");
                return;
            }
            if (self._paused && self.type !== "Directory") {
                self.once("resume", go);
                return;
            }
            var ev = events[e++];
            if (!ev) {
                return self._read();
            }
            self.emit(ev, props);
            go();
        })();
    }
};
Reader.prototype.pipe = function(dest) {
    var self = this;
    if (typeof dest.add === "function") {
        // piping to a multi-compatible, and we've got directory entries.
        self.on("entry", function(entry) {
            var ret = dest.add(entry);
            if (ret === false) {
                self.pause();
            }
        });
    }
    // console.error("R Pipe apply Stream Pipe")
    return Stream.prototype.pipe.apply(this, arguments);
};
Reader.prototype.pause = function(who) {
    this._paused = true;
    who = who || this;
    this.emit("pause", who);
    if (this._stream) this._stream.pause(who);
};
Reader.prototype.resume = function(who) {
    this._paused = false;
    who = who || this;
    this.emit("resume", who);
    if (this._stream) this._stream.resume(who);
    this._read();
};
Reader.prototype._read = function() {
    this.error("Cannot read unknown type: " + this.type);
};


/***/ }),

/***/ 74704:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Just get the stats, and then don't do anything.
// You can't really "read" from a socket.  You "connect" to it.
// Mostly, this is here so that reading a dir with a socket in it
// doesn't blow up.

module.exports = SocketReader;
var inherits = __webpack_require__(33834);
var Reader = __webpack_require__(54579);
inherits(SocketReader, Reader);
function SocketReader(props) {
    var self = this;
    if (!(self instanceof SocketReader)) {
        throw new Error("SocketReader must be called as constructor.");
    }
    if (!(props.type === "Socket" && props.Socket)) {
        throw new Error("Non-socket type " + props.type);
    }
    Reader.call(self, props);
}
SocketReader.prototype._read = function() {
    var self = this;
    if (self._paused) return;
    // basically just a no-op, since we got all the info we have
    // from the _stat method
    if (!self._ended) {
        self.emit("end");
        self.emit("close");
        self._ended = true;
    }
};


/***/ }),

/***/ 29000:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Writer;
var fs = __webpack_require__(33362);
var inherits = __webpack_require__(33834);
var rimraf = __webpack_require__(96076);
var mkdir = __webpack_require__(31196);
var path = __webpack_require__(71017);
var umask = process.platform === "win32" ? 0 : process.umask();
var getType = __webpack_require__(28582);
var Abstract = __webpack_require__(29554);
// Must do this *before* loading the child classes
inherits(Writer, Abstract);
Writer.dirmode = parseInt("0777", 8) & ~umask;
Writer.filemode = parseInt("0666", 8) & ~umask;
var DirWriter = __webpack_require__(15697);
var LinkWriter = __webpack_require__(8396);
var FileWriter = __webpack_require__(29742);
var ProxyWriter = __webpack_require__(27604);
// props is the desired state.  current is optionally the current stat,
// provided here so that subclasses can avoid statting the target
// more than necessary.
function Writer(props, current) {
    var self = this;
    if (typeof props === "string") {
        props = {
            path: props
        };
    }
    // polymorphism.
    // call fstream.Writer(dir) to get a DirWriter object, etc.
    var type = getType(props);
    var ClassType = Writer;
    switch(type){
        case "Directory":
            ClassType = DirWriter;
            break;
        case "File":
            ClassType = FileWriter;
            break;
        case "Link":
        case "SymbolicLink":
            ClassType = LinkWriter;
            break;
        case null:
        default:
            // Don't know yet what type to create, so we wrap in a proxy.
            ClassType = ProxyWriter;
            break;
    }
    if (!(self instanceof ClassType)) return new ClassType(props);
    // now get down to business.
    Abstract.call(self);
    if (!props.path) self.error("Must provide a path", null, true);
    // props is what we want to set.
    // set some convenience properties as well.
    self.type = props.type;
    self.props = props;
    self.depth = props.depth || 0;
    self.clobber = props.clobber === false ? props.clobber : true;
    self.parent = props.parent || null;
    self.root = props.root || props.parent && props.parent.root || self;
    self._path = self.path = path.resolve(props.path);
    if (process.platform === "win32") {
        self.path = self._path = self.path.replace(/\?/g, "_");
        if (self._path.length >= 260) {
            self._swallowErrors = true;
            self._path = "\\\\?\\" + self.path.replace(/\//g, "\\");
        }
    }
    self.basename = path.basename(props.path);
    self.dirname = path.dirname(props.path);
    self.linkpath = props.linkpath || null;
    props.parent = props.root = null;
    // console.error("\n\n\n%s setting size to", props.path, props.size)
    self.size = props.size;
    if (typeof props.mode === "string") {
        props.mode = parseInt(props.mode, 8);
    }
    self.readable = false;
    self.writable = true;
    // buffer until ready, or while handling another entry
    self._buffer = [];
    self.ready = false;
    self.filter = typeof props.filter === "function" ? props.filter : null;
    // start the ball rolling.
    // this checks what's there already, and then calls
    // self._create() to call the impl-specific creation stuff.
    self._stat(current);
}
// Calling this means that it's something we can't create.
// Just assert that it's already there, otherwise raise a warning.
Writer.prototype._create = function() {
    var self = this;
    fs[self.props.follow ? "stat" : "lstat"](self._path, function(er) {
        if (er) {
            return self.warn("Cannot create " + self._path + "\n" + "Unsupported type: " + self.type, "ENOTSUP");
        }
        self._finish();
    });
};
Writer.prototype._stat = function(current) {
    var self = this;
    var props = self.props;
    var stat = props.follow ? "stat" : "lstat";
    var who = self._proxy || self;
    if (current) statCb(null, current);
    else fs[stat](self._path, statCb);
    function statCb(er, current) {
        if (self.filter && !self.filter.call(who, who, current)) {
            self._aborted = true;
            self.emit("end");
            self.emit("close");
            return;
        }
        // if it's not there, great.  We'll just create it.
        // if it is there, then we'll need to change whatever differs
        if (er || !current) {
            return create(self);
        }
        self._old = current;
        var currentType = getType(current);
        // if it's a type change, then we need to clobber or error.
        // if it's not a type change, then let the impl take care of it.
        if (currentType !== self.type || self.type === "File" && current.nlink > 1) {
            return rimraf(self._path, function(er) {
                if (er) return self.error(er);
                self._old = null;
                create(self);
            });
        }
        // otherwise, just handle in the app-specific way
        // this creates a fs.WriteStream, or mkdir's, or whatever
        create(self);
    }
};
function create(self) {
    // console.error("W create", self._path, Writer.dirmode)
    // XXX Need to clobber non-dirs that are in the way,
    // unless { clobber: false } in the props.
    mkdir(path.dirname(self._path), Writer.dirmode, function(er, made) {
        // console.error("W created", path.dirname(self._path), er)
        if (er) return self.error(er);
        // later on, we have to set the mode and owner for these
        self._madeDir = made;
        return self._create();
    });
}
function endChmod(self, want, current, path, cb) {
    var wantMode = want.mode;
    var chmod = want.follow || self.type !== "SymbolicLink" ? "chmod" : "lchmod";
    if (!fs[chmod]) return cb();
    if (typeof wantMode !== "number") return cb();
    var curMode = current.mode & parseInt("0777", 8);
    wantMode = wantMode & parseInt("0777", 8);
    if (wantMode === curMode) return cb();
    fs[chmod](path, wantMode, cb);
}
function endChown(self, want, current, path, cb) {
    // Don't even try it unless root.  Too easy to EPERM.
    if (process.platform === "win32") return cb();
    if (!process.getuid || process.getuid() !== 0) return cb();
    if (typeof want.uid !== "number" && typeof want.gid !== "number") return cb();
    if (current.uid === want.uid && current.gid === want.gid) return cb();
    var chown = self.props.follow || self.type !== "SymbolicLink" ? "chown" : "lchown";
    if (!fs[chown]) return cb();
    if (typeof want.uid !== "number") want.uid = current.uid;
    if (typeof want.gid !== "number") want.gid = current.gid;
    fs[chown](path, want.uid, want.gid, cb);
}
function endUtimes(self, want, current, path, cb) {
    if (!fs.utimes || process.platform === "win32") return cb();
    var utimes = want.follow || self.type !== "SymbolicLink" ? "utimes" : "lutimes";
    if (utimes === "lutimes" && !fs[utimes]) {
        utimes = "utimes";
    }
    if (!fs[utimes]) return cb();
    var curA = current.atime;
    var curM = current.mtime;
    var meA = want.atime;
    var meM = want.mtime;
    if (meA === undefined) meA = curA;
    if (meM === undefined) meM = curM;
    if (!isDate(meA)) meA = new Date(meA);
    if (!isDate(meM)) meA = new Date(meM);
    if (meA.getTime() === curA.getTime() && meM.getTime() === curM.getTime()) return cb();
    fs[utimes](path, meA, meM, cb);
}
// XXX This function is beastly.  Break it up!
Writer.prototype._finish = function() {
    var self = this;
    if (self._finishing) return;
    self._finishing = true;
    // console.error(" W Finish", self._path, self.size)
    // set up all the things.
    // At this point, we're already done writing whatever we've gotta write,
    // adding files to the dir, etc.
    var todo = 0;
    var errState = null;
    var done = false;
    if (self._old) {
        // the times will almost *certainly* have changed.
        // adds the utimes syscall, but remove another stat.
        self._old.atime = new Date(0);
        self._old.mtime = new Date(0);
        // console.error(" W Finish Stale Stat", self._path, self.size)
        setProps(self._old);
    } else {
        var stat = self.props.follow ? "stat" : "lstat";
        // console.error(" W Finish Stating", self._path, self.size)
        fs[stat](self._path, function(er, current) {
            // console.error(" W Finish Stated", self._path, self.size, current)
            if (er) {
                // if we're in the process of writing out a
                // directory, it's very possible that the thing we're linking to
                // doesn't exist yet (especially if it was intended as a symlink),
                // so swallow ENOENT errors here and just soldier on.
                if (er.code === "ENOENT" && (self.type === "Link" || self.type === "SymbolicLink") && process.platform === "win32") {
                    self.ready = true;
                    self.emit("ready");
                    self.emit("end");
                    self.emit("close");
                    self.end = self._finish = function() {};
                    return;
                } else return self.error(er);
            }
            setProps(self._old = current);
        });
    }
    return;
    function setProps(current) {
        todo += 3;
        endChmod(self, self.props, current, self._path, next("chmod"));
        endChown(self, self.props, current, self._path, next("chown"));
        endUtimes(self, self.props, current, self._path, next("utimes"));
    }
    function next(what) {
        return function(er) {
            // console.error("   W Finish", what, todo)
            if (errState) return;
            if (er) {
                er.fstream_finish_call = what;
                return self.error(errState = er);
            }
            if (--todo > 0) return;
            if (done) return;
            done = true;
            // we may still need to set the mode/etc. on some parent dirs
            // that were created previously.  delay end/close until then.
            if (!self._madeDir) return end();
            else endMadeDir(self, self._path, end);
            function end(er) {
                if (er) {
                    er.fstream_finish_call = "setupMadeDir";
                    return self.error(er);
                }
                // all the props have been set, so we're completely done.
                self.emit("end");
                self.emit("close");
            }
        };
    }
};
function endMadeDir(self, p, cb) {
    var made = self._madeDir;
    // everything *between* made and path.dirname(self._path)
    // needs to be set up.  Note that this may just be one dir.
    var d = path.dirname(p);
    endMadeDir_(self, d, function(er) {
        if (er) return cb(er);
        if (d === made) {
            return cb();
        }
        endMadeDir(self, d, cb);
    });
}
function endMadeDir_(self, p, cb) {
    var dirProps = {};
    Object.keys(self.props).forEach(function(k) {
        dirProps[k] = self.props[k];
        // only make non-readable dirs if explicitly requested.
        if (k === "mode" && self.type !== "Directory") {
            dirProps[k] = dirProps[k] | parseInt("0111", 8);
        }
    });
    var todo = 3;
    var errState = null;
    fs.stat(p, function(er, current) {
        if (er) return cb(errState = er);
        endChmod(self, dirProps, current, p, next);
        endChown(self, dirProps, current, p, next);
        endUtimes(self, dirProps, current, p, next);
    });
    function next(er) {
        if (errState) return;
        if (er) return cb(errState = er);
        if (--todo === 0) return cb();
    }
}
Writer.prototype.pipe = function() {
    this.error("Can't pipe from writable stream");
};
Writer.prototype.add = function() {
    this.error("Can't add to non-Directory type");
};
Writer.prototype.write = function() {
    return true;
};
function objectToString(d) {
    return Object.prototype.toString.call(d);
}
function isDate(d) {
    return typeof d === "object" && objectToString(d) === "[object Date]";
}


/***/ }),

/***/ 38441:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.setopts = setopts;
exports.ownProp = ownProp;
exports.makeAbs = makeAbs;
exports.finish = finish;
exports.mark = mark;
exports.isIgnored = isIgnored;
exports.childrenIgnored = childrenIgnored;
function ownProp(obj, field) {
    return Object.prototype.hasOwnProperty.call(obj, field);
}
var fs = __webpack_require__(57147);
var path = __webpack_require__(71017);
var minimatch = __webpack_require__(56363);
var isAbsolute = __webpack_require__(16461);
var Minimatch = minimatch.Minimatch;
function alphasort(a, b) {
    return a.localeCompare(b, "en");
}
function setupIgnores(self, options) {
    self.ignore = options.ignore || [];
    if (!Array.isArray(self.ignore)) self.ignore = [
        self.ignore
    ];
    if (self.ignore.length) {
        self.ignore = self.ignore.map(ignoreMap);
    }
}
// ignore patterns are always in dot:true mode.
function ignoreMap(pattern) {
    var gmatcher = null;
    if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, {
            dot: true
        });
    }
    return {
        matcher: new Minimatch(pattern, {
            dot: true
        }),
        gmatcher: gmatcher
    };
}
function setopts(self, pattern, options) {
    if (!options) options = {};
    // base-matching: just use globstar for that.
    if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
            throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
    }
    self.silent = !!options.silent;
    self.pattern = pattern;
    self.strict = options.strict !== false;
    self.realpath = !!options.realpath;
    self.realpathCache = options.realpathCache || Object.create(null);
    self.follow = !!options.follow;
    self.dot = !!options.dot;
    self.mark = !!options.mark;
    self.nodir = !!options.nodir;
    if (self.nodir) self.mark = true;
    self.sync = !!options.sync;
    self.nounique = !!options.nounique;
    self.nonull = !!options.nonull;
    self.nosort = !!options.nosort;
    self.nocase = !!options.nocase;
    self.stat = !!options.stat;
    self.noprocess = !!options.noprocess;
    self.absolute = !!options.absolute;
    self.fs = options.fs || fs;
    self.maxLength = options.maxLength || Infinity;
    self.cache = options.cache || Object.create(null);
    self.statCache = options.statCache || Object.create(null);
    self.symlinks = options.symlinks || Object.create(null);
    setupIgnores(self, options);
    self.changedCwd = false;
    var cwd = process.cwd();
    if (!ownProp(options, "cwd")) self.cwd = cwd;
    else {
        self.cwd = path.resolve(options.cwd);
        self.changedCwd = self.cwd !== cwd;
    }
    self.root = options.root || path.resolve(self.cwd, "/");
    self.root = path.resolve(self.root);
    if (process.platform === "win32") self.root = self.root.replace(/\\/g, "/");
    // TODO: is an absolute `cwd` supposed to be resolved against `root`?
    // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
    self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
    if (process.platform === "win32") self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
    self.nomount = !!options.nomount;
    // disable comments and negation in Minimatch.
    // Note that they are not supported in Glob itself anyway.
    options.nonegate = true;
    options.nocomment = true;
    // always treat \ in patterns as escapes, not path separators
    options.allowWindowsEscape = false;
    self.minimatch = new Minimatch(pattern, options);
    self.options = self.minimatch.options;
}
function finish(self) {
    var nou = self.nounique;
    var all = nou ? [] : Object.create(null);
    for(var i = 0, l = self.matches.length; i < l; i++){
        var matches = self.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
            if (self.nonull) {
                // do like the shell, and spit out the literal glob
                var literal = self.minimatch.globSet[i];
                if (nou) all.push(literal);
                else all[literal] = true;
            }
        } else {
            // had matches
            var m = Object.keys(matches);
            if (nou) all.push.apply(all, m);
            else m.forEach(function(m) {
                all[m] = true;
            });
        }
    }
    if (!nou) all = Object.keys(all);
    if (!self.nosort) all = all.sort(alphasort);
    // at *some* point we statted all of these
    if (self.mark) {
        for(var i = 0; i < all.length; i++){
            all[i] = self._mark(all[i]);
        }
        if (self.nodir) {
            all = all.filter(function(e) {
                var notDir = !/\/$/.test(e);
                var c = self.cache[e] || self.cache[makeAbs(self, e)];
                if (notDir && c) notDir = c !== "DIR" && !Array.isArray(c);
                return notDir;
            });
        }
    }
    if (self.ignore.length) all = all.filter(function(m) {
        return !isIgnored(self, m);
    });
    self.found = all;
}
function mark(self, p) {
    var abs = makeAbs(self, p);
    var c = self.cache[abs];
    var m = p;
    if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash) m += "/";
        else if (!isDir && slash) m = m.slice(0, -1);
        if (m !== p) {
            var mabs = makeAbs(self, m);
            self.statCache[mabs] = self.statCache[abs];
            self.cache[mabs] = self.cache[abs];
        }
    }
    return m;
}
// lotta situps...
function makeAbs(self, f) {
    var abs = f;
    if (f.charAt(0) === "/") {
        abs = path.join(self.root, f);
    } else if (isAbsolute(f) || f === "") {
        abs = f;
    } else if (self.changedCwd) {
        abs = path.resolve(self.cwd, f);
    } else {
        abs = path.resolve(f);
    }
    if (process.platform === "win32") abs = abs.replace(/\\/g, "/");
    return abs;
}
// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored(self, path) {
    if (!self.ignore.length) return false;
    return self.ignore.some(function(item) {
        return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path));
    });
}
function childrenIgnored(self, path) {
    if (!self.ignore.length) return false;
    return self.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path));
    });
}


/***/ }),

/***/ 85642:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob;
var rp = __webpack_require__(5426);
var minimatch = __webpack_require__(56363);
var Minimatch = minimatch.Minimatch;
var inherits = __webpack_require__(33834);
var EE = (__webpack_require__(82361).EventEmitter);
var path = __webpack_require__(71017);
var assert = __webpack_require__(39491);
var isAbsolute = __webpack_require__(16461);
var globSync = __webpack_require__(81870);
var common = __webpack_require__(38441);
var setopts = common.setopts;
var ownProp = common.ownProp;
var inflight = __webpack_require__(92150);
var util = __webpack_require__(73837);
var childrenIgnored = common.childrenIgnored;
var isIgnored = common.isIgnored;
var once = __webpack_require__(59517);
function glob(pattern, options, cb) {
    if (typeof options === "function") cb = options, options = {};
    if (!options) options = {};
    if (options.sync) {
        if (cb) throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
    }
    return new Glob(pattern, options, cb);
}
glob.sync = globSync;
var GlobSync = glob.GlobSync = globSync.GlobSync;
// old api surface
glob.glob = glob;
function extend(origin, add) {
    if (add === null || typeof add !== "object") {
        return origin;
    }
    var keys = Object.keys(add);
    var i = keys.length;
    while(i--){
        origin[keys[i]] = add[keys[i]];
    }
    return origin;
}
glob.hasMagic = function(pattern, options_) {
    var options = extend({}, options_);
    options.noprocess = true;
    var g = new Glob(pattern, options);
    var set = g.minimatch.set;
    if (!pattern) return false;
    if (set.length > 1) return true;
    for(var j = 0; j < set[0].length; j++){
        if (typeof set[0][j] !== "string") return true;
    }
    return false;
};
glob.Glob = Glob;
inherits(Glob, EE);
function Glob(pattern, options, cb) {
    if (typeof options === "function") {
        cb = options;
        options = null;
    }
    if (options && options.sync) {
        if (cb) throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
    }
    if (!(this instanceof Glob)) return new Glob(pattern, options, cb);
    setopts(this, pattern, options);
    this._didRealPath = false;
    // process each pattern in the minimatch set
    var n = this.minimatch.set.length;
    // The matches are stored as {<filename>: true,...} so that
    // duplicates are automagically pruned.
    // Later, we do an Object.keys() on these.
    // Keep them as a list so we can fill in when nonull is set.
    this.matches = new Array(n);
    if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
            cb(null, matches);
        });
    }
    var self = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess) return this;
    if (n === 0) return done();
    var sync = true;
    for(var i = 0; i < n; i++){
        this._process(this.minimatch.set[i], i, false, done);
    }
    sync = false;
    function done() {
        --self._processing;
        if (self._processing <= 0) {
            if (sync) {
                process.nextTick(function() {
                    self._finish();
                });
            } else {
                self._finish();
            }
        }
    }
}
Glob.prototype._finish = function() {
    assert(this instanceof Glob);
    if (this.aborted) return;
    if (this.realpath && !this._didRealpath) return this._realpath();
    common.finish(this);
    this.emit("end", this.found);
};
Glob.prototype._realpath = function() {
    if (this._didRealpath) return;
    this._didRealpath = true;
    var n = this.matches.length;
    if (n === 0) return this._finish();
    var self = this;
    for(var i = 0; i < this.matches.length; i++)this._realpathSet(i, next);
    function next() {
        if (--n === 0) self._finish();
    }
};
Glob.prototype._realpathSet = function(index, cb) {
    var matchset = this.matches[index];
    if (!matchset) return cb();
    var found = Object.keys(matchset);
    var self = this;
    var n = found.length;
    if (n === 0) return cb();
    var set = this.matches[index] = Object.create(null);
    found.forEach(function(p, i) {
        // If there's a problem with the stat, then it means that
        // one or more of the links in the realpath couldn't be
        // resolved.  just return the abs value in that case.
        p = self._makeAbs(p);
        rp.realpath(p, self.realpathCache, function(er, real) {
            if (!er) set[real] = true;
            else if (er.syscall === "stat") set[p] = true;
            else self.emit("error", er) // srsly wtf right here
            ;
            if (--n === 0) {
                self.matches[index] = set;
                cb();
            }
        });
    });
};
Glob.prototype._mark = function(p) {
    return common.mark(this, p);
};
Glob.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
};
Glob.prototype.abort = function() {
    this.aborted = true;
    this.emit("abort");
};
Glob.prototype.pause = function() {
    if (!this.paused) {
        this.paused = true;
        this.emit("pause");
    }
};
Glob.prototype.resume = function() {
    if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
            var eq = this._emitQueue.slice(0);
            this._emitQueue.length = 0;
            for(var i = 0; i < eq.length; i++){
                var e = eq[i];
                this._emitMatch(e[0], e[1]);
            }
        }
        if (this._processQueue.length) {
            var pq = this._processQueue.slice(0);
            this._processQueue.length = 0;
            for(var i = 0; i < pq.length; i++){
                var p = pq[i];
                this._processing--;
                this._process(p[0], p[1], p[2], p[3]);
            }
        }
    }
};
Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
    assert(this instanceof Glob);
    assert(typeof cb === "function");
    if (this.aborted) return;
    this._processing++;
    if (this.paused) {
        this._processQueue.push([
            pattern,
            index,
            inGlobStar,
            cb
        ]);
        return;
    }
    //console.error('PROCESS %d', this._processing, pattern)
    // Get the first [n] parts of pattern that are all strings.
    var n = 0;
    while(typeof pattern[n] === "string"){
        n++;
    }
    // now n is the index of the first one that is *not* a string.
    // see if there's anything else
    var prefix;
    switch(n){
        // if not, then this is rather simple
        case pattern.length:
            this._processSimple(pattern.join("/"), index, cb);
            return;
        case 0:
            // pattern *starts* with some non-trivial item.
            // going to readdir(cwd), but not include the prefix in matches.
            prefix = null;
            break;
        default:
            // pattern has some string bits in the front.
            // whatever it starts with, whether that's 'absolute' like /foo/bar,
            // or 'relative' like '../baz'
            prefix = pattern.slice(0, n).join("/");
            break;
    }
    var remain = pattern.slice(n);
    // get the list of entries.
    var read;
    if (prefix === null) read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
    }).join("/"))) {
        if (!prefix || !isAbsolute(prefix)) prefix = "/" + prefix;
        read = prefix;
    } else read = prefix;
    var abs = this._makeAbs(read);
    //if ignored, skip _processing
    if (childrenIgnored(this, read)) return cb();
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
    else this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
};
Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
};
Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    // if the abs isn't a dir, then nothing can match!
    if (!entries) return cb();
    // It will only match dot entries if it starts with a dot, or if
    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for(var i = 0; i < entries.length; i++){
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
            var m;
            if (negate && !prefix) {
                m = !e.match(pn);
            } else {
                m = e.match(pn);
            }
            if (m) matchedEntries.push(e);
        }
    }
    //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)
    var len = matchedEntries.length;
    // If there are no matched entries, then nothing matches.
    if (len === 0) return cb();
    // if this is the last remaining pattern bit, then no need for
    // an additional stat *unless* the user has specified mark or
    // stat explicitly.  We know they exist, since readdir returned
    // them.
    if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index]) this.matches[index] = Object.create(null);
        for(var i = 0; i < len; i++){
            var e = matchedEntries[i];
            if (prefix) {
                if (prefix !== "/") e = prefix + "/" + e;
                else e = prefix + e;
            }
            if (e.charAt(0) === "/" && !this.nomount) {
                e = path.join(this.root, e);
            }
            this._emitMatch(index, e);
        }
        // This was the last one, and no stats were needed
        return cb();
    }
    // now test all matched entries as stand-ins for that part
    // of the pattern.
    remain.shift();
    for(var i = 0; i < len; i++){
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
            if (prefix !== "/") e = prefix + "/" + e;
            else e = prefix + e;
        }
        this._process([
            e
        ].concat(remain), index, inGlobStar, cb);
    }
    cb();
};
Glob.prototype._emitMatch = function(index, e) {
    if (this.aborted) return;
    if (isIgnored(this, e)) return;
    if (this.paused) {
        this._emitQueue.push([
            index,
            e
        ]);
        return;
    }
    var abs = isAbsolute(e) ? e : this._makeAbs(e);
    if (this.mark) e = this._mark(e);
    if (this.absolute) e = abs;
    if (this.matches[index][e]) return;
    if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c)) return;
    }
    this.matches[index][e] = true;
    var st = this.statCache[abs];
    if (st) this.emit("stat", e, st);
    this.emit("match", e);
};
Glob.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted) return;
    // follow all symlinked directories forever
    // just proceed as if this is a non-globstar situation
    if (this.follow) return this._readdir(abs, false, cb);
    var lstatkey = "lstat\x00" + abs;
    var self = this;
    var lstatcb = inflight(lstatkey, lstatcb_);
    if (lstatcb) self.fs.lstat(abs, lstatcb);
    function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT") return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self.symlinks[abs] = isSym;
        // If it's not a symlink or a dir, then it's definitely a regular file.
        // don't bother doing a readdir in that case.
        if (!isSym && lstat && !lstat.isDirectory()) {
            self.cache[abs] = "FILE";
            cb();
        } else self._readdir(abs, false, cb);
    }
};
Glob.prototype._readdir = function(abs, inGlobStar, cb) {
    if (this.aborted) return;
    cb = inflight("readdir\x00" + abs + "\x00" + inGlobStar, cb);
    if (!cb) return;
    //console.error('RD %j %j', +inGlobStar, abs)
    if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb);
    if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE") return cb();
        if (Array.isArray(c)) return cb(null, c);
    }
    var self = this;
    self.fs.readdir(abs, readdirCb(this, abs, cb));
};
function readdirCb(self, abs, cb) {
    return function(er, entries) {
        if (er) self._readdirError(abs, er, cb);
        else self._readdirEntries(abs, entries, cb);
    };
}
Glob.prototype._readdirEntries = function(abs, entries, cb) {
    if (this.aborted) return;
    // if we haven't asked to stat everything, then just
    // assume that everything in there exists, so we can avoid
    // having to stat it a second time.
    if (!this.mark && !this.stat) {
        for(var i = 0; i < entries.length; i++){
            var e = entries[i];
            if (abs === "/") e = abs + e;
            else e = abs + "/" + e;
            this.cache[e] = true;
        }
    }
    this.cache[abs] = entries;
    return cb(null, entries);
};
Glob.prototype._readdirError = function(f, er, cb) {
    if (this.aborted) return;
    // handle errors, and cache the information
    switch(er.code){
        case "ENOTSUP":
        case "ENOTDIR":
            var abs = this._makeAbs(f);
            this.cache[abs] = "FILE";
            if (abs === this.cwdAbs) {
                var error = new Error(er.code + " invalid cwd " + this.cwd);
                error.path = this.cwd;
                error.code = er.code;
                this.emit("error", error);
                this.abort();
            }
            break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
            this.cache[this._makeAbs(f)] = false;
            break;
        default:
            this.cache[this._makeAbs(f)] = false;
            if (this.strict) {
                this.emit("error", er);
                // If the error is handled, then we abort
                // if not, we threw out of here
                this.abort();
            }
            if (!this.silent) console.error("glob error", er);
            break;
    }
    return cb();
};
Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
};
Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    //console.error('pgs2', prefix, remain[0], entries)
    // no entries means not a dir, so it can never have matches
    // foo.txt/** doesn't match foo.txt
    if (!entries) return cb();
    // test without the globstar, and with every child both below
    // and replacing the globstar.
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [
        prefix
    ] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    // the noGlobStar pattern exits the inGlobStar state
    this._process(noGlobStar, index, false, cb);
    var isSym = this.symlinks[abs];
    var len = entries.length;
    // If it's a symlink, and we're in a globstar, then stop
    if (isSym && inGlobStar) return cb();
    for(var i = 0; i < len; i++){
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot) continue;
        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
    }
    cb();
};
Glob.prototype._processSimple = function(prefix, index, cb) {
    // XXX review this.  Shouldn't it be doing the mounting etc
    // before doing stat?  kinda weird?
    var self = this;
    this._stat(prefix, function(er, exists) {
        self._processSimple2(prefix, index, er, exists, cb);
    });
};
Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
    //console.error('ps2', prefix, exists)
    if (!this.matches[index]) this.matches[index] = Object.create(null);
    // If it doesn't exist, then just mark the lack of results
    if (!exists) return cb();
    if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
            prefix = path.join(this.root, prefix);
        } else {
            prefix = path.resolve(this.root, prefix);
            if (trail) prefix += "/";
        }
    }
    if (process.platform === "win32") prefix = prefix.replace(/\\/g, "/");
    // Mark this as a match
    this._emitMatch(index, prefix);
    cb();
};
// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function(f, cb) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength) return cb();
    if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c)) c = "DIR";
        // It exists, but maybe not how we need it
        if (!needDir || c === "DIR") return cb(null, c);
        if (needDir && c === "FILE") return cb();
    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
    }
    var exists;
    var stat = this.statCache[abs];
    if (stat !== undefined) {
        if (stat === false) return cb(null, stat);
        else {
            var type = stat.isDirectory() ? "DIR" : "FILE";
            if (needDir && type === "FILE") return cb();
            else return cb(null, type, stat);
        }
    }
    var self = this;
    var statcb = inflight("stat\x00" + abs, lstatcb_);
    if (statcb) self.fs.lstat(abs, statcb);
    function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
            // If it's a symlink, then treat it as the target, unless
            // the target does not exist, then treat it as a file.
            return self.fs.stat(abs, function(er, stat) {
                if (er) self._stat2(f, abs, null, lstat, cb);
                else self._stat2(f, abs, er, stat, cb);
            });
        } else {
            self._stat2(f, abs, er, lstat, cb);
        }
    }
};
Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
    }
    var needDir = f.slice(-1) === "/";
    this.statCache[abs] = stat;
    if (abs.slice(-1) === "/" && stat && !stat.isDirectory()) return cb(null, false, stat);
    var c = true;
    if (stat) c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE") return cb();
    return cb(null, c, stat);
};


/***/ }),

/***/ 81870:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = globSync;
globSync.GlobSync = GlobSync;
var rp = __webpack_require__(5426);
var minimatch = __webpack_require__(56363);
var Minimatch = minimatch.Minimatch;
var Glob = (__webpack_require__(85642).Glob);
var util = __webpack_require__(73837);
var path = __webpack_require__(71017);
var assert = __webpack_require__(39491);
var isAbsolute = __webpack_require__(16461);
var common = __webpack_require__(38441);
var setopts = common.setopts;
var ownProp = common.ownProp;
var childrenIgnored = common.childrenIgnored;
var isIgnored = common.isIgnored;
function globSync(pattern, options) {
    if (typeof options === "function" || arguments.length === 3) throw new TypeError("callback provided to sync glob\n" + "See: https://github.com/isaacs/node-glob/issues/167");
    return new GlobSync(pattern, options).found;
}
function GlobSync(pattern, options) {
    if (!pattern) throw new Error("must provide pattern");
    if (typeof options === "function" || arguments.length === 3) throw new TypeError("callback provided to sync glob\n" + "See: https://github.com/isaacs/node-glob/issues/167");
    if (!(this instanceof GlobSync)) return new GlobSync(pattern, options);
    setopts(this, pattern, options);
    if (this.noprocess) return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for(var i = 0; i < n; i++){
        this._process(this.minimatch.set[i], i, false);
    }
    this._finish();
}
GlobSync.prototype._finish = function() {
    assert.ok(this instanceof GlobSync);
    if (this.realpath) {
        var self = this;
        this.matches.forEach(function(matchset, index) {
            var set = self.matches[index] = Object.create(null);
            for(var p in matchset){
                try {
                    p = self._makeAbs(p);
                    var real = rp.realpathSync(p, self.realpathCache);
                    set[real] = true;
                } catch (er) {
                    if (er.syscall === "stat") set[self._makeAbs(p)] = true;
                    else throw er;
                }
            }
        });
    }
    common.finish(this);
};
GlobSync.prototype._process = function(pattern, index, inGlobStar) {
    assert.ok(this instanceof GlobSync);
    // Get the first [n] parts of pattern that are all strings.
    var n = 0;
    while(typeof pattern[n] === "string"){
        n++;
    }
    // now n is the index of the first one that is *not* a string.
    // See if there's anything else
    var prefix;
    switch(n){
        // if not, then this is rather simple
        case pattern.length:
            this._processSimple(pattern.join("/"), index);
            return;
        case 0:
            // pattern *starts* with some non-trivial item.
            // going to readdir(cwd), but not include the prefix in matches.
            prefix = null;
            break;
        default:
            // pattern has some string bits in the front.
            // whatever it starts with, whether that's 'absolute' like /foo/bar,
            // or 'relative' like '../baz'
            prefix = pattern.slice(0, n).join("/");
            break;
    }
    var remain = pattern.slice(n);
    // get the list of entries.
    var read;
    if (prefix === null) read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
    }).join("/"))) {
        if (!prefix || !isAbsolute(prefix)) prefix = "/" + prefix;
        read = prefix;
    } else read = prefix;
    var abs = this._makeAbs(read);
    //if ignored, skip processing
    if (childrenIgnored(this, read)) return;
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
    else this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
};
GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    // if the abs isn't a dir, then nothing can match!
    if (!entries) return;
    // It will only match dot entries if it starts with a dot, or if
    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for(var i = 0; i < entries.length; i++){
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
            var m;
            if (negate && !prefix) {
                m = !e.match(pn);
            } else {
                m = e.match(pn);
            }
            if (m) matchedEntries.push(e);
        }
    }
    var len = matchedEntries.length;
    // If there are no matched entries, then nothing matches.
    if (len === 0) return;
    // if this is the last remaining pattern bit, then no need for
    // an additional stat *unless* the user has specified mark or
    // stat explicitly.  We know they exist, since readdir returned
    // them.
    if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index]) this.matches[index] = Object.create(null);
        for(var i = 0; i < len; i++){
            var e = matchedEntries[i];
            if (prefix) {
                if (prefix.slice(-1) !== "/") e = prefix + "/" + e;
                else e = prefix + e;
            }
            if (e.charAt(0) === "/" && !this.nomount) {
                e = path.join(this.root, e);
            }
            this._emitMatch(index, e);
        }
        // This was the last one, and no stats were needed
        return;
    }
    // now test all matched entries as stand-ins for that part
    // of the pattern.
    remain.shift();
    for(var i = 0; i < len; i++){
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) newPattern = [
            prefix,
            e
        ];
        else newPattern = [
            e
        ];
        this._process(newPattern.concat(remain), index, inGlobStar);
    }
};
GlobSync.prototype._emitMatch = function(index, e) {
    if (isIgnored(this, e)) return;
    var abs = this._makeAbs(e);
    if (this.mark) e = this._mark(e);
    if (this.absolute) {
        e = abs;
    }
    if (this.matches[index][e]) return;
    if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c)) return;
    }
    this.matches[index][e] = true;
    if (this.stat) this._stat(e);
};
GlobSync.prototype._readdirInGlobStar = function(abs) {
    // follow all symlinked directories forever
    // just proceed as if this is a non-globstar situation
    if (this.follow) return this._readdir(abs, false);
    var entries;
    var lstat;
    var stat;
    try {
        lstat = this.fs.lstatSync(abs);
    } catch (er) {
        if (er.code === "ENOENT") {
            // lstat failed, doesn't exist
            return null;
        }
    }
    var isSym = lstat && lstat.isSymbolicLink();
    this.symlinks[abs] = isSym;
    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) this.cache[abs] = "FILE";
    else entries = this._readdir(abs, false);
    return entries;
};
GlobSync.prototype._readdir = function(abs, inGlobStar) {
    var entries;
    if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs);
    if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE") return null;
        if (Array.isArray(c)) return c;
    }
    try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
    } catch (er) {
        this._readdirError(abs, er);
        return null;
    }
};
GlobSync.prototype._readdirEntries = function(abs, entries) {
    // if we haven't asked to stat everything, then just
    // assume that everything in there exists, so we can avoid
    // having to stat it a second time.
    if (!this.mark && !this.stat) {
        for(var i = 0; i < entries.length; i++){
            var e = entries[i];
            if (abs === "/") e = abs + e;
            else e = abs + "/" + e;
            this.cache[e] = true;
        }
    }
    this.cache[abs] = entries;
    // mark and cache dir-ness
    return entries;
};
GlobSync.prototype._readdirError = function(f, er) {
    // handle errors, and cache the information
    switch(er.code){
        case "ENOTSUP":
        case "ENOTDIR":
            var abs = this._makeAbs(f);
            this.cache[abs] = "FILE";
            if (abs === this.cwdAbs) {
                var error = new Error(er.code + " invalid cwd " + this.cwd);
                error.path = this.cwd;
                error.code = er.code;
                throw error;
            }
            break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
            this.cache[this._makeAbs(f)] = false;
            break;
        default:
            this.cache[this._makeAbs(f)] = false;
            if (this.strict) throw er;
            if (!this.silent) console.error("glob error", er);
            break;
    }
};
GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    // no entries means not a dir, so it can never have matches
    // foo.txt/** doesn't match foo.txt
    if (!entries) return;
    // test without the globstar, and with every child both below
    // and replacing the globstar.
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [
        prefix
    ] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    // the noGlobStar pattern exits the inGlobStar state
    this._process(noGlobStar, index, false);
    var len = entries.length;
    var isSym = this.symlinks[abs];
    // If it's a symlink, and we're in a globstar, then stop
    if (isSym && inGlobStar) return;
    for(var i = 0; i < len; i++){
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot) continue;
        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
    }
};
GlobSync.prototype._processSimple = function(prefix, index) {
    // XXX review this.  Shouldn't it be doing the mounting etc
    // before doing stat?  kinda weird?
    var exists = this._stat(prefix);
    if (!this.matches[index]) this.matches[index] = Object.create(null);
    // If it doesn't exist, then just mark the lack of results
    if (!exists) return;
    if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
            prefix = path.join(this.root, prefix);
        } else {
            prefix = path.resolve(this.root, prefix);
            if (trail) prefix += "/";
        }
    }
    if (process.platform === "win32") prefix = prefix.replace(/\\/g, "/");
    // Mark this as a match
    this._emitMatch(index, prefix);
};
// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function(f) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength) return false;
    if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c)) c = "DIR";
        // It exists, but maybe not how we need it
        if (!needDir || c === "DIR") return c;
        if (needDir && c === "FILE") return false;
    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
    }
    var exists;
    var stat = this.statCache[abs];
    if (!stat) {
        var lstat;
        try {
            lstat = this.fs.lstatSync(abs);
        } catch (er) {
            if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
                this.statCache[abs] = false;
                return false;
            }
        }
        if (lstat && lstat.isSymbolicLink()) {
            try {
                stat = this.fs.statSync(abs);
            } catch (er) {
                stat = lstat;
            }
        } else {
            stat = lstat;
        }
    }
    this.statCache[abs] = stat;
    var c = true;
    if (stat) c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE") return false;
    return c;
};
GlobSync.prototype._mark = function(p) {
    return common.mark(this, p);
};
GlobSync.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
};


/***/ }),

/***/ 61295:
/***/ ((module) => {

"use strict";

module.exports = clone;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
};
function clone(obj) {
    if (obj === null || typeof obj !== "object") return obj;
    if (obj instanceof Object) var copy = {
        __proto__: getPrototypeOf(obj)
    };
    else var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
}


/***/ }),

/***/ 33362:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fs = __webpack_require__(57147);
var polyfills = __webpack_require__(19241);
var legacy = __webpack_require__(92935);
var clone = __webpack_require__(61295);
var util = __webpack_require__(73837);
/* istanbul ignore next - node 0.x polyfill */ var gracefulQueue;
var previousSymbol;
/* istanbul ignore else - node 0.x polyfill */ if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    // This is used in testing by future versions
    previousSymbol = Symbol.for("graceful-fs.previous");
} else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
}
function noop() {}
function publishQueue(context, queue) {
    Object.defineProperty(context, gracefulQueue, {
        get: function() {
            return queue;
        }
    });
}
var debug = noop;
if (util.debuglog) debug = util.debuglog("gfs4");
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) debug = function() {
    var m = util.format.apply(util, arguments);
    m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
    console.error(m);
};
// Once time initialization
if (!fs[gracefulQueue]) {
    // This queue can be shared by multiple loaded instances
    var queue = global[gracefulQueue] || [];
    publishQueue(fs, queue);
    // Patch fs.close/closeSync to shared queue version, because we need
    // to retry() whenever a close happens *anywhere* in the program.
    // This is essential when multiple graceful-fs instances are
    // in play at the same time.
    fs.close = function(fs$close) {
        function close(fd, cb) {
            return fs$close.call(fs, fd, function(err) {
                // This function uses the graceful-fs shared queue
                if (!err) {
                    resetQueue();
                }
                if (typeof cb === "function") cb.apply(this, arguments);
            });
        }
        Object.defineProperty(close, previousSymbol, {
            value: fs$close
        });
        return close;
    }(fs.close);
    fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
            // This function uses the graceful-fs shared queue
            fs$closeSync.apply(fs, arguments);
            resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
            value: fs$closeSync
        });
        return closeSync;
    }(fs.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
            debug(fs[gracefulQueue]);
            (__webpack_require__(39491).equal)(fs[gracefulQueue].length, 0);
        });
    }
}
if (!global[gracefulQueue]) {
    publishQueue(global, fs[gracefulQueue]);
}
module.exports = patch(clone(fs));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs);
    fs.__patched = true;
}
function patch(fs) {
    // Everything that references the open() function needs to be in here
    polyfills(fs);
    fs.gracefulify = patch;
    fs.createReadStream = createReadStream;
    fs.createWriteStream = createWriteStream;
    var fs$readFile = fs.readFile;
    fs.readFile = readFile;
    function readFile(path, options, cb) {
        if (typeof options === "function") cb = options, options = null;
        return go$readFile(path, options, cb);
        function go$readFile(path, options, cb, startTime) {
            return fs$readFile(path, options, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
                    go$readFile,
                    [
                        path,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === "function") cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$writeFile = fs.writeFile;
    fs.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
        if (typeof options === "function") cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        function go$writeFile(path, data, options, cb, startTime) {
            return fs$writeFile(path, data, options, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
                    go$writeFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === "function") cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$appendFile = fs.appendFile;
    if (fs$appendFile) fs.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
        if (typeof options === "function") cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        function go$appendFile(path, data, options, cb, startTime) {
            return fs$appendFile(path, data, options, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
                    go$appendFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === "function") cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$copyFile = fs.copyFile;
    if (fs$copyFile) fs.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
            cb = flags;
            flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src, dest, flags, cb, startTime) {
            return fs$copyFile(src, dest, flags, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
                    go$copyFile,
                    [
                        src,
                        dest,
                        flags,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === "function") cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$readdir = fs.readdir;
    fs.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
        if (typeof options === "function") cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path, options, cb, startTime) {
            return fs$readdir(path, fs$readdirCallback(path, options, cb, startTime));
        } : function go$readdir(path, options, cb, startTime) {
            return fs$readdir(path, options, fs$readdirCallback(path, options, cb, startTime));
        };
        return go$readdir(path, options, cb);
        function fs$readdirCallback(path, options, cb, startTime) {
            return function(err, files) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
                    go$readdir,
                    [
                        path,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (files && files.sort) files.sort();
                    if (typeof cb === "function") cb.call(this, err, files);
                }
            };
        }
    }
    if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs.ReadStream;
    if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs.WriteStream;
    if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs, "ReadStream", {
        get: function() {
            return ReadStream;
        },
        set: function(val) {
            ReadStream = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(fs, "WriteStream", {
        get: function() {
            return WriteStream;
        },
        set: function(val) {
            WriteStream = val;
        },
        enumerable: true,
        configurable: true
    });
    // legacy names
    var FileReadStream = ReadStream;
    Object.defineProperty(fs, "FileReadStream", {
        get: function() {
            return FileReadStream;
        },
        set: function(val) {
            FileReadStream = val;
        },
        enumerable: true,
        configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs, "FileWriteStream", {
        get: function() {
            return FileWriteStream;
        },
        set: function(val) {
            FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
    });
    function ReadStream(path, options) {
        if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;
        else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
                if (that.autoClose) that.destroy();
                that.emit("error", err);
            } else {
                that.fd = fd;
                that.emit("open", fd);
                that.read();
            }
        });
    }
    function WriteStream(path, options) {
        if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;
        else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
                that.destroy();
                that.emit("error", err);
            } else {
                that.fd = fd;
                that.emit("open", fd);
            }
        });
    }
    function createReadStream(path, options) {
        return new fs.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
        return new fs.WriteStream(path, options);
    }
    var fs$open = fs.open;
    fs.open = open;
    function open(path, flags, mode, cb) {
        if (typeof mode === "function") cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        function go$open(path, flags, mode, cb, startTime) {
            return fs$open(path, flags, mode, function(err, fd) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) enqueue([
                    go$open,
                    [
                        path,
                        flags,
                        mode,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === "function") cb.apply(this, arguments);
                }
            });
        }
    }
    return fs;
}
function enqueue(elem) {
    debug("ENQUEUE", elem[0].name, elem[1]);
    fs[gracefulQueue].push(elem);
    retry();
}
// keep track of the timeout between retry() calls
var retryTimer;
// reset the startTime and lastTime to now
// this resets the start of the 60 second overall timeout as well as the
// delay between attempts so that we'll retry these jobs sooner
function resetQueue() {
    var now = Date.now();
    for(var i = 0; i < fs[gracefulQueue].length; ++i){
        // entries that are only a length of 2 are from an older version, don't
        // bother modifying those since they'll be retried anyway.
        if (fs[gracefulQueue][i].length > 2) {
            fs[gracefulQueue][i][3] = now // startTime
            ;
            fs[gracefulQueue][i][4] = now // lastTime
            ;
        }
    }
    // call retry to make sure we're actively processing the queue
    retry();
}
function retry() {
    // clear the timer and remove it to help prevent unintended concurrency
    clearTimeout(retryTimer);
    retryTimer = undefined;
    if (fs[gracefulQueue].length === 0) return;
    var elem = fs[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    // these items may be unset if they were added by an older graceful-fs
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    // if we don't have a startTime we have no way of knowing if we've waited
    // long enough, so go ahead and retry this item now
    if (startTime === undefined) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
    } else if (Date.now() - startTime >= 60000) {
        // it's been more than 60 seconds total, bail now
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function") cb.call(null, err);
    } else {
        // the amount of time between the last attempt and right now
        var sinceAttempt = Date.now() - lastTime;
        // the amount of time between when we first tried, and when we last tried
        // rounded up to at least 1
        var sinceStart = Math.max(lastTime - startTime, 1);
        // backoff. wait longer than the total time we've been retrying, but only
        // up to a maximum of 100ms
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        // it's been long enough since the last retry, do it again
        if (sinceAttempt >= desiredDelay) {
            debug("RETRY", fn.name, args);
            fn.apply(null, args.concat([
                startTime
            ]));
        } else {
            // if we can't do this job yet, push it to the end of the queue
            // and let the next iteration check again
            fs[gracefulQueue].push(elem);
        }
    }
    // schedule our next run if one isn't already scheduled
    if (retryTimer === undefined) {
        retryTimer = setTimeout(retry, 0);
    }
}


/***/ }),

/***/ 92935:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Stream = (__webpack_require__(12781).Stream);
module.exports = legacy;
function legacy(fs) {
    return {
        ReadStream: ReadStream,
        WriteStream: WriteStream
    };
    function ReadStream(path, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options);
        Stream.call(this);
        var self = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438; /*=0666*/ 
        this.bufferSize = 64 * 1024;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== undefined) {
            if ("number" !== typeof this.start) {
                throw TypeError("start must be a Number");
            }
            if (this.end === undefined) {
                this.end = Infinity;
            } else if ("number" !== typeof this.end) {
                throw TypeError("end must be a Number");
            }
            if (this.start > this.end) {
                throw new Error("start must be <= end");
            }
            this.pos = this.start;
        }
        if (this.fd !== null) {
            process.nextTick(function() {
                self._read();
            });
            return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
            if (err) {
                self.emit("error", err);
                self.readable = false;
                return;
            }
            self.fd = fd;
            self.emit("open", fd);
            self._read();
        });
    }
    function WriteStream(path, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438; /*=0666*/ 
        this.bytesWritten = 0;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.start !== undefined) {
            if ("number" !== typeof this.start) {
                throw TypeError("start must be a Number");
            }
            if (this.start < 0) {
                throw new Error("start must be >= zero");
            }
            this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
            this._open = fs.open;
            this._queue.push([
                this._open,
                this.path,
                this.flags,
                this.mode,
                undefined
            ]);
            this.flush();
        }
    }
}


/***/ }),

/***/ 19241:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(22057);
var origCwd = process.cwd;
var cwd = null;
var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
    if (!cwd) cwd = origCwd.call(process);
    return cwd;
};
try {
    process.cwd();
} catch (er) {}
// This check is needed until node.js 12 is required
if (typeof process.chdir === "function") {
    var chdir = process.chdir;
    process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
    };
    if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
}
module.exports = patch;
function patch(fs) {
    // (re-)implement some things that are known busted or missing.
    // lchmod, broken prior to 0.6.2
    // back-port the fix here.
    if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
    }
    // lutimes implementation, or no-op
    if (!fs.lutimes) {
        patchLutimes(fs);
    }
    // https://github.com/isaacs/node-graceful-fs/issues/4
    // Chown should not fail on einval or eperm if non-root.
    // It should not fail on enosys ever, as this just indicates
    // that a fs doesn't support the intended operation.
    fs.chown = chownFix(fs.chown);
    fs.fchown = chownFix(fs.fchown);
    fs.lchown = chownFix(fs.lchown);
    fs.chmod = chmodFix(fs.chmod);
    fs.fchmod = chmodFix(fs.fchmod);
    fs.lchmod = chmodFix(fs.lchmod);
    fs.chownSync = chownFixSync(fs.chownSync);
    fs.fchownSync = chownFixSync(fs.fchownSync);
    fs.lchownSync = chownFixSync(fs.lchownSync);
    fs.chmodSync = chmodFixSync(fs.chmodSync);
    fs.fchmodSync = chmodFixSync(fs.fchmodSync);
    fs.lchmodSync = chmodFixSync(fs.lchmodSync);
    fs.stat = statFix(fs.stat);
    fs.fstat = statFix(fs.fstat);
    fs.lstat = statFix(fs.lstat);
    fs.statSync = statFixSync(fs.statSync);
    fs.fstatSync = statFixSync(fs.fstatSync);
    fs.lstatSync = statFixSync(fs.lstatSync);
    // if lchmod/lchown do not exist, then make them no-ops
    if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchmodSync = function() {};
    }
    if (fs.chown && !fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchownSync = function() {};
    }
    // on Windows, A/V software can lock the directory, causing this
    // to fail with an EACCES or EPERM if the directory contains newly
    // created files.  Try again on failure, for up to 60 seconds.
    // Set the timeout this long because some Windows Anti-Virus, such as Parity
    // bit9, may lock files for up to a minute, causing npm package install
    // failures. Also, take care to yield the scheduler. Windows scheduling gives
    // CPU to a busy looping process, which can cause the program causing the lock
    // contention to be starved of CPU by node, so the contention doesn't resolve.
    if (platform === "win32") {
        fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
            function rename(from, to, cb) {
                var start = Date.now();
                var backoff = 0;
                fs$rename(from, to, function CB(er) {
                    if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
                        setTimeout(function() {
                            fs.stat(to, function(stater, st) {
                                if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);
                                else cb(er);
                            });
                        }, backoff);
                        if (backoff < 100) backoff += 10;
                        return;
                    }
                    if (cb) cb(er);
                });
            }
            if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
            return rename;
        }(fs.rename);
    }
    // if read() returns EAGAIN, then just try it again.
    fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
            var callback;
            if (callback_ && typeof callback_ === "function") {
                var eagCounter = 0;
                callback = function(er, _, __) {
                    if (er && er.code === "EAGAIN" && eagCounter < 10) {
                        eagCounter++;
                        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
                    }
                    callback_.apply(this, arguments);
                };
            }
            return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        // This ensures `util.promisify` works as it does for native `fs.read`.
        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
        return read;
    }(fs.read);
    fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
            var eagCounter = 0;
            while(true){
                try {
                    return fs$readSync.call(fs, fd, buffer, offset, length, position);
                } catch (er) {
                    if (er.code === "EAGAIN" && eagCounter < 10) {
                        eagCounter++;
                        continue;
                    }
                    throw er;
                }
            }
        };
    }(fs.readSync);
    function patchLchmod(fs) {
        fs.lchmod = function(path, mode, callback) {
            fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
                if (err) {
                    if (callback) callback(err);
                    return;
                }
                // prefer to return the chmod error, if one occurs,
                // but still try to close, and report closing errors if they occur.
                fs.fchmod(fd, mode, function(err) {
                    fs.close(fd, function(err2) {
                        if (callback) callback(err || err2);
                    });
                });
            });
        };
        fs.lchmodSync = function(path, mode) {
            var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
            // prefer to return the chmod error, if one occurs,
            // but still try to close, and report closing errors if they occur.
            var threw = true;
            var ret;
            try {
                ret = fs.fchmodSync(fd, mode);
                threw = false;
            } finally{
                if (threw) {
                    try {
                        fs.closeSync(fd);
                    } catch (er) {}
                } else {
                    fs.closeSync(fd);
                }
            }
            return ret;
        };
    }
    function patchLutimes(fs) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
            fs.lutimes = function(path, at, mt, cb) {
                fs.open(path, constants.O_SYMLINK, function(er, fd) {
                    if (er) {
                        if (cb) cb(er);
                        return;
                    }
                    fs.futimes(fd, at, mt, function(er) {
                        fs.close(fd, function(er2) {
                            if (cb) cb(er || er2);
                        });
                    });
                });
            };
            fs.lutimesSync = function(path, at, mt) {
                var fd = fs.openSync(path, constants.O_SYMLINK);
                var ret;
                var threw = true;
                try {
                    ret = fs.futimesSync(fd, at, mt);
                    threw = false;
                } finally{
                    if (threw) {
                        try {
                            fs.closeSync(fd);
                        } catch (er) {}
                    } else {
                        fs.closeSync(fd);
                    }
                }
                return ret;
            };
        } else if (fs.futimes) {
            fs.lutimes = function(_a, _b, _c, cb) {
                if (cb) process.nextTick(cb);
            };
            fs.lutimesSync = function() {};
        }
    }
    function chmodFix(orig) {
        if (!orig) return orig;
        return function(target, mode, cb) {
            return orig.call(fs, target, mode, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chmodFixSync(orig) {
        if (!orig) return orig;
        return function(target, mode) {
            try {
                return orig.call(fs, target, mode);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function chownFix(orig) {
        if (!orig) return orig;
        return function(target, uid, gid, cb) {
            return orig.call(fs, target, uid, gid, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chownFixSync(orig) {
        if (!orig) return orig;
        return function(target, uid, gid) {
            try {
                return orig.call(fs, target, uid, gid);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function statFix(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options, cb) {
            if (typeof options === "function") {
                cb = options;
                options = null;
            }
            function callback(er, stats) {
                if (stats) {
                    if (stats.uid < 0) stats.uid += 0x100000000;
                    if (stats.gid < 0) stats.gid += 0x100000000;
                }
                if (cb) cb.apply(this, arguments);
            }
            return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
    }
    function statFixSync(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options) {
            var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
            if (stats) {
                if (stats.uid < 0) stats.uid += 0x100000000;
                if (stats.gid < 0) stats.gid += 0x100000000;
            }
            return stats;
        };
    }
    // ENOSYS means that the fs doesn't support the op. Just ignore
    // that, because it doesn't matter.
    //
    // if there's no getuid, or if getuid() is something other
    // than 0, and the error is EINVAL or EPERM, then just ignore
    // it.
    //
    // This specific case is a silent failure in cp, install, tar,
    // and most other unix tools that manage permissions.
    //
    // When running as root, or if other types of errors are
    // encountered, then it's strict.
    function chownErOk(er) {
        if (!er) return true;
        if (er.code === "ENOSYS") return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
            if (er.code === "EINVAL" || er.code === "EPERM") return true;
        }
        return false;
    }
}


/***/ }),

/***/ 92150:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wrappy = __webpack_require__(21779);
var reqs = Object.create(null);
var once = __webpack_require__(59517);
module.exports = wrappy(inflight);
function inflight(key, cb) {
    if (reqs[key]) {
        reqs[key].push(cb);
        return null;
    } else {
        reqs[key] = [
            cb
        ];
        return makeres(key);
    }
}
function makeres(key) {
    return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        // XXX It's somewhat ambiguous whether a new callback added in this
        // pass should be queued for later execution if something in the
        // list of callbacks throws, or if it should just be discarded.
        // However, it's such an edge case that it hardly matters, and either
        // choice is likely as surprising as the other.
        // As it happens, we do go ahead and schedule it for later execution.
        try {
            for(var i = 0; i < len; i++){
                cbs[i].apply(null, args);
            }
        } finally{
            if (cbs.length > len) {
                // added more in the interim.
                // de-zalgo, just in case, but don't call again.
                cbs.splice(0, len);
                process.nextTick(function() {
                    RES.apply(null, args);
                });
            } else {
                delete reqs[key];
            }
        }
    });
}
function slice(args) {
    var length = args.length;
    var array = [];
    for(var i = 0; i < length; i++)array[i] = args[i];
    return array;
}


/***/ }),

/***/ 28507:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var util = __webpack_require__(73837);
var PassThrough = __webpack_require__(52120);
module.exports = {
    Readable: Readable,
    Writable: Writable
};
util.inherits(Readable, PassThrough);
util.inherits(Writable, PassThrough);
// Patch the given method of instance so that the callback
// is executed once, before the actual method is called the
// first time.
function beforeFirstCall(instance, method, callback) {
    instance[method] = function() {
        delete instance[method];
        callback.apply(this, arguments);
        return this[method].apply(this, arguments);
    };
}
function Readable(fn, options) {
    if (!(this instanceof Readable)) return new Readable(fn, options);
    PassThrough.call(this, options);
    beforeFirstCall(this, "_read", function() {
        var source = fn.call(this, options);
        var emit = this.emit.bind(this, "error");
        source.on("error", emit);
        source.pipe(this);
    });
    this.emit("readable");
}
function Writable(fn, options) {
    if (!(this instanceof Writable)) return new Writable(fn, options);
    PassThrough.call(this, options);
    beforeFirstCall(this, "_write", function() {
        var destination = fn.call(this, options);
        var emit = this.emit.bind(this, "error");
        destination.on("error", emit);
        this.pipe(destination);
    });
    this.emit("writable");
}


/***/ }),

/***/ 63938:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/ var pna = __webpack_require__(11210);
/*</replacement>*/ /*<replacement>*/ var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for(var key in obj){
        keys.push(key);
    }
    return keys;
};
/*</replacement>*/ module.exports = Duplex;
/*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ var Readable = __webpack_require__(7647);
var Writable = __webpack_require__(30966);
util.inherits(Duplex, Readable);
{
    // avoid scope creep, the keys array can then be collected
    var keys = objectKeys(Writable.prototype);
    for(var v = 0; v < keys.length; v++){
        var method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
}function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
}
Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
        return this._writableState.highWaterMark;
    }
});
// the no-half-open enforcer
function onend() {
    // if we allow half-open state, or if the writable side ended,
    // then we're ok.
    if (this.allowHalfOpen || this._writableState.ended) return;
    // no more data can be written.
    // But allow more writes to happen in this tick.
    pna.nextTick(onEndNT, this);
}
function onEndNT(self) {
    self.end();
}
Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
        if (this._readableState === undefined || this._writableState === undefined) {
            return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});
Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
};


/***/ }),

/***/ 21088:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;
var Transform = __webpack_require__(70377);
/*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ util.inherits(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};


/***/ }),

/***/ 7647:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/ var pna = __webpack_require__(11210);
/*</replacement>*/ module.exports = Readable;
/*<replacement>*/ var isArray = __webpack_require__(46405);
/*</replacement>*/ /*<replacement>*/ var Duplex;
/*</replacement>*/ Readable.ReadableState = ReadableState;
/*<replacement>*/ var EE = (__webpack_require__(82361).EventEmitter);
var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
};
/*</replacement>*/ /*<replacement>*/ var Stream = __webpack_require__(4071);
/*</replacement>*/ /*<replacement>*/ var Buffer = (__webpack_require__(90209).Buffer);
var OurUint8Array = (typeof global !== "undefined" ? global :  false ? 0 : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/ /*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ /*<replacement>*/ var debugUtil = __webpack_require__(73837);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
} else {
    debug = function() {};
}
/*</replacement>*/ var BufferList = __webpack_require__(57976);
var destroyImpl = __webpack_require__(33384);
var StringDecoder;
util.inherits(Readable, Stream);
var kProxyEvents = [
    "error",
    "close",
    "destroy",
    "pause",
    "resume"
];
function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [
        fn,
        emitter._events[event]
    ];
}
function ReadableState(options, stream) {
    Duplex = Duplex || __webpack_require__(63938);
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    var isDuplex = stream instanceof Duplex;
    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    // cast to ints.
    this.highWaterMark = Math.floor(this.highWaterMark);
    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true;
    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    // has it been destroyed
    this.destroyed = false;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;
    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!StringDecoder) StringDecoder = (__webpack_require__(64105)/* .StringDecoder */ .s);
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    Duplex = Duplex || __webpack_require__(63938);
    if (!(this instanceof Readable)) return new Readable(options);
    this._readableState = new ReadableState(options, this);
    // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
}
Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
        if (this._readableState === undefined) {
            return false;
        }
        return this._readableState.destroyed;
    },
    set: function(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
};
// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = "";
            }
            skipChunkCheck = true;
        }
    } else {
        skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};
// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
            stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
                if (state.endEmitted) stream.emit("error", new Error("stream.unshift() after end event"));
                else addChunk(stream, state, chunk, true);
            } else if (state.ended) {
                stream.emit("error", new Error("stream.push() after EOF"));
            } else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                    else maybeReadMore(stream, state);
                } else {
                    addChunk(stream, state, chunk, false);
                }
            }
        } else if (!addToFront) {
            state.reading = false;
        }
    }
    return needMoreData(state);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
    } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
}
// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
};
// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(64105)/* .StringDecoder */ .s);
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
};
// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
        n = MAX_HWM;
    } else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
}
// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false;
    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
    }
    n = howMuchToRead(n, state);
    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
    }
    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug("need readable", doRead);
    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
    }
    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
    } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = fromList(n, state);
    else ret = null;
    if (ret === null) {
        state.needReadable = true;
        n = 0;
    } else {
        state.length -= n;
    }
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;
        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
};
function onEofChunk(stream, state) {
    if (state.ended) return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    // emit 'readable' now to make sure it gets picked up.
    emitReadable(stream);
}
// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync) pna.nextTick(emitReadable_, stream);
        else emitReadable_(stream);
    }
}
function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
}
// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    var len = state.length;
    while(!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark){
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) break;
        else len = state.length;
    }
    state.readingMore = false;
}
// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch(state.pipesCount){
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [
                state.pipes,
                dest
            ];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) pna.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug("onend");
        dest.end();
    }
    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
        debug("cleanup");
        // cleanup event handlers once the pipe is broken
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    // If the user pushes more data while we're writing to dest then we'll end up
    // in ondata again. However, we only want to increase awaitDrain once because
    // dest will only emit one 'drain' event for the multiple writes.
    // => Introduce a guard on increasing awaitDrain.
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug("false write response, pause", state.awaitDrain);
                state.awaitDrain++;
                increasedAwaitDrain = true;
            }
            src.pause();
        }
    }
    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    // Make sure our error handler is attached before userland ones.
    prependListener(dest, "error", onerror);
    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
    }
    // tell the dest that it's being piped to
    dest.emit("pipe", src);
    // start the flow if it hasn't been started already.
    if (!state.flowing) {
        debug("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src) {
    return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    };
    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;
    // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
    }
    // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for(var i = 0; i < len; i++){
            dests[i].emit("unpipe", this, {
                hasUnpiped: false
            });
        }
        return this;
    }
    // try to find the right one.
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
        // Start flowing on next tick if stream isn't explicitly paused
        if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) {
                pna.nextTick(nReadingNextTick, this);
            } else if (state.length) {
                emitReadable(this);
            }
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self1) {
    debug("readable nexttick read 0");
    self1.read(0);
}
// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
    }
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
    }
}
function resume_(stream, state) {
    if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    return this;
};
function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while(state.flowing && stream.read() !== null){}
}
// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    });
    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for(var i in stream){
        if (this[i] === undefined && typeof stream[i] === "function") {
            this[i] = function(method) {
                return function() {
                    return stream[method].apply(stream, arguments);
                };
            }(i);
        }
    }
    // proxy certain important events.
    for(var n = 0; n < kProxyEvents.length; n++){
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};
Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
        return this._readableState.highWaterMark;
    }
});
// exposed for testing purposes only.
Readable._fromList = fromList;
// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.head.data;
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else {
        // read part of list
        ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
}
// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
        // slice is the same for buffers and strings
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
        // first chunk is a perfect match
        ret = list.shift();
    } else {
        // result spans more than one buffer
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
}
// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while(p = p.next){
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;
        else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
            if (nb === str.length) {
                ++c;
                if (p.next) list.head = p.next;
                else list.head = list.tail = null;
            } else {
                list.head = p;
                p.data = str.slice(nb);
            }
            break;
        }
        ++c;
    }
    list.length -= c;
    return ret;
}
// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
    var ret = Buffer.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while(p = p.next){
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
            if (nb === buf.length) {
                ++c;
                if (p.next) list.head = p.next;
                else list.head = list.tail = null;
            } else {
                list.head = p;
                p.data = buf.slice(nb);
            }
            break;
        }
        ++c;
    }
    list.length -= c;
    return ret;
}
function endReadable(stream) {
    var state = stream._readableState;
    // If we get here before consuming all the bytes, then that is a
    // bug in node.  Should never happen.
    if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
    }
}
function indexOf(xs, x) {
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}


/***/ }),

/***/ 70377:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;
var Duplex = __webpack_require__(63938);
/*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ util.inherits(Transform, Duplex);
function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
    }
}
function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
    };
    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;
    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;
    if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
    }
    // When the writable side finishes, then flush out anything remaining.
    this.on("prefinish", prefinish);
}
function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
        this._flush(function(er, data) {
            done(_this, er, data);
        });
    } else {
        done(this, null, null);
    }
}
Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
};
// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
};
Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
};
// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
    }
};
Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
    });
};
function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null) stream.push(data);
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream.push(null);
}


/***/ }),

/***/ 30966:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

/*<replacement>*/ var pna = __webpack_require__(11210);
/*</replacement>*/ module.exports = Writable;
/* <replacement> */ function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
}
// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
        onCorkedFinish(_this, state);
    };
}
/* </replacement> */ /*<replacement>*/ var asyncWrite =  true && [
    "v0.10",
    "v0.9."
].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/ /*<replacement>*/ var Duplex;
/*</replacement>*/ Writable.WritableState = WritableState;
/*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ /*<replacement>*/ var internalUtil = {
    deprecate: __webpack_require__(62337)
};
/*</replacement>*/ /*<replacement>*/ var Stream = __webpack_require__(4071);
/*</replacement>*/ /*<replacement>*/ var Buffer = (__webpack_require__(90209).Buffer);
var OurUint8Array = (typeof global !== "undefined" ? global :  false ? 0 : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/ var destroyImpl = __webpack_require__(33384);
util.inherits(Writable, Stream);
function nop() {}
function WritableState(options, stream) {
    Duplex = Duplex || __webpack_require__(63938);
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    var isDuplex = stream instanceof Duplex;
    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    // cast to ints.
    this.highWaterMark = Math.floor(this.highWaterMark);
    // if _final has been called
    this.finalCalled = false;
    // drain event flag.
    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;
    // has it been destroyed
    this.destroyed = false;
    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;
    // a flag to see when we're in the middle of a write.
    this.writing = false;
    // when true all writes will be buffered until .uncork() call
    this.corked = 0;
    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;
    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;
    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function(er) {
        onwrite(stream, er);
    };
    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;
    // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;
    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;
    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;
    // count buffered requests
    this.bufferedRequestCount = 0;
    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while(current){
        out.push(current);
        current = current.next;
    }
    return out;
};
(function() {
    try {
        Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function() {
                return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
        });
    } catch (_) {}
})();
// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
        }
    });
} else {
    realHasInstance = function(object) {
        return object instanceof this;
    };
}
function Writable(options) {
    Duplex = Duplex || __webpack_require__(63938);
    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
}
// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
};
function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    // TODO: defer error events consistently everywhere, not just the cb
    stream.emit("error", er);
    pna.nextTick(cb, er);
}
// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
        er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
    }
    return valid;
}
Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
};
Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!([
        "hex",
        "utf8",
        "utf-8",
        "ascii",
        "binary",
        "base64",
        "ucs2",
        "ucs-2",
        "utf16le",
        "utf-16le",
        "raw"
    ].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer.from(chunk, encoding);
    }
    return chunk;
}
Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
        return this._writableState.highWaterMark;
    }
});
// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) {
            last.next = state.lastBufferedRequest;
        } else {
            state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
    } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        pna.nextTick(cb, er);
        // this can emit finish, and it will always happen
        // after error
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
    } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        // this can emit finish, but finish must
        // always follow error
        finishMaybe(stream, state);
    }
}
function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
        }
        if (sync) {
            /*<replacement>*/ asyncWrite(afterWrite, stream, state, finished, cb);
        /*</replacement>*/ } else {
            afterWrite(stream, state, finished, cb);
        }
    }
}
function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
}
// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
    }
}
// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while(entry){
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        } else {
            state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
    } else {
        // Slow case, write chunks one-by-one
        while(entry){
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) {
                break;
            }
        }
        if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
    // .end() fully uncorks
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    // ignore unnecessary end() calls.
    if (!state.ending) endWritable(this, state, cb);
};
function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
    stream._final(function(err) {
        state.pendingcb--;
        if (err) {
            stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
    });
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
            state.pendingcb++;
            state.finalCalled = true;
            pna.nextTick(callFinal, stream, state);
        } else {
            state.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
        }
    }
    return need;
}
function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
        if (state.finished) pna.nextTick(cb);
        else stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while(entry){
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
    }
    // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
        if (this._writableState === undefined) {
            return false;
        }
        return this._writableState.destroyed;
    },
    set: function(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._writableState.destroyed = value;
    }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
};


/***/ }),

/***/ 57976:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
var Buffer = (__webpack_require__(90209).Buffer);
var util = __webpack_require__(73837);
function copyBuffer(src, target, offset) {
    src.copy(target, offset);
}
module.exports = function() {
    function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
        var entry = {
            data: v,
            next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
        var entry = {
            data: v,
            next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
    };
    BufferList.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
    };
    BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
    };
    BufferList.prototype.join = function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while(p = p.next){
            ret += s + p.data;
        }
        return ret;
    };
    BufferList.prototype.concat = function concat(n) {
        if (this.length === 0) return Buffer.alloc(0);
        var ret = Buffer.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while(p){
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
        }
        return ret;
    };
    return BufferList;
}();
if (util && util.inspect && util.inspect.custom) {
    module.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({
            length: this.length
        });
        return this.constructor.name + " " + obj;
    };
}


/***/ }),

/***/ 33384:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*<replacement>*/ var pna = __webpack_require__(11210);
/*</replacement>*/ // undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) {
            cb(err);
        } else if (err) {
            if (!this._writableState) {
                pna.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                pna.nextTick(emitErrorNT, this, err);
            }
        }
        return this;
    }
    // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) {
        this._readableState.destroyed = true;
    }
    // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) {
        this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err) {
        if (!cb && err) {
            if (!_this._writableState) {
                pna.nextTick(emitErrorNT, _this, err);
            } else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                pna.nextTick(emitErrorNT, _this, err);
            }
        } else if (cb) {
            cb(err);
        }
    });
    return this;
}
function undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function emitErrorNT(self, err) {
    self.emit("error", err);
}
module.exports = {
    destroy: destroy,
    undestroy: undestroy
};


/***/ }),

/***/ 4071:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(12781);


/***/ }),

/***/ 52120:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(82834).PassThrough;


/***/ }),

/***/ 82834:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

var Stream = __webpack_require__(12781);
if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream;
    exports = module.exports = Stream.Readable;
    exports.Readable = Stream.Readable;
    exports.Writable = Stream.Writable;
    exports.Duplex = Stream.Duplex;
    exports.Transform = Stream.Transform;
    exports.PassThrough = Stream.PassThrough;
    exports.Stream = Stream;
} else {
    exports = module.exports = __webpack_require__(7647);
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = __webpack_require__(30966);
    exports.Duplex = __webpack_require__(63938);
    exports.Transform = __webpack_require__(70377);
    exports.PassThrough = __webpack_require__(21088);
}


/***/ }),

/***/ 90209:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* eslint-disable node/no-deprecated-api */ 
var buffer = __webpack_require__(14300);
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src){
        dst[key] = src[key];
    }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
} else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
    }
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === "string") {
            buf.fill(fill, encoding);
        } else {
            buf.fill(fill);
        }
    } else {
        buf.fill(0);
    }
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
};


/***/ }),

/***/ 64105:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/ var Buffer = (__webpack_require__(90209).Buffer);
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch(encoding && encoding.toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while(true){
        switch(enc){
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return enc;
            default:
                if (retried) return; // undefined
                enc = ("" + enc).toLowerCase();
                retried = true;
        }
    }
}
;
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.s = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return "";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return "";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return "";
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "";
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}


/***/ }),

/***/ 35360:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var listenerCount = (__webpack_require__(82361).listenerCount);
// listenerCount isn't in node 0.10, so here's a basic polyfill
listenerCount = listenerCount || function(ee, event) {
    var listeners = ee && ee._events && ee._events[event];
    if (Array.isArray(listeners)) {
        return listeners.length;
    } else if (typeof listeners === "function") {
        return 1;
    } else {
        return 0;
    }
};
module.exports = listenerCount;


/***/ }),

/***/ 25377:
/***/ ((module) => {

"use strict";
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as references for various `Number` constants. */ 
var MAX_SAFE_INTEGER = 9007199254740991;
/** `Object#toString` result references. */ var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */ function apply(func, thisArg, args) {
    switch(args.length){
        case 0:
            return func.call(thisArg);
        case 1:
            return func.call(thisArg, args[0]);
        case 2:
            return func.call(thisArg, args[0], args[1]);
        case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n){
        result[index] = iteratee(index);
    }
    return result;
}
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Built-in value references. */ var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for(var key in value){
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
/**
 * Used by `_.defaults` to customize its `_.assignIn` use.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */ function assignInDefaults(objValue, srcValue, key, object) {
    if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
        return srcValue;
    }
    return objValue;
}
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */ function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
        object[key] = value;
    }
}
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeysIn(object) {
    if (!isObject(object)) {
        return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for(var key in object){
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
        }
    }
    return result;
}
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */ function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while(++index < length){
            array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while(++index < start){
            otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
    };
}
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */ function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while(++index < length){
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
        assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }
    return object;
}
/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */ function createAssigner(assigner) {
    return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined : customizer;
            length = 1;
        }
        object = Object(object);
        while(++index < length){
            var source = sources[index];
            if (source) {
                assigner(object, source, index, customizer);
            }
        }
        return object;
    });
}
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */ function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
        return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
    }
    return false;
}
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
}
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
        for(var key in Object(object)){
            result.push(key);
        }
    }
    return result;
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */ function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */ var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
    copyObject(source, keysIn(source), object, customizer);
});
/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */ var defaults = baseRest(function(args) {
    args.push(undefined, assignInDefaults);
    return apply(assignInWith, undefined, args);
});
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */ function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
module.exports = defaults;


/***/ }),

/***/ 4212:
/***/ ((module) => {

"use strict";
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ 
var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/** `Object#toString` result references. */ var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */ function apply(func, thisArg, args) {
    switch(args.length){
        case 0:
            return func.call(thisArg);
        case 1:
            return func.call(thisArg, args[0]);
        case 2:
            return func.call(thisArg, args[0], args[1]);
        case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
}
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array ? array.length : 0;
    while(++index < length){
        if (comparator(value, array[index])) {
            return true;
        }
    }
    return false;
}
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */ function arrayMap(array, iteratee) {
    var index = -1, length = array ? array.length : 0, result = Array(length);
    while(++index < length){
        result[index] = iteratee(array[index], index, array);
    }
    return result;
}
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length){
        array[offset + index] = values[index];
    }
    return array;
}
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while(fromRight ? index-- : ++index < length){
        if (predicate(array[index], index, array)) {
            return index;
        }
    }
    return -1;
}
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array.length;
    while(++index < length){
        if (array[index] === value) {
            return index;
        }
    }
    return -1;
}
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */ function baseIsNaN(value) {
    return value !== value;
}
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */ function baseUnary(func) {
    return function(value) {
        return func(value);
    };
}
/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function cacheHas(cache, key) {
    return cache.has(key);
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != "function") {
        try {
            result = !!(value + "");
        } catch (e) {}
    }
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root["__core-js_shared__"];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
/** Built-in value references. */ var Symbol = root.Symbol, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max;
/* Built-in method references that are verified to be native. */ var Map = getNative(root, "Map"), nativeCreate = getNative(Object, "create");
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    } else {
        splice.call(data, index, 1);
    }
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        data.push([
            key,
            value
        ]);
    } else {
        data[index][1] = value;
    }
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        "hash": new Hash,
        "map": new (Map || ListCache),
        "string": new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */ function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache;
    while(++index < length){
        this.add(values[index]);
    }
}
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */ function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */ function setCacheHas(value) {
    return this.__data__.has(value);
}
// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) {
            return length;
        }
    }
    return -1;
}
/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */ function baseDifference(array, values, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
    if (!length) {
        return result;
    }
    if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
    }
    if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
    } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
    }
    outer: while(++index < length){
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while(valuesIndex--){
                if (values[valuesIndex] === computed) {
                    continue outer;
                }
            }
            result.push(value);
        } else if (!includes(values, computed, comparator)) {
            result.push(value);
        }
    }
    return result;
}
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */ function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while(++index < length){
        var value = array[index];
        if (depth > 0 && predicate(value)) {
            if (depth > 1) {
                // Recursively flatten arrays (susceptible to call stack limits).
                baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
                arrayPush(result, value);
            }
        } else if (!isStrict) {
            result[result.length] = value;
        }
    }
    return result;
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */ function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while(++index < length){
            array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while(++index < start){
            otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
    };
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */ function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + "";
        } catch (e) {}
    }
    return "";
}
/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order of result values is determined by the
 * order they occur in the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */ var difference = baseRest(function(array, values) {
    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
});
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */ function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
module.exports = difference;


/***/ }),

/***/ 5676:
/***/ ((module) => {

"use strict";
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as references for various `Number` constants. */ 
var INFINITY = 1 / 0;
/** `Object#toString` result references. */ var symbolTag = "[object Symbol]";
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Built-in value references. */ var Symbol = root.Symbol;
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */ function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == "string") {
        return value;
    }
    if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */ function toString(value) {
    return value == null ? "" : baseToString(value);
}
/**
 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */ function escapeRegExp(string) {
    string = toString(string);
    return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
}
module.exports = escapeRegExp;


/***/ }),

/***/ 95918:
/***/ ((module) => {

"use strict";
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as references for various `Number` constants. */ 
var MAX_SAFE_INTEGER = 9007199254740991;
/** `Object#toString` result references. */ var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length){
        array[offset + index] = values[index];
    }
    return array;
}
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Built-in value references. */ var Symbol = root.Symbol, propertyIsEnumerable = objectProto.propertyIsEnumerable, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */ function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while(++index < length){
        var value = array[index];
        if (depth > 0 && predicate(value)) {
            if (depth > 1) {
                // Recursively flatten arrays (susceptible to call stack limits).
                baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
                arrayPush(result, value);
            }
        } else if (!isStrict) {
            result[result.length] = value;
        }
    }
    return result;
}
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */ function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */ function flatten(array) {
    var length = array ? array.length : 0;
    return length ? baseFlatten(array, 1) : [];
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */ function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
module.exports = flatten;


/***/ }),

/***/ 39449:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ 
var LARGE_ARRAY_SIZE = 200;
/** Used as the `TypeError` message for "Functions" methods. */ var FUNC_ERROR_TEXT = "Expected a function";
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
/** Used to compose bitmasks for comparison styles. */ var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
/** `Object#toString` result references. */ var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
/** Used to match property names within property paths. */ var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to match backslashes in property paths. */ var reEscapeChar = /\\(\\)?/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/** Used to identify `toStringTag` values of typed arrays. */ var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
/** Detect free variable `exports`. */ var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && "object" == "object" && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */ var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */ var nodeUtil = function() {
    try {
        return freeProcess && freeProcess.binding("util");
    } catch (e) {}
}();
/* Node.js helper references. */ var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */ function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1, length = array ? array.length : 0;
    while(++index < length){
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
}
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */ function arraySome(array, predicate) {
    var index = -1, length = array ? array.length : 0;
    while(++index < length){
        if (predicate(array[index], index, array)) {
            return true;
        }
    }
    return false;
}
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */ function baseProperty(key) {
    return function(object) {
        return object == null ? undefined : object[key];
    };
}
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n){
        result[index] = iteratee(index);
    }
    return result;
}
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */ function baseUnary(func) {
    return function(value) {
        return func(value);
    };
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != "function") {
        try {
            result = !!(value + "");
        } catch (e) {}
    }
    return result;
}
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */ function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */ function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root["__core-js_shared__"];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
/** Built-in value references. */ var Symbol = root.Symbol, Uint8Array = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeKeys = overArg(Object.keys, Object);
/* Built-in method references that are verified to be native. */ var DataView = getNative(root, "DataView"), Map = getNative(root, "Map"), Promise = getNative(root, "Promise"), Set = getNative(root, "Set"), WeakMap = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
/** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    } else {
        splice.call(data, index, 1);
    }
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        data.push([
            key,
            value
        ]);
    } else {
        data[index][1] = value;
    }
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        "hash": new Hash,
        "map": new (Map || ListCache),
        "string": new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */ function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache;
    while(++index < length){
        this.add(values[index]);
    }
}
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */ function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */ function setCacheHas(value) {
    return this.__data__.has(value);
}
// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Stack(entries) {
    this.__data__ = new ListCache(entries);
}
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */ function stackClear() {
    this.__data__ = new ListCache;
}
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function stackDelete(key) {
    return this.__data__["delete"](key);
}
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function stackGet(key) {
    return this.__data__.get(key);
}
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function stackHas(key) {
    return this.__data__.has(key);
}
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */ function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            return this;
        }
        cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
}
// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for(var key in value){
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) {
            return length;
        }
    }
    return -1;
}
/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */ function baseAggregator(collection, setter, iteratee, accumulator) {
    baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
    });
    return accumulator;
}
/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */ var baseEach = createBaseEach(baseForOwn);
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */ var baseFor = createBaseFor();
/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */ function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
}
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */ function baseGet(object, path) {
    path = isKey(path, object) ? [
        path
    ] : castPath(path);
    var index = 0, length = path.length;
    while(object != null && index < length){
        object = object[toKey(path[index++])];
    }
    return index && index == length ? object : undefined;
}
/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    return objectToString.call(value);
}
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */ function baseHasIn(object, key) {
    return object != null && key in Object(object);
}
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */ function baseIsEqual(value, other, customizer, bitmask, stack) {
    if (value === other) {
        return true;
    }
    if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
    if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
    }
    if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
    }
    var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
    if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
    }
    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack);
            return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
    }
    if (!isSameTag) {
        return false;
    }
    stack || (stack = new Stack);
    return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */ function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length = index, noCustomizer = !customizer;
    if (object == null) {
        return !length;
    }
    object = Object(object);
    while(index--){
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
        }
    }
    while(++index < length){
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
            if (objValue === undefined && !(key in object)) {
                return false;
            }
        } else {
            var stack = new Stack;
            if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
                return false;
            }
        }
    }
    return true;
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */ function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}
/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */ function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == "function") {
        return value;
    }
    if (value == null) {
        return identity;
    }
    if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
}
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeys(object) {
    if (!isPrototype(object)) {
        return nativeKeys(object);
    }
    var result = [];
    for(var key in Object(object)){
        if (hasOwnProperty.call(object, key) && key != "constructor") {
            result.push(key);
        }
    }
    return result;
}
/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */ function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
    };
}
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */ function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
        var objValue = get(object, path);
        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
    };
}
/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */ function basePropertyDeep(path) {
    return function(object) {
        return baseGet(object, path);
    };
}
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */ function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == "string") {
        return value;
    }
    if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */ function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
}
/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */ function createAggregator(setter, initializer) {
    return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
    };
}
/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */ function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
        if (collection == null) {
            return collection;
        }
        if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while(fromRight ? index-- : ++index < length){
            if (iteratee(iterable[index], index, iterable) === false) {
                break;
            }
        }
        return collection;
    };
}
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */ function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while(length--){
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
                break;
            }
        }
        return object;
    };
}
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */ function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
        return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache : undefined;
    stack.set(array, other);
    stack.set(other, array);
    // Ignore non-index properties.
    while(++index < arrLength){
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
            if (compared) {
                continue;
            }
            result = false;
            break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
            if (!arraySome(other, function(othValue, othIndex) {
                if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                    return seen.add(othIndex);
                }
            })) {
                result = false;
                break;
            }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
            result = false;
            break;
        }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
}
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
    switch(tag){
        case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
            }
            object = object.buffer;
            other = other.buffer;
        case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
            }
            return true;
        case boolTag:
        case dateTag:
        case numberTag:
            // Coerce booleans to `1` or `0` and dates to milliseconds.
            // Invalid dates are coerced to `NaN`.
            return eq(+object, +other);
        case errorTag:
            return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
            // Coerce regexes to strings and treat strings, primitives and objects,
            // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
            // for more details.
            return object == other + "";
        case mapTag:
            var convert = mapToArray;
        case setTag:
            var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
                return false;
            }
            // Assume cyclic values are equal.
            var stacked = stack.get(object);
            if (stacked) {
                return stacked == other;
            }
            bitmask |= UNORDERED_COMPARE_FLAG;
            // Recursively compare objects (susceptible to call stack limits).
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
            stack["delete"](object);
            return result;
        case symbolTag:
            if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
    }
    return false;
}
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
        return false;
    }
    var index = objLength;
    while(index--){
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
        }
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
        return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while(++index < objLength){
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
            result = false;
            break;
        }
        skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
        }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */ function getMatchData(object) {
    var result = keys(object), length = result.length;
    while(length--){
        var key = result[length], value = object[key];
        result[length] = [
            key,
            value,
            isStrictComparable(value)
        ];
    }
    return result;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ var getTag = baseGetTag;
// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) {
    getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
        if (ctorString) {
            switch(ctorString){
                case dataViewCtorString:
                    return dataViewTag;
                case mapCtorString:
                    return mapTag;
                case promiseCtorString:
                    return promiseTag;
                case setCtorString:
                    return setTag;
                case weakMapCtorString:
                    return weakMapTag;
            }
        }
        return result;
    };
}
/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */ function hasPath(object, path, hasFunc) {
    path = isKey(path, object) ? [
        path
    ] : castPath(path);
    var result, index = -1, length = path.length;
    while(++index < length){
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
            break;
        }
        object = object[key];
    }
    if (result) {
        return result;
    }
    var length = object ? object.length : 0;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */ function isKey(value, object) {
    if (isArray(value)) {
        return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
}
/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */ function isStrictComparable(value) {
    return value === value && !isObject(value);
}
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */ function matchesStrictComparable(key, srcValue) {
    return function(object) {
        if (object == null) {
            return false;
        }
        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
}
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */ var stringToPath = memoize(function(string) {
    string = toString(string);
    var result = [];
    if (reLeadingDot.test(string)) {
        result.push("");
    }
    string.replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
});
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */ function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
        return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + "";
        } catch (e) {}
    }
    return "";
}
/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The order of grouped values
 * is determined by the order they occur in `collection`. The corresponding
 * value of each key is an array of elements responsible for generating the
 * key. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity]
 *  The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': [4.2], '6': [6.1, 6.3] }
 *
 * // The `_.property` iteratee shorthand.
 * _.groupBy(['one', 'two', 'three'], 'length');
 * // => { '3': ['one', 'two'], '5': ['three'] }
 */ var groupBy = createAggregator(function(result, value, key) {
    if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
    } else {
        result[key] = [
            value
        ];
    }
});
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */ function memoize(func, resolver) {
    if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
            return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
}
// Assign cache to `_.memoize`.
memoize.Cache = MapCache;
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */ function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */ var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */ function toString(value) {
    return value == null ? "" : baseToString(value);
}
/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */ function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
}
/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */ function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
}
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */ function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */ function identity(value) {
    return value;
}
/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */ function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
module.exports = groupBy;


/***/ }),

/***/ 93002:
/***/ ((module) => {

"use strict";
/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */ /** `Object#toString` result references. */ 
var boolTag = "[object Boolean]";
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */ function isBoolean(value) {
    return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
module.exports = isBoolean;


/***/ }),

/***/ 52053:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ 
var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/** `Object#toString` result references. */ var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/** Used to identify `toStringTag` values of typed arrays. */ var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
/** Detect free variable `exports`. */ var freeExports =  true && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && "object" == "object" && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */ var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */ var nodeUtil = function() {
    try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {}
}();
/* Node.js helper references. */ var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */ function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while(++index < length){
        var value = array[index];
        if (predicate(value, index, array)) {
            result[resIndex++] = value;
        }
    }
    return result;
}
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length){
        array[offset + index] = values[index];
    }
    return array;
}
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */ function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while(++index < length){
        if (predicate(array[index], index, array)) {
            return true;
        }
    }
    return false;
}
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n){
        result[index] = iteratee(index);
    }
    return result;
}
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */ function baseUnary(func) {
    return function(value) {
        return func(value);
    };
}
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function cacheHas(cache, key) {
    return cache.has(key);
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */ function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */ function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root["__core-js_shared__"];
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
}();
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
/** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined, Symbol = root.Symbol, Uint8Array = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeKeys = overArg(Object.keys, Object);
/* Built-in method references that are verified to be native. */ var DataView = getNative(root, "DataView"), Map = getNative(root, "Map"), Promise = getNative(root, "Promise"), Set = getNative(root, "Set"), WeakMap = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
/** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    } else {
        splice.call(data, index, 1);
    }
    --this.size;
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        ++this.size;
        data.push([
            key,
            value
        ]);
    } else {
        data[index][1] = value;
    }
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
        "hash": new Hash,
        "map": new (Map || ListCache),
        "string": new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */ function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache;
    while(++index < length){
        this.add(values[index]);
    }
}
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */ function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */ function setCacheHas(value) {
    return this.__data__.has(value);
}
// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
}
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */ function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
}
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
}
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function stackGet(key) {
    return this.__data__.get(key);
}
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function stackHas(key) {
    return this.__data__.has(key);
}
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */ function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            this.size = ++data.size;
            return this;
        }
        data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
}
// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for(var key in value){
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) {
            return length;
        }
    }
    return -1;
}
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */ function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
}
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */ function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
        return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
            return false;
        }
        objIsArr = true;
        objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack);
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
    }
    if (!isSameTag) {
        return false;
    }
    stack || (stack = new Stack);
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */ function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeys(object) {
    if (!isPrototype(object)) {
        return nativeKeys(object);
    }
    var result = [];
    for(var key in Object(object)){
        if (hasOwnProperty.call(object, key) && key != "constructor") {
            result.push(key);
        }
    }
    return result;
}
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */ function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
        return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined;
    stack.set(array, other);
    stack.set(other, array);
    // Ignore non-index properties.
    while(++index < arrLength){
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
            if (compared) {
                continue;
            }
            result = false;
            break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
            if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                }
            })) {
                result = false;
                break;
            }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
        }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
}
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch(tag){
        case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
            }
            object = object.buffer;
            other = other.buffer;
        case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
            }
            return true;
        case boolTag:
        case dateTag:
        case numberTag:
            // Coerce booleans to `1` or `0` and dates to milliseconds.
            // Invalid dates are coerced to `NaN`.
            return eq(+object, +other);
        case errorTag:
            return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
            // Coerce regexes to strings and treat strings, primitives and objects,
            // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
            // for more details.
            return object == other + "";
        case mapTag:
            var convert = mapToArray;
        case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
                return false;
            }
            // Assume cyclic values are equal.
            var stacked = stack.get(object);
            if (stacked) {
                return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            // Recursively compare objects (susceptible to call stack limits).
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result;
        case symbolTag:
            if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
    }
    return false;
}
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
        return false;
    }
    var index = objLength;
    while(index--){
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
        }
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
        return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while(++index < objLength){
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
        }
        skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
        }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
}
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */ function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */ function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
        value[symToStringTag] = undefined;
        var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) {
            value[symToStringTag] = tag;
        } else {
            delete value[symToStringTag];
        }
    }
    return result;
}
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
        return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
    });
};
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ var getTag = baseGetTag;
// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) {
    getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
            switch(ctorString){
                case dataViewCtorString:
                    return dataViewTag;
                case mapCtorString:
                    return mapTag;
                case promiseCtorString:
                    return promiseTag;
                case setCtorString:
                    return setTag;
                case weakMapCtorString:
                    return weakMapTag;
            }
        }
        return result;
    };
}
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
}
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */ function objectToString(value) {
    return nativeObjectToString.call(value);
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + "";
        } catch (e) {}
    }
    return "";
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ var isArguments = baseIsArguments(function() {
    return arguments;
}()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */ var isBuffer = nativeIsBuffer || stubFalse;
/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */ function isEqual(value, other) {
    return baseIsEqual(value, other);
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    if (!isObject(value)) {
        return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return value != null && typeof value == "object";
}
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */ var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */ function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */ function stubArray() {
    return [];
}
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */ function stubFalse() {
    return false;
}
module.exports = isEqual;


/***/ }),

/***/ 79009:
/***/ ((module) => {

"use strict";
/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** `Object#toString` result references. */ 
var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", nullTag = "[object Null]", proxyTag = "[object Proxy]", undefinedTag = "[object Undefined]";
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/** Built-in value references. */ var Symbol = root.Symbol, symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */ function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
        value[symToStringTag] = undefined;
        var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) {
            value[symToStringTag] = tag;
        } else {
            delete value[symToStringTag];
        }
    }
    return result;
}
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */ function objectToString(value) {
    return nativeObjectToString.call(value);
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    if (!isObject(value)) {
        return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
}
module.exports = isFunction;


/***/ }),

/***/ 78594:
/***/ ((module) => {

"use strict";
/**
 * lodash 4.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */ /**
 * Checks if `value` is `null` or `undefined`.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 *
 * _.isNil(null);
 * // => true
 *
 * _.isNil(void 0);
 * // => true
 *
 * _.isNil(NaN);
 * // => false
 */ 
function isNil(value) {
    return value == null;
}
module.exports = isNil;


/***/ }),

/***/ 22557:
/***/ ((module) => {

"use strict";
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** `Object#toString` result references. */ 
var objectTag = "[object Object]";
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != "function") {
        try {
            result = !!(value + "");
        } catch (e) {}
    }
    return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
/** Used for built-in method references. */ var funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to infer the `Object` constructor. */ var objectCtorString = funcToString.call(Object);
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Built-in value references. */ var getPrototype = overArg(Object.getPrototypeOf, Object);
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */ function isPlainObject(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
        return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
module.exports = isPlainObject;


/***/ }),

/***/ 62085:
/***/ ((module) => {

"use strict";
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */ /**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */ 
function isUndefined(value) {
    return value === undefined;
}
module.exports = isUndefined;


/***/ }),

/***/ 25372:
/***/ ((module) => {

"use strict";
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ 
var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
/** `Object#toString` result references. */ var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */ function apply(func, thisArg, args) {
    switch(args.length){
        case 0:
            return func.call(thisArg);
        case 1:
            return func.call(thisArg, args[0]);
        case 2:
            return func.call(thisArg, args[0], args[1]);
        case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
}
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array ? array.length : 0;
    while(++index < length){
        if (comparator(value, array[index])) {
            return true;
        }
    }
    return false;
}
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length){
        array[offset + index] = values[index];
    }
    return array;
}
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while(fromRight ? index-- : ++index < length){
        if (predicate(array[index], index, array)) {
            return index;
        }
    }
    return -1;
}
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array.length;
    while(++index < length){
        if (array[index] === value) {
            return index;
        }
    }
    return -1;
}
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */ function baseIsNaN(value) {
    return value !== value;
}
/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function cacheHas(cache, key) {
    return cache.has(key);
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != "function") {
        try {
            result = !!(value + "");
        } catch (e) {}
    }
    return result;
}
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */ function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root["__core-js_shared__"];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
/** Built-in value references. */ var Symbol = root.Symbol, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max;
/* Built-in method references that are verified to be native. */ var Map = getNative(root, "Map"), Set = getNative(root, "Set"), nativeCreate = getNative(Object, "create");
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    } else {
        splice.call(data, index, 1);
    }
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        data.push([
            key,
            value
        ]);
    } else {
        data[index][1] = value;
    }
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        "hash": new Hash,
        "map": new (Map || ListCache),
        "string": new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */ function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache;
    while(++index < length){
        this.add(values[index]);
    }
}
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */ function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */ function setCacheHas(value) {
    return this.__data__.has(value);
}
// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) {
            return length;
        }
    }
    return -1;
}
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */ function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while(++index < length){
        var value = array[index];
        if (depth > 0 && predicate(value)) {
            if (depth > 1) {
                // Recursively flatten arrays (susceptible to call stack limits).
                baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
                arrayPush(result, value);
            }
        } else if (!isStrict) {
            result[result.length] = value;
        }
    }
    return result;
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */ function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while(++index < length){
            array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while(++index < start){
            otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
    };
}
/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */ function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
            return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
    } else {
        seen = iteratee ? [] : result;
    }
    outer: while(++index < length){
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while(seenIndex--){
                if (seen[seenIndex] === computed) {
                    continue outer;
                }
            }
            if (iteratee) {
                seen.push(computed);
            }
            result.push(value);
        } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
                seen.push(computed);
            }
            result.push(value);
        }
    }
    return result;
}
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */ var createSet = !(Set && 1 / setToArray(new Set([
    ,
    -0
]))[1] == INFINITY) ? noop : function(values) {
    return new Set(values);
};
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */ function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + "";
        } catch (e) {}
    }
    return "";
}
/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */ var union = baseRest(function(arrays) {
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */ function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */ function noop() {
// No operation performed.
}
module.exports = union;


/***/ }),

/***/ 22377:
/***/ ((module) => {

"use strict";
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ 
var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
/** `Object#toString` result references. */ var funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
}
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array ? array.length : 0;
    while(++index < length){
        if (comparator(value, array[index])) {
            return true;
        }
    }
    return false;
}
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while(fromRight ? index-- : ++index < length){
        if (predicate(array[index], index, array)) {
            return index;
        }
    }
    return -1;
}
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array.length;
    while(++index < length){
        if (array[index] === value) {
            return index;
        }
    }
    return -1;
}
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */ function baseIsNaN(value) {
    return value !== value;
}
/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function cacheHas(cache, key) {
    return cache.has(key);
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != "function") {
        try {
            result = !!(value + "");
        } catch (e) {}
    }
    return result;
}
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */ function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root["__core-js_shared__"];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
/** Built-in value references. */ var splice = arrayProto.splice;
/* Built-in method references that are verified to be native. */ var Map = getNative(root, "Map"), Set = getNative(root, "Set"), nativeCreate = getNative(Object, "create");
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    } else {
        splice.call(data, index, 1);
    }
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        data.push([
            key,
            value
        ]);
    } else {
        data[index][1] = value;
    }
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        "hash": new Hash,
        "map": new (Map || ListCache),
        "string": new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */ function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache;
    while(++index < length){
        this.add(values[index]);
    }
}
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */ function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */ function setCacheHas(value) {
    return this.__data__.has(value);
}
// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) {
            return length;
        }
    }
    return -1;
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */ function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
            return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
    } else {
        seen = iteratee ? [] : result;
    }
    outer: while(++index < length){
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while(seenIndex--){
                if (seen[seenIndex] === computed) {
                    continue outer;
                }
            }
            if (iteratee) {
                seen.push(computed);
            }
            result.push(value);
        } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
                seen.push(computed);
            }
            result.push(value);
        }
    }
    return result;
}
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */ var createSet = !(Set && 1 / setToArray(new Set([
    ,
    -0
]))[1] == INFINITY) ? noop : function(values) {
    return new Set(values);
};
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + "";
        } catch (e) {}
    }
    return "";
}
/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */ function uniq(array) {
    return array && array.length ? baseUniq(array) : [];
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
}
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */ function noop() {
// No operation performed.
}
module.exports = uniq;


/***/ }),

/***/ 56363:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = minimatch;
minimatch.Minimatch = Minimatch;
var path = function() {
    try {
        return __webpack_require__(71017);
    } catch (e) {}
}() || {
    sep: "/"
};
minimatch.sep = path.sep;
var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
var expand = __webpack_require__(14152);
var plTypes = {
    "!": {
        open: "(?:(?!(?:",
        close: "))[^/]*?)"
    },
    "?": {
        open: "(?:",
        close: ")?"
    },
    "+": {
        open: "(?:",
        close: ")+"
    },
    "*": {
        open: "(?:",
        close: ")*"
    },
    "@": {
        open: "(?:",
        close: ")"
    }
};
// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = "[^/]";
// * => any number of characters
var star = qmark + "*?";
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
// characters that need to be escaped in RegExp.
var reSpecials = charSet("().*{}+?[]^$\\!");
// "abc" -> { a:true, b:true, c:true }
function charSet(s) {
    return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
    }, {});
}
// normalizes slashes.
var slashSplit = /\/+/;
minimatch.filter = filter;
function filter(pattern, options) {
    options = options || {};
    return function(p, i, list) {
        return minimatch(p, pattern, options);
    };
}
function ext(a, b) {
    b = b || {};
    var t = {};
    Object.keys(a).forEach(function(k) {
        t[k] = a[k];
    });
    Object.keys(b).forEach(function(k) {
        t[k] = b[k];
    });
    return t;
}
minimatch.defaults = function(def) {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
    }
    var orig = minimatch;
    var m = function minimatch(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
    };
    m.Minimatch = function Minimatch(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
    };
    m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
    };
    m.filter = function filter(pattern, options) {
        return orig.filter(pattern, ext(def, options));
    };
    m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
    };
    m.makeRe = function makeRe(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
    };
    m.braceExpand = function braceExpand(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
    };
    m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
    };
    return m;
};
Minimatch.defaults = function(def) {
    return minimatch.defaults(def).Minimatch;
};
function minimatch(p, pattern, options) {
    assertValidPattern(pattern);
    if (!options) options = {};
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
}
function Minimatch(pattern, options) {
    if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
    }
    assertValidPattern(pattern);
    if (!options) options = {};
    pattern = pattern.trim();
    // windows support: need to use /, not \
    if (!options.allowWindowsEscape && path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    // make the set of regexps etc.
    this.make();
}
Minimatch.prototype.debug = function() {};
Minimatch.prototype.make = make;
function make() {
    var pattern = this.pattern;
    var options = this.options;
    // empty patterns and comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
    }
    if (!pattern) {
        this.empty = true;
        return;
    }
    // step 1: figure out negation, etc.
    this.parseNegate();
    // step 2: expand braces
    var set = this.globSet = this.braceExpand();
    if (options.debug) this.debug = function debug() {
        console.error.apply(console, arguments);
    };
    this.debug(this.pattern, set);
    // step 3: now we have a set, so turn each one into a series of path-portion
    // matching patterns.
    // These will be regexps, except in the case of "**", which is
    // set to the GLOBSTAR object for globstar behavior,
    // and will not contain any / characters
    set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
    });
    this.debug(this.pattern, set);
    // glob --> regexps
    set = set.map(function(s, si, set) {
        return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    // filter out everything that didn't compile properly.
    set = set.filter(function(s) {
        return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
}
Minimatch.prototype.parseNegate = parseNegate;
function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate) return;
    for(var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++){
        negate = !negate;
        negateOffset++;
    }
    if (negateOffset) this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
}
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
};
Minimatch.prototype.braceExpand = braceExpand;
function braceExpand(pattern, options) {
    if (!options) {
        if (this instanceof Minimatch) {
            options = this.options;
        } else {
            options = {};
        }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    assertValidPattern(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [
            pattern
        ];
    }
    return expand(pattern);
}
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = function(pattern) {
    if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
    }
};
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse;
var SUBPARSE = {};
function parse(pattern, isSub) {
    assertValidPattern(pattern);
    var options = this.options;
    // shortcuts
    if (pattern === "**") {
        if (!options.noglobstar) return GLOBSTAR;
        else pattern = "*";
    }
    if (pattern === "") return "";
    var re = "";
    var hasMagic = !!options.nocase;
    var escaping = false;
    // ? => one single character
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    // . and .. never match anything that doesn't start with .,
    // even when options.dot is set.
    var patternStart = pattern.charAt(0) === "." ? "" // anything
     : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self = this;
    function clearStateChar() {
        if (stateChar) {
            // we had some state-tracking character
            // that wasn't consumed by this pass.
            switch(stateChar){
                case "*":
                    re += star;
                    hasMagic = true;
                    break;
                case "?":
                    re += qmark;
                    hasMagic = true;
                    break;
                default:
                    re += "\\" + stateChar;
                    break;
            }
            self.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
        }
    }
    for(var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++){
        this.debug("%s	%s %s %j", pattern, i, re, c);
        // skip over any that are escaped.
        if (escaping && reSpecials[c]) {
            re += "\\" + c;
            escaping = false;
            continue;
        }
        switch(c){
            /* istanbul ignore next */ case "/":
                {
                    // completely not allowed, even escaped.
                    // Should already be path-split by now.
                    return false;
                }
            case "\\":
                clearStateChar();
                escaping = true;
                continue;
            // the various stateChar values
            // for the "extglob" stuff.
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
                this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
                // all of those are literals inside a class, except that
                // the glob [!a] means [^a] in regexp
                if (inClass) {
                    this.debug("  in class");
                    if (c === "!" && i === classStart + 1) c = "^";
                    re += c;
                    continue;
                }
                // if we already have a stateChar, then it means
                // that there was something like ** or +? in there.
                // Handle the stateChar, then proceed with this one.
                self.debug("call clearStateChar %j", stateChar);
                clearStateChar();
                stateChar = c;
                // if extglob is disabled, then +(asdf|foo) isn't a thing.
                // just clear the statechar *now*, rather than even diving into
                // the patternList stuff.
                if (options.noext) clearStateChar();
                continue;
            case "(":
                if (inClass) {
                    re += "(";
                    continue;
                }
                if (!stateChar) {
                    re += "\\(";
                    continue;
                }
                patternListStack.push({
                    type: stateChar,
                    start: i - 1,
                    reStart: re.length,
                    open: plTypes[stateChar].open,
                    close: plTypes[stateChar].close
                });
                // negation is (?:(?!js)[^/]*)
                re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
                this.debug("plType %j %j", stateChar, re);
                stateChar = false;
                continue;
            case ")":
                if (inClass || !patternListStack.length) {
                    re += "\\)";
                    continue;
                }
                clearStateChar();
                hasMagic = true;
                var pl = patternListStack.pop();
                // negation is (?:(?!js)[^/]*)
                // The others are (?:<pattern>)<type>
                re += pl.close;
                if (pl.type === "!") {
                    negativeLists.push(pl);
                }
                pl.reEnd = re.length;
                continue;
            case "|":
                if (inClass || !patternListStack.length || escaping) {
                    re += "\\|";
                    escaping = false;
                    continue;
                }
                clearStateChar();
                re += "|";
                continue;
            // these are mostly the same in regexp and glob
            case "[":
                // swallow any state-tracking char before the [
                clearStateChar();
                if (inClass) {
                    re += "\\" + c;
                    continue;
                }
                inClass = true;
                classStart = i;
                reClassStart = re.length;
                re += c;
                continue;
            case "]":
                //  a right bracket shall lose its special
                //  meaning and represent itself in
                //  a bracket expression if it occurs
                //  first in the list.  -- POSIX.2 2.8.3.2
                if (i === classStart + 1 || !inClass) {
                    re += "\\" + c;
                    escaping = false;
                    continue;
                }
                // handle the case where we left a class open.
                // "[z-a]" is valid, equivalent to "\[z-a\]"
                // split where the last [ was, make sure we don't have
                // an invalid re. if so, re-walk the contents of the
                // would-be class to re-translate any characters that
                // were passed through as-is
                // TODO: It would probably be faster to determine this
                // without a try/catch and a new RegExp, but it's tricky
                // to do safely.  For now, this is safe and works.
                var cs = pattern.substring(classStart + 1, i);
                try {
                    RegExp("[" + cs + "]");
                } catch (er) {
                    // not a valid class!
                    var sp = this.parse(cs, SUBPARSE);
                    re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                    hasMagic = hasMagic || sp[1];
                    inClass = false;
                    continue;
                }
                // finish up the class.
                hasMagic = true;
                inClass = false;
                re += c;
                continue;
            default:
                // swallow any state char that wasn't consumed
                clearStateChar();
                if (escaping) {
                    // no need
                    escaping = false;
                } else if (reSpecials[c] && !(c === "^" && inClass)) {
                    re += "\\";
                }
                re += c;
        } // switch
    } // for
    // handle the case where we left a class open.
    // "[abc" is valid, equivalent to "\[abc"
    if (inClass) {
        // split where the last [ was, and escape it
        // this is a huge pita.  We now have to re-walk
        // the contents of the would-be class to re-translate
        // any characters that were passed through as-is
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
    }
    // handle the case where we had a +( thing at the *end*
    // of the pattern.
    // each pattern list stack adds 3 chars, and we need to go through
    // and escape any | chars that were passed through as-is for the regexp.
    // Go through and escape them, taking care not to double-escape any
    // | chars that were already escaped.
    for(pl = patternListStack.pop(); pl; pl = patternListStack.pop()){
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        // maybe some even number of \, then maybe 1 \, followed by a |
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
            if (!$2) {
                // the | isn't already escaped, so escape it.
                $2 = "\\";
            }
            // need to escape all those slashes *again*, without escaping the
            // one that we need for escaping the | character.  As it works out,
            // escaping an even number of slashes can be done by simply repeating
            // it exactly after itself.  That's why this trick works.
            //
            // I am sorry that you have to see this.
            return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    // handle trailing things that only matter at the very end.
    clearStateChar();
    if (escaping) {
        // trailing \\
        re += "\\\\";
    }
    // only need to apply the nodot start if the re starts with
    // something that could conceivably capture a dot
    var addPatternStart = false;
    switch(re.charAt(0)){
        case "[":
        case ".":
        case "(":
            addPatternStart = true;
    }
    // Hack to work around lack of negative lookbehind in JS
    // A pattern like: *.!(x).!(y|z) needs to ensure that a name
    // like 'a.xyz.yz' doesn't match.  So, the first negative
    // lookahead, has to look ALL the way ahead, to the end of
    // the pattern.
    for(var n = negativeLists.length - 1; n > -1; n--){
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        // Handle nested stuff like *(*.js|!(*.json)), where open parens
        // mean that we should *not* include the ) in the bit that is considered
        // "after" the negated section.
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for(i = 0; i < openParensBefore; i++){
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
            dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
    }
    // if the re is not "" at this point, then we need to make sure
    // it doesn't match against an empty path part.
    // Otherwise a/* will match a/, which it should not.
    if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
    }
    if (addPatternStart) {
        re = patternStart + re;
    }
    // parsing just a piece of a larger pattern.
    if (isSub === SUBPARSE) {
        return [
            re,
            hasMagic
        ];
    }
    // skip the regexp for non-magical patterns
    // unescape anything in it, though, so that it'll be
    // an exact match against a file etc.
    if (!hasMagic) {
        return globUnescape(pattern);
    }
    var flags = options.nocase ? "i" : "";
    try {
        var regExp = new RegExp("^" + re + "$", flags);
    } catch (er) /* istanbul ignore next - should be impossible */ {
        // If it was an invalid regular expression, then it can't match
        // anything.  This trick looks for a character after the end of
        // the string, which is of course impossible, except in multi-line
        // mode, but it's not a /m regex.
        return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
}
minimatch.makeRe = function(pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe();
};
Minimatch.prototype.makeRe = makeRe;
function makeRe() {
    if (this.regexp || this.regexp === false) return this.regexp;
    // at this point, this.set is a 2d array of partial
    // pattern strings, or "**".
    //
    // It's better to use .match().  This function shouldn't
    // be used, really, but it's pretty convenient sometimes,
    // when you just want to work with a regex.
    var set = this.set;
    if (!set.length) {
        this.regexp = false;
        return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? "i" : "";
    var re = set.map(function(pattern) {
        return pattern.map(function(p) {
            return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
    }).join("|");
    // must match entire pattern
    // ending in a * or ** will make it less strict.
    re = "^(?:" + re + ")$";
    // can match anything, as long as it's not this.
    if (this.negate) re = "^(?!" + re + ").*$";
    try {
        this.regexp = new RegExp(re, flags);
    } catch (ex) /* istanbul ignore next - should be impossible */ {
        this.regexp = false;
    }
    return this.regexp;
}
minimatch.match = function(list, pattern, options) {
    options = options || {};
    var mm = new Minimatch(pattern, options);
    list = list.filter(function(f) {
        return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
Minimatch.prototype.match = function match(f, partial) {
    if (typeof partial === "undefined") partial = this.partial;
    this.debug("match", f, this.pattern);
    // short-circuit in the case of busted things.
    // comments, etc.
    if (this.comment) return false;
    if (this.empty) return f === "";
    if (f === "/" && partial) return true;
    var options = this.options;
    // windows: need to use /, not \
    if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
    }
    // treat the test path as a set of pathparts.
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    // just ONE of the pattern sets in this.set needs to match
    // in order for it to be valid.  If negating, then just one
    // match means that we have failed.
    // Either way, return on the first hit.
    var set = this.set;
    this.debug(this.pattern, "set", set);
    // Find the basename of the path by looking for the last non-empty segment
    var filename;
    var i;
    for(i = f.length - 1; i >= 0; i--){
        filename = f[i];
        if (filename) break;
    }
    for(i = 0; i < set.length; i++){
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
            file = [
                filename
            ];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
            if (options.flipNegate) return true;
            return !this.negate;
        }
    }
    // didn't get any hits.  this is success if it's a negative
    // pattern, failure otherwise.
    if (options.flipNegate) return false;
    return this.negate;
};
// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options = this.options;
    this.debug("matchOne", {
        "this": this,
        file: file,
        pattern: pattern
    });
    this.debug("matchOne", file.length, pattern.length);
    for(var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++){
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        // should be impossible.
        // some invalid regexp stuff in the set.
        /* istanbul ignore if */ if (p === false) return false;
        if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [
                pattern,
                p,
                f
            ]);
            // "**"
            // a/**/b/**/c would match the following:
            // a/b/x/y/z/c
            // a/x/y/z/b/c
            // a/b/x/b/x/c
            // a/b/c
            // To do this, take the rest of the pattern after
            // the **, and see if it would match the file remainder.
            // If so, return success.
            // If not, the ** "swallows" a segment, and try again.
            // This is recursively awful.
            //
            // a/**/b/**/c matching a/b/x/y/z/c
            // - a matches a
            // - doublestar
            //   - matchOne(b/x/y/z/c, b/**/c)
            //     - b matches b
            //     - doublestar
            //       - matchOne(x/y/z/c, c) -> no
            //       - matchOne(y/z/c, c) -> no
            //       - matchOne(z/c, c) -> no
            //       - matchOne(c, c) yes, hit
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
                this.debug("** at the end");
                // a ** at the end will just swallow the rest.
                // We have found a match.
                // however, it will not swallow /.x, unless
                // options.dot is set.
                // . and .. are *never* matched by **, for explosively
                // exponential reasons.
                for(; fi < fl; fi++){
                    if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return false;
                }
                return true;
            }
            // ok, let's see if we can swallow whatever we can.
            while(fr < fl){
                var swallowee = file[fr];
                this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
                // XXX remove this slice.  Just pass the start index.
                if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                    this.debug("globstar found match!", fr, fl, swallowee);
                    // found a match.
                    return true;
                } else {
                    // can't swallow "." or ".." ever.
                    // can only swallow ".foo" when explicitly asked.
                    if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                        this.debug("dot detected!", file, fr, pattern, pr);
                        break;
                    }
                    // ** swallows a segment, and continue.
                    this.debug("globstar swallow a segment, and continue");
                    fr++;
                }
            }
            // no match was found.
            // However, in partial mode, we can't say this is necessarily over.
            // If there's more *pattern* left, then
            /* istanbul ignore if */ if (partial) {
                // ran out of file
                this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
                if (fr === fl) return true;
            }
            return false;
        }
        // something other than **
        // non-magic patterns just have to match exactly
        // patterns with magic have been turned into regexps.
        var hit;
        if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
        } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
        }
        if (!hit) return false;
    }
    // Note: ending in / means that we'll get a final ""
    // at the end of the pattern.  This can only match a
    // corresponding "" at the end of the file.
    // If the file ends in /, then it can only match a
    // a pattern that ends in /, unless the pattern just
    // doesn't have any more for it. But, a/b/ should *not*
    // match "a/b/*", even though "" matches against the
    // [^/]*? pattern, except in partial mode, where it might
    // simply not be reached yet.
    // However, a/b/ should still satisfy a/*
    // now either we fell off the end of the pattern, or we're done.
    if (fi === fl && pi === pl) {
        // ran out of pattern and filename at the same time.
        // an exact hit!
        return true;
    } else if (fi === fl) {
        // ran out of file, but still had pattern left.
        // this is ok if we're doing the match as part of
        // a glob fs traversal.
        return partial;
    } else /* istanbul ignore else */ if (pi === pl) {
        // ran out of pattern, still have file left.
        // this is only acceptable if we're on the very last
        // empty segment of a file with a trailing slash.
        // a/* should match a/b/
        return fi === fl - 1 && file[fi] === "";
    }
    // should be unreachable.
    /* istanbul ignore next */ throw new Error("wtf?");
};
// replace stuff like \* with *
function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
}
function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}


/***/ }),

/***/ 31196:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var path = __webpack_require__(71017);
var fs = __webpack_require__(57147);
var _0777 = parseInt("0777", 8);
module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
function mkdirP(p, opts, f, made) {
    if (typeof opts === "function") {
        f = opts;
        opts = {};
    } else if (!opts || typeof opts !== "object") {
        opts = {
            mode: opts
        };
    }
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    if (mode === undefined) {
        mode = _0777;
    }
    if (!made) made = null;
    var cb = f || /* istanbul ignore next */ function() {};
    p = path.resolve(p);
    xfs.mkdir(p, mode, function(er) {
        if (!er) {
            made = made || p;
            return cb(null, made);
        }
        switch(er.code){
            case "ENOENT":
                /* istanbul ignore if */ if (path.dirname(p) === p) return cb(er);
                mkdirP(path.dirname(p), opts, function(er, made) {
                    /* istanbul ignore if */ if (er) cb(er, made);
                    else mkdirP(p, opts, cb, made);
                });
                break;
            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, function(er2, stat) {
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) cb(er, made);
                    else cb(null, made);
                });
                break;
        }
    });
}
mkdirP.sync = function sync(p, opts, made) {
    if (!opts || typeof opts !== "object") {
        opts = {
            mode: opts
        };
    }
    var mode = opts.mode;
    var xfs = opts.fs || fs;
    if (mode === undefined) {
        mode = _0777;
    }
    if (!made) made = null;
    p = path.resolve(p);
    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    } catch (err0) {
        switch(err0.code){
            case "ENOENT":
                made = sync(path.dirname(p), opts, made);
                sync(p, opts, made);
                break;
            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                var stat;
                try {
                    stat = xfs.statSync(p);
                } catch (err1) /* istanbul ignore next */ {
                    throw err0;
                }
                /* istanbul ignore if */ if (!stat.isDirectory()) throw err0;
                break;
        }
    }
    return made;
};


/***/ }),

/***/ 26218:
/***/ ((module) => {

"use strict";
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */ 
module.exports = function(path, stripTrailing) {
    if (typeof path !== "string") {
        throw new TypeError("expected path to be a string");
    }
    if (path === "\\" || path === "/") return "/";
    var len = path.length;
    if (len <= 1) return path;
    // ensure that win32 namespaces has two leading slashes, so that the path is
    // handled properly by the win32 version of path.parse() after being normalized
    // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces
    var prefix = "";
    if (len > 4 && path[3] === "\\") {
        var ch = path[2];
        if ((ch === "?" || ch === ".") && path.slice(0, 2) === "\\\\") {
            path = path.slice(2);
            prefix = "//";
        }
    }
    var segs = path.split(/[/\\]+/);
    if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
    }
    return prefix + segs.join("/");
};


/***/ }),

/***/ 16461:
/***/ ((module) => {

"use strict";

function posix(path) {
    return path.charAt(0) === "/";
}
function win32(path) {
    // https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    var result = splitDeviceRe.exec(path);
    var device = result[1] || "";
    var isUnc = Boolean(device && device.charAt(1) !== ":");
    // UNC paths are always absolute
    return Boolean(result[2] || isUnc);
}
module.exports = process.platform === "win32" ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;


/***/ }),

/***/ 31413:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = readdirGlob;
const fs = __webpack_require__(57147);
const { EventEmitter } = __webpack_require__(82361);
const { Minimatch } = __webpack_require__(5415);
const { resolve } = __webpack_require__(71017);
function readdir(dir, strict) {
    return new Promise((resolve, reject)=>{
        fs.readdir(dir, {
            withFileTypes: true
        }, (err, files)=>{
            if (err) {
                switch(err.code){
                    case "ENOTDIR":
                        if (strict) {
                            reject(err);
                        } else {
                            resolve([]);
                        }
                        break;
                    case "ENOTSUP":
                    case "ENOENT":
                    case "ENAMETOOLONG":
                    case "UNKNOWN":
                        resolve([]);
                        break;
                    case "ELOOP":
                    default:
                        reject(err);
                        break;
                }
            } else {
                resolve(files);
            }
        });
    });
}
function stat(file, followSymlinks) {
    return new Promise((resolve, reject)=>{
        const statFunc = followSymlinks ? fs.stat : fs.lstat;
        statFunc(file, (err, stats)=>{
            if (err) {
                switch(err.code){
                    case "ENOENT":
                        if (followSymlinks) {
                            // Fallback to lstat to handle broken links as files
                            resolve(stat(file, false));
                        } else {
                            resolve(null);
                        }
                        break;
                    default:
                        resolve(null);
                        break;
                }
            } else {
                resolve(stats);
            }
        });
    });
}
async function* exploreWalkAsync(dir, path, followSymlinks, useStat, shouldSkip, strict) {
    let files = await readdir(path + dir, strict);
    for (const file of files){
        let name = file.name;
        if (name === undefined) {
            // undefined file.name means the `withFileTypes` options is not supported by node
            // we have to call the stat function to know if file is directory or not.
            name = file;
            useStat = true;
        }
        const filename = dir + "/" + name;
        const relative = filename.slice(1); // Remove the leading /
        const absolute = path + "/" + relative;
        let stats = null;
        if (useStat || followSymlinks) {
            stats = await stat(absolute, followSymlinks);
        }
        if (!stats && file.name !== undefined) {
            stats = file;
        }
        if (stats === null) {
            stats = {
                isDirectory: ()=>false
            };
        }
        if (stats.isDirectory()) {
            if (!shouldSkip(relative)) {
                yield {
                    relative,
                    absolute,
                    stats
                };
                yield* exploreWalkAsync(filename, path, followSymlinks, useStat, shouldSkip, false);
            }
        } else {
            yield {
                relative,
                absolute,
                stats
            };
        }
    }
}
async function* explore(path, followSymlinks, useStat, shouldSkip) {
    yield* exploreWalkAsync("", path, followSymlinks, useStat, shouldSkip, true);
}
function readOptions(options) {
    return {
        pattern: options.pattern,
        dot: !!options.dot,
        noglobstar: !!options.noglobstar,
        matchBase: !!options.matchBase,
        nocase: !!options.nocase,
        ignore: options.ignore,
        skip: options.skip,
        follow: !!options.follow,
        stat: !!options.stat,
        nodir: !!options.nodir,
        mark: !!options.mark,
        silent: !!options.silent,
        absolute: !!options.absolute
    };
}
class ReaddirGlob extends EventEmitter {
    constructor(cwd, options, cb){
        super();
        if (typeof options === "function") {
            cb = options;
            options = null;
        }
        this.options = readOptions(options || {});
        this.matchers = [];
        if (this.options.pattern) {
            const matchers = Array.isArray(this.options.pattern) ? this.options.pattern : [
                this.options.pattern
            ];
            this.matchers = matchers.map((m)=>new Minimatch(m, {
                    dot: this.options.dot,
                    noglobstar: this.options.noglobstar,
                    matchBase: this.options.matchBase,
                    nocase: this.options.nocase
                }));
        }
        this.ignoreMatchers = [];
        if (this.options.ignore) {
            const ignorePatterns = Array.isArray(this.options.ignore) ? this.options.ignore : [
                this.options.ignore
            ];
            this.ignoreMatchers = ignorePatterns.map((ignore)=>new Minimatch(ignore, {
                    dot: true
                }));
        }
        this.skipMatchers = [];
        if (this.options.skip) {
            const skipPatterns = Array.isArray(this.options.skip) ? this.options.skip : [
                this.options.skip
            ];
            this.skipMatchers = skipPatterns.map((skip)=>new Minimatch(skip, {
                    dot: true
                }));
        }
        this.iterator = explore(resolve(cwd || "."), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this));
        this.paused = false;
        this.inactive = false;
        this.aborted = false;
        if (cb) {
            this._matches = [];
            this.on("match", (match)=>this._matches.push(this.options.absolute ? match.absolute : match.relative));
            this.on("error", (err)=>cb(err));
            this.on("end", ()=>cb(null, this._matches));
        }
        setTimeout(()=>this._next(), 0);
    }
    _shouldSkipDirectory(relative) {
        //console.log(relative, this.skipMatchers.some(m => m.match(relative)));
        return this.skipMatchers.some((m)=>m.match(relative));
    }
    _fileMatches(relative, isDirectory) {
        const file = relative + (isDirectory ? "/" : "");
        return (this.matchers.length === 0 || this.matchers.some((m)=>m.match(file))) && !this.ignoreMatchers.some((m)=>m.match(file)) && (!this.options.nodir || !isDirectory);
    }
    _next() {
        if (!this.paused && !this.aborted) {
            this.iterator.next().then((obj)=>{
                if (!obj.done) {
                    const isDirectory = obj.value.stats.isDirectory();
                    if (this._fileMatches(obj.value.relative, isDirectory)) {
                        let relative = obj.value.relative;
                        let absolute = obj.value.absolute;
                        if (this.options.mark && isDirectory) {
                            relative += "/";
                            absolute += "/";
                        }
                        if (this.options.stat) {
                            this.emit("match", {
                                relative,
                                absolute,
                                stat: obj.value.stats
                            });
                        } else {
                            this.emit("match", {
                                relative,
                                absolute
                            });
                        }
                    }
                    this._next(this.iterator);
                } else {
                    this.emit("end");
                }
            }).catch((err)=>{
                this.abort();
                this.emit("error", err);
                if (!err.code && !this.options.silent) {
                    console.error(err);
                }
            });
        } else {
            this.inactive = true;
        }
    }
    abort() {
        this.aborted = true;
    }
    pause() {
        this.paused = true;
    }
    resume() {
        this.paused = false;
        if (this.inactive) {
            this.inactive = false;
            this._next();
        }
    }
}
function readdirGlob(pattern, options, cb) {
    return new ReaddirGlob(pattern, options, cb);
}
readdirGlob.ReaddirGlob = ReaddirGlob;


/***/ }),

/***/ 47011:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var balanced = __webpack_require__(2165);
module.exports = expandTop;
var escSlash = "\x00SLASH" + Math.random() + "\x00";
var escOpen = "\x00OPEN" + Math.random() + "\x00";
var escClose = "\x00CLOSE" + Math.random() + "\x00";
var escComma = "\x00COMMA" + Math.random() + "\x00";
var escPeriod = "\x00PERIOD" + Math.random() + "\x00";
function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
}
function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
}
// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
    if (!str) return [
        ""
    ];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m) return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
}
function expandTop(str) {
    if (!str) return [];
    // I don't know why Bash 4.3 does this, but it does.
    // Anything starting with {} will have the first two bytes preserved
    // but *only* at the top level, so {},a}b will not expand to anything,
    // but a{},b}c will be expanded to [a}c,abc].
    // One could argue that this is a bug in Bash, but since the goal of
    // this module is to match Bash's rules, we escape a leading {}
    if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
}
function embrace(str) {
    return "{" + str + "}";
}
function isPadded(el) {
    return /^-?0\d/.test(el);
}
function lte(i, y) {
    return i <= y;
}
function gte(i, y) {
    return i >= y;
}
function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m) return [
        str
    ];
    // no need to expand pre, since it is guaranteed to be free of brace-sets
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [
        ""
    ];
    if (/\$$/.test(m.pre)) {
        for(var k = 0; k < post.length; k++){
            var expansion = pre + "{" + m.body + "}" + post[k];
            expansions.push(expansion);
        }
    } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
            // {a},b}
            if (m.post.match(/,(?!,).*\}/)) {
                str = m.pre + "{" + m.body + escClose + m.post;
                return expand(str);
            }
            return [
                str
            ];
        }
        var n;
        if (isSequence) {
            n = m.body.split(/\.\./);
        } else {
            n = parseCommaParts(m.body);
            if (n.length === 1) {
                // x{{a,b}}y ==> x{a}y x{b}y
                n = expand(n[0], false).map(embrace);
                if (n.length === 1) {
                    return post.map(function(p) {
                        return m.pre + n[0] + p;
                    });
                }
            }
        }
        // at this point, n is the parts, and we know it's not a comma set
        // with a single entry.
        var N;
        if (isSequence) {
            var x = numeric(n[0]);
            var y = numeric(n[1]);
            var width = Math.max(n[0].length, n[1].length);
            var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
            var test = lte;
            var reverse = y < x;
            if (reverse) {
                incr *= -1;
                test = gte;
            }
            var pad = n.some(isPadded);
            N = [];
            for(var i = x; test(i, y); i += incr){
                var c;
                if (isAlphaSequence) {
                    c = String.fromCharCode(i);
                    if (c === "\\") c = "";
                } else {
                    c = String(i);
                    if (pad) {
                        var need = width - c.length;
                        if (need > 0) {
                            var z = new Array(need + 1).join("0");
                            if (i < 0) c = "-" + z + c.slice(1);
                            else c = z + c;
                        }
                    }
                }
                N.push(c);
            }
        } else {
            N = [];
            for(var j = 0; j < n.length; j++){
                N.push.apply(N, expand(n[j], false));
            }
        }
        for(var j = 0; j < N.length; j++){
            for(var k = 0; k < post.length; k++){
                var expansion = pre + N[j] + post[k];
                if (!isTop || isSequence || expansion) expansions.push(expansion);
            }
        }
    }
    return expansions;
}


/***/ }),

/***/ 50421:
/***/ ((module) => {

"use strict";

const isWindows = typeof process === "object" && process && process.platform === "win32";
module.exports = isWindows ? {
    sep: "\\"
} : {
    sep: "/"
};


/***/ }),

/***/ 5415:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const minimatch = module.exports = (p, pattern, options = {})=>{
    assertValidPattern(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
module.exports = minimatch;
const path = __webpack_require__(50421);
minimatch.sep = path.sep;
const GLOBSTAR = Symbol("globstar **");
minimatch.GLOBSTAR = GLOBSTAR;
const expand = __webpack_require__(47011);
const plTypes = {
    "!": {
        open: "(?:(?!(?:",
        close: "))[^/]*?)"
    },
    "?": {
        open: "(?:",
        close: ")?"
    },
    "+": {
        open: "(?:",
        close: ")+"
    },
    "*": {
        open: "(?:",
        close: ")*"
    },
    "@": {
        open: "(?:",
        close: ")"
    }
};
// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = "[^/]";
// * => any number of characters
const star = qmark + "*?";
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
// "abc" -> { a:true, b:true, c:true }
const charSet = (s)=>s.split("").reduce((set, c)=>{
        set[c] = true;
        return set;
    }, {});
// characters that need to be escaped in RegExp.
const reSpecials = charSet("().*{}+?[]^$\\!");
// characters that indicate we have to add the pattern start
const addPatternStartSet = charSet("[.(");
// normalizes slashes.
const slashSplit = /\/+/;
minimatch.filter = (pattern, options = {})=>(p, i, list)=>minimatch(p, pattern, options);
const ext = (a, b = {})=>{
    const t = {};
    Object.keys(a).forEach((k)=>t[k] = a[k]);
    Object.keys(b).forEach((k)=>t[k] = b[k]);
    return t;
};
minimatch.defaults = (def)=>{
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
    }
    const orig = minimatch;
    const m = (p, pattern, options)=>orig(p, pattern, ext(def, options));
    m.Minimatch = class Minimatch extends orig.Minimatch {
        constructor(pattern, options){
            super(pattern, ext(def, options));
        }
    };
    m.Minimatch.defaults = (options)=>orig.defaults(ext(def, options)).Minimatch;
    m.filter = (pattern, options)=>orig.filter(pattern, ext(def, options));
    m.defaults = (options)=>orig.defaults(ext(def, options));
    m.makeRe = (pattern, options)=>orig.makeRe(pattern, ext(def, options));
    m.braceExpand = (pattern, options)=>orig.braceExpand(pattern, ext(def, options));
    m.match = (list, pattern, options)=>orig.match(list, pattern, ext(def, options));
    return m;
};
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = (pattern, options)=>braceExpand(pattern, options);
const braceExpand = (pattern, options = {})=>{
    assertValidPattern(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [
            pattern
        ];
    }
    return expand(pattern);
};
const MAX_PATTERN_LENGTH = 1024 * 64;
const assertValidPattern = (pattern)=>{
    if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
    }
};
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const SUBPARSE = Symbol("subparse");
minimatch.makeRe = (pattern, options)=>new Minimatch(pattern, options || {}).makeRe();
minimatch.match = (list, pattern, options = {})=>{
    const mm = new Minimatch(pattern, options);
    list = list.filter((f)=>mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
// replace stuff like \* with *
const globUnescape = (s)=>s.replace(/\\(.)/g, "$1");
const charUnescape = (s)=>s.replace(/\\([^-\]])/g, "$1");
const regExpEscape = (s)=>s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
const braExpEscape = (s)=>s.replace(/[[\]\\]/g, "\\$&");
class Minimatch {
    constructor(pattern, options){
        assertValidPattern(pattern);
        if (!options) options = {};
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        // make the set of regexps etc.
        this.make();
    }
    debug() {}
    make() {
        const pattern = this.pattern;
        const options = this.options;
        // empty patterns and comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === "#") {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        // step 1: figure out negation, etc.
        this.parseNegate();
        // step 2: expand braces
        let set = this.globSet = this.braceExpand();
        if (options.debug) this.debug = (...args)=>console.error(...args);
        this.debug(this.pattern, set);
        // step 3: now we have a set, so turn each one into a series of path-portion
        // matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        set = this.globParts = set.map((s)=>s.split(slashSplit));
        this.debug(this.pattern, set);
        // glob --> regexps
        set = set.map((s, si, set)=>s.map(this.parse, this));
        this.debug(this.pattern, set);
        // filter out everything that didn't compile properly.
        set = set.filter((s)=>s.indexOf(false) === -1);
        this.debug(this.pattern, set);
        this.set = set;
    }
    parseNegate() {
        if (this.options.nonegate) return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for(let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++){
            negate = !negate;
            negateOffset++;
        }
        if (negateOffset) this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial) {
        var options = this.options;
        this.debug("matchOne", {
            "this": this,
            file: file,
            pattern: pattern
        });
        this.debug("matchOne", file.length, pattern.length);
        for(var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++){
            this.debug("matchOne loop");
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            // should be impossible.
            // some invalid regexp stuff in the set.
            /* istanbul ignore if */ if (p === false) return false;
            if (p === GLOBSTAR) {
                this.debug("GLOBSTAR", [
                    pattern,
                    p,
                    f
                ]);
                // "**"
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** "swallows" a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -> no
                //       - matchOne(y/z/c, c) -> no
                //       - matchOne(z/c, c) -> no
                //       - matchOne(c, c) yes, hit
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug("** at the end");
                    // a ** at the end will just swallow the rest.
                    // We have found a match.
                    // however, it will not swallow /.x, unless
                    // options.dot is set.
                    // . and .. are *never* matched by **, for explosively
                    // exponential reasons.
                    for(; fi < fl; fi++){
                        if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return false;
                    }
                    return true;
                }
                // ok, let's see if we can swallow whatever we can.
                while(fr < fl){
                    var swallowee = file[fr];
                    this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
                    // XXX remove this slice.  Just pass the start index.
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug("globstar found match!", fr, fl, swallowee);
                        // found a match.
                        return true;
                    } else {
                        // can't swallow "." or ".." ever.
                        // can only swallow ".foo" when explicitly asked.
                        if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                            this.debug("dot detected!", file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug("globstar swallow a segment, and continue");
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                // If there's more *pattern* left, then
                /* istanbul ignore if */ if (partial) {
                    // ran out of file
                    this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
                    if (fr === fl) return true;
                }
                return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            var hit;
            if (typeof p === "string") {
                hit = f === p;
                this.debug("string match", p, f, hit);
            } else {
                hit = f.match(p);
                this.debug("pattern match", p, f, hit);
            }
            if (!hit) return false;
        }
        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        } else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial;
        } else /* istanbul ignore else */ if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 && file[fi] === "";
        }
        // should be unreachable.
        /* istanbul ignore next */ throw new Error("wtf?");
    }
    braceExpand() {
        return braceExpand(this.pattern, this.options);
    }
    parse(pattern, isSub) {
        assertValidPattern(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === "**") {
            if (!options.noglobstar) return GLOBSTAR;
            else pattern = "*";
        }
        if (pattern === "") return "";
        let re = "";
        let hasMagic = false;
        let escaping = false;
        // ? => one single character
        const patternListStack = [];
        const negativeLists = [];
        let stateChar;
        let inClass = false;
        let reClassStart = -1;
        let classStart = -1;
        let cs;
        let pl;
        let sp;
        // . and .. never match anything that doesn't start with .,
        // even when options.dot is set.  However, if the pattern
        // starts with ., then traversal patterns can match.
        let dotTravAllowed = pattern.charAt(0) === ".";
        let dotFileAllowed = options.dot || dotTravAllowed;
        const patternStart = ()=>dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const subPatternStart = (p)=>p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const clearStateChar = ()=>{
            if (stateChar) {
                // we had some state-tracking character
                // that wasn't consumed by this pass.
                switch(stateChar){
                    case "*":
                        re += star;
                        hasMagic = true;
                        break;
                    case "?":
                        re += qmark;
                        hasMagic = true;
                        break;
                    default:
                        re += "\\" + stateChar;
                        break;
                }
                this.debug("clearStateChar %j %j", stateChar, re);
                stateChar = false;
            }
        };
        for(let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++){
            this.debug("%s	%s %s %j", pattern, i, re, c);
            // skip over any that are escaped.
            if (escaping) {
                /* istanbul ignore next - completely not allowed, even escaped. */ if (c === "/") {
                    return false;
                }
                if (reSpecials[c]) {
                    re += "\\";
                }
                re += c;
                escaping = false;
                continue;
            }
            switch(c){
                /* istanbul ignore next */ case "/":
                    {
                        // Should already be path-split by now.
                        return false;
                    }
                case "\\":
                    if (inClass && pattern.charAt(i + 1) === "-") {
                        re += c;
                        continue;
                    }
                    clearStateChar();
                    escaping = true;
                    continue;
                // the various stateChar values
                // for the "extglob" stuff.
                case "?":
                case "*":
                case "+":
                case "@":
                case "!":
                    this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
                    // all of those are literals inside a class, except that
                    // the glob [!a] means [^a] in regexp
                    if (inClass) {
                        this.debug("  in class");
                        if (c === "!" && i === classStart + 1) c = "^";
                        re += c;
                        continue;
                    }
                    // if we already have a stateChar, then it means
                    // that there was something like ** or +? in there.
                    // Handle the stateChar, then proceed with this one.
                    this.debug("call clearStateChar %j", stateChar);
                    clearStateChar();
                    stateChar = c;
                    // if extglob is disabled, then +(asdf|foo) isn't a thing.
                    // just clear the statechar *now*, rather than even diving into
                    // the patternList stuff.
                    if (options.noext) clearStateChar();
                    continue;
                case "(":
                    {
                        if (inClass) {
                            re += "(";
                            continue;
                        }
                        if (!stateChar) {
                            re += "\\(";
                            continue;
                        }
                        const plEntry = {
                            type: stateChar,
                            start: i - 1,
                            reStart: re.length,
                            open: plTypes[stateChar].open,
                            close: plTypes[stateChar].close
                        };
                        this.debug(this.pattern, "	", plEntry);
                        patternListStack.push(plEntry);
                        // negation is (?:(?!(?:js)(?:<rest>))[^/]*)
                        re += plEntry.open;
                        // next entry starts with a dot maybe?
                        if (plEntry.start === 0 && plEntry.type !== "!") {
                            dotTravAllowed = true;
                            re += subPatternStart(pattern.slice(i + 1));
                        }
                        this.debug("plType %j %j", stateChar, re);
                        stateChar = false;
                        continue;
                    }
                case ")":
                    {
                        const plEntry = patternListStack[patternListStack.length - 1];
                        if (inClass || !plEntry) {
                            re += "\\)";
                            continue;
                        }
                        patternListStack.pop();
                        // closing an extglob
                        clearStateChar();
                        hasMagic = true;
                        pl = plEntry;
                        // negation is (?:(?!js)[^/]*)
                        // The others are (?:<pattern>)<type>
                        re += pl.close;
                        if (pl.type === "!") {
                            negativeLists.push(Object.assign(pl, {
                                reEnd: re.length
                            }));
                        }
                        continue;
                    }
                case "|":
                    {
                        const plEntry = patternListStack[patternListStack.length - 1];
                        if (inClass || !plEntry) {
                            re += "\\|";
                            continue;
                        }
                        clearStateChar();
                        re += "|";
                        // next subpattern can start with a dot?
                        if (plEntry.start === 0 && plEntry.type !== "!") {
                            dotTravAllowed = true;
                            re += subPatternStart(pattern.slice(i + 1));
                        }
                        continue;
                    }
                // these are mostly the same in regexp and glob
                case "[":
                    // swallow any state-tracking char before the [
                    clearStateChar();
                    if (inClass) {
                        re += "\\" + c;
                        continue;
                    }
                    inClass = true;
                    classStart = i;
                    reClassStart = re.length;
                    re += c;
                    continue;
                case "]":
                    //  a right bracket shall lose its special
                    //  meaning and represent itself in
                    //  a bracket expression if it occurs
                    //  first in the list.  -- POSIX.2 2.8.3.2
                    if (i === classStart + 1 || !inClass) {
                        re += "\\" + c;
                        continue;
                    }
                    // split where the last [ was, make sure we don't have
                    // an invalid re. if so, re-walk the contents of the
                    // would-be class to re-translate any characters that
                    // were passed through as-is
                    // TODO: It would probably be faster to determine this
                    // without a try/catch and a new RegExp, but it's tricky
                    // to do safely.  For now, this is safe and works.
                    cs = pattern.substring(classStart + 1, i);
                    try {
                        RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
                        // looks good, finish up the class.
                        re += c;
                    } catch (er) {
                        // out of order ranges in JS are errors, but in glob syntax,
                        // they're just a range that matches nothing.
                        re = re.substring(0, reClassStart) + "(?:$.)" // match nothing ever
                        ;
                    }
                    hasMagic = true;
                    inClass = false;
                    continue;
                default:
                    // swallow any state char that wasn't consumed
                    clearStateChar();
                    if (reSpecials[c] && !(c === "^" && inClass)) {
                        re += "\\";
                    }
                    re += c;
                    break;
            } // switch
        } // for
        // handle the case where we left a class open.
        // "[abc" is valid, equivalent to "\[abc"
        if (inClass) {
            // split where the last [ was, and escape it
            // this is a huge pita.  We now have to re-walk
            // the contents of the would-be class to re-translate
            // any characters that were passed through as-is
            cs = pattern.slice(classStart + 1);
            sp = this.parse(cs, SUBPARSE);
            re = re.substring(0, reClassStart) + "\\[" + sp[0];
            hasMagic = hasMagic || sp[1];
        }
        // handle the case where we had a +( thing at the *end*
        // of the pattern.
        // each pattern list stack adds 3 chars, and we need to go through
        // and escape any | chars that were passed through as-is for the regexp.
        // Go through and escape them, taking care not to double-escape any
        // | chars that were already escaped.
        for(pl = patternListStack.pop(); pl; pl = patternListStack.pop()){
            let tail;
            tail = re.slice(pl.reStart + pl.open.length);
            this.debug("setting tail", re, pl);
            // maybe some even number of \, then maybe 1 \, followed by a |
            tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2)=>{
                /* istanbul ignore else - should already be done */ if (!$2) {
                    // the | isn't already escaped, so escape it.
                    $2 = "\\";
                }
                // need to escape all those slashes *again*, without escaping the
                // one that we need for escaping the | character.  As it works out,
                // escaping an even number of slashes can be done by simply repeating
                // it exactly after itself.  That's why this trick works.
                //
                // I am sorry that you have to see this.
                return $1 + $1 + $2 + "|";
            });
            this.debug("tail=%j\n   %s", tail, tail, pl, re);
            const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
            hasMagic = true;
            re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        // handle trailing things that only matter at the very end.
        clearStateChar();
        if (escaping) {
            // trailing \\
            re += "\\\\";
        }
        // only need to apply the nodot start if the re starts with
        // something that could conceivably capture a dot
        const addPatternStart = addPatternStartSet[re.charAt(0)];
        // Hack to work around lack of negative lookbehind in JS
        // A pattern like: *.!(x).!(y|z) needs to ensure that a name
        // like 'a.xyz.yz' doesn't match.  So, the first negative
        // lookahead, has to look ALL the way ahead, to the end of
        // the pattern.
        for(let n = negativeLists.length - 1; n > -1; n--){
            const nl = negativeLists[n];
            const nlBefore = re.slice(0, nl.reStart);
            const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
            let nlAfter = re.slice(nl.reEnd);
            const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
            // Handle nested stuff like *(*.js|!(*.json)), where open parens
            // mean that we should *not* include the ) in the bit that is considered
            // "after" the negated section.
            const closeParensBefore = nlBefore.split(")").length;
            const openParensBefore = nlBefore.split("(").length - closeParensBefore;
            let cleanAfter = nlAfter;
            for(let i = 0; i < openParensBefore; i++){
                cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
            }
            nlAfter = cleanAfter;
            const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
            re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        // if the re is not "" at this point, then we need to make sure
        // it doesn't match against an empty path part.
        // Otherwise a/* will match a/, which it should not.
        if (re !== "" && hasMagic) {
            re = "(?=.)" + re;
        }
        if (addPatternStart) {
            re = patternStart() + re;
        }
        // parsing just a piece of a larger pattern.
        if (isSub === SUBPARSE) {
            return [
                re,
                hasMagic
            ];
        }
        // if it's nocase, and the lcase/uppercase don't match, it's magic
        if (options.nocase && !hasMagic) {
            hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
        }
        // skip the regexp for non-magical patterns
        // unescape anything in it, though, so that it'll be
        // an exact match against a file etc.
        if (!hasMagic) {
            return globUnescape(pattern);
        }
        const flags = options.nocase ? "i" : "";
        try {
            return Object.assign(new RegExp("^" + re + "$", flags), {
                _glob: pattern,
                _src: re
            });
        } catch (er) /* istanbul ignore next - should be impossible */ {
            // If it was an invalid regular expression, then it can't match
            // anything.  This trick looks for a character after the end of
            // the string, which is of course impossible, except in multi-line
            // mode, but it's not a /m regex.
            return new RegExp("$.");
        }
    }
    makeRe() {
        if (this.regexp || this.regexp === false) return this.regexp;
        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
        const set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = options.nocase ? "i" : "";
        // coalesce globstars and regexpify non-globstar patterns
        // if it's the only item, then we just do one twoStar
        // if it's the first, and there are more, prepend (\/|twoStar\/)? to next
        // if it's the last, append (\/twoStar|) to previous
        // if it's in the middle, append (\/|\/twoStar\/) to previous
        // then filter out GLOBSTAR symbols
        let re = set.map((pattern)=>{
            pattern = pattern.map((p)=>typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src).reduce((set, p)=>{
                if (!(set[set.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
                    set.push(p);
                }
                return set;
            }, []);
            pattern.forEach((p, i)=>{
                if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
                    return;
                }
                if (i === 0) {
                    if (pattern.length > 1) {
                        pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
                    } else {
                        pattern[i] = twoStar;
                    }
                } else if (i === pattern.length - 1) {
                    pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
                } else {
                    pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
                    pattern[i + 1] = GLOBSTAR;
                }
            });
            return pattern.filter((p)=>p !== GLOBSTAR).join("/");
        }).join("|");
        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = "^(?:" + re + ")$";
        // can match anything, as long as it's not this.
        if (this.negate) re = "^(?!" + re + ").*$";
        try {
            this.regexp = new RegExp(re, flags);
        } catch (ex) /* istanbul ignore next - should be impossible */ {
            this.regexp = false;
        }
        return this.regexp;
    }
    match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) return false;
        if (this.empty) return f === "";
        if (f === "/" && partial) return true;
        const options = this.options;
        // windows: need to use /, not \
        if (path.sep !== "/") {
            f = f.split(path.sep).join("/");
        }
        // treat the test path as a set of pathparts.
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.
        const set = this.set;
        this.debug(this.pattern, "set", set);
        // Find the basename of the path by looking for the last non-empty segment
        let filename;
        for(let i = f.length - 1; i >= 0; i--){
            filename = f[i];
            if (filename) break;
        }
        for(let i = 0; i < set.length; i++){
            const pattern = set[i];
            let file = f;
            if (options.matchBase && pattern.length === 1) {
                file = [
                    filename
                ];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) return true;
                return !this.negate;
            }
        }
        // didn't get any hits.  this is success if it's a negative
        // pattern, failure otherwise.
        if (options.flipNegate) return false;
        return this.negate;
    }
    static defaults(def) {
        return minimatch.defaults(def).Minimatch;
    }
}
minimatch.Minimatch = Minimatch;


/***/ }),

/***/ 60014:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const ed5 = __webpack_require__(50829);
const ed2 = __webpack_require__(35679);
const NSed3 = __webpack_require__(60996);
var isS = ed5.isS;
var isChar10 = ed5.isChar;
var isNameStartChar = ed5.isNameStartChar;
var isNameChar = ed5.isNameChar;
var S_LIST = ed5.S_LIST;
var NAME_RE = ed5.NAME_RE;
var isChar11 = ed2.isChar;
var isNCNameStartChar = NSed3.isNCNameStartChar;
var isNCNameChar = NSed3.isNCNameChar;
var NC_NAME_RE = NSed3.NC_NAME_RE;
const XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
const XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
const rootNS = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    __proto__: null,
    xml: XML_NAMESPACE,
    xmlns: XMLNS_NAMESPACE
};
const XML_ENTITIES = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    __proto__: null,
    amp: "&",
    gt: ">",
    lt: "<",
    quot: '"',
    apos: "'"
};
// EOC: end-of-chunk
const EOC = -1;
const NL_LIKE = -2;
const S_BEGIN = 0; // Initial state.
const S_BEGIN_WHITESPACE = 1; // leading whitespace
const S_DOCTYPE = 2; // <!DOCTYPE
const S_DOCTYPE_QUOTE = 3; // <!DOCTYPE "//blah
const S_DTD = 4; // <!DOCTYPE "//blah" [ ...
const S_DTD_QUOTED = 5; // <!DOCTYPE "//blah" [ "foo
const S_DTD_OPEN_WAKA = 6;
const S_DTD_OPEN_WAKA_BANG = 7;
const S_DTD_COMMENT = 8; // <!--
const S_DTD_COMMENT_ENDING = 9; // <!-- blah -
const S_DTD_COMMENT_ENDED = 10; // <!-- blah --
const S_DTD_PI = 11; // <?
const S_DTD_PI_ENDING = 12; // <?hi "there" ?
const S_TEXT = 13; // general stuff
const S_ENTITY = 14; // &amp and such
const S_OPEN_WAKA = 15; // <
const S_OPEN_WAKA_BANG = 16; // <!...
const S_COMMENT = 17; // <!--
const S_COMMENT_ENDING = 18; // <!-- blah -
const S_COMMENT_ENDED = 19; // <!-- blah --
const S_CDATA = 20; // <![CDATA[ something
const S_CDATA_ENDING = 21; // ]
const S_CDATA_ENDING_2 = 22; // ]]
const S_PI_FIRST_CHAR = 23; // <?hi, first char
const S_PI_REST = 24; // <?hi, rest of the name
const S_PI_BODY = 25; // <?hi there
const S_PI_ENDING = 26; // <?hi "there" ?
const S_XML_DECL_NAME_START = 27; // <?xml
const S_XML_DECL_NAME = 28; // <?xml foo
const S_XML_DECL_EQ = 29; // <?xml foo=
const S_XML_DECL_VALUE_START = 30; // <?xml foo=
const S_XML_DECL_VALUE = 31; // <?xml foo="bar"
const S_XML_DECL_SEPARATOR = 32; // <?xml foo="bar"
const S_XML_DECL_ENDING = 33; // <?xml ... ?
const S_OPEN_TAG = 34; // <strong
const S_OPEN_TAG_SLASH = 35; // <strong /
const S_ATTRIB = 36; // <a
const S_ATTRIB_NAME = 37; // <a foo
const S_ATTRIB_NAME_SAW_WHITE = 38; // <a foo _
const S_ATTRIB_VALUE = 39; // <a foo=
const S_ATTRIB_VALUE_QUOTED = 40; // <a foo="bar
const S_ATTRIB_VALUE_CLOSED = 41; // <a foo="bar"
const S_ATTRIB_VALUE_UNQUOTED = 42; // <a foo=bar
const S_CLOSE_TAG = 43; // </a
const S_CLOSE_TAG_SAW_WHITE = 44; // </a   >
const TAB = 9;
const NL = 0xA;
const CR = 0xD;
const SPACE = 0x20;
const BANG = 0x21;
const DQUOTE = 0x22;
const AMP = 0x26;
const SQUOTE = 0x27;
const MINUS = 0x2D;
const FORWARD_SLASH = 0x2F;
const SEMICOLON = 0x3B;
const LESS = 0x3C;
const EQUAL = 0x3D;
const GREATER = 0x3E;
const QUESTION = 0x3F;
const OPEN_BRACKET = 0x5B;
const CLOSE_BRACKET = 0x5D;
const NEL = 0x85;
const LS = 0x2028; // Line Separator
const isQuote = (c)=>c === DQUOTE || c === SQUOTE;
const QUOTES = [
    DQUOTE,
    SQUOTE
];
const DOCTYPE_TERMINATOR = [
    ...QUOTES,
    OPEN_BRACKET,
    GREATER
];
const DTD_TERMINATOR = [
    ...QUOTES,
    LESS,
    CLOSE_BRACKET
];
const XML_DECL_NAME_TERMINATOR = [
    EQUAL,
    QUESTION,
    ...S_LIST
];
const ATTRIB_VALUE_UNQUOTED_TERMINATOR = [
    ...S_LIST,
    GREATER,
    AMP,
    LESS
];
function nsPairCheck(parser, prefix, uri) {
    switch(prefix){
        case "xml":
            if (uri !== XML_NAMESPACE) {
                parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);
            }
            break;
        case "xmlns":
            if (uri !== XMLNS_NAMESPACE) {
                parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);
            }
            break;
        default:
    }
    switch(uri){
        case XMLNS_NAMESPACE:
            parser.fail(prefix === "" ? `the default namespace may not be set to ${uri}.` : `may not assign a prefix (even "xmlns") to the URI \
${XMLNS_NAMESPACE}.`);
            break;
        case XML_NAMESPACE:
            switch(prefix){
                case "xml":
                    break;
                case "":
                    parser.fail(`the default namespace may not be set to ${uri}.`);
                    break;
                default:
                    parser.fail("may not assign the xml namespace to another prefix.");
            }
            break;
        default:
    }
}
function nsMappingCheck(parser, mapping) {
    for (const local of Object.keys(mapping)){
        nsPairCheck(parser, local, mapping[local]);
    }
}
const isNCName = (name)=>NC_NAME_RE.test(name);
const isName = (name)=>NAME_RE.test(name);
const FORBIDDEN_START = 0;
const FORBIDDEN_BRACKET = 1;
const FORBIDDEN_BRACKET_BRACKET = 2;
/**
 * The list of supported events.
 */ exports.EVENTS = [
    "xmldecl",
    "text",
    "processinginstruction",
    "doctype",
    "comment",
    "opentagstart",
    "attribute",
    "opentag",
    "closetag",
    "cdata",
    "error",
    "end",
    "ready"
];
const EVENT_NAME_TO_HANDLER_NAME = {
    xmldecl: "xmldeclHandler",
    text: "textHandler",
    processinginstruction: "piHandler",
    doctype: "doctypeHandler",
    comment: "commentHandler",
    opentagstart: "openTagStartHandler",
    attribute: "attributeHandler",
    opentag: "openTagHandler",
    closetag: "closeTagHandler",
    cdata: "cdataHandler",
    error: "errorHandler",
    end: "endHandler",
    ready: "readyHandler"
};
class SaxesParser {
    /**
     * @param opt The parser options.
     */ constructor(opt){
        this.opt = opt !== null && opt !== void 0 ? opt : {};
        this.fragmentOpt = !!this.opt.fragment;
        const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;
        this.trackPosition = this.opt.position !== false;
        this.fileName = this.opt.fileName;
        if (xmlnsOpt) {
            // This is the function we use to perform name checks on PIs and entities.
            // When namespaces are used, colons are not allowed in PI target names or
            // entity names. So the check depends on whether namespaces are used. See:
            //
            // https://www.w3.org/XML/xml-names-19990114-errata.html
            // NE08
            //
            this.nameStartCheck = isNCNameStartChar;
            this.nameCheck = isNCNameChar;
            this.isName = isNCName;
            // eslint-disable-next-line @typescript-eslint/unbound-method
            this.processAttribs = this.processAttribsNS;
            // eslint-disable-next-line @typescript-eslint/unbound-method
            this.pushAttrib = this.pushAttribNS;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.ns = Object.assign({
                __proto__: null
            }, rootNS);
            const additional = this.opt.additionalNamespaces;
            if (additional != null) {
                nsMappingCheck(this, additional);
                Object.assign(this.ns, additional);
            }
        } else {
            this.nameStartCheck = isNameStartChar;
            this.nameCheck = isNameChar;
            this.isName = isName;
            // eslint-disable-next-line @typescript-eslint/unbound-method
            this.processAttribs = this.processAttribsPlain;
            // eslint-disable-next-line @typescript-eslint/unbound-method
            this.pushAttrib = this.pushAttribPlain;
        }
        //
        // The order of the members in this table needs to correspond to the state
        // numbers given to the states that correspond to the methods being recorded
        // here.
        //
        this.stateTable = [
            /* eslint-disable @typescript-eslint/unbound-method */ this.sBegin,
            this.sBeginWhitespace,
            this.sDoctype,
            this.sDoctypeQuote,
            this.sDTD,
            this.sDTDQuoted,
            this.sDTDOpenWaka,
            this.sDTDOpenWakaBang,
            this.sDTDComment,
            this.sDTDCommentEnding,
            this.sDTDCommentEnded,
            this.sDTDPI,
            this.sDTDPIEnding,
            this.sText,
            this.sEntity,
            this.sOpenWaka,
            this.sOpenWakaBang,
            this.sComment,
            this.sCommentEnding,
            this.sCommentEnded,
            this.sCData,
            this.sCDataEnding,
            this.sCDataEnding2,
            this.sPIFirstChar,
            this.sPIRest,
            this.sPIBody,
            this.sPIEnding,
            this.sXMLDeclNameStart,
            this.sXMLDeclName,
            this.sXMLDeclEq,
            this.sXMLDeclValueStart,
            this.sXMLDeclValue,
            this.sXMLDeclSeparator,
            this.sXMLDeclEnding,
            this.sOpenTag,
            this.sOpenTagSlash,
            this.sAttrib,
            this.sAttribName,
            this.sAttribNameSawWhite,
            this.sAttribValue,
            this.sAttribValueQuoted,
            this.sAttribValueClosed,
            this.sAttribValueUnquoted,
            this.sCloseTag,
            this.sCloseTagSawWhite
        ];
        this._init();
    }
    /**
     * Indicates whether or not the parser is closed. If ``true``, wait for
     * the ``ready`` event to write again.
     */ get closed() {
        return this._closed;
    }
    _init() {
        var _a;
        this.openWakaBang = "";
        this.text = "";
        this.name = "";
        this.piTarget = "";
        this.entity = "";
        this.q = null;
        this.tags = [];
        this.tag = null;
        this.topNS = null;
        this.chunk = "";
        this.chunkPosition = 0;
        this.i = 0;
        this.prevI = 0;
        this.carriedFromPrevious = undefined;
        this.forbiddenState = FORBIDDEN_START;
        this.attribList = [];
        // The logic is organized so as to minimize the need to check
        // this.opt.fragment while parsing.
        const { fragmentOpt } = this;
        this.state = fragmentOpt ? S_TEXT : S_BEGIN;
        // We want these to be all true if we are dealing with a fragment.
        this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = fragmentOpt;
        // An XML declaration is intially possible only when parsing whole
        // documents.
        this.xmlDeclPossible = !fragmentOpt;
        this.xmlDeclExpects = [
            "version"
        ];
        this.entityReturnState = undefined;
        let { defaultXMLVersion } = this.opt;
        if (defaultXMLVersion === undefined) {
            if (this.opt.forceXMLVersion === true) {
                throw new Error("forceXMLVersion set but defaultXMLVersion is not set");
            }
            defaultXMLVersion = "1.0";
        }
        this.setXMLVersion(defaultXMLVersion);
        this.positionAtNewLine = 0;
        this.doctype = false;
        this._closed = false;
        this.xmlDecl = {
            version: undefined,
            encoding: undefined,
            standalone: undefined
        };
        this.line = 1;
        this.column = 0;
        this.ENTITIES = Object.create(XML_ENTITIES);
        // eslint-disable-next-line no-unused-expressions
        (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    /**
     * The stream position the parser is currently looking at. This field is
     * zero-based.
     *
     * This field is not based on counting Unicode characters but is to be
     * interpreted as a plain index into a JavaScript string.
     */ get position() {
        return this.chunkPosition + this.i;
    }
    /**
     * The column number of the next character to be read by the parser.  *
     * This field is zero-based. (The first column in a line is 0.)
     *
     * This field reports the index at which the next character would be in the
     * line if the line were represented as a JavaScript string.  Note that this
     * *can* be different to a count based on the number of *Unicode characters*
     * due to how JavaScript handles astral plane characters.
     *
     * See [[column]] for a number that corresponds to a count of Unicode
     * characters.
     */ get columnIndex() {
        return this.position - this.positionAtNewLine;
    }
    /**
     * Set an event listener on an event. The parser supports one handler per
     * event type. If you try to set an event handler over an existing handler,
     * the old handler is silently overwritten.
     *
     * @param name The event to listen to.
     *
     * @param handler The handler to set.
     */ on(name, handler) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;
    }
    /**
     * Unset an event handler.
     *
     * @parma name The event to stop listening to.
     */ off(name) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this[EVENT_NAME_TO_HANDLER_NAME[name]] = undefined;
    }
    /**
     * Make an error object. The error object will have a message that contains
     * the ``fileName`` option passed at the creation of the parser. If position
     * tracking was turned on, it will also have line and column number
     * information.
     *
     * @param message The message describing the error to report.
     *
     * @returns An error object with a properly formatted message.
     */ makeError(message) {
        var _a;
        let msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : "";
        if (this.trackPosition) {
            if (msg.length > 0) {
                msg += ":";
            }
            msg += `${this.line}:${this.column}`;
        }
        if (msg.length > 0) {
            msg += ": ";
        }
        return new Error(msg + message);
    }
    /**
     * Report a parsing error. This method is made public so that client code may
     * check for issues that are outside the scope of this project and can report
     * errors.
     *
     * @param message The error to report.
     *
     * @returns this
     */ fail(message) {
        const err = this.makeError(message);
        const handler = this.errorHandler;
        if (handler === undefined) {
            throw err;
        } else {
            handler(err);
        }
        return this;
    }
    /**
     * Write a XML data to the parser.
     *
     * @param chunk The XML data to write.
     *
     * @returns this
     */ write(chunk) {
        if (this.closed) {
            return this.fail("cannot write after close; assign an onready handler.");
        }
        let end = false;
        if (chunk === null) {
            // We cannot return immediately because carriedFromPrevious may need
            // processing.
            end = true;
            chunk = "";
        } else if (typeof chunk === "object") {
            chunk = chunk.toString();
        }
        // We checked if performing a pre-decomposition of the string into an array
        // of single complete characters (``Array.from(chunk)``) would be faster
        // than the current repeated calls to ``charCodeAt``. As of August 2018, it
        // isn't. (There may be Node-specific code that would perform faster than
        // ``Array.from`` but don't want to be dependent on Node.)
        if (this.carriedFromPrevious !== undefined) {
            // The previous chunk had char we must carry over.
            chunk = `${this.carriedFromPrevious}${chunk}`;
            this.carriedFromPrevious = undefined;
        }
        let limit = chunk.length;
        const lastCode = chunk.charCodeAt(limit - 1);
        if (!end && // A trailing CR or surrogate must be carried over to the next
        // chunk.
        (lastCode === CR || lastCode >= 0xD800 && lastCode <= 0xDBFF)) {
            // The chunk ends with a character that must be carried over. We cannot
            // know how to handle it until we get the next chunk or the end of the
            // stream. So save it for later.
            this.carriedFromPrevious = chunk[limit - 1];
            limit--;
            chunk = chunk.slice(0, limit);
        }
        const { stateTable } = this;
        this.chunk = chunk;
        this.i = 0;
        while(this.i < limit){
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            stateTable[this.state].call(this);
        }
        this.chunkPosition += limit;
        return end ? this.end() : this;
    }
    /**
     * Close the current stream. Perform final well-formedness checks and reset
     * the parser tstate.
     *
     * @returns this
     */ close() {
        return this.write(null);
    }
    /**
     * Get a single code point out of the current chunk. This updates the current
     * position if we do position tracking.
     *
     * This is the algorithm to use for XML 1.0.
     *
     * @returns The character read.
     */ getCode10() {
        const { chunk, i } = this;
        this.prevI = i;
        // Yes, we do this instead of doing this.i++. Doing it this way, we do not
        // read this.i again, which is a bit faster.
        this.i = i + 1;
        if (i >= chunk.length) {
            return EOC;
        }
        // Using charCodeAt and handling the surrogates ourselves is faster
        // than using codePointAt.
        const code = chunk.charCodeAt(i);
        this.column++;
        if (code < 0xD800) {
            if (code >= SPACE || code === TAB) {
                return code;
            }
            switch(code){
                case NL:
                    this.line++;
                    this.column = 0;
                    this.positionAtNewLine = this.position;
                    return NL;
                case CR:
                    // We may get NaN if we read past the end of the chunk, which is fine.
                    if (chunk.charCodeAt(i + 1) === NL) {
                        // A \r\n sequence is converted to \n so we have to skip over the
                        // next character. We already know it has a size of 1 so ++ is fine
                        // here.
                        this.i = i + 2;
                    }
                    // Otherwise, a \r is just converted to \n, so we don't have to skip
                    // ahead.
                    // In either case, \r becomes \n.
                    this.line++;
                    this.column = 0;
                    this.positionAtNewLine = this.position;
                    return NL_LIKE;
                default:
                    // If we get here, then code < SPACE and it is not NL CR or TAB.
                    this.fail("disallowed character.");
                    return code;
            }
        }
        if (code > 0xDBFF) {
            // This is a specialized version of isChar10 that takes into account
            // that in this context code > 0xDBFF and code <= 0xFFFF. So it does not
            // test cases that don't need testing.
            if (!(code >= 0xE000 && code <= 0xFFFD)) {
                this.fail("disallowed character.");
            }
            return code;
        }
        const final = 0x10000 + (code - 0xD800) * 0x400 + (chunk.charCodeAt(i + 1) - 0xDC00);
        this.i = i + 2;
        // This is a specialized version of isChar10 that takes into account that in
        // this context necessarily final >= 0x10000.
        if (final > 0x10FFFF) {
            this.fail("disallowed character.");
        }
        return final;
    }
    /**
     * Get a single code point out of the current chunk. This updates the current
     * position if we do position tracking.
     *
     * This is the algorithm to use for XML 1.1.
     *
     * @returns {number} The character read.
     */ getCode11() {
        const { chunk, i } = this;
        this.prevI = i;
        // Yes, we do this instead of doing this.i++. Doing it this way, we do not
        // read this.i again, which is a bit faster.
        this.i = i + 1;
        if (i >= chunk.length) {
            return EOC;
        }
        // Using charCodeAt and handling the surrogates ourselves is faster
        // than using codePointAt.
        const code = chunk.charCodeAt(i);
        this.column++;
        if (code < 0xD800) {
            if (code > 0x1F && code < 0x7F || code > 0x9F && code !== LS || code === TAB) {
                return code;
            }
            switch(code){
                case NL:
                    this.line++;
                    this.column = 0;
                    this.positionAtNewLine = this.position;
                    return NL;
                case CR:
                    {
                        // We may get NaN if we read past the end of the chunk, which is
                        // fine.
                        const next = chunk.charCodeAt(i + 1);
                        if (next === NL || next === NEL) {
                            // A CR NL or CR NEL sequence is converted to NL so we have to skip
                            // over the next character. We already know it has a size of 1.
                            this.i = i + 2;
                        }
                    // Otherwise, a CR is just converted to NL, no skip.
                    }
                /* yes, fall through */ case NEL:
                case LS:
                    this.line++;
                    this.column = 0;
                    this.positionAtNewLine = this.position;
                    return NL_LIKE;
                default:
                    this.fail("disallowed character.");
                    return code;
            }
        }
        if (code > 0xDBFF) {
            // This is a specialized version of isCharAndNotRestricted that takes into
            // account that in this context code > 0xDBFF and code <= 0xFFFF. So it
            // does not test cases that don't need testing.
            if (!(code >= 0xE000 && code <= 0xFFFD)) {
                this.fail("disallowed character.");
            }
            return code;
        }
        const final = 0x10000 + (code - 0xD800) * 0x400 + (chunk.charCodeAt(i + 1) - 0xDC00);
        this.i = i + 2;
        // This is a specialized version of isCharAndNotRestricted that takes into
        // account that in this context necessarily final >= 0x10000.
        if (final > 0x10FFFF) {
            this.fail("disallowed character.");
        }
        return final;
    }
    /**
     * Like ``getCode`` but with the return value normalized so that ``NL`` is
     * returned for ``NL_LIKE``.
     */ getCodeNorm() {
        const c = this.getCode();
        return c === NL_LIKE ? NL : c;
    }
    unget() {
        this.i = this.prevI;
        this.column--;
    }
    /**
     * Capture characters into a buffer until encountering one of a set of
     * characters.
     *
     * @param chars An array of codepoints. Encountering a character in the array
     * ends the capture. (``chars`` may safely contain ``NL``.)
     *
     * @return The character code that made the capture end, or ``EOC`` if we hit
     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
     * instead.
     */ captureTo(chars) {
        let { i: start } = this;
        const { chunk } = this;
        // eslint-disable-next-line no-constant-condition
        while(true){
            const c = this.getCode();
            const isNLLike = c === NL_LIKE;
            const final = isNLLike ? NL : c;
            if (final === EOC || chars.includes(final)) {
                this.text += chunk.slice(start, this.prevI);
                return final;
            }
            if (isNLLike) {
                this.text += `${chunk.slice(start, this.prevI)}\n`;
                start = this.i;
            }
        }
    }
    /**
     * Capture characters into a buffer until encountering a character.
     *
     * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT
     * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.
     *
     * @return ``true`` if we ran into the character. Otherwise, we ran into the
     * end of the current chunk.
     */ captureToChar(char) {
        let { i: start } = this;
        const { chunk } = this;
        // eslint-disable-next-line no-constant-condition
        while(true){
            let c = this.getCode();
            switch(c){
                case NL_LIKE:
                    this.text += `${chunk.slice(start, this.prevI)}\n`;
                    start = this.i;
                    c = NL;
                    break;
                case EOC:
                    this.text += chunk.slice(start);
                    return false;
                default:
            }
            if (c === char) {
                this.text += chunk.slice(start, this.prevI);
                return true;
            }
        }
    }
    /**
     * Capture characters that satisfy ``isNameChar`` into the ``name`` field of
     * this parser.
     *
     * @return The character code that made the test fail, or ``EOC`` if we hit
     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
     * instead.
     */ captureNameChars() {
        const { chunk, i: start } = this;
        // eslint-disable-next-line no-constant-condition
        while(true){
            const c = this.getCode();
            if (c === EOC) {
                this.name += chunk.slice(start);
                return EOC;
            }
            // NL is not a name char so we don't have to test specifically for it.
            if (!isNameChar(c)) {
                this.name += chunk.slice(start, this.prevI);
                return c === NL_LIKE ? NL : c;
            }
        }
    }
    /**
     * Skip white spaces.
     *
     * @return The character that ended the skip, or ``EOC`` if we hit
     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
     * instead.
     */ skipSpaces() {
        // eslint-disable-next-line no-constant-condition
        while(true){
            const c = this.getCodeNorm();
            if (c === EOC || !isS(c)) {
                return c;
            }
        }
    }
    setXMLVersion(version) {
        this.currentXMLVersion = version;
        /*  eslint-disable @typescript-eslint/unbound-method */ if (version === "1.0") {
            this.isChar = isChar10;
            this.getCode = this.getCode10;
        } else {
            this.isChar = isChar11;
            this.getCode = this.getCode11;
        }
    /* eslint-enable @typescript-eslint/unbound-method */ }
    // STATE ENGINE METHODS
    // This needs to be a state separate from S_BEGIN_WHITESPACE because we want
    // to be sure never to come back to this state later.
    sBegin() {
        // We are essentially peeking at the first character of the chunk. Since
        // S_BEGIN can be in effect only when we start working on the first chunk,
        // the index at which we must look is necessarily 0. Note also that the
        // following test does not depend on decoding surrogates.
        // If the initial character is 0xFEFF, ignore it.
        if (this.chunk.charCodeAt(0) === 0xFEFF) {
            this.i++;
            this.column++;
        }
        this.state = S_BEGIN_WHITESPACE;
    }
    sBeginWhitespace() {
        // We need to know whether we've encountered spaces or not because as soon
        // as we run into a space, an XML declaration is no longer possible. Rather
        // than slow down skipSpaces even in places where we don't care whether it
        // skipped anything or not, we check whether prevI is equal to the value of
        // i from before we skip spaces.
        const iBefore = this.i;
        const c = this.skipSpaces();
        if (this.prevI !== iBefore) {
            this.xmlDeclPossible = false;
        }
        switch(c){
            case LESS:
                this.state = S_OPEN_WAKA;
                // We could naively call closeText but in this state, it is not normal
                // to have text be filled with any data.
                if (this.text.length !== 0) {
                    throw new Error("no-empty text at start");
                }
                break;
            case EOC:
                break;
            default:
                this.unget();
                this.state = S_TEXT;
                this.xmlDeclPossible = false;
        }
    }
    sDoctype() {
        var _a;
        const c = this.captureTo(DOCTYPE_TERMINATOR);
        switch(c){
            case GREATER:
                {
                    // eslint-disable-next-line no-unused-expressions
                    (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
                    this.text = "";
                    this.state = S_TEXT;
                    this.doctype = true; // just remember that we saw it.
                    break;
                }
            case EOC:
                break;
            default:
                this.text += String.fromCodePoint(c);
                if (c === OPEN_BRACKET) {
                    this.state = S_DTD;
                } else if (isQuote(c)) {
                    this.state = S_DOCTYPE_QUOTE;
                    this.q = c;
                }
        }
    }
    sDoctypeQuote() {
        const q = this.q;
        if (this.captureToChar(q)) {
            this.text += String.fromCodePoint(q);
            this.q = null;
            this.state = S_DOCTYPE;
        }
    }
    sDTD() {
        const c = this.captureTo(DTD_TERMINATOR);
        if (c === EOC) {
            return;
        }
        this.text += String.fromCodePoint(c);
        if (c === CLOSE_BRACKET) {
            this.state = S_DOCTYPE;
        } else if (c === LESS) {
            this.state = S_DTD_OPEN_WAKA;
        } else if (isQuote(c)) {
            this.state = S_DTD_QUOTED;
            this.q = c;
        }
    }
    sDTDQuoted() {
        const q = this.q;
        if (this.captureToChar(q)) {
            this.text += String.fromCodePoint(q);
            this.state = S_DTD;
            this.q = null;
        }
    }
    sDTDOpenWaka() {
        const c = this.getCodeNorm();
        this.text += String.fromCodePoint(c);
        switch(c){
            case BANG:
                this.state = S_DTD_OPEN_WAKA_BANG;
                this.openWakaBang = "";
                break;
            case QUESTION:
                this.state = S_DTD_PI;
                break;
            default:
                this.state = S_DTD;
        }
    }
    sDTDOpenWakaBang() {
        const char = String.fromCodePoint(this.getCodeNorm());
        const owb = this.openWakaBang += char;
        this.text += char;
        if (owb !== "-") {
            this.state = owb === "--" ? S_DTD_COMMENT : S_DTD;
            this.openWakaBang = "";
        }
    }
    sDTDComment() {
        if (this.captureToChar(MINUS)) {
            this.text += "-";
            this.state = S_DTD_COMMENT_ENDING;
        }
    }
    sDTDCommentEnding() {
        const c = this.getCodeNorm();
        this.text += String.fromCodePoint(c);
        this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;
    }
    sDTDCommentEnded() {
        const c = this.getCodeNorm();
        this.text += String.fromCodePoint(c);
        if (c === GREATER) {
            this.state = S_DTD;
        } else {
            this.fail("malformed comment.");
            // <!-- blah -- bloo --> will be recorded as
            // a comment of " blah -- bloo "
            this.state = S_DTD_COMMENT;
        }
    }
    sDTDPI() {
        if (this.captureToChar(QUESTION)) {
            this.text += "?";
            this.state = S_DTD_PI_ENDING;
        }
    }
    sDTDPIEnding() {
        const c = this.getCodeNorm();
        this.text += String.fromCodePoint(c);
        if (c === GREATER) {
            this.state = S_DTD;
        }
    }
    sText() {
        //
        // We did try a version of saxes where the S_TEXT state was split in two
        // states: one for text inside the root element, and one for text
        // outside. This was avoiding having to test this.tags.length to decide
        // what implementation to actually use.
        //
        // Peformance testing on gigabyte-size files did not show any advantage to
        // using the two states solution instead of the current one. Conversely, it
        // made the code a bit more complicated elsewhere. For instance, a comment
        // can appear before the root element so when a comment ended it was
        // necessary to determine whether to return to the S_TEXT state or to the
        // new text-outside-root state.
        //
        if (this.tags.length !== 0) {
            this.handleTextInRoot();
        } else {
            this.handleTextOutsideRoot();
        }
    }
    sEntity() {
        // This is essentially a specialized version of captureToChar(SEMICOLON...)
        let { i: start } = this;
        const { chunk } = this;
        // eslint-disable-next-line no-labels, no-restricted-syntax
        loop: // eslint-disable-next-line no-constant-condition
        while(true){
            switch(this.getCode()){
                case NL_LIKE:
                    this.entity += `${chunk.slice(start, this.prevI)}\n`;
                    start = this.i;
                    break;
                case SEMICOLON:
                    {
                        const { entityReturnState } = this;
                        const entity = this.entity + chunk.slice(start, this.prevI);
                        this.state = entityReturnState;
                        let parsed;
                        if (entity === "") {
                            this.fail("empty entity name.");
                            parsed = "&;";
                        } else {
                            parsed = this.parseEntity(entity);
                            this.entity = "";
                        }
                        if (entityReturnState !== S_TEXT || this.textHandler !== undefined) {
                            this.text += parsed;
                        }
                        break loop;
                    }
                case EOC:
                    this.entity += chunk.slice(start);
                    break loop;
                default:
            }
        }
    }
    sOpenWaka() {
        // Reminder: a state handler is called with at least one character
        // available in the current chunk. So the first call to get code inside of
        // a state handler cannot return ``EOC``. That's why we don't test
        // for it.
        const c = this.getCode();
        // either a /, ?, !, or text is coming next.
        if (isNameStartChar(c)) {
            this.state = S_OPEN_TAG;
            this.unget();
            this.xmlDeclPossible = false;
        } else {
            switch(c){
                case FORWARD_SLASH:
                    this.state = S_CLOSE_TAG;
                    this.xmlDeclPossible = false;
                    break;
                case BANG:
                    this.state = S_OPEN_WAKA_BANG;
                    this.openWakaBang = "";
                    this.xmlDeclPossible = false;
                    break;
                case QUESTION:
                    this.state = S_PI_FIRST_CHAR;
                    break;
                default:
                    this.fail("disallowed character in tag name");
                    this.state = S_TEXT;
                    this.xmlDeclPossible = false;
            }
        }
    }
    sOpenWakaBang() {
        this.openWakaBang += String.fromCodePoint(this.getCodeNorm());
        switch(this.openWakaBang){
            case "[CDATA[":
                if (!this.sawRoot && !this.reportedTextBeforeRoot) {
                    this.fail("text data outside of root node.");
                    this.reportedTextBeforeRoot = true;
                }
                if (this.closedRoot && !this.reportedTextAfterRoot) {
                    this.fail("text data outside of root node.");
                    this.reportedTextAfterRoot = true;
                }
                this.state = S_CDATA;
                this.openWakaBang = "";
                break;
            case "--":
                this.state = S_COMMENT;
                this.openWakaBang = "";
                break;
            case "DOCTYPE":
                this.state = S_DOCTYPE;
                if (this.doctype || this.sawRoot) {
                    this.fail("inappropriately located doctype declaration.");
                }
                this.openWakaBang = "";
                break;
            default:
                // 7 happens to be the maximum length of the string that can possibly
                // match one of the cases above.
                if (this.openWakaBang.length >= 7) {
                    this.fail("incorrect syntax.");
                }
        }
    }
    sComment() {
        if (this.captureToChar(MINUS)) {
            this.state = S_COMMENT_ENDING;
        }
    }
    sCommentEnding() {
        var _a;
        const c = this.getCodeNorm();
        if (c === MINUS) {
            this.state = S_COMMENT_ENDED;
            // eslint-disable-next-line no-unused-expressions
            (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
            this.text = "";
        } else {
            this.text += `-${String.fromCodePoint(c)}`;
            this.state = S_COMMENT;
        }
    }
    sCommentEnded() {
        const c = this.getCodeNorm();
        if (c !== GREATER) {
            this.fail("malformed comment.");
            // <!-- blah -- bloo --> will be recorded as
            // a comment of " blah -- bloo "
            this.text += `--${String.fromCodePoint(c)}`;
            this.state = S_COMMENT;
        } else {
            this.state = S_TEXT;
        }
    }
    sCData() {
        if (this.captureToChar(CLOSE_BRACKET)) {
            this.state = S_CDATA_ENDING;
        }
    }
    sCDataEnding() {
        const c = this.getCodeNorm();
        if (c === CLOSE_BRACKET) {
            this.state = S_CDATA_ENDING_2;
        } else {
            this.text += `]${String.fromCodePoint(c)}`;
            this.state = S_CDATA;
        }
    }
    sCDataEnding2() {
        var _a;
        const c = this.getCodeNorm();
        switch(c){
            case GREATER:
                {
                    // eslint-disable-next-line no-unused-expressions
                    (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
                    this.text = "";
                    this.state = S_TEXT;
                    break;
                }
            case CLOSE_BRACKET:
                this.text += "]";
                break;
            default:
                this.text += `]]${String.fromCodePoint(c)}`;
                this.state = S_CDATA;
        }
    }
    // We need this separate state to check the first character fo the pi target
    // with this.nameStartCheck which allows less characters than this.nameCheck.
    sPIFirstChar() {
        const c = this.getCodeNorm();
        // This is first because in the case where the file is well-formed this is
        // the branch taken. We optimize for well-formedness.
        if (this.nameStartCheck(c)) {
            this.piTarget += String.fromCodePoint(c);
            this.state = S_PI_REST;
        } else if (c === QUESTION || isS(c)) {
            this.fail("processing instruction without a target.");
            this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;
        } else {
            this.fail("disallowed character in processing instruction name.");
            this.piTarget += String.fromCodePoint(c);
            this.state = S_PI_REST;
        }
    }
    sPIRest() {
        // Capture characters into a piTarget while ``this.nameCheck`` run on the
        // character read returns true.
        const { chunk, i: start } = this;
        // eslint-disable-next-line no-constant-condition
        while(true){
            const c = this.getCodeNorm();
            if (c === EOC) {
                this.piTarget += chunk.slice(start);
                return;
            }
            // NL cannot satisfy this.nameCheck so we don't have to test specifically
            // for it.
            if (!this.nameCheck(c)) {
                this.piTarget += chunk.slice(start, this.prevI);
                const isQuestion = c === QUESTION;
                if (isQuestion || isS(c)) {
                    if (this.piTarget === "xml") {
                        if (!this.xmlDeclPossible) {
                            this.fail("an XML declaration must be at the start of the document.");
                        }
                        this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;
                    } else {
                        this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;
                    }
                } else {
                    this.fail("disallowed character in processing instruction name.");
                    this.piTarget += String.fromCodePoint(c);
                }
                break;
            }
        }
    }
    sPIBody() {
        if (this.text.length === 0) {
            const c = this.getCodeNorm();
            if (c === QUESTION) {
                this.state = S_PI_ENDING;
            } else if (!isS(c)) {
                this.text = String.fromCodePoint(c);
            }
        } else if (this.captureToChar(QUESTION)) {
            this.state = S_PI_ENDING;
        }
    }
    sPIEnding() {
        var _a;
        const c = this.getCodeNorm();
        if (c === GREATER) {
            const { piTarget } = this;
            if (piTarget.toLowerCase() === "xml") {
                this.fail("the XML declaration must appear at the start of the document.");
            }
            // eslint-disable-next-line no-unused-expressions
            (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {
                target: piTarget,
                body: this.text
            });
            this.piTarget = this.text = "";
            this.state = S_TEXT;
        } else if (c === QUESTION) {
            // We ran into ?? as part of a processing instruction. We initially took
            // the first ? as a sign that the PI was ending, but it is not. So we have
            // to add it to the body but we take the new ? as a sign that the PI is
            // ending.
            this.text += "?";
        } else {
            this.text += `?${String.fromCodePoint(c)}`;
            this.state = S_PI_BODY;
        }
        this.xmlDeclPossible = false;
    }
    sXMLDeclNameStart() {
        const c = this.skipSpaces();
        // The question mark character is not valid inside any of the XML
        // declaration name/value pairs.
        if (c === QUESTION) {
            // It is valid to go to S_XML_DECL_ENDING from this state.
            this.state = S_XML_DECL_ENDING;
            return;
        }
        if (c !== EOC) {
            this.state = S_XML_DECL_NAME;
            this.name = String.fromCodePoint(c);
        }
    }
    sXMLDeclName() {
        const c = this.captureTo(XML_DECL_NAME_TERMINATOR);
        // The question mark character is not valid inside any of the XML
        // declaration name/value pairs.
        if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            this.name += this.text;
            this.text = "";
            this.fail("XML declaration is incomplete.");
            return;
        }
        if (!(isS(c) || c === EQUAL)) {
            return;
        }
        this.name += this.text;
        this.text = "";
        if (!this.xmlDeclExpects.includes(this.name)) {
            switch(this.name.length){
                case 0:
                    this.fail("did not expect any more name/value pairs.");
                    break;
                case 1:
                    this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);
                    break;
                default:
                    this.fail(`expected one of ${this.xmlDeclExpects.join(", ")}`);
            }
        }
        this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;
    }
    sXMLDeclEq() {
        const c = this.getCodeNorm();
        // The question mark character is not valid inside any of the XML
        // declaration name/value pairs.
        if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            this.fail("XML declaration is incomplete.");
            return;
        }
        if (isS(c)) {
            return;
        }
        if (c !== EQUAL) {
            this.fail("value required.");
        }
        this.state = S_XML_DECL_VALUE_START;
    }
    sXMLDeclValueStart() {
        const c = this.getCodeNorm();
        // The question mark character is not valid inside any of the XML
        // declaration name/value pairs.
        if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            this.fail("XML declaration is incomplete.");
            return;
        }
        if (isS(c)) {
            return;
        }
        if (!isQuote(c)) {
            this.fail("value must be quoted.");
            this.q = SPACE;
        } else {
            this.q = c;
        }
        this.state = S_XML_DECL_VALUE;
    }
    sXMLDeclValue() {
        const c = this.captureTo([
            this.q,
            QUESTION
        ]);
        // The question mark character is not valid inside any of the XML
        // declaration name/value pairs.
        if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            this.text = "";
            this.fail("XML declaration is incomplete.");
            return;
        }
        if (c === EOC) {
            return;
        }
        const value = this.text;
        this.text = "";
        switch(this.name){
            case "version":
                {
                    this.xmlDeclExpects = [
                        "encoding",
                        "standalone"
                    ];
                    const version = value;
                    this.xmlDecl.version = version;
                    // This is the test specified by XML 1.0 but it is fine for XML 1.1.
                    if (!/^1\.[0-9]+$/.test(version)) {
                        this.fail("version number must match /^1\\.[0-9]+$/.");
                    } else if (!this.opt.forceXMLVersion) {
                        this.setXMLVersion(version);
                    }
                    break;
                }
            case "encoding":
                if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {
                    this.fail("encoding value must match /^[A-Za-z0-9][A-Za-z0-9._-]*$/.");
                }
                this.xmlDeclExpects = [
                    "standalone"
                ];
                this.xmlDecl.encoding = value;
                break;
            case "standalone":
                if (value !== "yes" && value !== "no") {
                    this.fail('standalone value must match "yes" or "no".');
                }
                this.xmlDeclExpects = [];
                this.xmlDecl.standalone = value;
                break;
            default:
        }
        this.name = "";
        this.state = S_XML_DECL_SEPARATOR;
    }
    sXMLDeclSeparator() {
        const c = this.getCodeNorm();
        // The question mark character is not valid inside any of the XML
        // declaration name/value pairs.
        if (c === QUESTION) {
            // It is valid to go to S_XML_DECL_ENDING from this state.
            this.state = S_XML_DECL_ENDING;
            return;
        }
        if (!isS(c)) {
            this.fail("whitespace required.");
            this.unget();
        }
        this.state = S_XML_DECL_NAME_START;
    }
    sXMLDeclEnding() {
        var _a;
        const c = this.getCodeNorm();
        if (c === GREATER) {
            if (this.piTarget !== "xml") {
                this.fail("processing instructions are not allowed before root.");
            } else if (this.name !== "version" && this.xmlDeclExpects.includes("version")) {
                this.fail("XML declaration must contain a version.");
            }
            // eslint-disable-next-line no-unused-expressions
            (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);
            this.name = "";
            this.piTarget = this.text = "";
            this.state = S_TEXT;
        } else {
            // We got here because the previous character was a ?, but the question
            // mark character is not valid inside any of the XML declaration
            // name/value pairs.
            this.fail("The character ? is disallowed anywhere in XML declarations.");
        }
        this.xmlDeclPossible = false;
    }
    sOpenTag() {
        var _a;
        const c = this.captureNameChars();
        if (c === EOC) {
            return;
        }
        const tag = this.tag = {
            name: this.name,
            attributes: Object.create(null)
        };
        this.name = "";
        if (this.xmlnsOpt) {
            this.topNS = tag.ns = Object.create(null);
        }
        // eslint-disable-next-line no-unused-expressions
        (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
        this.sawRoot = true;
        if (!this.fragmentOpt && this.closedRoot) {
            this.fail("documents may contain only one root.");
        }
        switch(c){
            case GREATER:
                this.openTag();
                break;
            case FORWARD_SLASH:
                this.state = S_OPEN_TAG_SLASH;
                break;
            default:
                if (!isS(c)) {
                    this.fail("disallowed character in tag name.");
                }
                this.state = S_ATTRIB;
        }
    }
    sOpenTagSlash() {
        if (this.getCode() === GREATER) {
            this.openSelfClosingTag();
        } else {
            this.fail("forward-slash in opening tag not followed by >.");
            this.state = S_ATTRIB;
        }
    }
    sAttrib() {
        const c = this.skipSpaces();
        if (c === EOC) {
            return;
        }
        if (isNameStartChar(c)) {
            this.unget();
            this.state = S_ATTRIB_NAME;
        } else if (c === GREATER) {
            this.openTag();
        } else if (c === FORWARD_SLASH) {
            this.state = S_OPEN_TAG_SLASH;
        } else {
            this.fail("disallowed character in attribute name.");
        }
    }
    sAttribName() {
        const c = this.captureNameChars();
        if (c === EQUAL) {
            this.state = S_ATTRIB_VALUE;
        } else if (isS(c)) {
            this.state = S_ATTRIB_NAME_SAW_WHITE;
        } else if (c === GREATER) {
            this.fail("attribute without value.");
            this.pushAttrib(this.name, this.name);
            this.name = this.text = "";
            this.openTag();
        } else if (c !== EOC) {
            this.fail("disallowed character in attribute name.");
        }
    }
    sAttribNameSawWhite() {
        const c = this.skipSpaces();
        switch(c){
            case EOC:
                return;
            case EQUAL:
                this.state = S_ATTRIB_VALUE;
                break;
            default:
                this.fail("attribute without value.");
                // Should we do this???
                // this.tag.attributes[this.name] = "";
                this.text = "";
                this.name = "";
                if (c === GREATER) {
                    this.openTag();
                } else if (isNameStartChar(c)) {
                    this.unget();
                    this.state = S_ATTRIB_NAME;
                } else {
                    this.fail("disallowed character in attribute name.");
                    this.state = S_ATTRIB;
                }
        }
    }
    sAttribValue() {
        const c = this.getCodeNorm();
        if (isQuote(c)) {
            this.q = c;
            this.state = S_ATTRIB_VALUE_QUOTED;
        } else if (!isS(c)) {
            this.fail("unquoted attribute value.");
            this.state = S_ATTRIB_VALUE_UNQUOTED;
            this.unget();
        }
    }
    sAttribValueQuoted() {
        // We deliberately do not use captureTo here. The specialized code we use
        // here is faster than using captureTo.
        const { q, chunk } = this;
        let { i: start } = this;
        // eslint-disable-next-line no-constant-condition
        while(true){
            switch(this.getCode()){
                case q:
                    this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));
                    this.name = this.text = "";
                    this.q = null;
                    this.state = S_ATTRIB_VALUE_CLOSED;
                    return;
                case AMP:
                    this.text += chunk.slice(start, this.prevI);
                    this.state = S_ENTITY;
                    this.entityReturnState = S_ATTRIB_VALUE_QUOTED;
                    return;
                case NL:
                case NL_LIKE:
                case TAB:
                    this.text += `${chunk.slice(start, this.prevI)} `;
                    start = this.i;
                    break;
                case LESS:
                    this.text += chunk.slice(start, this.prevI);
                    this.fail("disallowed character.");
                    return;
                case EOC:
                    this.text += chunk.slice(start);
                    return;
                default:
            }
        }
    }
    sAttribValueClosed() {
        const c = this.getCodeNorm();
        if (isS(c)) {
            this.state = S_ATTRIB;
        } else if (c === GREATER) {
            this.openTag();
        } else if (c === FORWARD_SLASH) {
            this.state = S_OPEN_TAG_SLASH;
        } else if (isNameStartChar(c)) {
            this.fail("no whitespace between attributes.");
            this.unget();
            this.state = S_ATTRIB_NAME;
        } else {
            this.fail("disallowed character in attribute name.");
        }
    }
    sAttribValueUnquoted() {
        // We don't do anything regarding EOL or space handling for unquoted
        // attributes. We already have failed by the time we get here, and the
        // contract that saxes upholds states that upon failure, it is not safe to
        // rely on the data passed to event handlers (other than
        // ``onerror``). Passing "bad" data is not a problem.
        const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);
        switch(c){
            case AMP:
                this.state = S_ENTITY;
                this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;
                break;
            case LESS:
                this.fail("disallowed character.");
                break;
            case EOC:
                break;
            default:
                if (this.text.includes("]]>")) {
                    this.fail('the string "]]>" is disallowed in char data.');
                }
                this.pushAttrib(this.name, this.text);
                this.name = this.text = "";
                if (c === GREATER) {
                    this.openTag();
                } else {
                    this.state = S_ATTRIB;
                }
        }
    }
    sCloseTag() {
        const c = this.captureNameChars();
        if (c === GREATER) {
            this.closeTag();
        } else if (isS(c)) {
            this.state = S_CLOSE_TAG_SAW_WHITE;
        } else if (c !== EOC) {
            this.fail("disallowed character in closing tag.");
        }
    }
    sCloseTagSawWhite() {
        switch(this.skipSpaces()){
            case GREATER:
                this.closeTag();
                break;
            case EOC:
                break;
            default:
                this.fail("disallowed character in closing tag.");
        }
    }
    // END OF STATE ENGINE METHODS
    handleTextInRoot() {
        // This is essentially a specialized version of captureTo which is optimized
        // for performing the ]]> check. A previous version of this code, checked
        // ``this.text`` for the presence of ]]>. It simplified the code but was
        // very costly when character data contained a lot of entities to be parsed.
        //
        // Since we are using a specialized loop, we also keep track of the presence
        // of ]]> in text data. The sequence ]]> is forbidden to appear as-is.
        //
        let { i: start, forbiddenState } = this;
        const { chunk, textHandler: handler } = this;
        // eslint-disable-next-line no-labels, no-restricted-syntax
        scanLoop: // eslint-disable-next-line no-constant-condition
        while(true){
            switch(this.getCode()){
                case LESS:
                    {
                        this.state = S_OPEN_WAKA;
                        if (handler !== undefined) {
                            const { text } = this;
                            const slice = chunk.slice(start, this.prevI);
                            if (text.length !== 0) {
                                handler(text + slice);
                                this.text = "";
                            } else if (slice.length !== 0) {
                                handler(slice);
                            }
                        }
                        forbiddenState = FORBIDDEN_START;
                        break scanLoop;
                    }
                case AMP:
                    this.state = S_ENTITY;
                    this.entityReturnState = S_TEXT;
                    if (handler !== undefined) {
                        this.text += chunk.slice(start, this.prevI);
                    }
                    forbiddenState = FORBIDDEN_START;
                    break scanLoop;
                case CLOSE_BRACKET:
                    switch(forbiddenState){
                        case FORBIDDEN_START:
                            forbiddenState = FORBIDDEN_BRACKET;
                            break;
                        case FORBIDDEN_BRACKET:
                            forbiddenState = FORBIDDEN_BRACKET_BRACKET;
                            break;
                        case FORBIDDEN_BRACKET_BRACKET:
                            break;
                        default:
                            throw new Error("impossible state");
                    }
                    break;
                case GREATER:
                    if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {
                        this.fail('the string "]]>" is disallowed in char data.');
                    }
                    forbiddenState = FORBIDDEN_START;
                    break;
                case NL_LIKE:
                    if (handler !== undefined) {
                        this.text += `${chunk.slice(start, this.prevI)}\n`;
                    }
                    start = this.i;
                    forbiddenState = FORBIDDEN_START;
                    break;
                case EOC:
                    if (handler !== undefined) {
                        this.text += chunk.slice(start);
                    }
                    break scanLoop;
                default:
                    forbiddenState = FORBIDDEN_START;
            }
        }
        this.forbiddenState = forbiddenState;
    }
    handleTextOutsideRoot() {
        // This is essentially a specialized version of captureTo which is optimized
        // for a specialized task. We keep track of the presence of non-space
        // characters in the text since these are errors when appearing outside the
        // document root element.
        let { i: start } = this;
        const { chunk, textHandler: handler } = this;
        let nonSpace = false;
        // eslint-disable-next-line no-labels, no-restricted-syntax
        outRootLoop: // eslint-disable-next-line no-constant-condition
        while(true){
            const code = this.getCode();
            switch(code){
                case LESS:
                    {
                        this.state = S_OPEN_WAKA;
                        if (handler !== undefined) {
                            const { text } = this;
                            const slice = chunk.slice(start, this.prevI);
                            if (text.length !== 0) {
                                handler(text + slice);
                                this.text = "";
                            } else if (slice.length !== 0) {
                                handler(slice);
                            }
                        }
                        break outRootLoop;
                    }
                case AMP:
                    this.state = S_ENTITY;
                    this.entityReturnState = S_TEXT;
                    if (handler !== undefined) {
                        this.text += chunk.slice(start, this.prevI);
                    }
                    nonSpace = true;
                    break outRootLoop;
                case NL_LIKE:
                    if (handler !== undefined) {
                        this.text += `${chunk.slice(start, this.prevI)}\n`;
                    }
                    start = this.i;
                    break;
                case EOC:
                    if (handler !== undefined) {
                        this.text += chunk.slice(start);
                    }
                    break outRootLoop;
                default:
                    if (!isS(code)) {
                        nonSpace = true;
                    }
            }
        }
        if (!nonSpace) {
            return;
        }
        // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags
        // to avoid reporting errors for every single character that is out of
        // place.
        if (!this.sawRoot && !this.reportedTextBeforeRoot) {
            this.fail("text data outside of root node.");
            this.reportedTextBeforeRoot = true;
        }
        if (this.closedRoot && !this.reportedTextAfterRoot) {
            this.fail("text data outside of root node.");
            this.reportedTextAfterRoot = true;
        }
    }
    pushAttribNS(name, value) {
        var _a;
        const { prefix, local } = this.qname(name);
        const attr = {
            name,
            prefix,
            local,
            value
        };
        this.attribList.push(attr);
        // eslint-disable-next-line no-unused-expressions
        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
        if (prefix === "xmlns") {
            const trimmed = value.trim();
            if (this.currentXMLVersion === "1.0" && trimmed === "") {
                this.fail("invalid attempt to undefine prefix in XML 1.0");
            }
            this.topNS[local] = trimmed;
            nsPairCheck(this, local, trimmed);
        } else if (name === "xmlns") {
            const trimmed = value.trim();
            this.topNS[""] = trimmed;
            nsPairCheck(this, "", trimmed);
        }
    }
    pushAttribPlain(name, value) {
        var _a;
        const attr = {
            name,
            value
        };
        this.attribList.push(attr);
        // eslint-disable-next-line no-unused-expressions
        (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
    }
    /**
     * End parsing. This performs final well-formedness checks and resets the
     * parser to a clean state.
     *
     * @returns this
     */ end() {
        var _a, _b;
        if (!this.sawRoot) {
            this.fail("document must contain a root element.");
        }
        const { tags } = this;
        while(tags.length > 0){
            const tag = tags.pop();
            this.fail(`unclosed tag: ${tag.name}`);
        }
        if (this.state !== S_BEGIN && this.state !== S_TEXT) {
            this.fail("unexpected end.");
        }
        const { text } = this;
        if (text.length !== 0) {
            // eslint-disable-next-line no-unused-expressions
            (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);
            this.text = "";
        }
        this._closed = true;
        // eslint-disable-next-line no-unused-expressions
        (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);
        this._init();
        return this;
    }
    /**
     * Resolve a namespace prefix.
     *
     * @param prefix The prefix to resolve.
     *
     * @returns The namespace URI or ``undefined`` if the prefix is not defined.
     */ resolve(prefix) {
        var _a, _b;
        let uri = this.topNS[prefix];
        if (uri !== undefined) {
            return uri;
        }
        const { tags } = this;
        for(let index = tags.length - 1; index >= 0; index--){
            uri = tags[index].ns[prefix];
            if (uri !== undefined) {
                return uri;
            }
        }
        uri = this.ns[prefix];
        if (uri !== undefined) {
            return uri;
        }
        return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);
    }
    /**
     * Parse a qname into its prefix and local name parts.
     *
     * @param name The name to parse
     *
     * @returns
     */ qname(name) {
        // This is faster than using name.split(":").
        const colon = name.indexOf(":");
        if (colon === -1) {
            return {
                prefix: "",
                local: name
            };
        }
        const local = name.slice(colon + 1);
        const prefix = name.slice(0, colon);
        if (prefix === "" || local === "" || local.includes(":")) {
            this.fail(`malformed name: ${name}.`);
        }
        return {
            prefix,
            local
        };
    }
    processAttribsNS() {
        var _a;
        const { attribList } = this;
        const tag = this.tag;
        {
            // add namespace info to tag
            const { prefix, local } = this.qname(tag.name);
            tag.prefix = prefix;
            tag.local = local;
            const uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : "";
            if (prefix !== "") {
                if (prefix === "xmlns") {
                    this.fail('tags may not have "xmlns" as prefix.');
                }
                if (uri === "") {
                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);
                    tag.uri = prefix;
                }
            }
        }
        if (attribList.length === 0) {
            return;
        }
        const { attributes } = tag;
        const seen = new Set();
        // Note: do not apply default ns to attributes:
        //   http://www.w3.org/TR/REC-xml-names/#defaulting
        for (const attr of attribList){
            const { name, prefix, local } = attr;
            let uri;
            let eqname;
            if (prefix === "") {
                uri = name === "xmlns" ? XMLNS_NAMESPACE : "";
                eqname = name;
            } else {
                uri = this.resolve(prefix);
                // if there's any attributes with an undefined namespace,
                // then fail on them now.
                if (uri === undefined) {
                    this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);
                    uri = prefix;
                }
                eqname = `{${uri}}${local}`;
            }
            if (seen.has(eqname)) {
                this.fail(`duplicate attribute: ${eqname}.`);
            }
            seen.add(eqname);
            attr.uri = uri;
            attributes[name] = attr;
        }
        this.attribList = [];
    }
    processAttribsPlain() {
        const { attribList } = this;
        // eslint-disable-next-line prefer-destructuring
        const attributes = this.tag.attributes;
        for (const { name, value } of attribList){
            if (attributes[name] !== undefined) {
                this.fail(`duplicate attribute: ${name}.`);
            }
            attributes[name] = value;
        }
        this.attribList = [];
    }
    /**
     * Handle a complete open tag. This parser code calls this once it has seen
     * the whole tag. This method checks for well-formeness and then emits
     * ``onopentag``.
     */ openTag() {
        var _a;
        this.processAttribs();
        const { tags } = this;
        const tag = this.tag;
        tag.isSelfClosing = false;
        // There cannot be any pending text here due to the onopentagstart that was
        // necessarily emitted before we get here. So we do not check text.
        // eslint-disable-next-line no-unused-expressions
        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
        tags.push(tag);
        this.state = S_TEXT;
        this.name = "";
    }
    /**
     * Handle a complete self-closing tag. This parser code calls this once it has
     * seen the whole tag. This method checks for well-formeness and then emits
     * ``onopentag`` and ``onclosetag``.
     */ openSelfClosingTag() {
        var _a, _b, _c;
        this.processAttribs();
        const { tags } = this;
        const tag = this.tag;
        tag.isSelfClosing = true;
        // There cannot be any pending text here due to the onopentagstart that was
        // necessarily emitted before we get here. So we do not check text.
        // eslint-disable-next-line no-unused-expressions
        (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
        // eslint-disable-next-line no-unused-expressions
        (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);
        const top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;
        if (top === null) {
            this.closedRoot = true;
        }
        this.state = S_TEXT;
        this.name = "";
    }
    /**
     * Handle a complete close tag. This parser code calls this once it has seen
     * the whole tag. This method checks for well-formeness and then emits
     * ``onclosetag``.
     */ closeTag() {
        const { tags, name } = this;
        // Our state after this will be S_TEXT, no matter what, and we can clear
        // tagName now.
        this.state = S_TEXT;
        this.name = "";
        if (name === "") {
            this.fail("weird empty close tag.");
            this.text += "</>";
            return;
        }
        const handler = this.closeTagHandler;
        let l = tags.length;
        while(l-- > 0){
            const tag = this.tag = tags.pop();
            this.topNS = tag.ns;
            // eslint-disable-next-line no-unused-expressions
            handler === null || handler === void 0 ? void 0 : handler(tag);
            if (tag.name === name) {
                break;
            }
            this.fail("unexpected close tag.");
        }
        if (l === 0) {
            this.closedRoot = true;
        } else if (l < 0) {
            this.fail(`unmatched closing tag: ${name}.`);
            this.text += `</${name}>`;
        }
    }
    /**
     * Resolves an entity. Makes any necessary well-formedness checks.
     *
     * @param entity The entity to resolve.
     *
     * @returns The parsed entity.
     */ parseEntity(entity) {
        // startsWith would be significantly slower for this test.
        // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
        if (entity[0] !== "#") {
            const defined = this.ENTITIES[entity];
            if (defined !== undefined) {
                return defined;
            }
            this.fail(this.isName(entity) ? "undefined entity." : "disallowed character in entity name.");
            return `&${entity};`;
        }
        let num = NaN;
        if (entity[1] === "x" && /^#x[0-9a-f]+$/i.test(entity)) {
            num = parseInt(entity.slice(2), 16);
        } else if (/^#[0-9]+$/.test(entity)) {
            num = parseInt(entity.slice(1), 10);
        }
        // The character reference is required to match the CHAR production.
        if (!this.isChar(num)) {
            this.fail("malformed character entity.");
            return `&${entity};`;
        }
        return String.fromCodePoint(num);
    }
}
exports.SaxesParser = SaxesParser; //# sourceMappingURL=saxes.js.map


/***/ }),

/***/ 40426:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var util = __webpack_require__(73837);
var bl = __webpack_require__(89011);
var headers = __webpack_require__(77867);
var Writable = (__webpack_require__(98323).Writable);
var PassThrough = (__webpack_require__(98323).PassThrough);
var noop = function() {};
var overflow = function(size) {
    size &= 511;
    return size && 512 - size;
};
var emptyStream = function(self, offset) {
    var s = new Source(self, offset);
    s.end();
    return s;
};
var mixinPax = function(header, pax) {
    if (pax.path) header.name = pax.path;
    if (pax.linkpath) header.linkname = pax.linkpath;
    if (pax.size) header.size = parseInt(pax.size, 10);
    header.pax = pax;
    return header;
};
var Source = function(self, offset) {
    this._parent = self;
    this.offset = offset;
    PassThrough.call(this, {
        autoDestroy: false
    });
};
util.inherits(Source, PassThrough);
Source.prototype.destroy = function(err) {
    this._parent.destroy(err);
};
var Extract = function(opts) {
    if (!(this instanceof Extract)) return new Extract(opts);
    Writable.call(this, opts);
    opts = opts || {};
    this._offset = 0;
    this._buffer = bl();
    this._missing = 0;
    this._partial = false;
    this._onparse = noop;
    this._header = null;
    this._stream = null;
    this._overflow = null;
    this._cb = null;
    this._locked = false;
    this._destroyed = false;
    this._pax = null;
    this._paxGlobal = null;
    this._gnuLongPath = null;
    this._gnuLongLinkPath = null;
    var self = this;
    var b = self._buffer;
    var oncontinue = function() {
        self._continue();
    };
    var onunlock = function(err) {
        self._locked = false;
        if (err) return self.destroy(err);
        if (!self._stream) oncontinue();
    };
    var onstreamend = function() {
        self._stream = null;
        var drain = overflow(self._header.size);
        if (drain) self._parse(drain, ondrain);
        else self._parse(512, onheader);
        if (!self._locked) oncontinue();
    };
    var ondrain = function() {
        self._buffer.consume(overflow(self._header.size));
        self._parse(512, onheader);
        oncontinue();
    };
    var onpaxglobalheader = function() {
        var size = self._header.size;
        self._paxGlobal = headers.decodePax(b.slice(0, size));
        b.consume(size);
        onstreamend();
    };
    var onpaxheader = function() {
        var size = self._header.size;
        self._pax = headers.decodePax(b.slice(0, size));
        if (self._paxGlobal) self._pax = Object.assign({}, self._paxGlobal, self._pax);
        b.consume(size);
        onstreamend();
    };
    var ongnulongpath = function() {
        var size = self._header.size;
        this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
        b.consume(size);
        onstreamend();
    };
    var ongnulonglinkpath = function() {
        var size = self._header.size;
        this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
        b.consume(size);
        onstreamend();
    };
    var onheader = function() {
        var offset = self._offset;
        var header;
        try {
            header = self._header = headers.decode(b.slice(0, 512), opts.filenameEncoding, opts.allowUnknownFormat);
        } catch (err) {
            self.emit("error", err);
        }
        b.consume(512);
        if (!header) {
            self._parse(512, onheader);
            oncontinue();
            return;
        }
        if (header.type === "gnu-long-path") {
            self._parse(header.size, ongnulongpath);
            oncontinue();
            return;
        }
        if (header.type === "gnu-long-link-path") {
            self._parse(header.size, ongnulonglinkpath);
            oncontinue();
            return;
        }
        if (header.type === "pax-global-header") {
            self._parse(header.size, onpaxglobalheader);
            oncontinue();
            return;
        }
        if (header.type === "pax-header") {
            self._parse(header.size, onpaxheader);
            oncontinue();
            return;
        }
        if (self._gnuLongPath) {
            header.name = self._gnuLongPath;
            self._gnuLongPath = null;
        }
        if (self._gnuLongLinkPath) {
            header.linkname = self._gnuLongLinkPath;
            self._gnuLongLinkPath = null;
        }
        if (self._pax) {
            self._header = header = mixinPax(header, self._pax);
            self._pax = null;
        }
        self._locked = true;
        if (!header.size || header.type === "directory") {
            self._parse(512, onheader);
            self.emit("entry", header, emptyStream(self, offset), onunlock);
            return;
        }
        self._stream = new Source(self, offset);
        self.emit("entry", header, self._stream, onunlock);
        self._parse(header.size, onstreamend);
        oncontinue();
    };
    this._onheader = onheader;
    this._parse(512, onheader);
};
util.inherits(Extract, Writable);
Extract.prototype.destroy = function(err) {
    if (this._destroyed) return;
    this._destroyed = true;
    if (err) this.emit("error", err);
    this.emit("close");
    if (this._stream) this._stream.emit("close");
};
Extract.prototype._parse = function(size, onparse) {
    if (this._destroyed) return;
    this._offset += size;
    this._missing = size;
    if (onparse === this._onheader) this._partial = false;
    this._onparse = onparse;
};
Extract.prototype._continue = function() {
    if (this._destroyed) return;
    var cb = this._cb;
    this._cb = noop;
    if (this._overflow) this._write(this._overflow, undefined, cb);
    else cb();
};
Extract.prototype._write = function(data, enc, cb) {
    if (this._destroyed) return;
    var s = this._stream;
    var b = this._buffer;
    var missing = this._missing;
    if (data.length) this._partial = true;
    // we do not reach end-of-chunk now. just forward it
    if (data.length < missing) {
        this._missing -= data.length;
        this._overflow = null;
        if (s) return s.write(data, cb);
        b.append(data);
        return cb();
    }
    // end-of-chunk. the parser should call cb.
    this._cb = cb;
    this._missing = 0;
    var overflow = null;
    if (data.length > missing) {
        overflow = data.slice(missing);
        data = data.slice(0, missing);
    }
    if (s) s.end(data);
    else b.append(data);
    this._overflow = overflow;
    this._onparse();
};
Extract.prototype._final = function(cb) {
    if (this._partial) return this.destroy(new Error("Unexpected end of data"));
    cb();
};
module.exports = Extract;


/***/ }),

/***/ 77867:
/***/ ((__unused_webpack_module, exports) => {

var alloc = Buffer.alloc;
var ZEROS = "0000000000000000000";
var SEVENS = "7777777777777777777";
var ZERO_OFFSET = "0".charCodeAt(0);
var USTAR_MAGIC = Buffer.from("ustar\x00", "binary");
var USTAR_VER = Buffer.from("00", "binary");
var GNU_MAGIC = Buffer.from("ustar ", "binary");
var GNU_VER = Buffer.from(" \x00", "binary");
var MASK = parseInt("7777", 8);
var MAGIC_OFFSET = 257;
var VERSION_OFFSET = 263;
var clamp = function(index, len, defaultValue) {
    if (typeof index !== "number") return defaultValue;
    index = ~~index // Coerce to integer.
    ;
    if (index >= len) return len;
    if (index >= 0) return index;
    index += len;
    if (index >= 0) return index;
    return 0;
};
var toType = function(flag) {
    switch(flag){
        case 0:
            return "file";
        case 1:
            return "link";
        case 2:
            return "symlink";
        case 3:
            return "character-device";
        case 4:
            return "block-device";
        case 5:
            return "directory";
        case 6:
            return "fifo";
        case 7:
            return "contiguous-file";
        case 72:
            return "pax-header";
        case 55:
            return "pax-global-header";
        case 27:
            return "gnu-long-link-path";
        case 28:
        case 30:
            return "gnu-long-path";
    }
    return null;
};
var toTypeflag = function(flag) {
    switch(flag){
        case "file":
            return 0;
        case "link":
            return 1;
        case "symlink":
            return 2;
        case "character-device":
            return 3;
        case "block-device":
            return 4;
        case "directory":
            return 5;
        case "fifo":
            return 6;
        case "contiguous-file":
            return 7;
        case "pax-header":
            return 72;
    }
    return 0;
};
var indexOf = function(block, num, offset, end) {
    for(; offset < end; offset++){
        if (block[offset] === num) return offset;
    }
    return end;
};
var cksum = function(block) {
    var sum = 8 * 32;
    for(var i = 0; i < 148; i++)sum += block[i];
    for(var j = 156; j < 512; j++)sum += block[j];
    return sum;
};
var encodeOct = function(val, n) {
    val = val.toString(8);
    if (val.length > n) return SEVENS.slice(0, n) + " ";
    else return ZEROS.slice(0, n - val.length) + val + " ";
};
/* Copied from the node-tar repo and modified to meet
 * tar-stream coding standard.
 *
 * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349
 */ function parse256(buf) {
    // first byte MUST be either 80 or FF
    // 80 for positive, FF for 2's comp
    var positive;
    if (buf[0] === 0x80) positive = true;
    else if (buf[0] === 0xFF) positive = false;
    else return null;
    // build up a base-256 tuple from the least sig to the highest
    var tuple = [];
    for(var i = buf.length - 1; i > 0; i--){
        var byte = buf[i];
        if (positive) tuple.push(byte);
        else tuple.push(0xFF - byte);
    }
    var sum = 0;
    var l = tuple.length;
    for(i = 0; i < l; i++){
        sum += tuple[i] * Math.pow(256, i);
    }
    return positive ? sum : -1 * sum;
}
var decodeOct = function(val, offset, length) {
    val = val.slice(offset, offset + length);
    offset = 0;
    // If prefixed with 0x80 then parse as a base-256 integer
    if (val[offset] & 0x80) {
        return parse256(val);
    } else {
        // Older versions of tar can prefix with spaces
        while(offset < val.length && val[offset] === 32)offset++;
        var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
        while(offset < end && val[offset] === 0)offset++;
        if (end === offset) return 0;
        return parseInt(val.slice(offset, end).toString(), 8);
    }
};
var decodeStr = function(val, offset, length, encoding) {
    return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding);
};
var addLength = function(str) {
    var len = Buffer.byteLength(str);
    var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
    if (len + digits >= Math.pow(10, digits)) digits++;
    return len + digits + str;
};
exports.decodeLongPath = function(buf, encoding) {
    return decodeStr(buf, 0, buf.length, encoding);
};
exports.encodePax = function(opts) {
    var result = "";
    if (opts.name) result += addLength(" path=" + opts.name + "\n");
    if (opts.linkname) result += addLength(" linkpath=" + opts.linkname + "\n");
    var pax = opts.pax;
    if (pax) {
        for(var key in pax){
            result += addLength(" " + key + "=" + pax[key] + "\n");
        }
    }
    return Buffer.from(result);
};
exports.decodePax = function(buf) {
    var result = {};
    while(buf.length){
        var i = 0;
        while(i < buf.length && buf[i] !== 32)i++;
        var len = parseInt(buf.slice(0, i).toString(), 10);
        if (!len) return result;
        var b = buf.slice(i + 1, len - 1).toString();
        var keyIndex = b.indexOf("=");
        if (keyIndex === -1) return result;
        result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
        buf = buf.slice(len);
    }
    return result;
};
exports.encode = function(opts) {
    var buf = alloc(512);
    var name = opts.name;
    var prefix = "";
    if (opts.typeflag === 5 && name[name.length - 1] !== "/") name += "/";
    if (Buffer.byteLength(name) !== name.length) return null // utf-8
    ;
    while(Buffer.byteLength(name) > 100){
        var i = name.indexOf("/");
        if (i === -1) return null;
        prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
        name = name.slice(i + 1);
    }
    if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155) return null;
    if (opts.linkname && Buffer.byteLength(opts.linkname) > 100) return null;
    buf.write(name);
    buf.write(encodeOct(opts.mode & MASK, 6), 100);
    buf.write(encodeOct(opts.uid, 6), 108);
    buf.write(encodeOct(opts.gid, 6), 116);
    buf.write(encodeOct(opts.size, 11), 124);
    buf.write(encodeOct(opts.mtime.getTime() / 1000 | 0, 11), 136);
    buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
    if (opts.linkname) buf.write(opts.linkname, 157);
    USTAR_MAGIC.copy(buf, MAGIC_OFFSET);
    USTAR_VER.copy(buf, VERSION_OFFSET);
    if (opts.uname) buf.write(opts.uname, 265);
    if (opts.gname) buf.write(opts.gname, 297);
    buf.write(encodeOct(opts.devmajor || 0, 6), 329);
    buf.write(encodeOct(opts.devminor || 0, 6), 337);
    if (prefix) buf.write(prefix, 345);
    buf.write(encodeOct(cksum(buf), 6), 148);
    return buf;
};
exports.decode = function(buf, filenameEncoding, allowUnknownFormat) {
    var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
    var name = decodeStr(buf, 0, 100, filenameEncoding);
    var mode = decodeOct(buf, 100, 8);
    var uid = decodeOct(buf, 108, 8);
    var gid = decodeOct(buf, 116, 8);
    var size = decodeOct(buf, 124, 12);
    var mtime = decodeOct(buf, 136, 12);
    var type = toType(typeflag);
    var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
    var uname = decodeStr(buf, 265, 32);
    var gname = decodeStr(buf, 297, 32);
    var devmajor = decodeOct(buf, 329, 8);
    var devminor = decodeOct(buf, 337, 8);
    var c = cksum(buf);
    // checksum is still initial value if header was null.
    if (c === 8 * 32) return null;
    // valid checksum
    if (c !== decodeOct(buf, 148, 8)) throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
    if (USTAR_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0) {
        // ustar (posix) format.
        // prepend prefix, if present.
        if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
    } else if (GNU_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0 && GNU_VER.compare(buf, VERSION_OFFSET, VERSION_OFFSET + 2) === 0) {
    // 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and
    // multi-volume tarballs.
    } else {
        if (!allowUnknownFormat) {
            throw new Error("Invalid tar header: unknown format.");
        }
    }
    // to support old tar versions that use trailing / to indicate dirs
    if (typeflag === 0 && name && name[name.length - 1] === "/") typeflag = 5;
    return {
        name,
        mode,
        uid,
        gid,
        size,
        mtime: new Date(1000 * mtime),
        type,
        linkname,
        uname,
        gname,
        devmajor,
        devminor
    };
};


/***/ }),

/***/ 71202:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.extract = __webpack_require__(40426);
exports.pack = __webpack_require__(72862);


/***/ }),

/***/ 72862:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var constants = __webpack_require__(56399);
var eos = __webpack_require__(30604);
var inherits = __webpack_require__(33834);
var alloc = Buffer.alloc;
var Readable = (__webpack_require__(98323).Readable);
var Writable = (__webpack_require__(98323).Writable);
var StringDecoder = (__webpack_require__(71576).StringDecoder);
var headers = __webpack_require__(77867);
var DMODE = parseInt("755", 8);
var FMODE = parseInt("644", 8);
var END_OF_TAR = alloc(1024);
var noop = function() {};
var overflow = function(self, size) {
    size &= 511;
    if (size) self.push(END_OF_TAR.slice(0, 512 - size));
};
function modeToType(mode) {
    switch(mode & constants.S_IFMT){
        case constants.S_IFBLK:
            return "block-device";
        case constants.S_IFCHR:
            return "character-device";
        case constants.S_IFDIR:
            return "directory";
        case constants.S_IFIFO:
            return "fifo";
        case constants.S_IFLNK:
            return "symlink";
    }
    return "file";
}
var Sink = function(to) {
    Writable.call(this);
    this.written = 0;
    this._to = to;
    this._destroyed = false;
};
inherits(Sink, Writable);
Sink.prototype._write = function(data, enc, cb) {
    this.written += data.length;
    if (this._to.push(data)) return cb();
    this._to._drain = cb;
};
Sink.prototype.destroy = function() {
    if (this._destroyed) return;
    this._destroyed = true;
    this.emit("close");
};
var LinkSink = function() {
    Writable.call(this);
    this.linkname = "";
    this._decoder = new StringDecoder("utf-8");
    this._destroyed = false;
};
inherits(LinkSink, Writable);
LinkSink.prototype._write = function(data, enc, cb) {
    this.linkname += this._decoder.write(data);
    cb();
};
LinkSink.prototype.destroy = function() {
    if (this._destroyed) return;
    this._destroyed = true;
    this.emit("close");
};
var Void = function() {
    Writable.call(this);
    this._destroyed = false;
};
inherits(Void, Writable);
Void.prototype._write = function(data, enc, cb) {
    cb(new Error("No body allowed for this entry"));
};
Void.prototype.destroy = function() {
    if (this._destroyed) return;
    this._destroyed = true;
    this.emit("close");
};
var Pack = function(opts) {
    if (!(this instanceof Pack)) return new Pack(opts);
    Readable.call(this, opts);
    this._drain = noop;
    this._finalized = false;
    this._finalizing = false;
    this._destroyed = false;
    this._stream = null;
};
inherits(Pack, Readable);
Pack.prototype.entry = function(header, buffer, callback) {
    if (this._stream) throw new Error("already piping an entry");
    if (this._finalized || this._destroyed) return;
    if (typeof buffer === "function") {
        callback = buffer;
        buffer = null;
    }
    if (!callback) callback = noop;
    var self = this;
    if (!header.size || header.type === "symlink") header.size = 0;
    if (!header.type) header.type = modeToType(header.mode);
    if (!header.mode) header.mode = header.type === "directory" ? DMODE : FMODE;
    if (!header.uid) header.uid = 0;
    if (!header.gid) header.gid = 0;
    if (!header.mtime) header.mtime = new Date();
    if (typeof buffer === "string") buffer = Buffer.from(buffer);
    if (Buffer.isBuffer(buffer)) {
        header.size = buffer.length;
        this._encode(header);
        var ok = this.push(buffer);
        overflow(self, header.size);
        if (ok) process.nextTick(callback);
        else this._drain = callback;
        return new Void();
    }
    if (header.type === "symlink" && !header.linkname) {
        var linkSink = new LinkSink();
        eos(linkSink, function(err) {
            if (err) {
                self.destroy();
                return callback(err);
            }
            header.linkname = linkSink.linkname;
            self._encode(header);
            callback();
        });
        return linkSink;
    }
    this._encode(header);
    if (header.type !== "file" && header.type !== "contiguous-file") {
        process.nextTick(callback);
        return new Void();
    }
    var sink = new Sink(this);
    this._stream = sink;
    eos(sink, function(err) {
        self._stream = null;
        if (err) {
            self.destroy();
            return callback(err);
        }
        if (sink.written !== header.size) {
            self.destroy();
            return callback(new Error("size mismatch"));
        }
        overflow(self, header.size);
        if (self._finalizing) self.finalize();
        callback();
    });
    return sink;
};
Pack.prototype.finalize = function() {
    if (this._stream) {
        this._finalizing = true;
        return;
    }
    if (this._finalized) return;
    this._finalized = true;
    this.push(END_OF_TAR);
    this.push(null);
};
Pack.prototype.destroy = function(err) {
    if (this._destroyed) return;
    this._destroyed = true;
    if (err) this.emit("error", err);
    this.emit("close");
    if (this._stream && this._stream.destroy) this._stream.destroy();
};
Pack.prototype._encode = function(header) {
    if (!header.pax) {
        var buf = headers.encode(header);
        if (buf) {
            this.push(buf);
            return;
        }
    }
    this._encodePax(header);
};
Pack.prototype._encodePax = function(header) {
    var paxHeader = headers.encodePax({
        name: header.name,
        linkname: header.linkname,
        pax: header.pax
    });
    var newHeader = {
        name: "PaxHeader",
        mode: header.mode,
        uid: header.uid,
        gid: header.gid,
        size: paxHeader.length,
        mtime: header.mtime,
        type: "pax-header",
        linkname: header.linkname && "PaxHeader",
        uname: header.uname,
        gname: header.gname,
        devmajor: header.devmajor,
        devminor: header.devminor
    };
    this.push(headers.encode(newHeader));
    this.push(paxHeader);
    overflow(this, paxHeader.length);
    newHeader.size = header.size;
    newHeader.type = header.type;
    this.push(headers.encode(newHeader));
};
Pack.prototype._read = function(n) {
    var drain = this._drain;
    this._drain = noop;
    drain();
};
module.exports = Pack;


/***/ }),

/***/ 28861:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * Tmp
 *
 * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
 *
 * MIT Licensed
 */ /*
 * Module dependencies.
 */ 
const fs = __webpack_require__(57147);
const os = __webpack_require__(22037);
const path = __webpack_require__(71017);
const crypto = __webpack_require__(6113);
const _c = {
    fs: fs.constants,
    os: os.constants
};
/*
 * The working inner variables.
 */ const // the random characters to choose from
RANDOM_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", TEMPLATE_PATTERN = /XXXXXX/, DEFAULT_TRIES = 3, CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR), // constants are off on the windows platform and will not match the actual errno codes
IS_WIN32 = os.platform() === "win32", EBADF = _c.EBADF || _c.os.errno.EBADF, ENOENT = _c.ENOENT || _c.os.errno.ENOENT, DIR_MODE = 448 /* 448 */ , FILE_MODE = 384 /* 384 */ , EXIT = "exit", // this will hold the objects need to be removed on exit
_removeObjects = [], // API change in fs.rmdirSync leads to error when passing in a second parameter, e.g. the callback
FN_RMDIR_SYNC = fs.rmdirSync.bind(fs);
let _gracefulCleanup = false;
/**
 * Recursively remove a directory and its contents.
 *
 * @param {string} dirPath path of directory to remove
 * @param {Function} callback
 * @private
 */ function rimraf(dirPath, callback) {
    return fs.rm(dirPath, {
        recursive: true
    }, callback);
}
/**
 * Recursively remove a directory and its contents, synchronously.
 *
 * @param {string} dirPath path of directory to remove
 * @private
 */ function FN_RIMRAF_SYNC(dirPath) {
    return fs.rmSync(dirPath, {
        recursive: true
    });
}
/**
 * Gets a temporary file name.
 *
 * @param {(Options|tmpNameCallback)} options options or callback
 * @param {?tmpNameCallback} callback the callback function
 */ function tmpName(options, callback) {
    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
    try {
        _assertAndSanitizeOptions(opts);
    } catch (err) {
        return cb(err);
    }
    let tries = opts.tries;
    (function _getUniqueName() {
        try {
            const name = _generateTmpName(opts);
            // check whether the path exists then retry if needed
            fs.stat(name, function(err) {
                /* istanbul ignore else */ if (!err) {
                    /* istanbul ignore else */ if (tries-- > 0) return _getUniqueName();
                    return cb(new Error("Could not get a unique tmp filename, max tries reached " + name));
                }
                cb(null, name);
            });
        } catch (err) {
            cb(err);
        }
    })();
}
/**
 * Synchronous version of tmpName.
 *
 * @param {Object} options
 * @returns {string} the generated random name
 * @throws {Error} if the options are invalid or could not generate a filename
 */ function tmpNameSync(options) {
    const args = _parseArguments(options), opts = args[0];
    _assertAndSanitizeOptions(opts);
    let tries = opts.tries;
    do {
        const name = _generateTmpName(opts);
        try {
            fs.statSync(name);
        } catch (e) {
            return name;
        }
    }while (tries-- > 0);
    throw new Error("Could not get a unique tmp filename, max tries reached");
}
/**
 * Creates and opens a temporary file.
 *
 * @param {(Options|null|undefined|fileCallback)} options the config options or the callback function or null or undefined
 * @param {?fileCallback} callback
 */ function file(options, callback) {
    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
    // gets a temporary filename
    tmpName(opts, function _tmpNameCreated(err, name) {
        /* istanbul ignore else */ if (err) return cb(err);
        // create and open the file
        fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {
            /* istanbu ignore else */ if (err) return cb(err);
            if (opts.discardDescriptor) {
                return fs.close(fd, function _discardCallback(possibleErr) {
                    // the chance of getting an error on close here is rather low and might occur in the most edgiest cases only
                    return cb(possibleErr, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts, false));
                });
            } else {
                // detachDescriptor passes the descriptor whereas discardDescriptor closes it, either way, we no longer care
                // about the descriptor
                const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
                cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));
            }
        });
    });
}
/**
 * Synchronous version of file.
 *
 * @param {Options} options
 * @returns {FileSyncObject} object consists of name, fd and removeCallback
 * @throws {Error} if cannot create a file
 */ function fileSync(options) {
    const args = _parseArguments(options), opts = args[0];
    const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
    const name = tmpNameSync(opts);
    var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
    /* istanbul ignore else */ if (opts.discardDescriptor) {
        fs.closeSync(fd);
        fd = undefined;
    }
    return {
        name: name,
        fd: fd,
        removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)
    };
}
/**
 * Creates a temporary directory.
 *
 * @param {(Options|dirCallback)} options the options or the callback function
 * @param {?dirCallback} callback
 */ function dir(options, callback) {
    const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
    // gets a temporary filename
    tmpName(opts, function _tmpNameCreated(err, name) {
        /* istanbul ignore else */ if (err) return cb(err);
        // create the directory
        fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {
            /* istanbul ignore else */ if (err) return cb(err);
            cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));
        });
    });
}
/**
 * Synchronous version of dir.
 *
 * @param {Options} options
 * @returns {DirSyncObject} object consists of name and removeCallback
 * @throws {Error} if it cannot create a directory
 */ function dirSync(options) {
    const args = _parseArguments(options), opts = args[0];
    const name = tmpNameSync(opts);
    fs.mkdirSync(name, opts.mode || DIR_MODE);
    return {
        name: name,
        removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
    };
}
/**
 * Removes files asynchronously.
 *
 * @param {Object} fdPath
 * @param {Function} next
 * @private
 */ function _removeFileAsync(fdPath, next) {
    const _handler = function(err) {
        if (err && !_isENOENT(err)) {
            // reraise any unanticipated error
            return next(err);
        }
        next();
    };
    if (0 <= fdPath[0]) fs.close(fdPath[0], function() {
        fs.unlink(fdPath[1], _handler);
    });
    else fs.unlink(fdPath[1], _handler);
}
/**
 * Removes files synchronously.
 *
 * @param {Object} fdPath
 * @private
 */ function _removeFileSync(fdPath) {
    let rethrownException = null;
    try {
        if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);
    } catch (e) {
        // reraise any unanticipated error
        if (!_isEBADF(e) && !_isENOENT(e)) throw e;
    } finally{
        try {
            fs.unlinkSync(fdPath[1]);
        } catch (e) {
            // reraise any unanticipated error
            if (!_isENOENT(e)) rethrownException = e;
        }
    }
    if (rethrownException !== null) {
        throw rethrownException;
    }
}
/**
 * Prepares the callback for removal of the temporary file.
 *
 * Returns either a sync callback or a async callback depending on whether
 * fileSync or file was called, which is expressed by the sync parameter.
 *
 * @param {string} name the path of the file
 * @param {number} fd file descriptor
 * @param {Object} opts
 * @param {boolean} sync
 * @returns {fileCallback | fileCallbackSync}
 * @private
 */ function _prepareTmpFileRemoveCallback(name, fd, opts, sync) {
    const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [
        fd,
        name
    ], sync);
    const removeCallback = _prepareRemoveCallback(_removeFileAsync, [
        fd,
        name
    ], sync, removeCallbackSync);
    if (!opts.keep) _removeObjects.unshift(removeCallbackSync);
    return sync ? removeCallbackSync : removeCallback;
}
/**
 * Prepares the callback for removal of the temporary directory.
 *
 * Returns either a sync callback or a async callback depending on whether
 * tmpFileSync or tmpFile was called, which is expressed by the sync parameter.
 *
 * @param {string} name
 * @param {Object} opts
 * @param {boolean} sync
 * @returns {Function} the callback
 * @private
 */ function _prepareTmpDirRemoveCallback(name, opts, sync) {
    const removeFunction = opts.unsafeCleanup ? rimraf : fs.rmdir.bind(fs);
    const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;
    const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync);
    const removeCallback = _prepareRemoveCallback(removeFunction, name, sync, removeCallbackSync);
    if (!opts.keep) _removeObjects.unshift(removeCallbackSync);
    return sync ? removeCallbackSync : removeCallback;
}
/**
 * Creates a guarded function wrapping the removeFunction call.
 *
 * The cleanup callback is save to be called multiple times.
 * Subsequent invocations will be ignored.
 *
 * @param {Function} removeFunction
 * @param {string} fileOrDirName
 * @param {boolean} sync
 * @param {cleanupCallbackSync?} cleanupCallbackSync
 * @returns {cleanupCallback | cleanupCallbackSync}
 * @private
 */ function _prepareRemoveCallback(removeFunction, fileOrDirName, sync, cleanupCallbackSync) {
    let called = false;
    // if sync is true, the next parameter will be ignored
    return function _cleanupCallback(next) {
        /* istanbul ignore else */ if (!called) {
            // remove cleanupCallback from cache
            const toRemove = cleanupCallbackSync || _cleanupCallback;
            const index = _removeObjects.indexOf(toRemove);
            /* istanbul ignore else */ if (index >= 0) _removeObjects.splice(index, 1);
            called = true;
            if (sync || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {
                return removeFunction(fileOrDirName);
            } else {
                return removeFunction(fileOrDirName, next || function() {});
            }
        }
    };
}
/**
 * The garbage collector.
 *
 * @private
 */ function _garbageCollector() {
    /* istanbul ignore else */ if (!_gracefulCleanup) return;
    // the function being called removes itself from _removeObjects,
    // loop until _removeObjects is empty
    while(_removeObjects.length){
        try {
            _removeObjects[0]();
        } catch (e) {
        // already removed?
        }
    }
}
/**
 * Random name generator based on crypto.
 * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript
 *
 * @param {number} howMany
 * @returns {string} the generated random name
 * @private
 */ function _randomChars(howMany) {
    let value = [], rnd = null;
    // make sure that we do not fail because we ran out of entropy
    try {
        rnd = crypto.randomBytes(howMany);
    } catch (e) {
        rnd = crypto.pseudoRandomBytes(howMany);
    }
    for(var i = 0; i < howMany; i++){
        value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
    }
    return value.join("");
}
/**
 * Helper which determines whether a string s is blank, that is undefined, or empty or null.
 *
 * @private
 * @param {string} s
 * @returns {Boolean} true whether the string s is blank, false otherwise
 */ function _isBlank(s) {
    return s === null || _isUndefined(s) || !s.trim();
}
/**
 * Checks whether the `obj` parameter is defined or not.
 *
 * @param {Object} obj
 * @returns {boolean} true if the object is undefined
 * @private
 */ function _isUndefined(obj) {
    return typeof obj === "undefined";
}
/**
 * Parses the function arguments.
 *
 * This function helps to have optional arguments.
 *
 * @param {(Options|null|undefined|Function)} options
 * @param {?Function} callback
 * @returns {Array} parsed arguments
 * @private
 */ function _parseArguments(options, callback) {
    /* istanbul ignore else */ if (typeof options === "function") {
        return [
            {},
            options
        ];
    }
    /* istanbul ignore else */ if (_isUndefined(options)) {
        return [
            {},
            callback
        ];
    }
    // copy options so we do not leak the changes we make internally
    const actualOptions = {};
    for (const key of Object.getOwnPropertyNames(options)){
        actualOptions[key] = options[key];
    }
    return [
        actualOptions,
        callback
    ];
}
/**
 * Generates a new temporary name.
 *
 * @param {Object} opts
 * @returns {string} the new random name according to opts
 * @private
 */ function _generateTmpName(opts) {
    const tmpDir = opts.tmpdir;
    /* istanbul ignore else */ if (!_isUndefined(opts.name)) return path.join(tmpDir, opts.dir, opts.name);
    /* istanbul ignore else */ if (!_isUndefined(opts.template)) return path.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));
    // prefix and postfix
    const name = [
        opts.prefix ? opts.prefix : "tmp",
        "-",
        process.pid,
        "-",
        _randomChars(12),
        opts.postfix ? "-" + opts.postfix : ""
    ].join("");
    return path.join(tmpDir, opts.dir, name);
}
/**
 * Asserts whether the specified options are valid, also sanitizes options and provides sane defaults for missing
 * options.
 *
 * @param {Options} options
 * @private
 */ function _assertAndSanitizeOptions(options) {
    options.tmpdir = _getTmpDir(options);
    const tmpDir = options.tmpdir;
    /* istanbul ignore else */ if (!_isUndefined(options.name)) _assertIsRelative(options.name, "name", tmpDir);
    /* istanbul ignore else */ if (!_isUndefined(options.dir)) _assertIsRelative(options.dir, "dir", tmpDir);
    /* istanbul ignore else */ if (!_isUndefined(options.template)) {
        _assertIsRelative(options.template, "template", tmpDir);
        if (!options.template.match(TEMPLATE_PATTERN)) throw new Error(`Invalid template, found "${options.template}".`);
    }
    /* istanbul ignore else */ if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0) throw new Error(`Invalid tries, found "${options.tries}".`);
    // if a name was specified we will try once
    options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;
    options.keep = !!options.keep;
    options.detachDescriptor = !!options.detachDescriptor;
    options.discardDescriptor = !!options.discardDescriptor;
    options.unsafeCleanup = !!options.unsafeCleanup;
    // sanitize dir, also keep (multiple) blanks if the user, purportedly sane, requests us to
    options.dir = _isUndefined(options.dir) ? "" : path.relative(tmpDir, _resolvePath(options.dir, tmpDir));
    options.template = _isUndefined(options.template) ? undefined : path.relative(tmpDir, _resolvePath(options.template, tmpDir));
    // sanitize further if template is relative to options.dir
    options.template = _isBlank(options.template) ? undefined : path.relative(options.dir, options.template);
    // for completeness' sake only, also keep (multiple) blanks if the user, purportedly sane, requests us to
    options.name = _isUndefined(options.name) ? undefined : options.name;
    options.prefix = _isUndefined(options.prefix) ? "" : options.prefix;
    options.postfix = _isUndefined(options.postfix) ? "" : options.postfix;
}
/**
 * Resolve the specified path name in respect to tmpDir.
 *
 * The specified name might include relative path components, e.g. ../
 * so we need to resolve in order to be sure that is is located inside tmpDir
 *
 * @param name
 * @param tmpDir
 * @returns {string}
 * @private
 */ function _resolvePath(name, tmpDir) {
    if (name.startsWith(tmpDir)) {
        return path.resolve(name);
    } else {
        return path.resolve(path.join(tmpDir, name));
    }
}
/**
 * Asserts whether specified name is relative to the specified tmpDir.
 *
 * @param {string} name
 * @param {string} option
 * @param {string} tmpDir
 * @throws {Error}
 * @private
 */ function _assertIsRelative(name, option, tmpDir) {
    if (option === "name") {
        // assert that name is not absolute and does not contain a path
        if (path.isAbsolute(name)) throw new Error(`${option} option must not contain an absolute path, found "${name}".`);
        // must not fail on valid .<name> or ..<name> or similar such constructs
        let basename = path.basename(name);
        if (basename === ".." || basename === "." || basename !== name) throw new Error(`${option} option must not contain a path, found "${name}".`);
    } else {
        // assert that dir or template are relative to tmpDir
        if (path.isAbsolute(name) && !name.startsWith(tmpDir)) {
            throw new Error(`${option} option must be relative to "${tmpDir}", found "${name}".`);
        }
        let resolvedPath = _resolvePath(name, tmpDir);
        if (!resolvedPath.startsWith(tmpDir)) throw new Error(`${option} option must be relative to "${tmpDir}", found "${resolvedPath}".`);
    }
}
/**
 * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.
 *
 * @private
 */ function _isEBADF(error) {
    return _isExpectedError(error, -EBADF, "EBADF");
}
/**
 * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.
 *
 * @private
 */ function _isENOENT(error) {
    return _isExpectedError(error, -ENOENT, "ENOENT");
}
/**
 * Helper to determine whether the expected error code matches the actual code and errno,
 * which will differ between the supported node versions.
 *
 * - Node >= 7.0:
 *   error.code {string}
 *   error.errno {number} any numerical value will be negated
 *
 * CAVEAT
 *
 * On windows, the errno for EBADF is -4083 but os.constants.errno.EBADF is different and we must assume that ENOENT
 * is no different here.
 *
 * @param {SystemError} error
 * @param {number} errno
 * @param {string} code
 * @private
 */ function _isExpectedError(error, errno, code) {
    return IS_WIN32 ? error.code === code : error.code === code && error.errno === errno;
}
/**
 * Sets the graceful cleanup.
 *
 * If graceful cleanup is set, tmp will remove all controlled temporary objects on process exit, otherwise the
 * temporary objects will remain in place, waiting to be cleaned up on system restart or otherwise scheduled temporary
 * object removals.
 */ function setGracefulCleanup() {
    _gracefulCleanup = true;
}
/**
 * Returns the currently configured tmp dir from os.tmpdir().
 *
 * @private
 * @param {?Options} options
 * @returns {string} the currently configured tmp dir
 */ function _getTmpDir(options) {
    return path.resolve(options && options.tmpdir || os.tmpdir());
}
// Install process exit listener
process.addListener(EXIT, _garbageCollector);
/**
 * Configuration options.
 *
 * @typedef {Object} Options
 * @property {?boolean} keep the temporary object (file or dir) will not be garbage collected
 * @property {?number} tries the number of tries before give up the name generation
 * @property (?int) mode the access mode, defaults are 0o700 for directories and 0o600 for files
 * @property {?string} template the "mkstemp" like filename template
 * @property {?string} name fixed name relative to tmpdir or the specified dir option
 * @property {?string} dir tmp directory relative to the root tmp directory in use
 * @property {?string} prefix prefix for the generated name
 * @property {?string} postfix postfix for the generated name
 * @property {?string} tmpdir the root tmp directory which overrides the os tmpdir
 * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty
 * @property {?boolean} detachDescriptor detaches the file descriptor, caller is responsible for closing the file, tmp will no longer try closing the file during garbage collection
 * @property {?boolean} discardDescriptor discards the file descriptor (closes file, fd is -1), tmp will no longer try closing the file during garbage collection
 */ /**
 * @typedef {Object} FileSyncObject
 * @property {string} name the name of the file
 * @property {string} fd the file descriptor or -1 if the fd has been discarded
 * @property {fileCallback} removeCallback the callback function to remove the file
 */ /**
 * @typedef {Object} DirSyncObject
 * @property {string} name the name of the directory
 * @property {fileCallback} removeCallback the callback function to remove the directory
 */ /**
 * @callback tmpNameCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 */ /**
 * @callback fileCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {number} fd the file descriptor or -1 if the fd had been discarded
 * @param {cleanupCallback} fn the cleanup callback function
 */ /**
 * @callback fileCallbackSync
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {number} fd the file descriptor or -1 if the fd had been discarded
 * @param {cleanupCallbackSync} fn the cleanup callback function
 */ /**
 * @callback dirCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {cleanupCallback} fn the cleanup callback function
 */ /**
 * @callback dirCallbackSync
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {cleanupCallbackSync} fn the cleanup callback function
 */ /**
 * Removes the temporary created file or directory.
 *
 * @callback cleanupCallback
 * @param {simpleCallback} [next] function to call whenever the tmp object needs to be removed
 */ /**
 * Removes the temporary created file or directory.
 *
 * @callback cleanupCallbackSync
 */ /**
 * Callback function for function composition.
 * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}
 *
 * @callback simpleCallback
 */ // exporting all the needed methods
// evaluate _getTmpDir() lazily, mainly for simplifying testing but it also will
// allow users to reconfigure the temporary directory
Object.defineProperty(module.exports, "tmpdir", ({
    enumerable: true,
    configurable: false,
    get: function() {
        return _getTmpDir();
    }
}));
module.exports.dir = dir;
module.exports.dirSync = dirSync;
module.exports.file = file;
module.exports.fileSync = fileSync;
module.exports.tmpName = tmpName;
module.exports.tmpNameSync = tmpNameSync;
module.exports.setGracefulCleanup = setGracefulCleanup;


/***/ }),

/***/ 61695:
/***/ ((module) => {

"use strict";

module.exports = Traverse;
function Traverse(obj) {
    if (!(this instanceof Traverse)) return new Traverse(obj);
    this.value = obj;
}
Traverse.prototype.get = function(ps) {
    var node = this.value;
    for(var i = 0; i < ps.length; i++){
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};
Traverse.prototype.set = function(ps, value) {
    var node = this.value;
    for(var i = 0; i < ps.length - 1; i++){
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};
Traverse.prototype.map = function(cb) {
    return walk(this.value, cb, true);
};
Traverse.prototype.forEach = function(cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};
Traverse.prototype.reduce = function(cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function(x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};
Traverse.prototype.deepEqual = function(obj) {
    if (arguments.length !== 1) {
        throw new Error("deepEqual requires exactly one object to compare against");
    }
    var equal = true;
    var node = obj;
    this.forEach(function(y) {
        var notEqual = (function() {
            equal = false;
            //this.stop();
            return undefined;
        }).bind(this);
        //if (node === undefined || node === null) return notEqual();
        if (!this.isRoot) {
            /*
            if (!Object.hasOwnProperty.call(node, this.key)) {
                return notEqual();
            }
        */ if (typeof node !== "object") return notEqual();
            node = node[this.key];
        }
        var x = node;
        this.post(function() {
            node = x;
        });
        var toS = function(o) {
            return Object.prototype.toString.call(o);
        };
        if (this.circular) {
            if (Traverse(obj).get(this.circular.path) !== x) notEqual();
        } else if (typeof x !== typeof y) {
            notEqual();
        } else if (x === null || y === null || x === undefined || y === undefined) {
            if (x !== y) notEqual();
        } else if (x.__proto__ !== y.__proto__) {
            notEqual();
        } else if (x === y) {
        // nop
        } else if (typeof x === "function") {
            if (x instanceof RegExp) {
                // both regexps on account of the __proto__ check
                if (x.toString() != y.toString()) notEqual();
            } else if (x !== y) notEqual();
        } else if (typeof x === "object") {
            if (toS(y) === "[object Arguments]" || toS(x) === "[object Arguments]") {
                if (toS(x) !== toS(y)) {
                    notEqual();
                }
            } else if (x instanceof Date || y instanceof Date) {
                if (!(x instanceof Date) || !(y instanceof Date) || x.getTime() !== y.getTime()) {
                    notEqual();
                }
            } else {
                var kx = Object.keys(x);
                var ky = Object.keys(y);
                if (kx.length !== ky.length) return notEqual();
                for(var i = 0; i < kx.length; i++){
                    var k = kx[i];
                    if (!Object.hasOwnProperty.call(y, k)) {
                        notEqual();
                    }
                }
            }
        }
    });
    return equal;
};
Traverse.prototype.paths = function() {
    var acc = [];
    this.forEach(function(x) {
        acc.push(this.path);
    });
    return acc;
};
Traverse.prototype.nodes = function() {
    var acc = [];
    this.forEach(function(x) {
        acc.push(this.node);
    });
    return acc;
};
Traverse.prototype.clone = function() {
    var parents = [], nodes = [];
    return function clone(src) {
        for(var i = 0; i < parents.length; i++){
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        if (typeof src === "object" && src !== null) {
            var dst = copy(src);
            parents.push(src);
            nodes.push(dst);
            Object.keys(src).forEach(function(key) {
                dst[key] = clone(src[key]);
            });
            parents.pop();
            nodes.pop();
            return dst;
        } else {
            return src;
        }
    }(this.value);
};
function walk(root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    return function walker(node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        var state = {
            node: node,
            node_: node_,
            path: [].concat(path),
            parent: parents.slice(-1)[0],
            key: path.slice(-1)[0],
            isRoot: path.length === 0,
            level: path.length,
            circular: null,
            update: function(x) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
            },
            "delete": function() {
                delete state.parent.node[state.key];
            },
            remove: function() {
                if (Array.isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                } else {
                    delete state.parent.node[state.key];
                }
            },
            before: function(f) {
                modifiers.before = f;
            },
            after: function(f) {
                modifiers.after = f;
            },
            pre: function(f) {
                modifiers.pre = f;
            },
            post: function(f) {
                modifiers.post = f;
            },
            stop: function() {
                alive = false;
            }
        };
        if (!alive) return state;
        if (typeof node === "object" && node !== null) {
            state.isLeaf = Object.keys(node).length == 0;
            for(var i = 0; i < parents.length; i++){
                if (parents[i].node_ === node_) {
                    state.circular = parents[i];
                    break;
                }
            }
        } else {
            state.isLeaf = true;
        }
        state.notLeaf = !state.isLeaf;
        state.notRoot = !state.isRoot;
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        if (modifiers.before) modifiers.before.call(state, state.node);
        if (typeof state.node == "object" && state.node !== null && !state.circular) {
            parents.push(state);
            var keys = Object.keys(state.node);
            keys.forEach(function(key, i) {
                path.push(key);
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                var child = walker(state.node[key]);
                if (immutable && Object.hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                child.isLast = i == keys.length - 1;
                child.isFirst = i == 0;
                if (modifiers.post) modifiers.post.call(state, child);
                path.pop();
            });
            parents.pop();
        }
        if (modifiers.after) modifiers.after.call(state, state.node);
        return state;
    }(root).node;
}
Object.keys(Traverse.prototype).forEach(function(key) {
    Traverse[key] = function(obj) {
        var args = [].slice.call(arguments, 1);
        var t = Traverse(obj);
        return t[key].apply(t, args);
    };
});
function copy(src) {
    if (typeof src === "object" && src !== null) {
        var dst;
        if (Array.isArray(src)) {
            dst = [];
        } else if (src instanceof Date) {
            dst = new Date(src);
        } else if (src instanceof Boolean) {
            dst = new Boolean(src);
        } else if (src instanceof Number) {
            dst = new Number(src);
        } else if (src instanceof String) {
            dst = new String(src);
        } else {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        Object.keys(src).forEach(function(key) {
            dst[key] = src[key];
        });
        return dst;
    } else return src;
}


/***/ }),

/***/ 79812:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(14300).Buffer);
// Backwards compatibility for node versions < 8
if (Buffer.from === undefined) {
    Buffer.from = function(a, b, c) {
        return new Buffer(a, b, c);
    };
    Buffer.alloc = Buffer.from;
}
module.exports = Buffer;


/***/ }),

/***/ 24120:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Promise = __webpack_require__(72468);
var Stream = __webpack_require__(12781);
var Buffer = __webpack_require__(79812);
// Backwards compatibility for node versions < 8
if (!Stream.Writable || !Stream.Writable.prototype.destroy) Stream = __webpack_require__(8320);
module.exports = function(entry) {
    return new Promise(function(resolve, reject) {
        var chunks = [];
        var bufferStream = Stream.Transform().on("finish", function() {
            resolve(Buffer.concat(chunks));
        }).on("error", reject);
        bufferStream._transform = function(d, e, cb) {
            chunks.push(d);
            cb();
        };
        entry.on("error", reject).pipe(bufferStream);
    });
};


/***/ }),

/***/ 85266:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var bigInt = __webpack_require__(29037);
var Stream = __webpack_require__(12781);
// Backwards compatibility for node versions < 8
if (!Stream.Writable || !Stream.Writable.prototype.destroy) Stream = __webpack_require__(8320);
var table;
function generateTable() {
    var poly = 0xEDB88320, c, n, k;
    table = [];
    for(n = 0; n < 256; n++){
        c = n;
        for(k = 0; k < 8; k++)c = c & 1 ? poly ^ c >>> 1 : c = c >>> 1;
        table[n] = c >>> 0;
    }
}
function crc(ch, crc) {
    if (!table) generateTable();
    if (ch.charCodeAt) ch = ch.charCodeAt(0);
    return bigInt(crc).shiftRight(8).and(0xffffff).xor(table[bigInt(crc).xor(ch).and(0xff)]).value;
}
function Decrypt() {
    if (!(this instanceof Decrypt)) return new Decrypt();
    this.key0 = 305419896;
    this.key1 = 591751049;
    this.key2 = 878082192;
}
Decrypt.prototype.update = function(h) {
    this.key0 = crc(h, this.key0);
    this.key1 = bigInt(this.key0).and(255).and(4294967295).add(this.key1);
    this.key1 = bigInt(this.key1).multiply(134775813).add(1).and(4294967295).value;
    this.key2 = crc(bigInt(this.key1).shiftRight(24).and(255), this.key2);
};
Decrypt.prototype.decryptByte = function(c) {
    var k = bigInt(this.key2).or(2);
    c = c ^ bigInt(k).multiply(bigInt(k ^ 1)).shiftRight(8).and(255);
    this.update(c);
    return c;
};
Decrypt.prototype.stream = function() {
    var stream = Stream.Transform(), self = this;
    stream._transform = function(d, e, cb) {
        for(var i = 0; i < d.length; i++){
            d[i] = self.decryptByte(d[i]);
        }
        this.push(d);
        cb();
    };
    return stream;
};
module.exports = Decrypt;


/***/ }),

/***/ 53773:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Stream = __webpack_require__(12781);
var util = __webpack_require__(73837);
// Backwards compatibility for node versions < 8
if (!Stream.Writable || !Stream.Writable.prototype.destroy) Stream = __webpack_require__(8320);
function NoopStream() {
    if (!(this instanceof NoopStream)) {
        return new NoopStream();
    }
    Stream.Transform.call(this);
}
util.inherits(NoopStream, Stream.Transform);
NoopStream.prototype._transform = function(d, e, cb) {
    cb();
};
module.exports = NoopStream;


/***/ }),

/***/ 36317:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var binary = __webpack_require__(2361);
var PullStream = __webpack_require__(77043);
var unzip = __webpack_require__(11154);
var Promise = __webpack_require__(72468);
var BufferStream = __webpack_require__(24120);
var parseExtraField = __webpack_require__(27416);
var Buffer = __webpack_require__(79812);
var path = __webpack_require__(71017);
var Writer = (__webpack_require__(63693).Writer);
var parseDateTime = __webpack_require__(18866);
var signature = Buffer.alloc(4);
signature.writeUInt32LE(0x06054b50, 0);
function getCrxHeader(source) {
    var sourceStream = source.stream(0).pipe(PullStream());
    return sourceStream.pull(4).then(function(data) {
        var signature = data.readUInt32LE(0);
        if (signature === 0x34327243) {
            var crxHeader;
            return sourceStream.pull(12).then(function(data) {
                crxHeader = binary.parse(data).word32lu("version").word32lu("pubKeyLength").word32lu("signatureLength").vars;
            }).then(function() {
                return sourceStream.pull(crxHeader.pubKeyLength + crxHeader.signatureLength);
            }).then(function(data) {
                crxHeader.publicKey = data.slice(0, crxHeader.pubKeyLength);
                crxHeader.signature = data.slice(crxHeader.pubKeyLength);
                crxHeader.size = 16 + crxHeader.pubKeyLength + crxHeader.signatureLength;
                return crxHeader;
            });
        }
    });
}
// Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT
function getZip64CentralDirectory(source, zip64CDL) {
    var d64loc = binary.parse(zip64CDL).word32lu("signature").word32lu("diskNumber").word64lu("offsetToStartOfCentralDirectory").word32lu("numberOfDisks").vars;
    if (d64loc.signature != 0x07064b50) {
        throw new Error("invalid zip64 end of central dir locator signature (0x07064b50): 0x" + d64loc.signature.toString(16));
    }
    var dir64 = PullStream();
    source.stream(d64loc.offsetToStartOfCentralDirectory).pipe(dir64);
    return dir64.pull(56);
}
// Zip64 File Format Notes: https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT
function parseZip64DirRecord(dir64record) {
    var vars = binary.parse(dir64record).word32lu("signature").word64lu("sizeOfCentralDirectory").word16lu("version").word16lu("versionsNeededToExtract").word32lu("diskNumber").word32lu("diskStart").word64lu("numberOfRecordsOnDisk").word64lu("numberOfRecords").word64lu("sizeOfCentralDirectory").word64lu("offsetToStartOfCentralDirectory").vars;
    if (vars.signature != 0x06064b50) {
        throw new Error("invalid zip64 end of central dir locator signature (0x06064b50): 0x0" + vars.signature.toString(16));
    }
    return vars;
}
module.exports = function centralDirectory(source, options) {
    var endDir = PullStream(), records = PullStream(), tailSize = options && options.tailSize || 80, sourceSize, crxHeader, startOffset, vars;
    if (options && options.crx) crxHeader = getCrxHeader(source);
    return source.size().then(function(size) {
        sourceSize = size;
        source.stream(Math.max(0, size - tailSize)).on("error", function(error) {
            endDir.emit("error", error);
        }).pipe(endDir);
        return endDir.pull(signature);
    }).then(function() {
        return Promise.props({
            directory: endDir.pull(22),
            crxHeader: crxHeader
        });
    }).then(function(d) {
        var data = d.directory;
        startOffset = d.crxHeader && d.crxHeader.size || 0;
        vars = binary.parse(data).word32lu("signature").word16lu("diskNumber").word16lu("diskStart").word16lu("numberOfRecordsOnDisk").word16lu("numberOfRecords").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
        // Is this zip file using zip64 format? Use same check as Go:
        // https://github.com/golang/go/blob/master/src/archive/zip/reader.go#L503
        // For zip64 files, need to find zip64 central directory locator header to extract
        // relative offset for zip64 central directory record.
        if (vars.numberOfRecords == 0xffff || vars.numberOfRecords == 0xffff || vars.offsetToStartOfCentralDirectory == 0xffffffff) {
            // Offset to zip64 CDL is 20 bytes before normal CDR
            const zip64CDLSize = 20;
            const zip64CDLOffset = sourceSize - (tailSize - endDir.match + zip64CDLSize);
            const zip64CDLStream = PullStream();
            source.stream(zip64CDLOffset).pipe(zip64CDLStream);
            return zip64CDLStream.pull(zip64CDLSize).then(function(d) {
                return getZip64CentralDirectory(source, d);
            }).then(function(dir64record) {
                vars = parseZip64DirRecord(dir64record);
            });
        } else {
            vars.offsetToStartOfCentralDirectory += startOffset;
        }
    }).then(function() {
        if (vars.commentLength) return endDir.pull(vars.commentLength).then(function(comment) {
            vars.comment = comment.toString("utf8");
        });
    }).then(function() {
        source.stream(vars.offsetToStartOfCentralDirectory).pipe(records);
        vars.extract = function(opts) {
            if (!opts || !opts.path) throw new Error("PATH_MISSING");
            // make sure path is normalized before using it
            opts.path = path.resolve(path.normalize(opts.path));
            return vars.files.then(function(files) {
                return Promise.map(files, function(entry) {
                    if (entry.type == "Directory") return;
                    // to avoid zip slip (writing outside of the destination), we resolve
                    // the target path, and make sure it's nested in the intended
                    // destination, or not extract it otherwise.
                    var extractPath = path.join(opts.path, entry.path);
                    if (extractPath.indexOf(opts.path) != 0) {
                        return;
                    }
                    var writer = opts.getWriter ? opts.getWriter({
                        path: extractPath
                    }) : Writer({
                        path: extractPath
                    });
                    return new Promise(function(resolve, reject) {
                        entry.stream(opts.password).on("error", reject).pipe(writer).on("close", resolve).on("error", reject);
                    });
                }, {
                    concurrency: opts.concurrency > 1 ? opts.concurrency : 1
                });
            });
        };
        vars.files = Promise.mapSeries(Array(vars.numberOfRecords), function() {
            return records.pull(46).then(function(data) {
                var vars = binary.parse(data).word32lu("signature").word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
                vars.offsetToLocalFileHeader += startOffset;
                vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);
                return records.pull(vars.fileNameLength).then(function(fileNameBuffer) {
                    vars.pathBuffer = fileNameBuffer;
                    vars.path = fileNameBuffer.toString("utf8");
                    vars.isUnicode = (vars.flags & 0x800) != 0;
                    return records.pull(vars.extraFieldLength);
                }).then(function(extraField) {
                    vars.extra = parseExtraField(extraField, vars);
                    return records.pull(vars.fileCommentLength);
                }).then(function(comment) {
                    vars.comment = comment;
                    vars.type = vars.uncompressedSize === 0 && /[\/\\]$/.test(vars.path) ? "Directory" : "File";
                    vars.stream = function(_password) {
                        return unzip(source, vars.offsetToLocalFileHeader, _password, vars);
                    };
                    vars.buffer = function(_password) {
                        return BufferStream(vars.stream(_password));
                    };
                    return vars;
                });
            });
        });
        return Promise.props(vars);
    });
};


/***/ }),

/***/ 70788:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fs = __webpack_require__(33362);
var Promise = __webpack_require__(72468);
var directory = __webpack_require__(36317);
var Stream = __webpack_require__(12781);
// Backwards compatibility for node versions < 8
if (!Stream.Writable || !Stream.Writable.prototype.destroy) Stream = __webpack_require__(8320);
module.exports = {
    buffer: function(buffer, options) {
        var source = {
            stream: function(offset, length) {
                var stream = Stream.PassThrough();
                stream.end(buffer.slice(offset, length));
                return stream;
            },
            size: function() {
                return Promise.resolve(buffer.length);
            }
        };
        return directory(source, options);
    },
    file: function(filename, options) {
        var source = {
            stream: function(offset, length) {
                return fs.createReadStream(filename, {
                    start: offset,
                    end: length && offset + length
                });
            },
            size: function() {
                return new Promise(function(resolve, reject) {
                    fs.stat(filename, function(err, d) {
                        if (err) reject(err);
                        else resolve(d.size);
                    });
                });
            }
        };
        return directory(source, options);
    },
    url: function(request, params, options) {
        if (typeof params === "string") params = {
            url: params
        };
        if (!params.url) throw "URL missing";
        params.headers = params.headers || {};
        var source = {
            stream: function(offset, length) {
                var options = Object.create(params);
                options.headers = Object.create(params.headers);
                options.headers.range = "bytes=" + offset + "-" + (length ? length : "");
                return request(options);
            },
            size: function() {
                return new Promise(function(resolve, reject) {
                    var req = request(params);
                    req.on("response", function(d) {
                        req.abort();
                        if (!d.headers["content-length"]) reject(new Error("Missing content length header"));
                        else resolve(d.headers["content-length"]);
                    }).on("error", reject);
                });
            }
        };
        return directory(source, options);
    },
    s3: function(client, params, options) {
        var source = {
            size: function() {
                return new Promise(function(resolve, reject) {
                    client.headObject(params, function(err, d) {
                        if (err) reject(err);
                        else resolve(d.ContentLength);
                    });
                });
            },
            stream: function(offset, length) {
                var d = {};
                for(var key in params)d[key] = params[key];
                d.Range = "bytes=" + offset + "-" + (length ? length : "");
                return client.getObject(d).createReadStream();
            }
        };
        return directory(source, options);
    },
    custom: function(source, options) {
        return directory(source, options);
    }
};


/***/ }),

/***/ 11154:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Promise = __webpack_require__(72468);
var Decrypt = __webpack_require__(85266);
var PullStream = __webpack_require__(77043);
var Stream = __webpack_require__(12781);
var binary = __webpack_require__(2361);
var zlib = __webpack_require__(59796);
var parseExtraField = __webpack_require__(27416);
var Buffer = __webpack_require__(79812);
var parseDateTime = __webpack_require__(18866);
// Backwards compatibility for node versions < 8
if (!Stream.Writable || !Stream.Writable.prototype.destroy) Stream = __webpack_require__(8320);
module.exports = function unzip(source, offset, _password, directoryVars) {
    var file = PullStream(), entry = Stream.PassThrough();
    var req = source.stream(offset);
    req.pipe(file).on("error", function(e) {
        entry.emit("error", e);
    });
    entry.vars = file.pull(30).then(function(data) {
        var vars = binary.parse(data).word32lu("signature").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
        vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);
        return file.pull(vars.fileNameLength).then(function(fileName) {
            vars.fileName = fileName.toString("utf8");
            return file.pull(vars.extraFieldLength);
        }).then(function(extraField) {
            var checkEncryption;
            vars.extra = parseExtraField(extraField, vars);
            // Ignore logal file header vars if the directory vars are available
            if (directoryVars && directoryVars.compressedSize) vars = directoryVars;
            if (vars.flags & 0x01) checkEncryption = file.pull(12).then(function(header) {
                if (!_password) throw new Error("MISSING_PASSWORD");
                var decrypt = Decrypt();
                String(_password).split("").forEach(function(d) {
                    decrypt.update(d);
                });
                for(var i = 0; i < header.length; i++)header[i] = decrypt.decryptByte(header[i]);
                vars.decrypt = decrypt;
                vars.compressedSize -= 12;
                var check = vars.flags & 0x8 ? vars.lastModifiedTime >> 8 & 0xff : vars.crc32 >> 24 & 0xff;
                if (header[11] !== check) throw new Error("BAD_PASSWORD");
                return vars;
            });
            return Promise.resolve(checkEncryption).then(function() {
                entry.emit("vars", vars);
                return vars;
            });
        });
    });
    entry.vars.then(function(vars) {
        var fileSizeKnown = !(vars.flags & 0x08) || vars.compressedSize > 0, eof;
        var inflater = vars.compressionMethod ? zlib.createInflateRaw() : Stream.PassThrough();
        if (fileSizeKnown) {
            entry.size = vars.uncompressedSize;
            eof = vars.compressedSize;
        } else {
            eof = Buffer.alloc(4);
            eof.writeUInt32LE(0x08074b50, 0);
        }
        var stream = file.stream(eof);
        if (vars.decrypt) stream = stream.pipe(vars.decrypt.stream());
        stream.pipe(inflater).on("error", function(err) {
            entry.emit("error", err);
        }).pipe(entry).on("finish", function() {
            if (req.destroy) req.destroy();
            else if (req.abort) req.abort();
            else if (req.close) req.close();
            else if (req.push) req.push();
            else console.log("warning - unable to close stream");
        });
    }).catch(function(e) {
        entry.emit("error", e);
    });
    return entry;
};


/***/ }),

/***/ 77043:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Stream = __webpack_require__(12781);
var Promise = __webpack_require__(72468);
var util = __webpack_require__(73837);
var Buffer = __webpack_require__(79812);
var strFunction = "function";
// Backwards compatibility for node versions < 8
if (!Stream.Writable || !Stream.Writable.prototype.destroy) Stream = __webpack_require__(8320);
function PullStream() {
    if (!(this instanceof PullStream)) return new PullStream();
    Stream.Duplex.call(this, {
        decodeStrings: false,
        objectMode: true
    });
    this.buffer = Buffer.from("");
    var self = this;
    self.on("finish", function() {
        self.finished = true;
        self.emit("chunk", false);
    });
}
util.inherits(PullStream, Stream.Duplex);
PullStream.prototype._write = function(chunk, e, cb) {
    this.buffer = Buffer.concat([
        this.buffer,
        chunk
    ]);
    this.cb = cb;
    this.emit("chunk");
};
// The `eof` parameter is interpreted as `file_length` if the type is number
// otherwise (i.e. buffer) it is interpreted as a pattern signaling end of stream
PullStream.prototype.stream = function(eof, includeEof) {
    var p = Stream.PassThrough();
    var done, self = this;
    function cb() {
        if (typeof self.cb === strFunction) {
            var callback = self.cb;
            self.cb = undefined;
            return callback();
        }
    }
    function pull() {
        var packet;
        if (self.buffer && self.buffer.length) {
            if (typeof eof === "number") {
                packet = self.buffer.slice(0, eof);
                self.buffer = self.buffer.slice(eof);
                eof -= packet.length;
                done = !eof;
            } else {
                var match = self.buffer.indexOf(eof);
                if (match !== -1) {
                    // store signature match byte offset to allow us to reference
                    // this for zip64 offset
                    self.match = match;
                    if (includeEof) match = match + eof.length;
                    packet = self.buffer.slice(0, match);
                    self.buffer = self.buffer.slice(match);
                    done = true;
                } else {
                    var len = self.buffer.length - eof.length;
                    if (len <= 0) {
                        cb();
                    } else {
                        packet = self.buffer.slice(0, len);
                        self.buffer = self.buffer.slice(len);
                    }
                }
            }
            if (packet) p.write(packet, function() {
                if (self.buffer.length === 0 || eof.length && self.buffer.length <= eof.length) cb();
            });
        }
        if (!done) {
            if (self.finished) {
                self.removeListener("chunk", pull);
                self.emit("error", new Error("FILE_ENDED"));
                return;
            }
        } else {
            self.removeListener("chunk", pull);
            p.end();
        }
    }
    self.on("chunk", pull);
    pull();
    return p;
};
PullStream.prototype.pull = function(eof, includeEof) {
    if (eof === 0) return Promise.resolve("");
    // If we already have the required data in buffer
    // we can resolve the request immediately
    if (!isNaN(eof) && this.buffer.length > eof) {
        var data = this.buffer.slice(0, eof);
        this.buffer = this.buffer.slice(eof);
        return Promise.resolve(data);
    }
    // Otherwise we stream until we have it
    var buffer = Buffer.from(""), self = this;
    var concatStream = Stream.Transform();
    concatStream._transform = function(d, e, cb) {
        buffer = Buffer.concat([
            buffer,
            d
        ]);
        cb();
    };
    var rejectHandler;
    var pullStreamRejectHandler;
    return new Promise(function(resolve, reject) {
        rejectHandler = reject;
        pullStreamRejectHandler = function(e) {
            self.__emittedError = e;
            reject(e);
        };
        if (self.finished) return reject(new Error("FILE_ENDED"));
        self.once("error", pullStreamRejectHandler); // reject any errors from pullstream itself
        self.stream(eof, includeEof).on("error", reject).pipe(concatStream).on("finish", function() {
            resolve(buffer);
        }).on("error", reject);
    }).finally(function() {
        self.removeListener("error", rejectHandler);
        self.removeListener("error", pullStreamRejectHandler);
    });
};
PullStream.prototype._read = function() {};
module.exports = PullStream;


/***/ }),

/***/ 77871:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Extract;
var Parse = __webpack_require__(15695);
var Writer = (__webpack_require__(63693).Writer);
var path = __webpack_require__(71017);
var stream = __webpack_require__(12781);
var duplexer2 = __webpack_require__(11652);
var Promise = __webpack_require__(72468);
function Extract(opts) {
    // make sure path is normalized before using it
    opts.path = path.resolve(path.normalize(opts.path));
    var parser = new Parse(opts);
    var outStream = new stream.Writable({
        objectMode: true
    });
    outStream._write = function(entry, encoding, cb) {
        if (entry.type == "Directory") return cb();
        // to avoid zip slip (writing outside of the destination), we resolve
        // the target path, and make sure it's nested in the intended
        // destination, or not extract it otherwise.
        var extractPath = path.join(opts.path, entry.path);
        if (extractPath.indexOf(opts.path) != 0) {
            return cb();
        }
        const writer = opts.getWriter ? opts.getWriter({
            path: extractPath
        }) : Writer({
            path: extractPath
        });
        entry.pipe(writer).on("error", cb).on("close", cb);
    };
    var extract = duplexer2(parser, outStream);
    parser.once("crx-header", function(crxHeader) {
        extract.crxHeader = crxHeader;
    });
    parser.pipe(outStream).on("finish", function() {
        extract.emit("close");
    });
    extract.promise = function() {
        return new Promise(function(resolve, reject) {
            extract.on("close", resolve);
            extract.on("error", reject);
        });
    };
    return extract;
}


/***/ }),

/***/ 15695:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var util = __webpack_require__(73837);
var zlib = __webpack_require__(59796);
var Stream = __webpack_require__(12781);
var binary = __webpack_require__(2361);
var Promise = __webpack_require__(72468);
var PullStream = __webpack_require__(77043);
var NoopStream = __webpack_require__(53773);
var BufferStream = __webpack_require__(24120);
var parseExtraField = __webpack_require__(27416);
var Buffer = __webpack_require__(79812);
var parseDateTime = __webpack_require__(18866);
// Backwards compatibility for node versions < 8
if (!Stream.Writable || !Stream.Writable.prototype.destroy) Stream = __webpack_require__(8320);
var endDirectorySignature = Buffer.alloc(4);
endDirectorySignature.writeUInt32LE(0x06054b50, 0);
function Parse(opts) {
    if (!(this instanceof Parse)) {
        return new Parse(opts);
    }
    var self = this;
    self._opts = opts || {
        verbose: false
    };
    PullStream.call(self, self._opts);
    self.on("finish", function() {
        self.emit("end");
        self.emit("close");
    });
    self._readRecord().catch(function(e) {
        if (!self.__emittedError || self.__emittedError !== e) self.emit("error", e);
    });
}
util.inherits(Parse, PullStream);
Parse.prototype._readRecord = function() {
    var self = this;
    return self.pull(4).then(function(data) {
        if (data.length === 0) return;
        var signature = data.readUInt32LE(0);
        if (signature === 0x34327243) {
            return self._readCrxHeader();
        }
        if (signature === 0x04034b50) {
            return self._readFile();
        } else if (signature === 0x02014b50) {
            self.reachedCD = true;
            return self._readCentralDirectoryFileHeader();
        } else if (signature === 0x06054b50) {
            return self._readEndOfCentralDirectoryRecord();
        } else if (self.reachedCD) {
            // _readEndOfCentralDirectoryRecord expects the EOCD
            // signature to be consumed so set includeEof=true
            var includeEof = true;
            return self.pull(endDirectorySignature, includeEof).then(function() {
                return self._readEndOfCentralDirectoryRecord();
            });
        } else self.emit("error", new Error("invalid signature: 0x" + signature.toString(16)));
    });
};
Parse.prototype._readCrxHeader = function() {
    var self = this;
    return self.pull(12).then(function(data) {
        self.crxHeader = binary.parse(data).word32lu("version").word32lu("pubKeyLength").word32lu("signatureLength").vars;
        return self.pull(self.crxHeader.pubKeyLength + self.crxHeader.signatureLength);
    }).then(function(data) {
        self.crxHeader.publicKey = data.slice(0, self.crxHeader.pubKeyLength);
        self.crxHeader.signature = data.slice(self.crxHeader.pubKeyLength);
        self.emit("crx-header", self.crxHeader);
        return self._readRecord();
    });
};
Parse.prototype._readFile = function() {
    var self = this;
    return self.pull(26).then(function(data) {
        var vars = binary.parse(data).word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
        vars.lastModifiedDateTime = parseDateTime(vars.lastModifiedDate, vars.lastModifiedTime);
        if (self.crxHeader) vars.crxHeader = self.crxHeader;
        return self.pull(vars.fileNameLength).then(function(fileNameBuffer) {
            var fileName = fileNameBuffer.toString("utf8");
            var entry = Stream.PassThrough();
            var __autodraining = false;
            entry.autodrain = function() {
                __autodraining = true;
                var draining = entry.pipe(NoopStream());
                draining.promise = function() {
                    return new Promise(function(resolve, reject) {
                        draining.on("finish", resolve);
                        draining.on("error", reject);
                    });
                };
                return draining;
            };
            entry.buffer = function() {
                return BufferStream(entry);
            };
            entry.path = fileName;
            entry.props = {};
            entry.props.path = fileName;
            entry.props.pathBuffer = fileNameBuffer;
            entry.props.flags = {
                "isUnicode": (vars.flags & 0x800) != 0
            };
            entry.type = vars.uncompressedSize === 0 && /[\/\\]$/.test(fileName) ? "Directory" : "File";
            if (self._opts.verbose) {
                if (entry.type === "Directory") {
                    console.log("   creating:", fileName);
                } else if (entry.type === "File") {
                    if (vars.compressionMethod === 0) {
                        console.log(" extracting:", fileName);
                    } else {
                        console.log("  inflating:", fileName);
                    }
                }
            }
            return self.pull(vars.extraFieldLength).then(function(extraField) {
                var extra = parseExtraField(extraField, vars);
                entry.vars = vars;
                entry.extra = extra;
                if (self._opts.forceStream) {
                    self.push(entry);
                } else {
                    self.emit("entry", entry);
                    if (self._readableState.pipesCount || self._readableState.pipes && self._readableState.pipes.length) self.push(entry);
                }
                if (self._opts.verbose) console.log({
                    filename: fileName,
                    vars: vars,
                    extra: extra
                });
                var fileSizeKnown = !(vars.flags & 0x08) || vars.compressedSize > 0, eof;
                entry.__autodraining = __autodraining; // expose __autodraining for test purposes
                var inflater = vars.compressionMethod && !__autodraining ? zlib.createInflateRaw() : Stream.PassThrough();
                if (fileSizeKnown) {
                    entry.size = vars.uncompressedSize;
                    eof = vars.compressedSize;
                } else {
                    eof = Buffer.alloc(4);
                    eof.writeUInt32LE(0x08074b50, 0);
                }
                return new Promise(function(resolve, reject) {
                    self.stream(eof).pipe(inflater).on("error", function(err) {
                        self.emit("error", err);
                    }).pipe(entry).on("finish", function() {
                        return fileSizeKnown ? self._readRecord().then(resolve).catch(reject) : self._processDataDescriptor(entry).then(resolve).catch(reject);
                    });
                });
            });
        });
    });
};
Parse.prototype._processDataDescriptor = function(entry) {
    var self = this;
    return self.pull(16).then(function(data) {
        var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").vars;
        entry.size = vars.uncompressedSize;
        return self._readRecord();
    });
};
Parse.prototype._readCentralDirectoryFileHeader = function() {
    var self = this;
    return self.pull(42).then(function(data) {
        var vars = binary.parse(data).word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
        return self.pull(vars.fileNameLength).then(function(fileName) {
            vars.fileName = fileName.toString("utf8");
            return self.pull(vars.extraFieldLength);
        }).then(function(extraField) {
            return self.pull(vars.fileCommentLength);
        }).then(function(fileComment) {
            return self._readRecord();
        });
    });
};
Parse.prototype._readEndOfCentralDirectoryRecord = function() {
    var self = this;
    return self.pull(18).then(function(data) {
        var vars = binary.parse(data).word16lu("diskNumber").word16lu("diskStart").word16lu("numberOfRecordsOnDisk").word16lu("numberOfRecords").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
        return self.pull(vars.commentLength).then(function(comment) {
            comment = comment.toString("utf8");
            self.end();
            self.push(null);
        });
    });
};
Parse.prototype.promise = function() {
    var self = this;
    return new Promise(function(resolve, reject) {
        self.on("finish", resolve);
        self.on("error", reject);
    });
};
module.exports = Parse;


/***/ }),

/***/ 18866:
/***/ ((module) => {

"use strict";
// Dates in zip file entries are stored as DosDateTime
// Spec is here: https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-dosdatetimetofiletime

module.exports = function parseDateTime(date, time) {
    const day = date & 0x1F;
    const month = date >> 5 & 0x0F;
    const year = (date >> 9 & 0x7F) + 1980;
    const seconds = time ? (time & 0x1F) * 2 : 0;
    const minutes = time ? time >> 5 & 0x3F : 0;
    const hours = time ? time >> 11 : 0;
    return new Date(Date.UTC(year, month - 1, day, hours, minutes, seconds));
};


/***/ }),

/***/ 27416:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var binary = __webpack_require__(2361);
module.exports = function(extraField, vars) {
    var extra;
    // Find the ZIP64 header, if present.
    while(!extra && extraField && extraField.length){
        var candidateExtra = binary.parse(extraField).word16lu("signature").word16lu("partsize").word64lu("uncompressedSize").word64lu("compressedSize").word64lu("offset").word64lu("disknum").vars;
        if (candidateExtra.signature === 0x0001) {
            extra = candidateExtra;
        } else {
            // Advance the buffer to the next part.
            // The total size of this part is the 4 byte header + partsize.
            extraField = extraField.slice(candidateExtra.partsize + 4);
        }
    }
    extra = extra || {};
    if (vars.compressedSize === 0xffffffff) vars.compressedSize = extra.compressedSize;
    if (vars.uncompressedSize === 0xffffffff) vars.uncompressedSize = extra.uncompressedSize;
    if (vars.offsetToLocalFileHeader === 0xffffffff) vars.offsetToLocalFileHeader = extra.offset;
    return extra;
};


/***/ }),

/***/ 63465:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Stream = __webpack_require__(12781);
var Parse = __webpack_require__(15695);
var duplexer2 = __webpack_require__(11652);
var BufferStream = __webpack_require__(24120);
// Backwards compatibility for node versions < 8
if (!Stream.Writable || !Stream.Writable.prototype.destroy) Stream = __webpack_require__(8320);
function parseOne(match, opts) {
    var inStream = Stream.PassThrough({
        objectMode: true
    });
    var outStream = Stream.PassThrough();
    var transform = Stream.Transform({
        objectMode: true
    });
    var re = match instanceof RegExp ? match : match && new RegExp(match);
    var found;
    transform._transform = function(entry, e, cb) {
        if (found || re && !re.exec(entry.path)) {
            entry.autodrain();
            return cb();
        } else {
            found = true;
            out.emit("entry", entry);
            entry.on("error", function(e) {
                outStream.emit("error", e);
            });
            entry.pipe(outStream).on("error", function(err) {
                cb(err);
            }).on("finish", function(d) {
                cb(null, d);
            });
        }
    };
    inStream.pipe(Parse(opts)).on("error", function(err) {
        outStream.emit("error", err);
    }).pipe(transform).on("error", Object) // Silence error as its already addressed in transform
    .on("finish", function() {
        if (!found) outStream.emit("error", new Error("PATTERN_NOT_FOUND"));
        else outStream.end();
    });
    var out = duplexer2(inStream, outStream);
    out.buffer = function() {
        return BufferStream(outStream);
    };
    return out;
}
module.exports = parseOne;


/***/ }),

/***/ 85462:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/ var pna = __webpack_require__(11210);
/*</replacement>*/ /*<replacement>*/ var objectKeys = Object.keys || function(obj) {
    var keys = [];
    for(var key in obj){
        keys.push(key);
    }
    return keys;
};
/*</replacement>*/ module.exports = Duplex;
/*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ var Readable = __webpack_require__(31036);
var Writable = __webpack_require__(96276);
util.inherits(Duplex, Readable);
{
    // avoid scope creep, the keys array can then be collected
    var keys = objectKeys(Writable.prototype);
    for(var v = 0; v < keys.length; v++){
        var method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
}function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
}
Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
        return this._writableState.highWaterMark;
    }
});
// the no-half-open enforcer
function onend() {
    // if we allow half-open state, or if the writable side ended,
    // then we're ok.
    if (this.allowHalfOpen || this._writableState.ended) return;
    // no more data can be written.
    // But allow more writes to happen in this tick.
    pna.nextTick(onEndNT, this);
}
function onEndNT(self) {
    self.end();
}
Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
        if (this._readableState === undefined || this._writableState === undefined) {
            return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});
Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
};


/***/ }),

/***/ 46242:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;
var Transform = __webpack_require__(56879);
/*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ util.inherits(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
};


/***/ }),

/***/ 31036:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/ var pna = __webpack_require__(11210);
/*</replacement>*/ module.exports = Readable;
/*<replacement>*/ var isArray = __webpack_require__(46405);
/*</replacement>*/ /*<replacement>*/ var Duplex;
/*</replacement>*/ Readable.ReadableState = ReadableState;
/*<replacement>*/ var EE = (__webpack_require__(82361).EventEmitter);
var EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
};
/*</replacement>*/ /*<replacement>*/ var Stream = __webpack_require__(64101);
/*</replacement>*/ /*<replacement>*/ var Buffer = (__webpack_require__(66705).Buffer);
var OurUint8Array = (typeof global !== "undefined" ? global :  false ? 0 : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/ /*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ /*<replacement>*/ var debugUtil = __webpack_require__(73837);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
} else {
    debug = function() {};
}
/*</replacement>*/ var BufferList = __webpack_require__(71023);
var destroyImpl = __webpack_require__(22406);
var StringDecoder;
util.inherits(Readable, Stream);
var kProxyEvents = [
    "error",
    "close",
    "destroy",
    "pause",
    "resume"
];
function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [
        fn,
        emitter._events[event]
    ];
}
function ReadableState(options, stream) {
    Duplex = Duplex || __webpack_require__(85462);
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    var isDuplex = stream instanceof Duplex;
    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    // cast to ints.
    this.highWaterMark = Math.floor(this.highWaterMark);
    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true;
    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    // has it been destroyed
    this.destroyed = false;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;
    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!StringDecoder) StringDecoder = (__webpack_require__(35239)/* .StringDecoder */ .s);
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    Duplex = Duplex || __webpack_require__(85462);
    if (!(this instanceof Readable)) return new Readable(options);
    this._readableState = new ReadableState(options, this);
    // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
}
Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
        if (this._readableState === undefined) {
            return false;
        }
        return this._readableState.destroyed;
    },
    set: function(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
};
// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = "";
            }
            skipChunkCheck = true;
        }
    } else {
        skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};
// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
            stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
                if (state.endEmitted) stream.emit("error", new Error("stream.unshift() after end event"));
                else addChunk(stream, state, chunk, true);
            } else if (state.ended) {
                stream.emit("error", new Error("stream.push() after EOF"));
            } else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                    else maybeReadMore(stream, state);
                } else {
                    addChunk(stream, state, chunk, false);
                }
            }
        } else if (!addToFront) {
            state.reading = false;
        }
    }
    return needMoreData(state);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
    } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
}
// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
};
// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(35239)/* .StringDecoder */ .s);
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
};
// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
        n = MAX_HWM;
    } else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
}
// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false;
    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
    }
    n = howMuchToRead(n, state);
    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
    }
    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug("need readable", doRead);
    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
    }
    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
    } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0) state.needReadable = true;
        // call internal read method
        this._read(state.highWaterMark);
        state.sync = false;
        // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading) n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = fromList(n, state);
    else ret = null;
    if (ret === null) {
        state.needReadable = true;
        n = 0;
    } else {
        state.length -= n;
    }
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended) state.needReadable = true;
        // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
};
function onEofChunk(stream, state) {
    if (state.ended) return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    // emit 'readable' now to make sure it gets picked up.
    emitReadable(stream);
}
// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync) pna.nextTick(emitReadable_, stream);
        else emitReadable_(stream);
    }
}
function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
}
// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    var len = state.length;
    while(!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark){
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) break;
        else len = state.length;
    }
    state.readingMore = false;
}
// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch(state.pipesCount){
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [
                state.pipes,
                dest
            ];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) pna.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug("onend");
        dest.end();
    }
    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
        debug("cleanup");
        // cleanup event handlers once the pipe is broken
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    // If the user pushes more data while we're writing to dest then we'll end up
    // in ondata again. However, we only want to increase awaitDrain once because
    // dest will only emit one 'drain' event for the multiple writes.
    // => Introduce a guard on increasing awaitDrain.
    var increasedAwaitDrain = false;
    src.on("data", ondata);
    function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug("false write response, pause", state.awaitDrain);
                state.awaitDrain++;
                increasedAwaitDrain = true;
            }
            src.pause();
        }
    }
    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    // Make sure our error handler is attached before userland ones.
    prependListener(dest, "error", onerror);
    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
    }
    // tell the dest that it's being piped to
    dest.emit("pipe", src);
    // start the flow if it hasn't been started already.
    if (!state.flowing) {
        debug("pipe resume");
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src) {
    return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    };
    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;
    // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
    }
    // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for(var i = 0; i < len; i++){
            dests[i].emit("unpipe", this, {
                hasUnpiped: false
            });
        }
        return this;
    }
    // try to find the right one.
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
};
// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
        // Start flowing on next tick if stream isn't explicitly paused
        if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) {
                pna.nextTick(nReadingNextTick, this);
            } else if (state.length) {
                emitReadable(this);
            }
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self1) {
    debug("readable nexttick read 0");
    self1.read(0);
}
// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
    }
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
    }
}
function resume_(stream, state) {
    if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
    }
    return this;
};
function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while(state.flowing && stream.read() !== null){}
}
// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    });
    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for(var i in stream){
        if (this[i] === undefined && typeof stream[i] === "function") {
            this[i] = function(method) {
                return function() {
                    return stream[method].apply(stream, arguments);
                };
            }(i);
        }
    }
    // proxy certain important events.
    for(var n = 0; n < kProxyEvents.length; n++){
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};
Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
        return this._readableState.highWaterMark;
    }
});
// exposed for testing purposes only.
Readable._fromList = fromList;
// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.head.data;
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else {
        // read part of list
        ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
}
// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
        // slice is the same for buffers and strings
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
        // first chunk is a perfect match
        ret = list.shift();
    } else {
        // result spans more than one buffer
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
}
// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while(p = p.next){
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;
        else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
            if (nb === str.length) {
                ++c;
                if (p.next) list.head = p.next;
                else list.head = list.tail = null;
            } else {
                list.head = p;
                p.data = str.slice(nb);
            }
            break;
        }
        ++c;
    }
    list.length -= c;
    return ret;
}
// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
    var ret = Buffer.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while(p = p.next){
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
            if (nb === buf.length) {
                ++c;
                if (p.next) list.head = p.next;
                else list.head = list.tail = null;
            } else {
                list.head = p;
                p.data = buf.slice(nb);
            }
            break;
        }
        ++c;
    }
    list.length -= c;
    return ret;
}
function endReadable(stream) {
    var state = stream._readableState;
    // If we get here before consuming all the bytes, then that is a
    // bug in node.  Should never happen.
    if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
    }
}
function indexOf(xs, x) {
    for(var i = 0, l = xs.length; i < l; i++){
        if (xs[i] === x) return i;
    }
    return -1;
}


/***/ }),

/***/ 56879:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;
var Duplex = __webpack_require__(85462);
/*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ util.inherits(Transform, Duplex);
function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
    }
}
function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
    };
    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;
    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;
    if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
    }
    // When the writable side finishes, then flush out anything remaining.
    this.on("prefinish", prefinish);
}
function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
        this._flush(function(er, data) {
            done(_this, er, data);
        });
    } else {
        done(this, null, null);
    }
}
Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
};
// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
};
Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
};
// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
    }
};
Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
    });
};
function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null) stream.push(data);
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream.push(null);
}


/***/ }),

/***/ 96276:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

/*<replacement>*/ var pna = __webpack_require__(11210);
/*</replacement>*/ module.exports = Writable;
/* <replacement> */ function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
}
// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
        onCorkedFinish(_this, state);
    };
}
/* </replacement> */ /*<replacement>*/ var asyncWrite =  true && [
    "v0.10",
    "v0.9."
].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/ /*<replacement>*/ var Duplex;
/*</replacement>*/ Writable.WritableState = WritableState;
/*<replacement>*/ var util = Object.create(__webpack_require__(82718));
util.inherits = __webpack_require__(33834);
/*</replacement>*/ /*<replacement>*/ var internalUtil = {
    deprecate: __webpack_require__(62337)
};
/*</replacement>*/ /*<replacement>*/ var Stream = __webpack_require__(64101);
/*</replacement>*/ /*<replacement>*/ var Buffer = (__webpack_require__(66705).Buffer);
var OurUint8Array = (typeof global !== "undefined" ? global :  false ? 0 : typeof self !== "undefined" ? self : {}).Uint8Array || function() {};
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/ var destroyImpl = __webpack_require__(22406);
util.inherits(Writable, Stream);
function nop() {}
function WritableState(options, stream) {
    Duplex = Duplex || __webpack_require__(85462);
    options = options || {};
    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    var isDuplex = stream instanceof Duplex;
    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    // cast to ints.
    this.highWaterMark = Math.floor(this.highWaterMark);
    // if _final has been called
    this.finalCalled = false;
    // drain event flag.
    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;
    // has it been destroyed
    this.destroyed = false;
    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || "utf8";
    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;
    // a flag to see when we're in the middle of a write.
    this.writing = false;
    // when true all writes will be buffered until .uncork() call
    this.corked = 0;
    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;
    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;
    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function(er) {
        onwrite(stream, er);
    };
    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;
    // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;
    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;
    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;
    // count buffered requests
    this.bufferedRequestCount = 0;
    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while(current){
        out.push(current);
        current = current.next;
    }
    return out;
};
(function() {
    try {
        Object.defineProperty(WritableState.prototype, "buffer", {
            get: internalUtil.deprecate(function() {
                return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
        });
    } catch (_) {}
})();
// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
            if (realHasInstance.call(this, object)) return true;
            if (this !== Writable) return false;
            return object && object._writableState instanceof WritableState;
        }
    });
} else {
    realHasInstance = function(object) {
        return object instanceof this;
    };
}
function Writable(options) {
    Duplex = Duplex || __webpack_require__(85462);
    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
}
// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
};
function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    // TODO: defer error events consistently everywhere, not just the cb
    stream.emit("error", er);
    pna.nextTick(cb, er);
}
// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
        er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
    }
    return valid;
}
Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
};
Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!([
        "hex",
        "utf8",
        "utf-8",
        "ascii",
        "binary",
        "base64",
        "ucs2",
        "ucs-2",
        "utf16le",
        "utf-16le",
        "raw"
    ].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer.from(chunk, encoding);
    }
    return chunk;
}
Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
        return this._writableState.highWaterMark;
    }
});
// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) {
            last.next = state.lastBufferedRequest;
        } else {
            state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
    } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        pna.nextTick(cb, er);
        // this can emit finish, and it will always happen
        // after error
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
    } else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        // this can emit finish, but finish must
        // always follow error
        finishMaybe(stream, state);
    }
}
function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
        }
        if (sync) {
            /*<replacement>*/ asyncWrite(afterWrite, stream, state, finished, cb);
        /*</replacement>*/ } else {
            afterWrite(stream, state, finished, cb);
        }
    }
}
function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
}
// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
    }
}
// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while(entry){
            buffer[count] = entry;
            if (!entry.isBuf) allBuffers = false;
            entry = entry.next;
            count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        } else {
            state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
    } else {
        // Slow case, write chunks one-by-one
        while(entry){
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) {
                break;
            }
        }
        if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
};
Writable.prototype._writev = null;
Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
    // .end() fully uncorks
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    // ignore unnecessary end() calls.
    if (!state.ending) endWritable(this, state, cb);
};
function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
    stream._final(function(err) {
        state.pendingcb--;
        if (err) {
            stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
    });
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
            state.pendingcb++;
            state.finalCalled = true;
            pna.nextTick(callFinal, stream, state);
        } else {
            state.prefinished = true;
            stream.emit("prefinish");
        }
    }
}
function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
        }
    }
    return need;
}
function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
        if (state.finished) pna.nextTick(cb);
        else stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while(entry){
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
    }
    // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
        if (this._writableState === undefined) {
            return false;
        }
        return this._writableState.destroyed;
    },
    set: function(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) {
            return;
        }
        // backward compatibility, the user is explicitly
        // managing destroyed
        this._writableState.destroyed = value;
    }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
};


/***/ }),

/***/ 71023:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
var Buffer = (__webpack_require__(66705).Buffer);
var util = __webpack_require__(73837);
function copyBuffer(src, target, offset) {
    src.copy(target, offset);
}
module.exports = function() {
    function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    BufferList.prototype.push = function push(v) {
        var entry = {
            data: v,
            next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
    };
    BufferList.prototype.unshift = function unshift(v) {
        var entry = {
            data: v,
            next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
    };
    BufferList.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
    };
    BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
    };
    BufferList.prototype.join = function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while(p = p.next){
            ret += s + p.data;
        }
        return ret;
    };
    BufferList.prototype.concat = function concat(n) {
        if (this.length === 0) return Buffer.alloc(0);
        var ret = Buffer.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while(p){
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
        }
        return ret;
    };
    return BufferList;
}();
if (util && util.inspect && util.inspect.custom) {
    module.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({
            length: this.length
        });
        return this.constructor.name + " " + obj;
    };
}


/***/ }),

/***/ 22406:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*<replacement>*/ var pna = __webpack_require__(11210);
/*</replacement>*/ // undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) {
            cb(err);
        } else if (err) {
            if (!this._writableState) {
                pna.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                pna.nextTick(emitErrorNT, this, err);
            }
        }
        return this;
    }
    // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) {
        this._readableState.destroyed = true;
    }
    // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) {
        this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err) {
        if (!cb && err) {
            if (!_this._writableState) {
                pna.nextTick(emitErrorNT, _this, err);
            } else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                pna.nextTick(emitErrorNT, _this, err);
            }
        } else if (cb) {
            cb(err);
        }
    });
    return this;
}
function undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function emitErrorNT(self, err) {
    self.emit("error", err);
}
module.exports = {
    destroy: destroy,
    undestroy: undestroy
};


/***/ }),

/***/ 64101:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(12781);


/***/ }),

/***/ 8320:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

var Stream = __webpack_require__(12781);
if (process.env.READABLE_STREAM === "disable" && Stream) {
    module.exports = Stream;
    exports = module.exports = Stream.Readable;
    exports.Readable = Stream.Readable;
    exports.Writable = Stream.Writable;
    exports.Duplex = Stream.Duplex;
    exports.Transform = Stream.Transform;
    exports.PassThrough = Stream.PassThrough;
    exports.Stream = Stream;
} else {
    exports = module.exports = __webpack_require__(31036);
    exports.Stream = Stream || exports;
    exports.Readable = exports;
    exports.Writable = __webpack_require__(96276);
    exports.Duplex = __webpack_require__(85462);
    exports.Transform = __webpack_require__(56879);
    exports.PassThrough = __webpack_require__(46242);
}


/***/ }),

/***/ 66705:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* eslint-disable node/no-deprecated-api */ 
var buffer = __webpack_require__(14300);
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src){
        dst[key] = src[key];
    }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
} else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
    }
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === "string") {
            buf.fill(fill, encoding);
        } else {
            buf.fill(fill);
        }
    } else {
        buf.fill(0);
    }
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
};


/***/ }),

/***/ 35239:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/ var Buffer = (__webpack_require__(66705).Buffer);
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch(encoding && encoding.toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while(true){
        switch(enc){
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return enc;
            default:
                if (retried) return; // undefined
                enc = ("" + enc).toLowerCase();
                retried = true;
        }
    }
}
;
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.s = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return "";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return "";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return "";
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "";
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}


/***/ }),

/***/ 67494:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// Polyfills for node 0.8
__webpack_require__(35360);
__webpack_require__(89622);
__webpack_require__(89570);
exports.Parse = __webpack_require__(15695);
exports.ParseOne = __webpack_require__(63465);
exports.Extract = __webpack_require__(77871);
exports.Open = __webpack_require__(70788);


/***/ }),

/***/ 50829:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Character classes and associated utilities for the 5th edition of XML 1.0.
 *
 * @author Louis-Dominique Dubeau
 * @license MIT
 * @copyright Louis-Dominique Dubeau
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
//
// Fragments.
//
exports.CHAR = "	\n\r --\uD800\uDC00-\uDBFF\uDFFF";
exports.S = " 	\r\n";
// tslint:disable-next-line:max-line-length
exports.NAME_START_CHAR = ":A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8--------\uD800\uDC00-\uDB7F\uDFFF";
exports.NAME_CHAR = "-" + exports.NAME_START_CHAR + ".0-9\xb7--";
//
// Regular expressions.
//
exports.CHAR_RE = new RegExp("^[" + exports.CHAR + "]$", "u");
exports.S_RE = new RegExp("^[" + exports.S + "]+$", "u");
exports.NAME_START_CHAR_RE = new RegExp("^[" + exports.NAME_START_CHAR + "]$", "u");
exports.NAME_CHAR_RE = new RegExp("^[" + exports.NAME_CHAR + "]$", "u");
exports.NAME_RE = new RegExp("^[" + exports.NAME_START_CHAR + "][" + exports.NAME_CHAR + "]*$", "u");
exports.NMTOKEN_RE = new RegExp("^[" + exports.NAME_CHAR + "]+$", "u");
var TAB = 9;
var NL = 0xA;
var CR = 0xD;
var SPACE = 0x20;
//
// Lists.
//
/** All characters in the ``S`` production. */ exports.S_LIST = [
    SPACE,
    NL,
    CR,
    TAB
];
/**
 * Determines whether a codepoint matches the ``CHAR`` production.
 *
 * @param c The code point.
 *
 * @returns ``true`` if the codepoint matches ``CHAR``.
 */ function isChar(c) {
    return c >= SPACE && c <= 0xD7FF || c === NL || c === CR || c === TAB || c >= 0xE000 && c <= 0xFFFD || c >= 0x10000 && c <= 0x10FFFF;
}
exports.isChar = isChar;
/**
 * Determines whether a codepoint matches the ``S`` (space) production.
 *
 * @param c The code point.
 *
 * @returns ``true`` if the codepoint matches ``S``.
 */ function isS(c) {
    return c === SPACE || c === NL || c === CR || c === TAB;
}
exports.isS = isS;
/**
 * Determines whether a codepoint matches the ``NAME_START_CHAR`` production.
 *
 * @param c The code point.
 *
 * @returns ``true`` if the codepoint matches ``NAME_START_CHAR``.
 */ function isNameStartChar(c) {
    return c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A || c === 0x3A || c === 0x5F || c === 0x200C || c === 0x200D || c >= 0xC0 && c <= 0xD6 || c >= 0xD8 && c <= 0xF6 || c >= 0x00F8 && c <= 0x02FF || c >= 0x0370 && c <= 0x037D || c >= 0x037F && c <= 0x1FFF || c >= 0x2070 && c <= 0x218F || c >= 0x2C00 && c <= 0x2FEF || c >= 0x3001 && c <= 0xD7FF || c >= 0xF900 && c <= 0xFDCF || c >= 0xFDF0 && c <= 0xFFFD || c >= 0x10000 && c <= 0xEFFFF;
}
exports.isNameStartChar = isNameStartChar;
/**
 * Determines whether a codepoint matches the ``NAME_CHAR`` production.
 *
 * @param c The code point.
 *
 * @returns ``true`` if the codepoint matches ``NAME_CHAR``.
 */ function isNameChar(c) {
    return isNameStartChar(c) || c >= 0x30 && c <= 0x39 || c === 0x2D || c === 0x2E || c === 0xB7 || c >= 0x0300 && c <= 0x036F || c >= 0x203F && c <= 0x2040;
}
exports.isNameChar = isNameChar; //# sourceMappingURL=ed5.js.map


/***/ }),

/***/ 35679:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Character classes and associated utilities for the 2nd edition of XML 1.1.
 *
 * @author Louis-Dominique Dubeau
 * @license MIT
 * @copyright Louis-Dominique Dubeau
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
//
// Fragments.
//
exports.CHAR = "\x01--\uD800\uDC00-\uDBFF\uDFFF";
exports.RESTRICTED_CHAR = "\x01-\b\v\f\x0e-\x1f\x7f-\x84\x86-\x9f";
exports.S = " 	\r\n";
// tslint:disable-next-line:max-line-length
exports.NAME_START_CHAR = ":A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8--------\uD800\uDC00-\uDB7F\uDFFF";
exports.NAME_CHAR = "-" + exports.NAME_START_CHAR + ".0-9\xb7--";
//
// Regular expressions.
//
exports.CHAR_RE = new RegExp("^[" + exports.CHAR + "]$", "u");
exports.RESTRICTED_CHAR_RE = new RegExp("^[" + exports.RESTRICTED_CHAR + "]$", "u");
exports.S_RE = new RegExp("^[" + exports.S + "]+$", "u");
exports.NAME_START_CHAR_RE = new RegExp("^[" + exports.NAME_START_CHAR + "]$", "u");
exports.NAME_CHAR_RE = new RegExp("^[" + exports.NAME_CHAR + "]$", "u");
exports.NAME_RE = new RegExp("^[" + exports.NAME_START_CHAR + "][" + exports.NAME_CHAR + "]*$", "u");
exports.NMTOKEN_RE = new RegExp("^[" + exports.NAME_CHAR + "]+$", "u");
var TAB = 9;
var NL = 0xA;
var CR = 0xD;
var SPACE = 0x20;
//
// Lists.
//
/** All characters in the ``S`` production. */ exports.S_LIST = [
    SPACE,
    NL,
    CR,
    TAB
];
/**
 * Determines whether a codepoint matches the ``CHAR`` production.
 *
 * @param c The code point.
 *
 * @returns ``true`` if the codepoint matches ``CHAR``.
 */ function isChar(c) {
    return c >= 0x0001 && c <= 0xD7FF || c >= 0xE000 && c <= 0xFFFD || c >= 0x10000 && c <= 0x10FFFF;
}
exports.isChar = isChar;
/**
 * Determines whether a codepoint matches the ``RESTRICTED_CHAR`` production.
 *
 * @param c The code point.
 *
 * @returns ``true`` if the codepoint matches ``RESTRICTED_CHAR``.
 */ function isRestrictedChar(c) {
    return c >= 0x1 && c <= 0x8 || c === 0xB || c === 0xC || c >= 0xE && c <= 0x1F || c >= 0x7F && c <= 0x84 || c >= 0x86 && c <= 0x9F;
}
exports.isRestrictedChar = isRestrictedChar;
/**
 * Determines whether a codepoint matches the ``CHAR`` production and does not
 * match the ``RESTRICTED_CHAR`` production. ``isCharAndNotRestricted(x)`` is
 * equivalent to ``isChar(x) && !isRestrictedChar(x)``. This function is faster
 * than running the two-call equivalent.
 *
 * @param c The code point.
 *
 * @returns ``true`` if the codepoint matches ``CHAR`` and does not match
 * ``RESTRICTED_CHAR``.
 */ function isCharAndNotRestricted(c) {
    return c === 0x9 || c === 0xA || c === 0xD || c > 0x1F && c < 0x7F || c === 0x85 || c > 0x9F && c <= 0xD7FF || c >= 0xE000 && c <= 0xFFFD || c >= 0x10000 && c <= 0x10FFFF;
}
exports.isCharAndNotRestricted = isCharAndNotRestricted;
/**
 * Determines whether a codepoint matches the ``S`` (space) production.
 *
 * @param c The code point.
 *
 * @returns ``true`` if the codepoint matches ``S``.
 */ function isS(c) {
    return c === SPACE || c === NL || c === CR || c === TAB;
}
exports.isS = isS;
/**
 * Determines whether a codepoint matches the ``NAME_START_CHAR`` production.
 *
 * @param c The code point.
 *
 * @returns ``true`` if the codepoint matches ``NAME_START_CHAR``.
 */ // tslint:disable-next-line:cyclomatic-complexity
function isNameStartChar(c) {
    return c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A || c === 0x3A || c === 0x5F || c === 0x200C || c === 0x200D || c >= 0xC0 && c <= 0xD6 || c >= 0xD8 && c <= 0xF6 || c >= 0x00F8 && c <= 0x02FF || c >= 0x0370 && c <= 0x037D || c >= 0x037F && c <= 0x1FFF || c >= 0x2070 && c <= 0x218F || c >= 0x2C00 && c <= 0x2FEF || c >= 0x3001 && c <= 0xD7FF || c >= 0xF900 && c <= 0xFDCF || c >= 0xFDF0 && c <= 0xFFFD || c >= 0x10000 && c <= 0xEFFFF;
}
exports.isNameStartChar = isNameStartChar;
/**
 * Determines whether a codepoint matches the ``NAME_CHAR`` production.
 *
 * @param c The code point.
 *
 * @returns ``true`` if the codepoint matches ``NAME_CHAR``.
 */ function isNameChar(c) {
    return isNameStartChar(c) || c >= 0x30 && c <= 0x39 || c === 0x2D || c === 0x2E || c === 0xB7 || c >= 0x0300 && c <= 0x036F || c >= 0x203F && c <= 0x2040;
}
exports.isNameChar = isNameChar; //# sourceMappingURL=ed2.js.map


/***/ }),

/***/ 60996:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Character class utilities for XML NS 1.0 edition 3.
 *
 * @author Louis-Dominique Dubeau
 * @license MIT
 * @copyright Louis-Dominique Dubeau
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
//
// Fragments.
//
// tslint:disable-next-line:max-line-length
exports.NC_NAME_START_CHAR = "A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8---------\uD800\uDC00-\uDB7F\uDFFF";
exports.NC_NAME_CHAR = "-" + exports.NC_NAME_START_CHAR + ".0-9\xb7--";
//
// Regular expressions.
//
exports.NC_NAME_START_CHAR_RE = new RegExp("^[" + exports.NC_NAME_START_CHAR + "]$", "u");
exports.NC_NAME_CHAR_RE = new RegExp("^[" + exports.NC_NAME_CHAR + "]$", "u");
exports.NC_NAME_RE = new RegExp("^[" + exports.NC_NAME_START_CHAR + "][" + exports.NC_NAME_CHAR + "]*$", "u");
/**
 * Determines whether a codepoint matches [[NC_NAME_START_CHAR]].
 *
 * @param c The code point.
 *
 * @returns ``true`` if the codepoint matches.
 */ // tslint:disable-next-line:cyclomatic-complexity
function isNCNameStartChar(c) {
    return c >= 0x41 && c <= 0x5A || c === 0x5F || c >= 0x61 && c <= 0x7A || c >= 0xC0 && c <= 0xD6 || c >= 0xD8 && c <= 0xF6 || c >= 0x00F8 && c <= 0x02FF || c >= 0x0370 && c <= 0x037D || c >= 0x037F && c <= 0x1FFF || c >= 0x200C && c <= 0x200D || c >= 0x2070 && c <= 0x218F || c >= 0x2C00 && c <= 0x2FEF || c >= 0x3001 && c <= 0xD7FF || c >= 0xF900 && c <= 0xFDCF || c >= 0xFDF0 && c <= 0xFFFD || c >= 0x10000 && c <= 0xEFFFF;
}
exports.isNCNameStartChar = isNCNameStartChar;
/**
 * Determines whether a codepoint matches [[NC_NAME_CHAR]].
 *
 * @param c The code point.
 *
 * @returns ``true`` if the codepoint matches.
 */ function isNCNameChar(c) {
    return isNCNameStartChar(c) || c === 0x2D || c === 0x2E || c >= 0x30 && c <= 0x39 || c === 0x00B7 || c >= 0x0300 && c <= 0x036F || c >= 0x203F && c <= 0x2040;
}
exports.isNCNameChar = isNCNameChar; //# sourceMappingURL=ed3.js.map


/***/ }),

/***/ 78295:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * ZipStream
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-zip-stream/blob/master/LICENSE}
 * @copyright (c) 2014 Chris Talkington, contributors.
 */ 
var inherits = (__webpack_require__(73837).inherits);
var ZipArchiveOutputStream = (__webpack_require__(58700).ZipArchiveOutputStream);
var ZipArchiveEntry = (__webpack_require__(58700).ZipArchiveEntry);
var util = __webpack_require__(92919);
/**
 * @constructor
 * @extends external:ZipArchiveOutputStream
 * @param {Object} [options]
 * @param {String} [options.comment] Sets the zip archive comment.
 * @param {Boolean} [options.forceLocalTime=false] Forces the archive to contain local file times instead of UTC.
 * @param {Boolean} [options.forceZip64=false] Forces the archive to contain ZIP64 headers.
 * @param {Boolean} [options.store=false] Sets the compression method to STORE.
 * @param {Object} [options.zlib] Passed to [zlib]{@link https://nodejs.org/api/zlib.html#zlib_class_options}
 * to control compression.
 */ var ZipStream = module.exports = function(options) {
    if (!(this instanceof ZipStream)) {
        return new ZipStream(options);
    }
    options = this.options = options || {};
    options.zlib = options.zlib || {};
    ZipArchiveOutputStream.call(this, options);
    if (typeof options.level === "number" && options.level >= 0) {
        options.zlib.level = options.level;
        delete options.level;
    }
    if (!options.forceZip64 && typeof options.zlib.level === "number" && options.zlib.level === 0) {
        options.store = true;
    }
    options.namePrependSlash = options.namePrependSlash || false;
    if (options.comment && options.comment.length > 0) {
        this.setComment(options.comment);
    }
};
inherits(ZipStream, ZipArchiveOutputStream);
/**
 * Normalizes entry data with fallbacks for key properties.
 *
 * @private
 * @param  {Object} data
 * @return {Object}
 */ ZipStream.prototype._normalizeFileData = function(data) {
    data = util.defaults(data, {
        type: "file",
        name: null,
        namePrependSlash: this.options.namePrependSlash,
        linkname: null,
        date: null,
        mode: null,
        store: this.options.store,
        comment: ""
    });
    var isDir = data.type === "directory";
    var isSymlink = data.type === "symlink";
    if (data.name) {
        data.name = util.sanitizePath(data.name);
        if (!isSymlink && data.name.slice(-1) === "/") {
            isDir = true;
            data.type = "directory";
        } else if (isDir) {
            data.name += "/";
        }
    }
    if (isDir || isSymlink) {
        data.store = true;
    }
    data.date = util.dateify(data.date);
    return data;
};
/**
 * Appends an entry given an input source (text string, buffer, or stream).
 *
 * @param  {(Buffer|Stream|String)} source The input source.
 * @param  {Object} data
 * @param  {String} data.name Sets the entry name including internal path.
 * @param  {String} [data.comment] Sets the entry comment.
 * @param  {(String|Date)} [data.date=NOW()] Sets the entry date.
 * @param  {Number} [data.mode=D:0755/F:0644] Sets the entry permissions.
 * @param  {Boolean} [data.store=options.store] Sets the compression method to STORE.
 * @param  {String} [data.type=file] Sets the entry type. Defaults to `directory`
 * if name ends with trailing slash.
 * @param  {Function} callback
 * @return this
 */ ZipStream.prototype.entry = function(source, data, callback) {
    if (typeof callback !== "function") {
        callback = this._emitErrorCallback.bind(this);
    }
    data = this._normalizeFileData(data);
    if (data.type !== "file" && data.type !== "directory" && data.type !== "symlink") {
        callback(new Error(data.type + " entries not currently supported"));
        return;
    }
    if (typeof data.name !== "string" || data.name.length === 0) {
        callback(new Error("entry name must be a non-empty string value"));
        return;
    }
    if (data.type === "symlink" && typeof data.linkname !== "string") {
        callback(new Error("entry linkname must be a non-empty string value when type equals symlink"));
        return;
    }
    var entry = new ZipArchiveEntry(data.name);
    entry.setTime(data.date, this.options.forceLocalTime);
    if (data.namePrependSlash) {
        entry.setName(data.name, true);
    }
    if (data.store) {
        entry.setMethod(0);
    }
    if (data.comment.length > 0) {
        entry.setComment(data.comment);
    }
    if (data.type === "symlink" && typeof data.mode !== "number") {
        data.mode = 40960; // 0120000
    }
    if (typeof data.mode === "number") {
        if (data.type === "symlink") {
            data.mode |= 40960;
        }
        entry.setUnixMode(data.mode);
    }
    if (data.type === "symlink" && typeof data.linkname === "string") {
        source = Buffer.from(data.linkname);
    }
    return ZipArchiveOutputStream.prototype.entry.call(this, entry, source, callback);
};
/**
 * Finalizes the instance and prevents further appending to the archive
 * structure (queue will continue til drained).
 *
 * @return void
 */ ZipStream.prototype.finalize = function() {
    this.finish();
}; /**
 * Returns the current number of bytes written to this stream.
 * @function ZipStream#getBytesWritten
 * @returns {Number}
 */  /**
 * Compress Commons ZipArchiveOutputStream
 * @external ZipArchiveOutputStream
 * @see {@link https://github.com/archiverjs/node-compress-commons}
 */ 


/***/ }),

/***/ 79195:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * archiver-utils
 *
 * Copyright (c) 2012-2014 Chris Talkington, contributors.
 * Licensed under the MIT license.
 * https://github.com/archiverjs/node-archiver/blob/master/LICENSE-MIT
 */ 
var fs = __webpack_require__(33362);
var path = __webpack_require__(71017);
var flatten = __webpack_require__(95918);
var difference = __webpack_require__(4212);
var union = __webpack_require__(25372);
var isPlainObject = __webpack_require__(22557);
var glob = __webpack_require__(85642);
var file = module.exports = {};
var pathSeparatorRe = /[\/\\]/g;
// Process specified wildcard glob patterns or filenames against a
// callback, excluding and uniquing files in the result set.
var processPatterns = function(patterns, fn) {
    // Filepaths to return.
    var result = [];
    // Iterate over flattened patterns array.
    flatten(patterns).forEach(function(pattern) {
        // If the first character is ! it should be omitted
        var exclusion = pattern.indexOf("!") === 0;
        // If the pattern is an exclusion, remove the !
        if (exclusion) {
            pattern = pattern.slice(1);
        }
        // Find all matching files for this pattern.
        var matches = fn(pattern);
        if (exclusion) {
            // If an exclusion, remove matching files.
            result = difference(result, matches);
        } else {
            // Otherwise add matching files.
            result = union(result, matches);
        }
    });
    return result;
};
// True if the file path exists.
file.exists = function() {
    var filepath = path.join.apply(path, arguments);
    return fs.existsSync(filepath);
};
// Return an array of all file paths that match the given wildcard patterns.
file.expand = function(...args) {
    // If the first argument is an options object, save those options to pass
    // into the File.prototype.glob.sync method.
    var options = isPlainObject(args[0]) ? args.shift() : {};
    // Use the first argument if it's an Array, otherwise convert the arguments
    // object to an array and use that.
    var patterns = Array.isArray(args[0]) ? args[0] : args;
    // Return empty set if there are no patterns or filepaths.
    if (patterns.length === 0) {
        return [];
    }
    // Return all matching filepaths.
    var matches = processPatterns(patterns, function(pattern) {
        // Find all matching files for this pattern.
        return glob.sync(pattern, options);
    });
    // Filter result set?
    if (options.filter) {
        matches = matches.filter(function(filepath) {
            filepath = path.join(options.cwd || "", filepath);
            try {
                if (typeof options.filter === "function") {
                    return options.filter(filepath);
                } else {
                    // If the file is of the right type and exists, this should work.
                    return fs.statSync(filepath)[options.filter]();
                }
            } catch (e) {
                // Otherwise, it's probably not the right type.
                return false;
            }
        });
    }
    return matches;
};
// Build a multi task "files" object dynamically.
file.expandMapping = function(patterns, destBase, options) {
    options = Object.assign({
        rename: function(destBase, destPath) {
            return path.join(destBase || "", destPath);
        }
    }, options);
    var files = [];
    var fileByDest = {};
    // Find all files matching pattern, using passed-in options.
    file.expand(options, patterns).forEach(function(src) {
        var destPath = src;
        // Flatten?
        if (options.flatten) {
            destPath = path.basename(destPath);
        }
        // Change the extension?
        if (options.ext) {
            destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
        }
        // Generate destination filename.
        var dest = options.rename(destBase, destPath, options);
        // Prepend cwd to src path if necessary.
        if (options.cwd) {
            src = path.join(options.cwd, src);
        }
        // Normalize filepaths to be unix-style.
        dest = dest.replace(pathSeparatorRe, "/");
        src = src.replace(pathSeparatorRe, "/");
        // Map correct src path to dest path.
        if (fileByDest[dest]) {
            // If dest already exists, push this src onto that dest's src array.
            fileByDest[dest].src.push(src);
        } else {
            // Otherwise create a new src-dest file mapping object.
            files.push({
                src: [
                    src
                ],
                dest: dest
            });
            // And store a reference for later use.
            fileByDest[dest] = files[files.length - 1];
        }
    });
    return files;
};
// reusing bits of grunt's multi-task source normalization
file.normalizeFilesArray = function(data) {
    var files = [];
    data.forEach(function(obj) {
        var prop;
        if ("src" in obj || "dest" in obj) {
            files.push(obj);
        }
    });
    if (files.length === 0) {
        return [];
    }
    files = _(files).chain().forEach(function(obj) {
        if (!("src" in obj) || !obj.src) {
            return;
        }
        // Normalize .src properties to flattened array.
        if (Array.isArray(obj.src)) {
            obj.src = flatten(obj.src);
        } else {
            obj.src = [
                obj.src
            ];
        }
    }).map(function(obj) {
        // Build options object, removing unwanted properties.
        var expandOptions = Object.assign({}, obj);
        delete expandOptions.src;
        delete expandOptions.dest;
        // Expand file mappings.
        if (obj.expand) {
            return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {
                // Copy obj properties to result.
                var result = Object.assign({}, obj);
                // Make a clone of the orig obj available.
                result.orig = Object.assign({}, obj);
                // Set .src and .dest, processing both as templates.
                result.src = mapObj.src;
                result.dest = mapObj.dest;
                // Remove unwanted properties.
                [
                    "expand",
                    "cwd",
                    "flatten",
                    "rename",
                    "ext"
                ].forEach(function(prop) {
                    delete result[prop];
                });
                return result;
            });
        }
        // Copy obj properties to result, adding an .orig property.
        var result = Object.assign({}, obj);
        // Make a clone of the orig obj available.
        result.orig = Object.assign({}, obj);
        if ("src" in result) {
            // Expose an expand-on-demand getter method as .src.
            Object.defineProperty(result, "src", {
                enumerable: true,
                get: function fn() {
                    var src;
                    if (!("result" in fn)) {
                        src = obj.src;
                        // If src is an array, flatten it. Otherwise, make it into an array.
                        src = Array.isArray(src) ? flatten(src) : [
                            src
                        ];
                        // Expand src files, memoizing result.
                        fn.result = file.expand(expandOptions, src);
                    }
                    return fn.result;
                }
            });
        }
        if ("dest" in result) {
            result.dest = obj.dest;
        }
        return result;
    }).flatten().value();
    return files;
};


/***/ }),

/***/ 92919:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**
 * archiver-utils
 *
 * Copyright (c) 2015 Chris Talkington.
 * Licensed under the MIT license.
 * https://github.com/archiverjs/archiver-utils/blob/master/LICENSE
 */ 
var fs = __webpack_require__(33362);
var path = __webpack_require__(71017);
var lazystream = __webpack_require__(28507);
var normalizePath = __webpack_require__(26218);
var defaults = __webpack_require__(25377);
var Stream = (__webpack_require__(12781).Stream);
var PassThrough = (__webpack_require__(98323).PassThrough);
var utils = module.exports = {};
utils.file = __webpack_require__(79195);
utils.collectStream = function(source, callback) {
    var collection = [];
    var size = 0;
    source.on("error", callback);
    source.on("data", function(chunk) {
        collection.push(chunk);
        size += chunk.length;
    });
    source.on("end", function() {
        var buf = Buffer.alloc(size);
        var offset = 0;
        collection.forEach(function(data) {
            data.copy(buf, offset);
            offset += data.length;
        });
        callback(null, buf);
    });
};
utils.dateify = function(dateish) {
    dateish = dateish || new Date();
    if (dateish instanceof Date) {
        dateish = dateish;
    } else if (typeof dateish === "string") {
        dateish = new Date(dateish);
    } else {
        dateish = new Date();
    }
    return dateish;
};
// this is slightly different from lodash version
utils.defaults = function(object, source, guard) {
    var args = arguments;
    args[0] = args[0] || {};
    return defaults(...args);
};
utils.isStream = function(source) {
    return source instanceof Stream;
};
utils.lazyReadStream = function(filepath) {
    return new lazystream.Readable(function() {
        return fs.createReadStream(filepath);
    });
};
utils.normalizeInputSource = function(source) {
    if (source === null) {
        return Buffer.alloc(0);
    } else if (typeof source === "string") {
        return Buffer.from(source);
    } else if (utils.isStream(source)) {
        // Always pipe through a PassThrough stream to guarantee pausing the stream if it's already flowing,
        // since it will only be processed in a (distant) future iteration of the event loop, and will lose
        // data if already flowing now.
        return source.pipe(new PassThrough());
    }
    return source;
};
utils.sanitizePath = function(filepath) {
    return normalizePath(filepath, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
};
utils.trailingSlashIt = function(str) {
    return str.slice(-1) !== "/" ? str + "/" : str;
};
utils.unixifyPath = function(filepath) {
    return normalizePath(filepath, false).replace(/^\w+:/, "");
};
utils.walkdir = function(dirpath, base, callback) {
    var results = [];
    if (typeof base === "function") {
        callback = base;
        base = dirpath;
    }
    fs.readdir(dirpath, function(err, list) {
        var i = 0;
        var file;
        var filepath;
        if (err) {
            return callback(err);
        }
        (function next() {
            file = list[i++];
            if (!file) {
                return callback(null, results);
            }
            filepath = path.join(dirpath, file);
            fs.stat(filepath, function(err, stats) {
                results.push({
                    path: filepath,
                    relative: path.relative(base, filepath).replace(/\\/g, "/"),
                    stats: stats
                });
                if (stats && stats.isDirectory()) {
                    utils.walkdir(filepath, base, function(err, res) {
                        res.forEach(function(dirEntry) {
                            results.push(dirEntry);
                        });
                        next();
                    });
                } else {
                    next();
                }
            });
        })();
    });
};


/***/ })

};
;