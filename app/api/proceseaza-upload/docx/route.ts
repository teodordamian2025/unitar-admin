import { NextRequest, NextResponse } from 'next/server';
import JSZip from 'jszip';

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const file = formData.get('file') as File;
    const prompt = formData.get('prompt') as string;
    
    if (!file) {
      return NextResponse.json({ error: 'Nu a fost gÄƒsit fiÈ™ierul' }, { status: 400 });
    }

    if (!file.name.toLowerCase().endsWith('.docx')) {
      return NextResponse.json({ error: 'FiÈ™ierul trebuie sÄƒ fie .docx' }, { status: 400 });
    }

    // Conversie pentru procesare
    const arrayBuffer = await file.arrayBuffer();
    
    let extractedText = '';
    
    try {
      // Folosim JSZip pentru a extrage conÈ›inutul DOCX
      const zip = new JSZip();
      const zipContent = await zip.loadAsync(arrayBuffer);
      
      // Extragem document.xml din arhiva ZIP
      const documentXml = zipContent.files['word/document.xml'];
      if (!documentXml) {
        throw new Error('Nu s-a gÄƒsit document.xml Ã®n fiÈ™ierul DOCX');
      }
      
      const xmlContent = await documentXml.async('text');
      
      // Extragere text din XML folosind regex
      const textMatches = xmlContent.match(/<w:t[^>]*>(.*?)<\/w:t>/g);
      if (textMatches && textMatches.length > 0) {
        extractedText = textMatches
          .map(match => {
            const textMatch = match.match(/<w:t[^>]*>(.*?)<\/w:t>/);
            return textMatch ? textMatch[1] : '';
          })
          .filter(text => text.trim().length > 0)
          .join(' ')
          .replace(/\s+/g, ' ')
          .trim();
      }
      
      // CurÄƒÈ›Äƒm textul de caractere XML speciale
      extractedText = extractedText
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&')
        .replace(/&quot;/g, '"')
        .replace(/&apos;/g, "'");
      
    } catch (parseError) {
      console.error('Eroare la parsarea Word:', parseError);
      return NextResponse.json({ 
        error: 'FiÈ™ierul Word nu poate fi procesat',
        reply: 'Nu am putut citi conÈ›inutul fiÈ™ierului Word. Te rog sÄƒ Ã®ncerci din nou sau sÄƒ verifici dacÄƒ fiÈ™ierul este valid.'
      }, { status: 400 });
    }

    if (!extractedText.trim()) {
      return NextResponse.json({ 
        error: 'FiÈ™ierul Word pare sÄƒ fie gol sau nu conÈ›ine text extractabil',
        reply: 'FiÈ™ierul Word pare sÄƒ fie gol sau nu conÈ›ine text extractabil.'
      }, { status: 400 });
    }

    // Procesarea conÈ›inutului pentru analizÄƒ
    const wordCount = extractedText.split(/\s+/).filter(word => word.length > 0).length;
    const sentences = extractedText.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const characterCount = extractedText.length;

    const documentStructure = {
      wordCount,
      characterCount,
      sentenceCount: sentences.length,
      estimatedReadingTime: Math.ceil(wordCount / 200) // minute
    };

    // ðŸ”´ Interpretarea cu AI
    let aiReply = `FiÈ™ierul Word "${file.name}" a fost procesat cu succes. ConÈ›ine ${wordCount} cuvinte È™i ${sentences.length} propoziÈ›ii.`;
    
    if (prompt && extractedText.trim()) {
      try {
        const aiPrompt = `AnalizeazÄƒ urmÄƒtorul document Word È™i rÄƒspunde la Ã®ntrebarea utilizatorului:

Nume fiÈ™ier: ${file.name}
Statistici document:
- NumÄƒr cuvinte: ${wordCount}
- NumÄƒr propoziÈ›ii: ${sentences.length}
- NumÄƒr caractere: ${characterCount}

ConÈ›inut document:
${extractedText}

ÃŽntrebarea utilizatorului: ${prompt}

Te rog sÄƒ rÄƒspunzi Ã®n romÃ¢nÄƒ È™i sÄƒ fii cÃ¢t mai precis posibil, referindu-te la conÈ›inutul specific din document.`;

        const aiResponse = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/queryOpenAI`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: aiPrompt })
        });

        if (aiResponse.ok) {
          const aiData = await aiResponse.json();
          aiReply = aiData.reply || aiReply;
        } else {
          console.error('Eroare la apelarea OpenAI:', aiResponse.status);
          aiReply = `Am procesat documentul cu ${wordCount} cuvinte, dar nu am putut conecta la AI pentru interpretare. ConÈ›inutul Ã®ncepe cu: "${extractedText.substring(0, 100)}..."`;
        }
      } catch (aiError) {
        console.error('Eroare la interpretarea AI:', aiError);
        aiReply = `Am procesat documentul cu ${wordCount} cuvinte. ConÈ›inutul Ã®ncepe cu: "${extractedText.substring(0, 100)}..."`;
      }
    }
    
    return NextResponse.json({
      success: true,
      reply: aiReply, // ðŸ”´ CÃ‚MPUL PE CARE ÃŽL AÈ˜TEAPTÄ‚ CHATBOT-UL
      fileName: file.name,
      fileSize: file.size,
      extractedText: extractedText,
      documentStructure: documentStructure,
      summary: {
        wordCount,
        characterCount,
        sentenceCount: sentences.length,
        estimatedReadingTime: Math.ceil(wordCount / 200),
        preview: extractedText.substring(0, 200) + (extractedText.length > 200 ? '...' : '')
      }
    });

  } catch (error) {
    console.error('Eroare la procesarea fiÈ™ierului Word:', error);
    return NextResponse.json({ 
      error: 'Eroare la procesarea fiÈ™ierului Word',
      reply: 'Eroare la procesarea fiÈ™ierului Word. Te rog sÄƒ Ã®ncerci din nou.',
      details: error instanceof Error ? error.message : 'Eroare necunoscutÄƒ'
    }, { status: 500 });
  }
}

